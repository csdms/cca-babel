/*
 * File:          sidlx_rmi_JimEchoServer_Module.c
 * Symbol:        sidlx.rmi.JimEchoServer-v0.1
 * Symbol Type:   class
 * Babel Version: 1.4.0 (Revision: 6607 release-1-4-0-branch)
 * Description:   implement a C extension type for a sidl extendable
 * 
 * WARNING: Automatically generated; changes will be lost
 * 
 */

/*
 * THIS CODE IS AUTOMATICALLY GENERATED BY THE BABEL
 * COMPILER. DO NOT EDIT THIS!
 * 
 * This file contains the implementation of a Python C
 * extension type (i.e. a Python type implemented in C).
 * This extension type provides Python interface to the
 * sidl type sidlx.rmi.JimEchoServer.
 */


/**
 * Symbol "sidlx.rmi.JimEchoServer" (version 0.1)
 * 
 *  
 * Echos strings back to the client using Jim's echo protocol
 */
#include <Python.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#ifndef included_sidl_BaseClass_h
#include "sidl_BaseClass.h"
#endif
#ifndef included_sidl_ClassInfo_h
#include "sidl_ClassInfo.h"
#endif
#ifndef included_sidl_rmi_ProtocolFactory_h
#include "sidl_rmi_ProtocolFactory.h"
#endif
#ifndef included_sidl_rmi_InstanceRegistry_h
#include "sidl_rmi_InstanceRegistry.h"
#endif
#ifndef included_sidl_rmi_InstanceHandle_h
#include "sidl_rmi_InstanceHandle.h"
#endif
#ifndef included_sidl_rmi_Invocation_h
#include "sidl_rmi_Invocation.h"
#endif
#ifndef included_sidl_rmi_Response_h
#include "sidl_rmi_Response.h"
#endif
#ifndef included_sidl_rmi_ServerRegistry_h
#include "sidl_rmi_ServerRegistry.h"
#endif
#ifndef included_sidl_rmi_ConnectRegistry_h
#include "sidl_rmi_ConnectRegistry.h"
#endif
#ifndef included_sidl_io_Serializable_h
#include "sidl_io_Serializable.h"
#endif
#ifndef included_sidl_MemAllocException_h
#include "sidl_MemAllocException.h"
#endif
#ifndef included_sidl_NotImplementedException_h
#include "sidl_NotImplementedException.h"
#endif
#include "sidl_Exception.h"

#ifndef NULL
#define NULL 0
#endif

#include "sidl_thread.h"
#ifdef HAVE_PTHREAD
static struct sidl_recursive_mutex_t sidlx_rmi_JimEchoServer__mutex= SIDL_RECURSIVE_MUTEX_INITIALIZER;
#define LOCK_STATIC_GLOBALS sidl_recursive_mutex_lock( &sidlx_rmi_JimEchoServer__mutex )
#define UNLOCK_STATIC_GLOBALS sidl_recursive_mutex_unlock( &sidlx_rmi_JimEchoServer__mutex )
/* #define HAVE_LOCKED_STATIC_GLOBALS (sidl_recursive_mutex_trylock( &sidlx_rmi_JimEchoServer__mutex )==EDEADLOCK) */
#else
#define LOCK_STATIC_GLOBALS
#define UNLOCK_STATIC_GLOBALS
/* #define HAVE_LOCKED_STATIC_GLOBALS (1) */
#endif

#define sidlx_rmi_JimEchoServer_INTERNAL 1
#include "sidlx_rmi_JimEchoServer_Module.h"
#ifndef included_sidlx_rmi_JimEchoServer_IOR_h
#include "sidlx_rmi_JimEchoServer_IOR.h"
#endif
#include "sidlObjA.h"
#include "sidlPyArrays.h"
#ifdef SIDL_HAVE_NUMPY
#include "oldnumeric.h"
#elif defined(SIDL_HAVE_NUMERIC_PYTHON)
#include "Numeric/arrayobject.h"
#else
#error Neither Numeric Python nor NumPy installed
#endif
#ifndef included_sidl_Loader_h
#include "sidl_Loader.h"
#endif
#ifndef included_sidl_header_h
#include "sidl_header.h"
#endif
#ifndef included_sidl_String_h
#include "sidl_String.h"
#endif
#ifndef included_sidl_Python_h
#include "sidl_Python.h"
#endif
#ifndef included_sidl_interface_IOR_h
#include "sidl_interface_IOR.h"
#endif
#include "sidl_rmi_NetworkException_Module.h"
#include "sidl_BaseClass_Module.h"
#include "sidl_BaseInterface_Module.h"
#include "sidl_ClassInfo_Module.h"
#include "sidl_RuntimeException_Module.h"
#include "sidl_io_Serializable_Module.h"
#include "sidl_rmi_ServerInfo_Module.h"
#include "sidlx_rmi_SimpleServer_Module.h"
#include "sidlx_rmi_Socket_Module.h"
#include "sidl_rmi_Call_Module.h"
#include "sidl_rmi_Return_Module.h"
#include "sidl_rmi_Ticket_Module.h"
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>

/*
 * lang_inited is a boolean value showing if we have already imported all the nescessary modules
 */

static int lang_inited = 0;

static void _loadDependentMods(void) {
  PyGILState_STATE _gstate;
#if (PY_VERSION_HEX >= 0x02040000)
  _gstate = PyGILState_Ensure();
  sidl_Python_LogGILEnsure(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
  sidl_BaseClass__import();
  sidl_BaseInterface__import();
  sidl_ClassInfo__import();
  sidl_RuntimeException__import();
  sidl_io_Serializable__import();
  sidl_rmi_ServerInfo__import();
  sidlx_rmi_JimEchoServer__import();
  sidlx_rmi_SimpleServer__import();
  sidlx_rmi_Socket__import();
  sidl_rmi_Ticket__import();
#if (PY_VERSION_HEX >= 0x02040000)
  PyGILState_Release(_gstate);
  sidl_Python_LogGILRelease(__func__, __FILE__, __LINE__, (int)_gstate);
#endif /* Python 2.4 or later */
}

#define LANG_SPECIFIC_INIT() if(!lang_inited) { \
  lang_inited = 1; \
  _loadDependentMods(); \
}

#ifdef WITH_RMI

/**
 * RMI connector function for the class. (no addref)
 */
struct sidlx_rmi_JimEchoServer__object*
sidlx_rmi_JimEchoServer__connectI(const char * url, sidl_bool ar, struct      \
  sidl_BaseInterface__object **_ex);


#endif /*WITH_RMI*/

/* Static variables to hold version of IOR */
static const int32_t s_IOR_MAJOR_VERSION = 2;
static const int32_t s_IOR_MINOR_VERSION = 0;

/* Static variables for managing EPV initialization. */
static int s_remote_initialized = 0;

static struct sidlx_rmi_JimEchoServer__epv s_rem_epv__sidlx_rmi_jimechoserver;

static struct sidl_BaseClass__epv  s_rem_epv__sidl_baseclass;

static struct sidl_BaseInterface__epv  s_rem_epv__sidl_baseinterface;

static struct sidl_rmi_ServerInfo__epv  s_rem_epv__sidl_rmi_serverinfo;

static struct sidlx_rmi_SimpleServer__epv  s_rem_epv__sidlx_rmi_simpleserver;

#ifdef WITH_RMI


/* REMOTE CAST: dynamic type casting for remote objects. */
static void* remote_sidlx_rmi_JimEchoServer__cast(
  struct sidlx_rmi_JimEchoServer__object* self,
  const char* name, sidl_BaseInterface* _ex)
{
  int cmp;
  void* cast = NULL;
  *_ex = NULL; /* default to no exception */
  cmp = strcmp(name, "sidl.rmi.ServerInfo");
  if (!cmp) {
    (*self->d_epv->f_addRef)(self, _ex); SIDL_CHECK(*_ex);
    cast = &((*self).d_sidlx_rmi_simpleserver.d_sidl_rmi_serverinfo);
    return cast;
  }
  else if (cmp < 0) {
    cmp = strcmp(name, "sidl.BaseInterface");
    if (!cmp) {
      (*self->d_epv->f_addRef)(self, _ex); SIDL_CHECK(*_ex);
      cast = &((                                                              \
        *self).d_sidlx_rmi_simpleserver.d_sidl_baseclass.d_sidl_baseinterface);
      return cast;
    }
    else if (cmp < 0) {
      cmp = strcmp(name, "sidl.BaseClass");
      if (!cmp) {
        (*self->d_epv->f_addRef)(self, _ex); SIDL_CHECK(*_ex);
        cast = ((struct sidl_BaseClass__object*)self);
        return cast;
      }
    }
  }
  else if (cmp > 0) {
    cmp = strcmp(name, "sidlx.rmi.SimpleServer");
    if (!cmp) {
      (*self->d_epv->f_addRef)(self, _ex); SIDL_CHECK(*_ex);
      cast = ((struct sidlx_rmi_SimpleServer__object*)self);
      return cast;
    }
    else if (cmp < 0) {
      cmp = strcmp(name, "sidlx.rmi.JimEchoServer");
      if (!cmp) {
        (*self->d_epv->f_addRef)(self, _ex); SIDL_CHECK(*_ex);
        cast = ((struct sidlx_rmi_JimEchoServer__object*)self);
        return cast;
      }
    }
  }
  if ((*self->d_epv->f_isType)(self,name, _ex)) {
    void* (*func)(struct sidl_rmi_InstanceHandle__object*, struct             \
      sidl_BaseInterface__object**) = 
      (void* (*)(struct sidl_rmi_InstanceHandle__object*, struct              \
        sidl_BaseInterface__object**)) 
      sidl_rmi_ConnectRegistry_getConnect(name, _ex);SIDL_CHECK(*_ex);
    cast =  (*func)(((struct                                                  \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih, _ex);
  }

  return cast;
  EXIT:
  return NULL;
}

/* REMOTE DELETE: call the remote destructor for the object. */
static void remote_sidlx_rmi_JimEchoServer__delete(
  struct sidlx_rmi_JimEchoServer__object* self,
  struct sidl_BaseInterface__object* *_ex)
{
  *_ex = NULL;
  free((void*) self);
}

/* REMOTE GETURL: call the getURL function for the object. */
static char* remote_sidlx_rmi_JimEchoServer__getURL(
  struct sidlx_rmi_JimEchoServer__object* self, struct                        \
    sidl_BaseInterface__object* *_ex)
{
  struct sidl_rmi_InstanceHandle__object *conn = ((struct                     \
    sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
  *_ex = NULL;
  if(conn != NULL) {
    return sidl_rmi_InstanceHandle_getObjectURL(conn, _ex);
  }
  return NULL;
}

/* REMOTE ADDREF: For internal babel use only! Remote addRef. */
static void remote_sidlx_rmi_JimEchoServer__raddRef(
  struct sidlx_rmi_JimEchoServer__object* self,struct                         \
    sidl_BaseInterface__object* *_ex)
{
  struct sidl_BaseException__object* netex = NULL;
  /* initialize a new invocation */
  struct sidl_BaseInterface__object* _throwaway = NULL;
  struct sidl_rmi_InstanceHandle__object *_conn = ((struct                    \
    sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
  sidl_rmi_Response _rsvp = NULL;
  sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation( _conn, \
    "addRef", _ex ); SIDL_CHECK(*_ex);
  /* send actual RMI request */
  _rsvp = sidl_rmi_Invocation_invokeMethod(_inv,_ex);SIDL_CHECK(*_ex);
  /* Check for exceptions */
  netex = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);
  if(netex != NULL) {
    *_ex = (struct sidl_BaseInterface__object*)netex;
    return;
  }

  /* cleanup and return */
  EXIT:
  if(_inv) { sidl_rmi_Invocation_deleteRef(_inv,&_throwaway); }
  if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp,&_throwaway); }
  return;
}

/* REMOTE ISREMOTE: returns true if this object is Remote (it is). */
static sidl_bool
remote_sidlx_rmi_JimEchoServer__isRemote(
    struct sidlx_rmi_JimEchoServer__object* self, 
    struct sidl_BaseInterface__object* *_ex) {
  *_ex = NULL;
  return TRUE;
}

/* REMOTE METHOD STUB:_set_hooks */
static void
remote_sidlx_rmi_JimEchoServer__set_hooks(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ sidl_bool enable,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "_set_hooks", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packBool( _inv, "enable", enable, _ex);SIDL_CHECK(    \
      *_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer._set_hooks.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* Contract enforcement has not been implemented for remote use. */
/* REMOTE METHOD STUB:_set_contracts */
static void
remote_sidlx_rmi_JimEchoServer__set_contracts(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ sidl_bool enable,
  /* in */ const char* enfFilename,
  /* in */ sidl_bool resetCounters,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "_set_contracts", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packBool( _inv, "enable", enable, _ex);SIDL_CHECK(    \
      *_ex);
    sidl_rmi_Invocation_packString( _inv, "enfFilename", enfFilename,         \
      _ex);SIDL_CHECK(*_ex);
    sidl_rmi_Invocation_packBool( _inv, "resetCounters", resetCounters,       \
      _ex);SIDL_CHECK(*_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer._set_contracts.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* Contract enforcement has not been implemented for remote use. */
/* REMOTE METHOD STUB:_dump_stats */
static void
remote_sidlx_rmi_JimEchoServer__dump_stats(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ const char* filename,
  /* in */ const char* prefix,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "_dump_stats", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packString( _inv, "filename", filename,               \
      _ex);SIDL_CHECK(*_ex);
    sidl_rmi_Invocation_packString( _inv, "prefix", prefix, _ex);SIDL_CHECK(  \
      *_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer._dump_stats.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* REMOTE EXEC: call the exec function for the object. */
static void remote_sidlx_rmi_JimEchoServer__exec(
  struct sidlx_rmi_JimEchoServer__object* self,const char* methodName,
  sidl_rmi_Call inArgs,
  sidl_rmi_Return outArgs,
  struct sidl_BaseInterface__object* *_ex)
{
  *_ex = NULL;
}

/* REMOTE METHOD STUB:serviceRequest */
static void
remote_sidlx_rmi_JimEchoServer_serviceRequest(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ struct sidlx_rmi_Socket__object* sock,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "serviceRequest", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    if(sock){
      char* _url = sidl_BaseInterface__getURL((sidl_BaseInterface)sock,       \
        _ex);SIDL_CHECK(*_ex);
      sidl_rmi_Invocation_packString( _inv, "sock", _url, _ex);SIDL_CHECK(    \
        *_ex);
      free((void*)_url);
    } else {
      sidl_rmi_Invocation_packString( _inv, "sock", NULL, _ex);SIDL_CHECK(    \
        *_ex);
    }

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.serviceRequest.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* REMOTE METHOD STUB:isLocalObject */
static char*
remote_sidlx_rmi_JimEchoServer_isLocalObject(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ const char* url,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    char* _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "isLocalObject", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packString( _inv, "url", url, _ex);SIDL_CHECK(*_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.isLocalObject.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackString( _rsvp, "_retval", &_retval,               \
      _ex);SIDL_CHECK(*_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:getExceptions */
static struct sidl_io_Serializable__array*
remote_sidlx_rmi_JimEchoServer_getExceptions(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_io_Serializable__array* _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "getExceptions", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.getExceptions.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackSerializableArray( _rsvp, "_retval", (struct      \
      sidl_io_Serializable__array**)&_retval,0,0,FALSE, _ex);SIDL_CHECK(*_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:setMaxThreadPool */
static void
remote_sidlx_rmi_JimEchoServer_setMaxThreadPool(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ int32_t max,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "setMaxThreadPool", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packInt( _inv, "max", max, _ex);SIDL_CHECK(*_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.setMaxThreadPool.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* REMOTE METHOD STUB:requestPort */
static sidl_bool
remote_sidlx_rmi_JimEchoServer_requestPort(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ int32_t port,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    sidl_bool _retval = FALSE;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "requestPort", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packInt( _inv, "port", port, _ex);SIDL_CHECK(*_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.requestPort.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackBool( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK(\
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:requestPortInRange */
static sidl_bool
remote_sidlx_rmi_JimEchoServer_requestPortInRange(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ int32_t minport,
  /* in */ int32_t maxport,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    sidl_bool _retval = FALSE;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "requestPortInRange", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packInt( _inv, "minport", minport, _ex);SIDL_CHECK(   \
      *_ex);
    sidl_rmi_Invocation_packInt( _inv, "maxport", maxport, _ex);SIDL_CHECK(   \
      *_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.requestPortInRange.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackBool( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK(\
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:getPort */
static int32_t
remote_sidlx_rmi_JimEchoServer_getPort(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    int32_t _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "getPort", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.getPort.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackInt( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK( \
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:getServerName */
static char*
remote_sidlx_rmi_JimEchoServer_getServerName(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    char* _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "getServerName", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.getServerName.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackString( _rsvp, "_retval", &_retval,               \
      _ex);SIDL_CHECK(*_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:getServerURL */
static char*
remote_sidlx_rmi_JimEchoServer_getServerURL(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ const char* objID,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    char* _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "getServerURL", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packString( _inv, "objID", objID, _ex);SIDL_CHECK(    \
      *_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.getServerURL.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackString( _rsvp, "_retval", &_retval,               \
      _ex);SIDL_CHECK(*_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:run */
static int64_t
remote_sidlx_rmi_JimEchoServer_run(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    int64_t _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "run", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.run.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackLong( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK(\
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:shutdown */
static void
remote_sidlx_rmi_JimEchoServer_shutdown(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "shutdown", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.shutdown.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* REMOTE METHOD STUB:shutdownNoWait */
static void
remote_sidlx_rmi_JimEchoServer_shutdownNoWait(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "shutdownNoWait", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.shutdownNoWait.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return;
  }
}

/* REMOTE METHOD STUB:isRunning */
static sidl_bool
remote_sidlx_rmi_JimEchoServer_isRunning(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    sidl_bool _retval = FALSE;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "isRunning", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.isRunning.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackBool( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK(\
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:addRef */
static void
remote_sidlx_rmi_JimEchoServer_addRef(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    struct sidlx_rmi_JimEchoServer__remote* r_obj = (struct                   \
      sidlx_rmi_JimEchoServer__remote*)self->d_data;
    LOCK_STATIC_GLOBALS;
    r_obj->d_refcount++;
#ifdef SIDL_DEBUG_REFCOUNT
    fprintf(stderr, "babel: addRef %p new count %d (type %s)\n",
      r_obj, r_obj->d_refcount, 
      "sidlx.rmi.JimEchoServer Remote Stub");
#endif /* SIDL_DEBUG_REFCOUNT */ 
    UNLOCK_STATIC_GLOBALS;
  }
}

/* REMOTE METHOD STUB:deleteRef */
static void
remote_sidlx_rmi_JimEchoServer_deleteRef(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    struct sidlx_rmi_JimEchoServer__remote* r_obj = (struct                   \
      sidlx_rmi_JimEchoServer__remote*)self->d_data;
    LOCK_STATIC_GLOBALS;
    r_obj->d_refcount--;
#ifdef SIDL_DEBUG_REFCOUNT
    fprintf(stderr, "babel: deleteRef %p new count %d (type %s)\n",r_obj, r_obj->d_refcount, "sidlx.rmi.JimEchoServer Remote Stub");
#endif /* SIDL_DEBUG_REFCOUNT */ 
    if(r_obj->d_refcount == 0) {
      sidl_rmi_InstanceHandle_deleteRef(r_obj->d_ih, _ex);
      free(r_obj);
      free(self);
    }
    UNLOCK_STATIC_GLOBALS;
  }
}

/* REMOTE METHOD STUB:isSame */
static sidl_bool
remote_sidlx_rmi_JimEchoServer_isSame(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ struct sidl_BaseInterface__object* iobj,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    sidl_bool _retval = FALSE;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "isSame", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    if(iobj){
      char* _url = sidl_BaseInterface__getURL((sidl_BaseInterface)iobj,       \
        _ex);SIDL_CHECK(*_ex);
      sidl_rmi_Invocation_packString( _inv, "iobj", _url, _ex);SIDL_CHECK(    \
        *_ex);
      free((void*)_url);
    } else {
      sidl_rmi_Invocation_packString( _inv, "iobj", NULL, _ex);SIDL_CHECK(    \
        *_ex);
    }

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.isSame.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackBool( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK(\
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:isType */
static sidl_bool
remote_sidlx_rmi_JimEchoServer_isType(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* in */ const char* name,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    sidl_bool _retval = FALSE;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "isType", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */
    sidl_rmi_Invocation_packString( _inv, "name", name, _ex);SIDL_CHECK(*_ex);

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.isType.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackBool( _rsvp, "_retval", &_retval, _ex);SIDL_CHECK(\
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE METHOD STUB:getClassInfo */
static struct sidl_ClassInfo__object*
remote_sidlx_rmi_JimEchoServer_getClassInfo(
  /* in */ struct sidlx_rmi_JimEchoServer__object*self ,
  /* out */ struct sidl_BaseInterface__object **_ex)
{
  LANG_SPECIFIC_INIT();
  *_ex = NULL;
  {
    /* initialize a new invocation */
    struct sidl_BaseInterface__object* _throwaway = NULL;
    sidl_BaseException _be = NULL;
    sidl_rmi_Response _rsvp = NULL;
    char*_retval_str = NULL;
    struct sidl_ClassInfo__object* _retval = 0;
    struct sidl_rmi_InstanceHandle__object * _conn = ((struct                 \
      sidlx_rmi_JimEchoServer__remote*)self->d_data)->d_ih;
    sidl_rmi_Invocation _inv = sidl_rmi_InstanceHandle_createInvocation(      \
      _conn, "getClassInfo", _ex ); SIDL_CHECK(*_ex);

    /* pack in and inout arguments */

    /* send actual RMI request */
    _rsvp = sidl_rmi_Invocation_invokeMethod(_inv, _ex);SIDL_CHECK(*_ex);

    _be = sidl_rmi_Response_getExceptionThrown(_rsvp, _ex);SIDL_CHECK(*_ex);
    if (_be != NULL) {
      struct sidl_BaseInterface__object* throwaway_exception = NULL;
      sidl_BaseException_addLine(_be, 
      "Exception unserialized from sidlx.rmi.JimEchoServer.getClassInfo.",
        &throwaway_exception);
      *_ex = (struct sidl_BaseInterface__object*) sidl_BaseInterface__cast(   \
        _be,&throwaway_exception);
      goto EXIT;
    }

    /* extract return value */
    sidl_rmi_Response_unpackString( _rsvp, "_retval", &_retval_str,           \
      _ex);SIDL_CHECK(*_ex);
    _retval = sidl_ClassInfo__connectI(_retval_str, FALSE, _ex);SIDL_CHECK(   \
      *_ex);

    /* unpack out and inout arguments */

    /* cleanup and return */
    EXIT:
    if(_inv) { sidl_rmi_Invocation_deleteRef(_inv, &_throwaway); }
    if(_rsvp) { sidl_rmi_Response_deleteRef(_rsvp, &_throwaway); }
    return _retval;
  }
}

/* REMOTE EPV: create remote entry point vectors (EPVs). */
static void sidlx_rmi_JimEchoServer__init_remote_epv(void)
{
  /* assert( HAVE_LOCKED_STATIC_GLOBALS ); */
  struct sidlx_rmi_JimEchoServer__epv* epv =                                  \
    &s_rem_epv__sidlx_rmi_jimechoserver;
  struct sidl_BaseClass__epv*          e0  = &s_rem_epv__sidl_baseclass;
  struct sidl_BaseInterface__epv*      e1  = &s_rem_epv__sidl_baseinterface;
  struct sidl_rmi_ServerInfo__epv*     e2  = &s_rem_epv__sidl_rmi_serverinfo;
  struct sidlx_rmi_SimpleServer__epv*  e3  =                                  \
    &s_rem_epv__sidlx_rmi_simpleserver;

  epv->f__cast                   = remote_sidlx_rmi_JimEchoServer__cast;
  epv->f__delete                 = remote_sidlx_rmi_JimEchoServer__delete;
  epv->f__exec                   = remote_sidlx_rmi_JimEchoServer__exec;
  epv->f__getURL                 = remote_sidlx_rmi_JimEchoServer__getURL;
  epv->f__raddRef                = remote_sidlx_rmi_JimEchoServer__raddRef;
  epv->f__isRemote               = remote_sidlx_rmi_JimEchoServer__isRemote;
  epv->f__set_hooks              = remote_sidlx_rmi_JimEchoServer__set_hooks;
  epv->f__set_contracts          =                                            \
    remote_sidlx_rmi_JimEchoServer__set_contracts;
  epv->f__dump_stats             = remote_sidlx_rmi_JimEchoServer__dump_stats;
  epv->f__ctor                   = NULL;
  epv->f__ctor2                  = NULL;
  epv->f__dtor                   = NULL;
  epv->f_serviceRequest          =                                            \
    remote_sidlx_rmi_JimEchoServer_serviceRequest;
  epv->f_isLocalObject           =                                            \
    remote_sidlx_rmi_JimEchoServer_isLocalObject;
  epv->f_getExceptions           =                                            \
    remote_sidlx_rmi_JimEchoServer_getExceptions;
  epv->f_setMaxThreadPool        =                                            \
    remote_sidlx_rmi_JimEchoServer_setMaxThreadPool;
  epv->f_requestPort             = remote_sidlx_rmi_JimEchoServer_requestPort;
  epv->f_requestPortInRange      =                                            \
    remote_sidlx_rmi_JimEchoServer_requestPortInRange;
  epv->f_getPort                 = remote_sidlx_rmi_JimEchoServer_getPort;
  epv->f_getServerName           =                                            \
    remote_sidlx_rmi_JimEchoServer_getServerName;
  epv->f_getServerURL            =                                            \
    remote_sidlx_rmi_JimEchoServer_getServerURL;
  epv->f_run                     = remote_sidlx_rmi_JimEchoServer_run;
  epv->f_shutdown                = remote_sidlx_rmi_JimEchoServer_shutdown;
  epv->f_shutdownNoWait          =                                            \
    remote_sidlx_rmi_JimEchoServer_shutdownNoWait;
  epv->f_isRunning               = remote_sidlx_rmi_JimEchoServer_isRunning;
  epv->f_addRef                  = remote_sidlx_rmi_JimEchoServer_addRef;
  epv->f_deleteRef               = remote_sidlx_rmi_JimEchoServer_deleteRef;
  epv->f_isSame                  = remote_sidlx_rmi_JimEchoServer_isSame;
  epv->f_isType                  = remote_sidlx_rmi_JimEchoServer_isType;
  epv->f_getClassInfo            =                                            \
    remote_sidlx_rmi_JimEchoServer_getClassInfo;

  e0->f__cast          = (void* (*)(struct sidl_BaseClass__object*, const     \
    char*, struct sidl_BaseInterface__object**)) epv->f__cast;
  e0->f__delete        = (void (*)(struct sidl_BaseClass__object*, struct     \
    sidl_BaseInterface__object**)) epv->f__delete;
  e0->f__getURL        = (char* (*)(struct sidl_BaseClass__object*, struct    \
    sidl_BaseInterface__object**)) epv->f__getURL;
  e0->f__raddRef       = (void (*)(struct sidl_BaseClass__object*, struct     \
    sidl_BaseInterface__object**)) epv->f__raddRef;
  e0->f__isRemote      = (sidl_bool (*)(struct sidl_BaseClass__object*,       \
    struct sidl_BaseInterface__object**)) epv->f__isRemote;
  e0->f__set_hooks     = (void (*)(struct sidl_BaseClass__object*, sidl_bool, \
    struct sidl_BaseInterface__object**)) epv->f__set_hooks;
  e0->f__set_contracts = (void (*)(struct sidl_BaseClass__object*, sidl_bool, \
    const char*, sidl_bool, struct sidl_BaseInterface__object**))             \
    epv->f__set_contracts;
  e0->f__dump_stats    = (void (*)(struct sidl_BaseClass__object*, const      \
    char*, const char*, struct sidl_BaseInterface__object**))                 \
    epv->f__dump_stats;
  e0->f__exec          = (void (*)(struct sidl_BaseClass__object*,const char*,\
    struct sidl_rmi_Call__object*,struct sidl_rmi_Return__object*,struct      \
    sidl_BaseInterface__object **)) epv->f__exec;
  e0->f_addRef         = (void (*)(struct sidl_BaseClass__object*,struct      \
    sidl_BaseInterface__object **)) epv->f_addRef;
  e0->f_deleteRef      = (void (*)(struct sidl_BaseClass__object*,struct      \
    sidl_BaseInterface__object **)) epv->f_deleteRef;
  e0->f_isSame         = (sidl_bool (*)(struct sidl_BaseClass__object*,struct \
    sidl_BaseInterface__object*,struct sidl_BaseInterface__object **))        \
    epv->f_isSame;
  e0->f_isType         = (sidl_bool (*)(struct sidl_BaseClass__object*,const  \
    char*,struct sidl_BaseInterface__object **)) epv->f_isType;
  e0->f_getClassInfo   = (struct sidl_ClassInfo__object* (*)(struct           \
    sidl_BaseClass__object*,struct sidl_BaseInterface__object **))            \
    epv->f_getClassInfo;

  e1->f__cast          = (void* (*)(void*, const char*, struct                \
    sidl_BaseInterface__object**)) epv->f__cast;
  e1->f__delete        = (void (*)(void*, struct                              \
    sidl_BaseInterface__object**)) epv->f__delete;
  e1->f__getURL        = (char* (*)(void*, struct                             \
    sidl_BaseInterface__object**)) epv->f__getURL;
  e1->f__raddRef       = (void (*)(void*, struct                              \
    sidl_BaseInterface__object**)) epv->f__raddRef;
  e1->f__isRemote      = (sidl_bool (*)(void*, struct                         \
    sidl_BaseInterface__object**)) epv->f__isRemote;
  e1->f__set_hooks     = (void (*)(void*, sidl_bool, struct                   \
    sidl_BaseInterface__object**)) epv->f__set_hooks;
  e1->f__set_contracts = (void (*)(void*, sidl_bool, const char*, sidl_bool,  \
    struct sidl_BaseInterface__object**)) epv->f__set_contracts;
  e1->f__dump_stats    = (void (*)(void*, const char*, const char*, struct    \
    sidl_BaseInterface__object**)) epv->f__dump_stats;
  e1->f__exec          = (void (*)(void*,const char*,struct                   \
    sidl_rmi_Call__object*,struct sidl_rmi_Return__object*,struct             \
    sidl_BaseInterface__object **)) epv->f__exec;
  e1->f_addRef         = (void (*)(void*,struct sidl_BaseInterface__object    \
    **)) epv->f_addRef;
  e1->f_deleteRef      = (void (*)(void*,struct sidl_BaseInterface__object    \
    **)) epv->f_deleteRef;
  e1->f_isSame         = (sidl_bool (*)(void*,struct                          \
    sidl_BaseInterface__object*,struct sidl_BaseInterface__object **))        \
    epv->f_isSame;
  e1->f_isType         = (sidl_bool (*)(void*,const char*,struct              \
    sidl_BaseInterface__object **)) epv->f_isType;
  e1->f_getClassInfo   = (struct sidl_ClassInfo__object* (*)(void*,struct     \
    sidl_BaseInterface__object **)) epv->f_getClassInfo;

  e2->f__cast          = (void* (*)(void*, const char*, struct                \
    sidl_BaseInterface__object**)) epv->f__cast;
  e2->f__delete        = (void (*)(void*, struct                              \
    sidl_BaseInterface__object**)) epv->f__delete;
  e2->f__getURL        = (char* (*)(void*, struct                             \
    sidl_BaseInterface__object**)) epv->f__getURL;
  e2->f__raddRef       = (void (*)(void*, struct                              \
    sidl_BaseInterface__object**)) epv->f__raddRef;
  e2->f__isRemote      = (sidl_bool (*)(void*, struct                         \
    sidl_BaseInterface__object**)) epv->f__isRemote;
  e2->f__set_hooks     = (void (*)(void*, sidl_bool, struct                   \
    sidl_BaseInterface__object**)) epv->f__set_hooks;
  e2->f__set_contracts = (void (*)(void*, sidl_bool, const char*, sidl_bool,  \
    struct sidl_BaseInterface__object**)) epv->f__set_contracts;
  e2->f__dump_stats    = (void (*)(void*, const char*, const char*, struct    \
    sidl_BaseInterface__object**)) epv->f__dump_stats;
  e2->f__exec          = (void (*)(void*,const char*,struct                   \
    sidl_rmi_Call__object*,struct sidl_rmi_Return__object*,struct             \
    sidl_BaseInterface__object **)) epv->f__exec;
  e2->f_getServerURL   = (char* (*)(void*,const char*,struct                  \
    sidl_BaseInterface__object **)) epv->f_getServerURL;
  e2->f_isLocalObject  = (char* (*)(void*,const char*,struct                  \
    sidl_BaseInterface__object **)) epv->f_isLocalObject;
  e2->f_getExceptions  = (struct sidl_io_Serializable__array* (*)(void*,      \
    struct sidl_BaseInterface__object **)) epv->f_getExceptions;
  e2->f_addRef         = (void (*)(void*,struct sidl_BaseInterface__object    \
    **)) epv->f_addRef;
  e2->f_deleteRef      = (void (*)(void*,struct sidl_BaseInterface__object    \
    **)) epv->f_deleteRef;
  e2->f_isSame         = (sidl_bool (*)(void*,struct                          \
    sidl_BaseInterface__object*,struct sidl_BaseInterface__object **))        \
    epv->f_isSame;
  e2->f_isType         = (sidl_bool (*)(void*,const char*,struct              \
    sidl_BaseInterface__object **)) epv->f_isType;
  e2->f_getClassInfo   = (struct sidl_ClassInfo__object* (*)(void*,struct     \
    sidl_BaseInterface__object **)) epv->f_getClassInfo;

  e3->f__cast              = (void* (*)(struct                                \
    sidlx_rmi_SimpleServer__object*, const char*, struct                      \
    sidl_BaseInterface__object**)) epv->f__cast;
  e3->f__delete            = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidl_BaseInterface__object**)) epv->f__delete;
  e3->f__getURL            = (char* (*)(struct                                \
    sidlx_rmi_SimpleServer__object*, struct sidl_BaseInterface__object**))    \
    epv->f__getURL;
  e3->f__raddRef           = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidl_BaseInterface__object**)) epv->f__raddRef;
  e3->f__isRemote          = (sidl_bool (*)(struct                            \
    sidlx_rmi_SimpleServer__object*, struct sidl_BaseInterface__object**))    \
    epv->f__isRemote;
  e3->f__set_hooks         = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    sidl_bool, struct sidl_BaseInterface__object**)) epv->f__set_hooks;
  e3->f__set_contracts     = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    sidl_bool, const char*, sidl_bool, struct sidl_BaseInterface__object**))  \
    epv->f__set_contracts;
  e3->f__dump_stats        = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    const char*, const char*, struct sidl_BaseInterface__object**))           \
    epv->f__dump_stats;
  e3->f__exec              = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    const char*,struct sidl_rmi_Call__object*,struct sidl_rmi_Return__object*,\
    struct sidl_BaseInterface__object **)) epv->f__exec;
  e3->f_setMaxThreadPool   = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    int32_t,struct sidl_BaseInterface__object **)) epv->f_setMaxThreadPool;
  e3->f_requestPort        = (sidl_bool (*)(struct                            \
    sidlx_rmi_SimpleServer__object*,int32_t,struct sidl_BaseInterface__object \
    **)) epv->f_requestPort;
  e3->f_requestPortInRange = (sidl_bool (*)(struct                            \
    sidlx_rmi_SimpleServer__object*,int32_t,int32_t,struct                    \
    sidl_BaseInterface__object **)) epv->f_requestPortInRange;
  e3->f_getPort            = (int32_t (*)(struct                              \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object **))    \
    epv->f_getPort;
  e3->f_getServerName      = (char* (*)(struct                                \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object **))    \
    epv->f_getServerName;
  e3->f_getServerURL       = (char* (*)(struct                                \
    sidlx_rmi_SimpleServer__object*,const char*,struct                        \
    sidl_BaseInterface__object **)) epv->f_getServerURL;
  e3->f_run                = (int64_t (*)(struct                              \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object **))    \
    epv->f_run;
  e3->f_shutdown           = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidl_BaseInterface__object **)) epv->f_shutdown;
  e3->f_shutdownNoWait     = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidl_BaseInterface__object **)) epv->f_shutdownNoWait;
  e3->f_isRunning          = (sidl_bool (*)(struct                            \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object **))    \
    epv->f_isRunning;
  e3->f_serviceRequest     = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidlx_rmi_Socket__object*,struct sidl_BaseInterface__object **))   \
    epv->f_serviceRequest;
  e3->f_getExceptions      = (struct sidl_io_Serializable__array* (*)(struct  \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object **))    \
    epv->f_getExceptions;
  e3->f_addRef             = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidl_BaseInterface__object **)) epv->f_addRef;
  e3->f_deleteRef          = (void (*)(struct sidlx_rmi_SimpleServer__object*,\
    struct sidl_BaseInterface__object **)) epv->f_deleteRef;
  e3->f_isSame             = (sidl_bool (*)(struct                            \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object*,struct \
    sidl_BaseInterface__object **)) epv->f_isSame;
  e3->f_isType             = (sidl_bool (*)(struct                            \
    sidlx_rmi_SimpleServer__object*,const char*,struct                        \
    sidl_BaseInterface__object **)) epv->f_isType;
  e3->f_getClassInfo       = (struct sidl_ClassInfo__object* (*)(struct       \
    sidlx_rmi_SimpleServer__object*,struct sidl_BaseInterface__object **))    \
    epv->f_getClassInfo;
  e3->f_isLocalObject      = (char* (*)(struct                                \
    sidlx_rmi_SimpleServer__object*,const char*,struct                        \
    sidl_BaseInterface__object **)) epv->f_isLocalObject;

  s_remote_initialized = 1;
}

/* Create an instance that connects to an existing remote object. */
static struct sidlx_rmi_JimEchoServer__object*
sidlx_rmi_JimEchoServer__remoteConnect(const char *url, sidl_bool ar, struct  \
  sidl_BaseInterface__object* *_ex)
{
  struct sidlx_rmi_JimEchoServer__object* self = NULL;

  struct sidlx_rmi_JimEchoServer__object* s0;
  struct sidlx_rmi_SimpleServer__object* s1;
  struct sidl_BaseClass__object* s2;

  struct sidlx_rmi_JimEchoServer__remote* r_obj = NULL;
  sidl_rmi_InstanceHandle instance = NULL;
  char* objectID = NULL;
  objectID = NULL;
  *_ex = NULL;
  if(url == NULL) {return NULL;}
  objectID = sidl_rmi_ServerRegistry_isLocalObject(url, _ex);
  if(objectID) {
    struct sidlx_rmi_JimEchoServer__object* retobj = NULL;
    struct sidl_BaseInterface__object *throwaway_exception;
    sidl_BaseInterface bi = (                                                 \
      sidl_BaseInterface)sidl_rmi_InstanceRegistry_getInstanceByString(       \
      objectID, _ex); SIDL_CHECK(*_ex);
    (*bi->d_epv->f_deleteRef)(bi->d_object, &throwaway_exception);
    retobj = (struct sidlx_rmi_JimEchoServer__object*) (*bi->d_epv->f__cast)( \
      bi->d_object, "sidlx.rmi.JimEchoServer", _ex);
    if(!ar) { 
      (*bi->d_epv->f_deleteRef)(bi->d_object, &throwaway_exception);
    }
    return retobj;
  }
  instance = sidl_rmi_ProtocolFactory_connectInstance(url,                    \
    "sidlx.rmi.JimEchoServer", ar, _ex ); SIDL_CHECK(*_ex);
  if ( instance == NULL) { return NULL; }
  self =
    (struct sidlx_rmi_JimEchoServer__object*) malloc(
      sizeof(struct sidlx_rmi_JimEchoServer__object));

  r_obj =
    (struct sidlx_rmi_JimEchoServer__remote*) malloc(
      sizeof(struct sidlx_rmi_JimEchoServer__remote));

  if(!self || !r_obj) {
    sidl_MemAllocException ex = sidl_MemAllocException_getSingletonException( \
      _ex);
    SIDL_CHECK(*_ex);
    sidl_MemAllocException_setNote(ex, "Out of memory.", _ex); SIDL_CHECK(    \
      *_ex);
    sidl_MemAllocException_add(ex, __FILE__, __LINE__,                        \
      "sidlx.rmi.JimEchoServer.EPVgeneration", _ex);
    SIDL_CHECK(*_ex);
    *_ex = (struct sidl_BaseInterface__object*)ex;
    goto EXIT;
  }

  r_obj->d_refcount = 1;
  r_obj->d_ih = instance;
  s0 =                                   self;
  s1 =                                   &s0->d_sidlx_rmi_simpleserver;
  s2 =                                   &s1->d_sidl_baseclass;

  LOCK_STATIC_GLOBALS;
  if (!s_remote_initialized) {
    sidlx_rmi_JimEchoServer__init_remote_epv();
  }
  UNLOCK_STATIC_GLOBALS;

  s2->d_sidl_baseinterface.d_epv    = &s_rem_epv__sidl_baseinterface;
  s2->d_sidl_baseinterface.d_object = (void*) self;

  s2->d_data = (void*) r_obj;
  s2->d_epv  = &s_rem_epv__sidl_baseclass;

  s1->d_sidl_rmi_serverinfo.d_epv    = &s_rem_epv__sidl_rmi_serverinfo;
  s1->d_sidl_rmi_serverinfo.d_object = (void*) self;

  s1->d_data = (void*) r_obj;
  s1->d_epv  = &s_rem_epv__sidlx_rmi_simpleserver;

  s0->d_data = (void*) r_obj;
  s0->d_epv  = &s_rem_epv__sidlx_rmi_jimechoserver;

  self->d_data = (void*) r_obj;

  return self;
  EXIT:
  if(self) { free(self); }
  if(r_obj) { free(r_obj); }
  return NULL;
}
/* Create an instance that uses an already existing  */
/* InstanceHandle to connect to an existing remote object. */
static struct sidlx_rmi_JimEchoServer__object*
sidlx_rmi_JimEchoServer__IHConnect(sidl_rmi_InstanceHandle instance, struct   \
  sidl_BaseInterface__object* *_ex)
{
  struct sidlx_rmi_JimEchoServer__object* self = NULL;

  struct sidlx_rmi_JimEchoServer__object* s0;
  struct sidlx_rmi_SimpleServer__object* s1;
  struct sidl_BaseClass__object* s2;

  struct sidlx_rmi_JimEchoServer__remote* r_obj = NULL;
  self =
    (struct sidlx_rmi_JimEchoServer__object*) malloc(
      sizeof(struct sidlx_rmi_JimEchoServer__object));

  r_obj =
    (struct sidlx_rmi_JimEchoServer__remote*) malloc(
      sizeof(struct sidlx_rmi_JimEchoServer__remote));

  if(!self || !r_obj) {
    sidl_MemAllocException ex = sidl_MemAllocException_getSingletonException( \
      _ex);
    SIDL_CHECK(*_ex);
    sidl_MemAllocException_setNote(ex, "Out of memory.", _ex); SIDL_CHECK(    \
      *_ex);
    sidl_MemAllocException_add(ex, __FILE__, __LINE__,                        \
      "sidlx.rmi.JimEchoServer.EPVgeneration", _ex);
    SIDL_CHECK(*_ex);
    *_ex = (struct sidl_BaseInterface__object*)ex;
    goto EXIT;
  }

  r_obj->d_refcount = 1;
  r_obj->d_ih = instance;
  s0 =                                   self;
  s1 =                                   &s0->d_sidlx_rmi_simpleserver;
  s2 =                                   &s1->d_sidl_baseclass;

  LOCK_STATIC_GLOBALS;
  if (!s_remote_initialized) {
    sidlx_rmi_JimEchoServer__init_remote_epv();
  }
  UNLOCK_STATIC_GLOBALS;

  s2->d_sidl_baseinterface.d_epv    = &s_rem_epv__sidl_baseinterface;
  s2->d_sidl_baseinterface.d_object = (void*) self;

  s2->d_data = (void*) r_obj;
  s2->d_epv  = &s_rem_epv__sidl_baseclass;

  s1->d_sidl_rmi_serverinfo.d_epv    = &s_rem_epv__sidl_rmi_serverinfo;
  s1->d_sidl_rmi_serverinfo.d_object = (void*) self;

  s1->d_data = (void*) r_obj;
  s1->d_epv  = &s_rem_epv__sidlx_rmi_simpleserver;

  s0->d_data = (void*) r_obj;
  s0->d_epv  = &s_rem_epv__sidlx_rmi_jimechoserver;

  self->d_data = (void*) r_obj;

  sidl_rmi_InstanceHandle_addRef(instance,_ex);SIDL_CHECK(*_ex);
  return self;
  EXIT:
  if(self) { free(self); }
  if(r_obj) { free(r_obj); }
  return NULL;
}
/* REMOTE: generate remote instance given URL string. */
static struct sidlx_rmi_JimEchoServer__object*
sidlx_rmi_JimEchoServer__remoteCreate(const char *url, struct                 \
  sidl_BaseInterface__object **_ex)
{
  struct sidl_BaseInterface__object* _throwaway_exception = NULL;
  struct sidlx_rmi_JimEchoServer__object* self = NULL;

  struct sidlx_rmi_JimEchoServer__object* s0;
  struct sidlx_rmi_SimpleServer__object* s1;
  struct sidl_BaseClass__object* s2;

  struct sidlx_rmi_JimEchoServer__remote* r_obj = NULL;
  sidl_rmi_InstanceHandle instance = sidl_rmi_ProtocolFactory_createInstance( \
    url, "sidlx.rmi.JimEchoServer", _ex ); SIDL_CHECK(*_ex);
  if ( instance == NULL) { return NULL; }
  self =
    (struct sidlx_rmi_JimEchoServer__object*) malloc(
      sizeof(struct sidlx_rmi_JimEchoServer__object));

  r_obj =
    (struct sidlx_rmi_JimEchoServer__remote*) malloc(
      sizeof(struct sidlx_rmi_JimEchoServer__remote));

  if(!self || !r_obj) {
    sidl_MemAllocException ex = sidl_MemAllocException_getSingletonException( \
      _ex);
    SIDL_CHECK(*_ex);
    sidl_MemAllocException_setNote(ex, "Out of memory.", _ex); SIDL_CHECK(    \
      *_ex);
    sidl_MemAllocException_add(ex, __FILE__, __LINE__,                        \
      "sidlx.rmi.JimEchoServer.EPVgeneration", _ex);
    SIDL_CHECK(*_ex);
    *_ex = (struct sidl_BaseInterface__object*)ex;
    goto EXIT;
  }

  r_obj->d_refcount = 1;
  r_obj->d_ih = instance;
  s0 =                                   self;
  s1 =                                   &s0->d_sidlx_rmi_simpleserver;
  s2 =                                   &s1->d_sidl_baseclass;

  LOCK_STATIC_GLOBALS;
  if (!s_remote_initialized) {
    sidlx_rmi_JimEchoServer__init_remote_epv();
  }
  UNLOCK_STATIC_GLOBALS;

  s2->d_sidl_baseinterface.d_epv    = &s_rem_epv__sidl_baseinterface;
  s2->d_sidl_baseinterface.d_object = (void*) self;

  s2->d_data = (void*) r_obj;
  s2->d_epv  = &s_rem_epv__sidl_baseclass;

  s1->d_sidl_rmi_serverinfo.d_epv    = &s_rem_epv__sidl_rmi_serverinfo;
  s1->d_sidl_rmi_serverinfo.d_object = (void*) self;

  s1->d_data = (void*) r_obj;
  s1->d_epv  = &s_rem_epv__sidlx_rmi_simpleserver;

  s0->d_data = (void*) r_obj;
  s0->d_epv  = &s_rem_epv__sidlx_rmi_jimechoserver;

  self->d_data = (void*) r_obj;

  return self;
  EXIT:
  if(instance) { sidl_rmi_InstanceHandle_deleteRef(instance,                  \
    &_throwaway_exception); }
  if(self) { free(self); }
  if(r_obj) { free(r_obj); }
  return NULL;
}
/*
 * RMI connector function for the class.
 */

struct sidlx_rmi_JimEchoServer__object*
sidlx_rmi_JimEchoServer__connectI(const char* url, sidl_bool ar, struct       \
  sidl_BaseInterface__object **_ex)
{
  return sidlx_rmi_JimEchoServer__remoteConnect(url, ar, _ex);
}


#endif /*WITH_RMI*/
#ifdef WITH_RMI

static PyObject *
pStub_JimEchoServer__connect(PyObject *_ignored, PyObject *_args, PyObject    \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object* self = NULL;
  char* url = NULL;
  struct sidl_BaseInterface__object *_exception = NULL;
  static char *_kwlist[] = {
    "url",
    NULL
  };
  int _okay;
  sidl_rmi_NetworkException__import();
  _okay = PyArg_ParseTupleAndKeywords(
    _args, _kwdict, 
    "z", _kwlist,
    &url);
  if (_okay) {
#if (PY_VERSION_HEX >= 0x02040000)
    Py_BEGIN_ALLOW_THREADS
    sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    self = sidlx_rmi_JimEchoServer__remoteConnect(url,1,&_exception);
#if (PY_VERSION_HEX >= 0x02040000)
    Py_END_ALLOW_THREADS
    sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    if (_exception) {
      struct sidl_rmi_NetworkException__object *_ex0;
      if ((_ex0 = (struct sidl_rmi_NetworkException__object *)
      sidl_PyExceptionCast(_exception, "sidl.rmi.NetworkException"))) {
        struct sidl_BaseInterface__object *throwaway_exception;
        PyObject *_obj = sidl_rmi_NetworkException__wrap(_ex0);
        PyObject *_eargs = PyTuple_New(1);
        PyTuple_SetItem(_eargs, 0, _obj);
        _obj = PyObject_CallObject(sidl_rmi_NetworkException__type, _eargs);
        PyErr_SetObject(sidl_rmi_NetworkException__type, _obj);
        Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
        Py_BEGIN_ALLOW_THREADS
        sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
        (*(_exception->d_epv->f_deleteRef))(_exception->d_object,             \
          &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
        Py_END_ALLOW_THREADS
        sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
        Py_XDECREF(_eargs);
      }
    }
    else {
      _return_value = Py_BuildValue(
        "O&",
        (void *)sidlx_rmi_JimEchoServer__wrap, self);
    }
  }
  return _return_value;
}


#endif /*WITH_RMI*/
staticforward PyTypeObject _sidlx_rmi_JimEchoServerType;

static const struct sidlx_rmi_JimEchoServer__external *_implEPV = NULL;

static void *
_loadClassImpl(void) {
  if (!_implEPV) {
    /* Load the implementation. */
    struct sidl_BaseInterface__object *throwaway_exception;
    sidl_DLL dll = NULL;
    char *errmsg = NULL;
    struct sidlx_rmi_JimEchoServer__external*(*_extFunc)(void) = NULL;
    /* Try search global namespace first */
#if (PY_VERSION_HEX >= 0x02040000)
    Py_BEGIN_ALLOW_THREADS
    sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    dll = sidl_DLL__create(&throwaway_exception);
    if (dll && sidl_DLL_loadLibrary(dll, "main:", TRUE, FALSE,                \
      &throwaway_exception)) {
      _extFunc = (struct sidlx_rmi_JimEchoServer__external*(*)(void))
        sidl_DLL_lookupSymbol(dll, "sidlx_rmi_JimEchoServer__externals",      \
          &throwaway_exception);
      if ((!throwaway_exception) && _extFunc) {
        _implEPV = (*_extFunc)();
      }
    }
    if (dll) sidl_DLL_deleteRef(dll, &throwaway_exception);
    if (!_implEPV) {
      dll = sidl_Loader_findLibrary("sidlx.rmi.JimEchoServer",
        "ior/impl", sidl_Scope_SCLSCOPE,
        sidl_Resolve_SCLRESOLVE, &throwaway_exception);
      if (dll) {
        _extFunc = (struct sidlx_rmi_JimEchoServer__external*(*)(void))
          sidl_DLL_lookupSymbol(dll, "sidlx_rmi_JimEchoServer__externals",    \
            &throwaway_exception);
        if (!throwaway_exception && _extFunc) {
          _implEPV = (*_extFunc)();
        }
        else {
          char *name = sidl_DLL_getName(dll, &throwaway_exception);
          if (throwaway_exception) {
            name = sidl_String_strdup("(unknown)");
          }
          errmsg = sidl_String_concat3(
            "babel: The shared library containing SIDL type sidlx.rmi.JimEchoServer, ",
            name,
            ", was loaded but is missing a required symbol (sidlx_rmi_JimEchoServer__externals).");
          sidl_String_free(name);
        }
        sidl_DLL_deleteRef(dll, &throwaway_exception);
      }
      else {
        errmsg = sidl_String_strdup("babel: Unable to find or load a shared library containing the implementation of SIDL type sidlx.rmi.JimEchoServer. To get more debugging information trying setting the SIDL_DEBUG_DLOPEN environment variable and rerunning.");
      }
    }
#if (PY_VERSION_HEX >= 0x02040000)
    Py_END_ALLOW_THREADS
    sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    if (!_implEPV) {
      if (errmsg) PyErr_SetString(PyExc_RuntimeError, errmsg);
      else PyErr_SetString(PyExc_RuntimeError, "Unexpected error loading SIDL implementation for sidlx.rmi.JimEchoServer.");
      sidl_String_free(errmsg);
    }
  }
  return (void *)_implEPV;
}
static PyObject *
pStub_JimEchoServer__exec(PyObject *_self, PyObject *_args, PyObject          \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    char* methodName = NULL;
    struct sidl_rmi_Call__object* inArgs = NULL;
    struct sidl_rmi_Return__object* outArgs = NULL;
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      "methodName",
      "inArgs",
      "outArgs",
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    sidl_rmi_Call__import();
    sidl_rmi_Return__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "zO&O&", _kwlist,
      &methodName,
      (void *)sidl_rmi_Call__convert, &inArgs,
      (void *)sidl_rmi_Return__convert, &outArgs);
    if (_okay) {
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f__exec))(_self_ior, methodName, inArgs, outArgs,  \
        &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_None;
        Py_INCREF(_return_value);
      }
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      sidl_rmi_Call_deref(inArgs);
      sidl_rmi_Return_deref(outArgs);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer__getURL(PyObject *_self, PyObject *_args, PyObject        \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "", _kwlist);
    if (_okay) {
      char* _return = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _return = (*(_self_ior->d_epv->f__getURL))(_self_ior, &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_BuildValue(
          "z",
          _return);
        free((void *)_return);
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer__isLocal(PyObject *_self, PyObject *_args, PyObject       \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "", _kwlist);
    if (_okay) {
      sidl_bool _return = (sidl_bool) 0;
      int _proxy__return;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _return = !(*(_self_ior->d_epv->f__isRemote))(_self_ior, &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _proxy__return = _return;
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_BuildValue(
          "i",
          _proxy__return);
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer__isRemote(PyObject *_self, PyObject *_args, PyObject      \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "", _kwlist);
    if (_okay) {
      sidl_bool _return = (sidl_bool) 0;
      int _proxy__return;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _return = (*(_self_ior->d_epv->f__isRemote))(_self_ior, &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _proxy__return = _return;
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_BuildValue(
          "i",
          _proxy__return);
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer__set_hooks(PyObject *_self, PyObject *_args, PyObject     \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    sidl_bool enable = (sidl_bool) 0;
    struct sidl_BaseInterface__object *_exception = NULL;
    int _proxy_enable;
    static char *_kwlist[] = {
      "enable",
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "i", _kwlist,
      &_proxy_enable);
    if (_okay) {
      enable = (_proxy_enable ? (TRUE) : (FALSE));
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f__set_hooks))(_self_ior, enable, &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_None;
        Py_INCREF(_return_value);
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer_getExceptions(PyObject *_self, PyObject *_args, PyObject  \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    sidl_io_Serializable__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "", _kwlist);
    if (_okay) {
      struct sidl_io_Serializable__array* _return = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _return = (*(_self_ior->d_epv->f_getExceptions))(_self_ior,             \
        &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_BuildValue(
          "O&",
          (void *)sidl_io_Serializable__convert_sidl_array, _return);
#if (PY_VERSION_HEX >= 0x02040000)
        Py_BEGIN_ALLOW_THREADS
        sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
        sidl_python_deleteRef_array((struct sidl__array *)_return);
#if (PY_VERSION_HEX >= 0x02040000)
        Py_END_ALLOW_THREADS
        sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer_getServerURL(PyObject *_self, PyObject *_args, PyObject   \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    char* objID = NULL;
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      "objID",
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "z", _kwlist,
      &objID);
    if (_okay) {
      char* _return = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _return = (*(_self_ior->d_epv->f_getServerURL))(_self_ior, objID,       \
        &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_BuildValue(
          "z",
          _return);
        free((void *)_return);
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer_isLocalObject(PyObject *_self, PyObject *_args, PyObject  \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    char* url = NULL;
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      "url",
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "z", _kwlist,
      &url);
    if (_okay) {
      char* _return = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      _return = (*(_self_ior->d_epv->f_isLocalObject))(_self_ior, url,        \
        &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_BuildValue(
          "z",
          _return);
        free((void *)_return);
      }
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static PyObject *
pStub_JimEchoServer_serviceRequest(PyObject *_self, PyObject *_args, PyObject \
  *_kwdict) {
  PyObject *_return_value = NULL;
  struct sidlx_rmi_JimEchoServer__object *_self_ior =
    ((struct sidlx_rmi_JimEchoServer__object *)
     sidl_Cast(_self, "sidlx.rmi.JimEchoServer"));
  if (_self_ior) {
    struct sidlx_rmi_Socket__object* sock = NULL;
    struct sidl_BaseInterface__object *_exception = NULL;
    static char *_kwlist[] = {
      "sock",
      NULL
    };
    int _okay;
    sidl_RuntimeException__import();
    sidlx_rmi_Socket__import();
    _okay = PyArg_ParseTupleAndKeywords(
      _args, _kwdict, 
      "O&", _kwlist,
      (void *)sidlx_rmi_Socket__convert, &sock);
    if (_okay) {
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_serviceRequest))(_self_ior, sock, &_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        struct sidl_RuntimeException__object *_ex0;
        if ((_ex0 = (struct sidl_RuntimeException__object *)
        sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
          struct sidl_BaseInterface__object *throwaway_exception;
          PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
          PyObject *_eargs = PyTuple_New(1);
          PyTuple_SetItem(_eargs, 0, _obj);
          _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
          PyErr_SetObject(sidl_RuntimeException__type, _obj);
          Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_BEGIN_ALLOW_THREADS
          sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          (*(_exception->d_epv->f_deleteRef))(_exception->d_object,           \
            &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
          Py_END_ALLOW_THREADS
          sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
          Py_XDECREF(_eargs);
        }
      }
      else {
        _return_value = Py_None;
        Py_INCREF(_return_value);
      }
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      sidlx_rmi_Socket_deref(sock);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
    {
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*(_self_ior->d_epv->f_deleteRef))(_self_ior, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
  }
  else {
    PyErr_SetString(PyExc_TypeError, 
      "self pointer is not a sidlx.rmi.JimEchoServer");
  }
  return _return_value;
}

static int
sidlx_rmi_JimEchoServer_createCast(PyObject *self, PyObject *args, PyObject   \
  *kwds) {
  struct sidlx_rmi_JimEchoServer__object *optarg = NULL;
  char* url = NULL;
  PyObject * implObj = NULL;
  static char *_kwlist[] = {"sobj",  "url", "impl", NULL };
  int _okay = PyArg_ParseTupleAndKeywords(args, kwds, "|O&zO", _kwlist, (void \
    *)sidlx_rmi_JimEchoServer__convert, &optarg, &url, &implObj);
  if (_okay) {
    if (!optarg && !url && !implObj) {
      struct sidl_BaseInterface__object *_exception;
      if (!_loadClassImpl()) return -1;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      optarg = (*(_implEPV->createObject))(NULL,&_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        sidl_RuntimeException__import();
        {
          struct sidl_RuntimeException__object *_ex0;
          if ((_ex0 = (struct sidl_RuntimeException__object *)
          sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
            struct sidl_BaseInterface__object *throwaway_exception;
            PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
            PyObject *_eargs = PyTuple_New(1);
            PyTuple_SetItem(_eargs, 0, _obj);
            _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
            PyErr_SetObject(sidl_RuntimeException__type, _obj);
            Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_BEGIN_ALLOW_THREADS
            sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            (*(_exception->d_epv->f_deleteRef))(_exception->d_object,         \
              &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_END_ALLOW_THREADS
            sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            Py_XDECREF(_eargs);
          }
          return -1;
        }
      }
    }
    else if (!optarg && !url && implObj) {
      struct sidl_BaseInterface__object *_exception;
      if (!_loadClassImpl()) return -1;
      Py_INCREF(implObj);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      optarg = (*(_implEPV->createObject))((void*)implObj,&_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        sidl_RuntimeException__import();
        {
          struct sidl_RuntimeException__object *_ex0;
          if ((_ex0 = (struct sidl_RuntimeException__object *)
          sidl_PyExceptionCast(_exception, "sidl.RuntimeException"))) {
            struct sidl_BaseInterface__object *throwaway_exception;
            PyObject *_obj = sidl_RuntimeException__wrap(_ex0);
            PyObject *_eargs = PyTuple_New(1);
            PyTuple_SetItem(_eargs, 0, _obj);
            _obj = PyObject_CallObject(sidl_RuntimeException__type, _eargs);
            PyErr_SetObject(sidl_RuntimeException__type, _obj);
            Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_BEGIN_ALLOW_THREADS
            sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            (*(_exception->d_epv->f_deleteRef))(_exception->d_object,         \
              &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_END_ALLOW_THREADS
            sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            Py_XDECREF(_eargs);
          }
          return -1;
        }
      }
    }

#ifdef WITH_RMI

    else if(url && !optarg && !implObj) {
      struct sidl_BaseInterface__object *_exception = NULL;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      optarg = sidlx_rmi_JimEchoServer__remoteCreate(url,&_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      if (_exception) {
        sidl_rmi_NetworkException__import();
        {
          struct sidl_rmi_NetworkException__object *_ex0;
          if ((_ex0 = (struct sidl_rmi_NetworkException__object *)
          sidl_PyExceptionCast(_exception, "sidl.rmi.NetworkException"))) {
            struct sidl_BaseInterface__object *throwaway_exception;
            PyObject *_obj = sidl_rmi_NetworkException__wrap(_ex0);
            PyObject *_eargs = PyTuple_New(1);
            PyTuple_SetItem(_eargs, 0, _obj);
            _obj = PyObject_CallObject(sidl_rmi_NetworkException__type,       \
              _eargs);
            PyErr_SetObject(sidl_rmi_NetworkException__type, _obj);
            Py_XDECREF(_obj);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_BEGIN_ALLOW_THREADS
            sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            (*(_exception->d_epv->f_deleteRef))(_exception->d_object,         \
              &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_END_ALLOW_THREADS
            sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            Py_XDECREF(_eargs);
          }
          }
        return -1;
      }
    }

#endif /*WITH_RMI*/

    /* OK, but fall though */
    else if(!url && optarg && !implObj) {}
    /* Error case. */
    else {
      return -1;
    }
    return sidl_Object_Init(
      (SPObject *)self,
      (struct sidl_BaseInterface__object *)optarg,
      sidl_PyStealRef);
  }
  return -1;
}

static PyMethodDef _JimEchoServerModuleMethods[] = {

#ifdef WITH_RMI

  { "_connect", (PyCFunction)pStub_JimEchoServer__connect,
  (METH_VARARGS | METH_KEYWORDS),
"\
_connect( in string url)\n\
RETURNS\n\
   ( out sidlx.rmi.JimEchoServer self)\n\
RAISES\n\
    sidl.rmi.NetworkException\n\
"
   },

#endif /*WITH_RMI*/

  { NULL, NULL }
};

static PyMethodDef _JimEchoServerObjectMethods[] = {
  { "_exec", (PyCFunction)pStub_JimEchoServer__exec,
  (METH_VARARGS | METH_KEYWORDS),
"\
_exec( in string methodName,\n\
       in sidl.rmi.Call inArgs,\n\
       in sidl.rmi.Return outArgs)\n\
RETURNS\n\
    None\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
Select and execute a method by name"
   },
  { "_getURL", (PyCFunction)pStub_JimEchoServer__getURL,
  (METH_VARARGS | METH_KEYWORDS),
"\
_getURL()\n\
RETURNS\n\
   (string _return)\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
Get the URL of the Implementation of this object (for RMI)"
   },
  { "_isLocal", (PyCFunction)pStub_JimEchoServer__isLocal,
  (METH_VARARGS | METH_KEYWORDS),
"\
_isLocal()\n\
RETURNS\n\
   (bool _return)\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
TRUE if this object is local, false if remote"
   },
  { "_isRemote", (PyCFunction)pStub_JimEchoServer__isRemote,
  (METH_VARARGS | METH_KEYWORDS),
"\
_isRemote()\n\
RETURNS\n\
   (bool _return)\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
TRUE if this object is remote, false if local"
   },
  { "_set_hooks", (PyCFunction)pStub_JimEchoServer__set_hooks,
  (METH_VARARGS | METH_KEYWORDS),
"\
_set_hooks( in bool enable)\n\
RETURNS\n\
    None\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
Method to enable/disable method hooks invocation."
   },
  { "getExceptions", (PyCFunction)pStub_JimEchoServer_getExceptions,
  (METH_VARARGS | METH_KEYWORDS),
"\
getExceptions()\n\
RETURNS\n\
   (array<sidl.io.Serializable> _return)\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
This gets an array of logged exceptions.  If an exception can\n\
not be thrown back to the caller, we log it with the Server.  This \n\
gets the array of all those exceptions.\n\
THIS IS SOMETHING OF A TEST! THIS MAY CHANGE!"
   },
  { "getServerURL", (PyCFunction)pStub_JimEchoServer_getServerURL,
  (METH_VARARGS | METH_KEYWORDS),
"\
getServerURL( in string objID)\n\
RETURNS\n\
   (string _return)\n\
RAISES\n\
    sidl.RuntimeException\n\
\n\
\
Get the full URL for exporting objects (Doesn't do anything in this server)"
   },
  { "isLocalObject", (PyCFunction)pStub_JimEchoServer_isLocalObject,
  (METH_VARARGS | METH_KEYWORDS),
"\
isLocalObject( in string url)\n\
RETURNS\n\
   (string _return)\n\
RAISES\n\
    sidl.RuntimeException\n\
"
   },
  { "serviceRequest", (PyCFunction)pStub_JimEchoServer_serviceRequest,
  (METH_VARARGS | METH_KEYWORDS),
"\
serviceRequest( in sidlx.rmi.Socket sock)\n\
RETURNS\n\
    None\n\
RAISES\n\
    sidl.RuntimeException\n\
"
   },
  { NULL, NULL }
};

static PyTypeObject _sidlx_rmi_JimEchoServerType = {
  PyObject_HEAD_INIT(NULL)
  0,      /* ob_size */
  "sidlx.rmi.JimEchoServer.JimEchoServer", /* tp_name */
  0,      /* tp_basicsize */
  0,      /* tp_itemsize */
  0,      /* tp_dealloc */
  0,      /* tp_print */
  0,      /* tp_getattr */
  0,      /* tp_setattr */
  0,      /* tp_compare */
  0,      /* tp_repr */
  0,      /* tp_as_number */
  0,      /* tp_as_sequence */
  0,      /* tp_as_mapping */
  0,      /* tp_hash  */
  0,      /* tp_call */
  0,      /* tp_str */
  0,      /* tp_getattro */
  0,      /* tp_setattro */
  0,      /* tp_as_buffer */
  Py_TPFLAGS_DEFAULT, /* tp_flags */
  "\
\
 \n\
Echos strings back to the client using Jim's echo protocol", /* tp_doc */
  0,      /* tp_traverse */
  0,       /* tp_clear */
  0,       /* tp_richcompare */
  0,       /* tp_weaklistoffset */
  0,       /* tp_iter */
  0,       /* tp_iternext */
  _JimEchoServerObjectMethods, /* tp_methods */
  0,       /* tp_members */
  0,       /* tp_getset */
  0,       /* tp_base */
  0,       /* tp_dict */
  0,       /* tp_descr_get */
  0,       /* tp_descr_set */
  0,       /* tp_dictoffset */
  sidlx_rmi_JimEchoServer_createCast,   /* tp_init */
  0,       /* tp_alloc */
  0,       /* tp_new */
};

sidlx_rmi_JimEchoServer__wrap_RETURN
sidlx_rmi_JimEchoServer__wrap sidlx_rmi_JimEchoServer__wrap_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidlx_rmi_JimEchoServerType.tp_new(                             \
      &_sidlx_rmi_JimEchoServerType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyStealRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidlx_rmi_JimEchoServer__weakRef_RETURN
sidlx_rmi_JimEchoServer__weakRef sidlx_rmi_JimEchoServer__weakRef_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidlx_rmi_JimEchoServerType.tp_new(                             \
      &_sidlx_rmi_JimEchoServerType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyWeakRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidlx_rmi_JimEchoServer_deref_RETURN
sidlx_rmi_JimEchoServer_deref sidlx_rmi_JimEchoServer_deref_PROTO {
  if (sidlobj) {
    struct sidl_BaseInterface__object *throwaway_exception;
    (*(sidlobj->d_epv->f_deleteRef))(sidlobj, &throwaway_exception);
  }
}

sidlx_rmi_JimEchoServer__newRef_RETURN
sidlx_rmi_JimEchoServer__newRef sidlx_rmi_JimEchoServer__newRef_PROTO {
  PyObject *result;
  if (sidlobj) {
    result = _sidlx_rmi_JimEchoServerType.tp_new(                             \
      &_sidlx_rmi_JimEchoServerType, NULL, NULL);
    if (result) {
      if (sidl_Object_Init(
        (SPObject *)result,
        (struct sidl_BaseInterface__object *)(sidlobj),
        sidl_PyNewRef))
      {
        Py_DECREF(result);
        result = NULL;
      }
    }
  }
  else {
    result = Py_None;
    Py_INCREF(result);
  }
  return result;
}

sidlx_rmi_JimEchoServer__addRef_RETURN
sidlx_rmi_JimEchoServer__addRef sidlx_rmi_JimEchoServer__addRef_PROTO {
  if (sidlobj) {
    struct sidl_BaseInterface__object *throwaway_exception;
    (*(sidlobj->d_epv->f_addRef))(sidlobj, &throwaway_exception);
  }
}

sidlx_rmi_JimEchoServer_PyType_RETURN
sidlx_rmi_JimEchoServer_PyType sidlx_rmi_JimEchoServer_PyType_PROTO {
  Py_INCREF(&_sidlx_rmi_JimEchoServerType);
  return &_sidlx_rmi_JimEchoServerType;
}

sidlx_rmi_JimEchoServer__convert_RETURN
sidlx_rmi_JimEchoServer__convert sidlx_rmi_JimEchoServer__convert_PROTO {
  if (*sidlobj) {
    struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
    Py_BEGIN_ALLOW_THREADS
    sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    (*((*sidlobj)->d_epv->f_deleteRef))((*sidlobj), &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
    Py_END_ALLOW_THREADS
    sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
  }
  *sidlobj = sidl_Cast(obj, "sidlx.rmi.JimEchoServer");
  if ((!(*sidlobj)) && (obj != Py_None)) {
    PyErr_SetString(PyExc_TypeError, 
      "argument is not a(n) sidlx.rmi.JimEchoServer");
    return 0;
  }
  return 1;
}

static int
_convertPython(void *sidlarray, const int *ind, PyObject *pyobj)
{
  struct sidlx_rmi_JimEchoServer__object *sidlobj = NULL;
  if (sidlx_rmi_JimEchoServer__convert(pyobj, &sidlobj)) {
    sidl_interface__array_set((struct sidl_interface__array *)sidlarray,
    ind, (struct sidl_BaseInterface__object *)sidlobj);
    if (sidlobj) {
      struct sidl_BaseInterface__object *asInt = (struct                      \
        sidl_BaseInterface__object *)sidlobj;
      struct sidl_BaseInterface__object *throwaway_exception;
#if (PY_VERSION_HEX >= 0x02040000)
      Py_BEGIN_ALLOW_THREADS
      sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
      (*asInt->d_epv->f_deleteRef)(asInt->d_object, &throwaway_exception);
#if (PY_VERSION_HEX >= 0x02040000)
      Py_END_ALLOW_THREADS
      sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    }
    return FALSE;
  }
  return TRUE;
}

sidlx_rmi_JimEchoServer__convert_python_array_RETURN
sidlx_rmi_JimEchoServer__convert_python_array                                 \
  sidlx_rmi_JimEchoServer__convert_python_array_PROTO {
  int result = 0;
  if (*sidlarray) {
#if (PY_VERSION_HEX >= 0x02040000)
    Py_BEGIN_ALLOW_THREADS
    sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    sidl__array_deleteRef((struct sidl__array *)*sidlarray);
#if (PY_VERSION_HEX >= 0x02040000)
    Py_END_ALLOW_THREADS
    sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
    *sidlarray = NULL;
  }
  if (obj == Py_None) {
    result = TRUE;
  }
  else {
    PyObject *pya = PyArray_FromObject(obj, PyArray_OBJECT, 0, 0);
    if (pya) {
      if (PyArray_OBJECT == ((PyArrayObject *)pya)->descr->type_num) {
        int dimen, lower[SIDL_MAX_ARRAY_DIMENSION],
          upper[SIDL_MAX_ARRAY_DIMENSION],
          stride[SIDL_MAX_ARRAY_DIMENSION];
        if (sidl_array__extract_python_info
          (pya, &dimen, lower, upper, stride))
        {
            *sidlarray = (struct                                              \
              sidlx_rmi_JimEchoServer__array*)sidl_interface__array_createRow
            (dimen, lower, upper);
          result = sidl_array__convert_python
            (pya, dimen, *sidlarray, _convertPython);
          if (*sidlarray && !result) {
#if (PY_VERSION_HEX >= 0x02040000)
            Py_BEGIN_ALLOW_THREADS
            sidl_Python_LogUnlock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            sidl_interface__array_deleteRef(
              (struct  sidl_interface__array *)*sidlarray);
#if (PY_VERSION_HEX >= 0x02040000)
            Py_END_ALLOW_THREADS
            sidl_Python_LogRelock(__func__, __FILE__, __LINE__);
#endif /* Python 2.4 or later */
            *sidlarray = NULL;
          }
        }
      }
      Py_DECREF(pya);
    }
  }
  return result;
}

static int
_convertSIDL(void *sidlarray, const int *ind, PyObject **dest)
{
  struct sidlx_rmi_JimEchoServer__object *sidlobj = (struct                   \
    sidlx_rmi_JimEchoServer__object*)
  sidl_interface__array_get((struct sidl_interface__array *)
    sidlarray, ind);
  *dest = sidlx_rmi_JimEchoServer__wrap(sidlobj);
  return (*dest == NULL);
}

sidlx_rmi_JimEchoServer__convert_sidl_array_RETURN
sidlx_rmi_JimEchoServer__convert_sidl_array                                   \
  sidlx_rmi_JimEchoServer__convert_sidl_array_PROTO {
  PyObject *pya = NULL;
  if (sidlarray) {
    const int dimen = sidlArrayDim(sidlarray);
    int numelem[7];
    int32_t start[7];
#if SIZEOF_INT != 4
    int lower[7];
    int upper[7];
    int32_t s_numelem[7];
#else
    int * const lower = (int *)(sidlarray->d_lower);
    int * const upper = (int *)(sidlarray->d_upper);
    int32_t * const s_numelem = numelem;
#endif
    int i;
    for(i = 0; i < dimen; ++i) {
      start[i] = sidlLower(sidlarray, i);
#if SIZEOF_INT != 4
      lower[i] = sidlLower(sidlarray, i);
      upper[i] = sidlUpper(sidlarray, i);
      s_numelem[i] = sidlLength(sidlarray, i);
#endif
      numelem[i] = 1 + upper[i] - lower[i];
    }
    pya = PyArray_FromDims(dimen, numelem, PyArray_OBJECT);
    if (pya) {
      if (!sidl_array__convert_sidl(pya, dimen, start,
        sidlarray->d_upper,
        s_numelem, sidlarray, _convertSIDL))
      {
        Py_DECREF(pya);
        pya = NULL;
      }
    }
  }
  else {
    Py_INCREF(Py_None);
    pya = Py_None;
  }
  return pya;
}

void
initJimEchoServer(void) {
  PyObject *module, *dict, *c_api;
  static void *ExternalAPI[sidlx_rmi_JimEchoServer__API_NUM];
  struct sidl_BaseInterface__object *throwaway_exception;
  module = Py_InitModule3("JimEchoServer", _JimEchoServerModuleMethods, "\
\
 \n\
Echos strings back to the client using Jim's echo protocol"
  );
  dict = PyModule_GetDict(module);
  ExternalAPI[sidlx_rmi_JimEchoServer__wrap_NUM] = (                          \
    void*)sidlx_rmi_JimEchoServer__wrap;
  ExternalAPI[sidlx_rmi_JimEchoServer__convert_NUM] = (                       \
    void*)sidlx_rmi_JimEchoServer__convert;
  ExternalAPI[sidlx_rmi_JimEchoServer__convert_python_array_NUM] = (          \
    void*)sidlx_rmi_JimEchoServer__convert_python_array;
  ExternalAPI[sidlx_rmi_JimEchoServer__convert_sidl_array_NUM] = (            \
    void*)sidlx_rmi_JimEchoServer__convert_sidl_array;
  ExternalAPI[sidlx_rmi_JimEchoServer__weakRef_NUM] = (                       \
    void*)sidlx_rmi_JimEchoServer__weakRef;
  ExternalAPI[sidlx_rmi_JimEchoServer_deref_NUM] = (                          \
    void*)sidlx_rmi_JimEchoServer_deref;
  ExternalAPI[sidlx_rmi_JimEchoServer__newRef_NUM] = (                        \
    void*)sidlx_rmi_JimEchoServer__newRef;
  ExternalAPI[sidlx_rmi_JimEchoServer__addRef_NUM] = (                        \
    void*)sidlx_rmi_JimEchoServer__addRef;
  ExternalAPI[sidlx_rmi_JimEchoServer_PyType_NUM] = (                         \
    void*)sidlx_rmi_JimEchoServer_PyType;
#ifdef WITH_RMI
  ExternalAPI[sidlx_rmi_JimEchoServer__connectI_NUM] = (                      \
    void*)sidlx_rmi_JimEchoServer__connectI;
#endif /*WITH_RMI*/
  import_SIDLObjA();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing sidlObjA module.");
  }
  c_api = PyCObject_FromVoidPtr((void *)ExternalAPI, NULL);
  PyDict_SetItemString(dict, "_C_API", c_api);
  Py_XDECREF(c_api);
  import_SIDLPyArrays();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing sidlPyArrays module.");
  }
  import_array();
  if (PyErr_Occurred()) {
    Py_FatalError("Error importing Numeric Python module.");
  }
  sidlx_rmi_SimpleServer__import();
  _sidlx_rmi_JimEchoServerType.tp_base = sidlx_rmi_SimpleServer_PyType();
  _sidlx_rmi_JimEchoServerType.tp_bases = PyTuple_New(1);
  PyTuple_SetItem(_sidlx_rmi_JimEchoServerType.tp_bases,0, (PyObject          \
    *)sidlx_rmi_SimpleServer_PyType());
  if (PyType_Ready(&_sidlx_rmi_JimEchoServerType) < 0) {
    PyErr_Print();
    fprintf(stderr, "PyType_Ready on sidlx.rmi.JimEchoServer failed.\n");
    return;
  }
  Py_INCREF(&_sidlx_rmi_JimEchoServerType);
  PyDict_SetItemString(dict, "JimEchoServer", (PyObject                       \
    *)&_sidlx_rmi_JimEchoServerType);

#ifdef WITH_RMI


  sidl_rmi_ConnectRegistry_registerConnect("sidlx.rmi.JimEchoServer", (       \
    void*)sidlx_rmi_JimEchoServer__IHConnect, &throwaway_exception);

#endif /*WITH_RMI*/

}
