/*
 * File:        sidl_string_IOR.c
 * Copyright:   (c) 2001 Lawrence Livermore National Security, LLC
 * Revision:    @(#) $Revision$
 * Date:        $Date$
 * Description: string array implementation
 * AUTOMATICALLY GENERATED BY createarrays.py
 *
 * See header file for method comments.
 */

#include "sidl_string_IOR.h"
#include <stdlib.h>
#include <string.h>

#ifdef MAX
#undef MAX
#endif
#ifdef MIN
#undef MIN
#endif
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#define MIN(x,y) (((x) < (y)) ? (x) : (y))

static void swap_i32(int32_t *i1, int32_t *i2)
{
  int32_t tmp = *i1;
  *i1 = *i2;
  *i2 = tmp;
}

#include "sidl_String.h"
#define HELPER_VARIABLE
#define COPY_VALUE(x) sidl_String_strdup((x))
#define DESTROY_VALUE(x) sidl_String_free((x))
#define INIT_VALUES(ptr,size) if (ptr) memset((ptr), 0, (size))
#define DESTROY_VALUES_TOO 1

static char * const sidl_string__array_zero = NULL;


/**
 * The data structure for multi-dimensional arrays for sidl string.
 * The client may access this with the functions below or using
 * the macros in the header file sidlArray.h.
 */
struct sidl_string__array {
  struct sidl__array   d_metadata;
  char * *d_firstElement;
};

static void
sidl_string__array_bdestroy(struct sidl_string__array* array)
{
  if (array) {
#ifdef SIDL_DEBUG_REFCOUNT
    sidl__array_remove((struct sidl__array *)array);
#endif
    memset(array, 0, sizeof(struct sidl_string__array) +
           3 * (size_t)array->d_metadata.d_dimen * sizeof(int32_t));
    free(array);
  }
}

static void
sidl_string__array_destroy(struct sidl_string__array* array)
{
  if (array) {
#ifdef DESTROY_VALUES_TOO
    char * *ptr = array->d_firstElement;
    int32_t i;
    int32_t size = 1;
    HELPER_VARIABLE;
    for(i = 0; i < array->d_metadata.d_dimen;++i){
      size *= (1 + array->d_metadata.d_upper[i] -
                   array->d_metadata.d_lower[i]);
    }
    while (size--) {
      DESTROY_VALUE(*ptr);
      *(ptr++) = NULL;
    }
#endif
    free(array->d_firstElement);
    sidl_string__array_bdestroy(array);
  }
}

static void
sidl_string__array_rdestroy(struct sidl_string__array* array)
{
#ifdef SIDL_DEBUG_REFCOUNT
  if (array) sidl__array_remove((struct sidl__array *)array);
#endif
}
static void
sidl_string__array_sdestroy(struct sidl_string__array* array)
{
  if (array) {
    static const size_t arraySize = sizeof(struct sidl_string__array)
      + (sizeof(void *) - (sizeof(struct sidl_string__array)
                        % sizeof(void *))) % sizeof(void *);
    struct sidl_string__array **orig;
    orig = (struct sidl_string__array **)((char *)array + arraySize);
    if (*orig) {
      sidl_string__array_deleteRef(*orig);
      *orig = NULL;
    }
    sidl_string__array_bdestroy(array);
  }
}

static struct sidl_string__array*
sidl_string__array_smartCp(struct sidl_string__array* array)
{
  sidl_string__array_addRef(array);
  return array;
}

static struct sidl_string__array*
sidl_string__array_borrowSmartCp(struct sidl_string__array* array)
{
  struct sidl_string__array* copy = NULL;
  if (array) {
    if (sidl_string__array_isColumnOrder(array)) {
      copy = sidl_string__array_createCol(array->d_metadata.d_dimen,
                                                array->d_metadata.d_lower,
                                                array->d_metadata.d_upper);
    }
    else {
      copy = sidl_string__array_createRow(array->d_metadata.d_dimen,
                                                array->d_metadata.d_lower,
                                                array->d_metadata.d_upper);
    }
    sidl_string__array_copy(array, copy);
  }
  return copy;
}

static int32_t
string_arrayType(void)
{
  return sidl_string_array;
}

static const struct sidl__array_vtable rarray_string_vtable = {
  (void (*)(struct sidl__array *))sidl_string__array_rdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_string__array_borrowSmartCp,
  string_arrayType
};

static const struct sidl__array_vtable normal_string_vtable = {
  (void (*)(struct sidl__array *))sidl_string__array_destroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_string__array_smartCp,
  string_arrayType
};

static const struct sidl__array_vtable borrowed_string_vtable = {
  (void (*)(struct sidl__array *))sidl_string__array_bdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_string__array_borrowSmartCp,
  string_arrayType
};

static const struct sidl__array_vtable sliced_string_vtable = {
  (void (*)(struct sidl__array *))sidl_string__array_sdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_string__array_smartCp,
  string_arrayType
};

static const struct sidl__array_vtable bsliced_string_vtable = {
  (void (*)(struct sidl__array *))sidl_string__array_sdestroy,
  (struct sidl__array *(*)(struct sidl__array *))
    sidl_string__array_borrowSmartCp,
  string_arrayType
};
static struct sidl_string__array*
newArray(int32_t dimen, const int32_t lower[], const int32_t upper[],
         struct sidl_string__array *orig)
{
  static const size_t arraySize = sizeof(struct sidl_string__array)
    + (sizeof(void *) - (sizeof(struct sidl_string__array)
                      % sizeof(void *))) % sizeof(void *);
  const size_t baseSize = arraySize +
    (orig ? sizeof(struct sidl_string__array *) : 0);
  const size_t extraBytes = 3 * sizeof(int32_t) * (size_t)dimen;
  const size_t totalSize = baseSize + extraBytes;
  struct sidl_string__array *result = (struct sidl_string__array *)malloc(totalSize);
  result->d_metadata.d_dimen = dimen;
  result->d_metadata.d_refcount = 1;
  result->d_metadata.d_lower = (int32_t *)((char *)result + baseSize);
  result->d_metadata.d_upper = result->d_metadata.d_lower + dimen;
  result->d_metadata.d_stride = result->d_metadata.d_upper + dimen;
  if (orig) {
    struct sidl_string__array **ref;
    ref = (struct sidl_string__array **)((char *)result + arraySize);
    *ref = orig;
    sidl_string__array_addRef(orig);
    result->d_metadata.d_vtable = &sliced_string_vtable;
  }
  else {
    result->d_metadata.d_vtable = &normal_string_vtable;
  }
  memcpy(result->d_metadata.d_lower, lower, sizeof(int32_t)*(size_t)dimen);
  memcpy(result->d_metadata.d_upper, upper, sizeof(int32_t)*(size_t)dimen);
#ifdef SIDL_DEBUG_REFCOUNT
  sidl__array_add((struct sidl__array *)result);
#endif
  return result;
}

struct sidl_string__array *
sidl_string__array_createCol(int32_t       dimen,
                             const int32_t lower[],
                             const int32_t upper[])
{
  int i;
  size_t size=1;
  struct sidl_string__array *result = newArray(dimen, lower, upper, NULL);
  for(i = 0; i < dimen; ++i) {
    result->d_metadata.d_stride[i] = size;
    size *= (size_t)(1 + upper[i] - lower[i]);
  }
  size *= sizeof(char *);
  result->d_firstElement = (char * *)malloc(size);
  INIT_VALUES(result->d_firstElement, size);
  return result;
}

struct sidl_string__array *
sidl_string__array_createRow(int32_t       dimen,
                             const int32_t lower[],
                             const int32_t upper[])
{
  int i;
  size_t size=1;
  struct sidl_string__array *result = newArray(dimen, lower, upper, NULL);
  for(i = dimen-1; i >= 0; --i) {
    result->d_metadata.d_stride[i] = size;
    size *= (size_t)(1 + upper[i] - lower[i]);
  }
  size *= sizeof(char *);
  result->d_firstElement = (char * *)malloc(size);
  INIT_VALUES(result->d_firstElement, size);
  return result;
}

void
sidl_string__array_init(const char ** c_array,
struct sidl_string__array* sidl_array, int32_t dim,
int32_t lower[], int32_t upper[], int32_t stride[])
{
  int32_t i = 0;
  int32_t size = 1;
  for(i=0; i < dim; ++i) 
     lower[i] = 0;

  for(i = 0; i < dim; ++i) {
    stride[i] = size;
    size *= (1 + upper[i] - lower[i]);
  }

  sidl_array->d_metadata.d_lower = lower;
  sidl_array->d_metadata.d_upper = upper;
  sidl_array->d_metadata.d_stride = stride;
  sidl_array->d_metadata.d_dimen = dim;	
  sidl_array->d_metadata.d_lower = lower;
  sidl_array->d_metadata.d_vtable = &rarray_string_vtable;
  sidl_array->d_metadata.d_refcount = 1;
  sidl_array->d_firstElement = (char * *)c_array;
#ifdef SIDL_DEBUG_REFCOUNT
  sidl__array_add((struct sidl__array *)sidl_array);
#endif
}

struct sidl_string__array *
sidl_string__array_create1d(int32_t len)
{
  static const int32_t zero = 0;
  --len;
  return sidl_string__array_createCol(1, &zero, &len);
}

struct sidl_string__array *
sidl_string__array_create1dInit(int32_t len,
                                const char ** data)
{
  struct sidl_string__array *result;
  if (data && (len > 0)) {
    static const int32_t lower = 0;
    const int32_t upper = len - 1;
    result = newArray(1, &lower, &upper, NULL);
    if (result) {
      const char * * restrict src =
        (const char * * restrict)data;
      char * * restrict dest;
      HELPER_VARIABLE;
      result->d_metadata.d_stride[0] = 1;
      result->d_firstElement =
        (char * *)malloc((size_t)len*sizeof(char *));
      dest = (char * * restrict)(result->d_firstElement);
      while (len--) {
        *dest = COPY_VALUE(*src);
        ++dest;
        ++src;
      }
    }
  }
  else {
    result = sidl_string__array_create1d(len);
  }
  return result;
}

struct sidl_string__array *
sidl_string__array_create2dCol(int32_t m, int32_t n)
{
  static const int32_t zero[2] = {0, 0};
  int32_t upper[2];
  upper[0] = m-1;
  upper[1] = n-1;
  return sidl_string__array_createCol(2, zero, upper);
}

struct sidl_string__array *
sidl_string__array_create2dRow(int32_t m, int32_t n)
{
  static const int32_t zero[2] = {0, 0};
  int32_t upper[2];
  upper[0] = m-1;
  upper[1] = n-1;
  return sidl_string__array_createRow(2, zero, upper);
}

static int32_t
getStride(const int32_t *srcStride, const int32_t i)
{
  return srcStride ? srcStride[i] : 1;
}
static int
goodSliceArgs(struct sidl_string__array* src,
               int32_t       dimen,
               const int32_t *srcStart,
               const int32_t *srcStride,
               const int32_t *newStart,
               const int32_t *numElem)
{
  if (src && numElem && (dimen > 0) && (dimen <= src->d_metadata.d_dimen)) {
    int32_t i, numZeros;
    const int32_t *srcFirst = (srcStart ? srcStart : src->d_metadata.d_lower);
    for(i = 0, numZeros=0; i < src->d_metadata.d_dimen; ++i) {
      if ((srcFirst[i] < src->d_metadata.d_lower[i]) ||
          (srcFirst[i] > src->d_metadata.d_upper[i]) ||
          (numElem[i] &&
           (((srcFirst[i] + (numElem[i]-1)*getStride(srcStride,i)) >
              src->d_metadata.d_upper[i]) ||
            ((srcFirst[i] + (numElem[i]-1)*getStride(srcStride,i)) <
              src->d_metadata.d_lower[i]))))
        return 0;
      if (!numElem[i]) ++numZeros;
    }
    return (dimen + numZeros) == src->d_metadata.d_dimen;
  }
  return 0;
}

struct sidl_string__array *
sidl_string__array_slice(struct sidl_string__array *src,
                         int32_t       dimen,
                         const int32_t numElem[],
                         const int32_t *srcStart,
                         const int32_t *srcStride,
                         const int32_t *newStart)
{
  struct sidl_string__array *result = NULL;
  if (goodSliceArgs(src, dimen, srcStart, srcStride, newStart, numElem)) {
    const int32_t *srcFirst = (srcStart ? srcStart : src->d_metadata.d_lower);
    const int32_t *newFirst = (newStart ? newStart : srcFirst);
    int32_t *newLast = malloc(sizeof(int32_t)*(size_t)dimen);
    int32_t i, j;
    if (!newLast) return NULL;
    for(i = 0, j = 0; i < src->d_metadata.d_dimen; ++i) {
      if (numElem[i]) {
        newLast[j] = newFirst[j] + numElem[i] - 1;
        ++j;
      }
    }
    result = newArray(dimen, newFirst, newLast, src);
    free(newLast);
    if (result) {
      result->d_firstElement = src->d_firstElement;
      for(i = 0, j = 0; i < src->d_metadata.d_dimen; ++i) {
        result->d_firstElement +=
          ((srcFirst[i] - src->d_metadata.d_lower[i])*
           src->d_metadata.d_stride[i]);
        if (numElem[i]) {
          result->d_metadata.d_stride[j] = src->d_metadata.d_stride[i]*
            getStride(srcStride, i);
          ++j;
        }
      }
      if (src->d_metadata.d_vtable->d_smartcopy ==
          (struct sidl__array *(*)(struct sidl__array *))
           sidl_string__array_smartCp) {
        result->d_metadata.d_vtable = &sliced_string_vtable;
      }
      else {
        result->d_metadata.d_vtable = &bsliced_string_vtable;
      }
    }
  }
  return result;
}

struct sidl_string__array *
sidl_string__array_borrow(char ** firstElement,
                          int32_t        dimen,
                          const int32_t  lower[],
                          const int32_t  upper[],
                          const int32_t  stride[])
{
  struct sidl_string__array *result = newArray(dimen, lower, upper, NULL);
  memcpy(result->d_metadata.d_stride, stride, sizeof(int32_t)*(size_t)dimen);
  result->d_firstElement = firstElement;
  result->d_metadata.d_vtable = &borrowed_string_vtable;
  return result;
}

struct sidl_string__array *
sidl_string__array_smartCopy(struct sidl_string__array *array)
{
  return (struct sidl_string__array *)
     sidl__array_smartCopy((struct sidl__array*)array);
}

void
sidl_string__array_addRef(struct sidl_string__array* array)
{
  sidl__array_addRef((struct sidl__array*)array);
}

void
sidl_string__array_deleteRef(struct sidl_string__array* array)
{
  sidl__array_deleteRef((struct sidl__array*)array);
}

struct sidl_string__array*
sidl_string__array_cast(struct sidl__array* array)
{
  return (array &&
          (sidl_string_array == ((array->d_vtable->d_arraytype)())))
    ? (struct sidl_string__array *)array : NULL;
}

char *
sidl_string__array_get1(const struct sidl_string__array* array,
                        const int32_t i1)
{
  if (array && (1 == array->d_metadata.d_dimen) &&
      ((array->d_metadata.d_lower[0] <= i1) &&
      (array->d_metadata.d_upper[0] >= i1))) {
    HELPER_VARIABLE;
    return COPY_VALUE(*(array->d_firstElement +
                        (i1 - array->d_metadata.d_lower[0])*
                        array->d_metadata.d_stride[0]));
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get2(const struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2)
{
  if (array && (2 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (up[0] >= i1);
    register int c3 = (low[1] <= i2);
    register int c4 = (up[1] >= i2);
    HELPER_VARIABLE;
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1]));
    }
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get3(const struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3)
{
  if (array && (3 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    if (c1 && c2 && c3) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1] +
                          (i3 - low[2])* stride[2]));
    }
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get4(const struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4)
{
  if (array && (4 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking to avoid strict left to right */
    /* evaluation of && which serializes evaluation */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      return COPY_VALUE(*(array->d_firstElement +
                         (((i1 - low[0])* stride[0] +
                           (i2 - low[1])* stride[1]) +
                          ((i3 - low[2])* stride[2] +
                           (i4 - low[3])* stride[3]))));
    }
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get5(const struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const int32_t i5)
{
  if (array && (5 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c1 = c1 && c3;
    if (c1 && c5) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1] +
                          (i3 - low[2])* stride[2] +
                          (i4 - low[3])* stride[3] +
                          (i5 - low[4])* stride[4]));
    }
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get6(const struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const int32_t i5,
                        const int32_t i6)
{
  if (array && (6 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    register int c6 = (low[5] <= i6);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c6 = c6 && (up[5] >= i6);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c5 = c5 && c6;
    c1 = c1 && c3;
    if (c1 && c5) {
      return COPY_VALUE(*(array->d_firstElement +
                          (i1 - low[0])* stride[0] +
                          (i2 - low[1])* stride[1] +
                          (i3 - low[2])* stride[2] +
                          (i4 - low[3])* stride[3] +
                          (i5 - low[4])* stride[4] +
                          (i6 - low[5])* stride[5]));
    }
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get7(const struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const int32_t i5,
                        const int32_t i6,
                        const int32_t i7)
{
  if (array) {
    switch(array->d_metadata.d_dimen) {
    case 1: return sidl_string__array_get1(array, i1);
    case 2: return sidl_string__array_get2(array, i1, i2);
    case 3: return sidl_string__array_get3(array, i1, i2, i3);
    case 4: return sidl_string__array_get4(array, i1, i2, i3, i4);
    case 5: return sidl_string__array_get5(array, i1, i2, i3, i4, i5);
    case 6: return sidl_string__array_get6(array, i1, i2, i3, i4, i5, i6);
    case 7:
      {
        const int32_t * const low = array->d_metadata.d_lower;
        const int32_t * const up = array->d_metadata.d_upper;
        const int32_t * const stride = array->d_metadata.d_stride;
        /* unserialize array bounds checking (i.e. avoid strict left to right */
        /* evaluation of && which serializes evaluation) */
        register int c1 = (low[0] <= i1);
        register int c2 = (low[1] <= i2);
        register int c3 = (low[2] <= i3);
        register int c4 = (low[3] <= i4);
        register int c5 = (low[4] <= i5);
        register int c6 = (low[5] <= i6);
        register int c7 = (low[6] <= i7);
        HELPER_VARIABLE;
        c1 = c1 && (up[0] >= i1);
        c2 = c2 && (up[1] >= i2);
        c3 = c3 && (up[2] >= i3);
        c4 = c4 && (up[3] >= i4);
        c5 = c5 && (up[4] >= i5);
        c6 = c6 && (up[5] >= i6);
        c7 = c7 && (up[6] >= i7);
        c1 = c1 && c2;
        c3 = c3 && c4;
        c5 = c5 && c6;
        c1 = c1 && c3;
        c5 = c5 && c7;
        if (c1 && c5) {
          return COPY_VALUE(*(array->d_firstElement +
                              (i1 - low[0])* stride[0] +
                              (i2 - low[1])* stride[1] +
                              (i3 - low[2])* stride[2] +
                              (i4 - low[3])* stride[3] +
                              (i5 - low[4])* stride[4] +
                              (i6 - low[5])* stride[5] +
                              (i7 - low[6])* stride[6]));
        }
      }
    }
  }
  return sidl_string__array_zero;
}

char *
sidl_string__array_get(const struct sidl_string__array* array,
                       const int32_t indices[])
{
  if (array) {
    char * *result = array->d_firstElement;
    int32_t i = 0;
    HELPER_VARIABLE;
    while (i < array->d_metadata.d_dimen) {
      if ((indices[i] < array->d_metadata.d_lower[i]) ||
          (indices[i] > array->d_metadata.d_upper[i]))
        return sidl_string__array_zero;
      result += ((indices[i] - array->d_metadata.d_lower[i])*
       array->d_metadata.d_stride[i]);
      ++i;
    }
    return COPY_VALUE(*result);
  }
  return sidl_string__array_zero;
}

void
sidl_string__array_set1(struct sidl_string__array* array,
                        const int32_t i1,
                        const char * value)
{
  if (array && (1 == array->d_metadata.d_dimen) &&
      ((array->d_metadata.d_lower[0] <= i1) &&
       (array->d_metadata.d_upper[0] >= i1))) {
    HELPER_VARIABLE;
    DESTROY_VALUE(*(array->d_firstElement +
      (i1 - array->d_metadata.d_lower[0])*array->d_metadata.d_stride[0]));
    *(array->d_firstElement +
      (i1 - array->d_metadata.d_lower[0])*array->d_metadata.d_stride[0]) =
       COPY_VALUE(value);
  }
}

void
sidl_string__array_set2(struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const char * value)
{
  if (array && (2 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (up[0] >= i1);
    register int c3 = (low[1] <= i2);
    register int c4 = (up[1] >= i2);
    HELPER_VARIABLE;
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1]) =
         COPY_VALUE(value);
    }
  }
}

void
sidl_string__array_set3(struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const char * value)
{
  if (array && (3 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    if (c1 && c2 && c3) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2]) =
         COPY_VALUE(value);
    }
  }
}

void
sidl_string__array_set4(struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const char * value)
{
  if (array && (array->d_metadata.d_dimen == 4)) {
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking to. avoid strict left to right */
    /* evaluation of && which serializes evaluation */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c1 = c1 && c2;
    c3 = c3 && c4;
    if (c1 && c3) {
      DESTROY_VALUE(*(array->d_firstElement +
        (((i1 - low[0])*stride[0] +
          (i2 - low[1])*stride[1]) +
         ((i3 - low[2])*stride[2] +
          (i4 - low[3])*
           stride[3]))));
      *(array->d_firstElement +
        (((i1 - low[0])*stride[0] +
          (i2 - low[1])*stride[1]) +
         ((i3 - low[2])*stride[2] +
         (i4 - low[3])*stride[3]))) =
         COPY_VALUE(value);
    }
  }
}

void
sidl_string__array_set5(struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const int32_t i5,
                        const char * value)
{
  if (array && (5 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c1 = c1 && c3;
    if (c1 && c5) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4]) =
         COPY_VALUE(value);
    }
  }
}

void
sidl_string__array_set6(struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const int32_t i5,
                        const int32_t i6,
                        const char * value)
{
  if (array && (6 == array->d_metadata.d_dimen)){
    const int32_t * const low = array->d_metadata.d_lower;
    const int32_t * const up = array->d_metadata.d_upper;
    const int32_t * const stride = array->d_metadata.d_stride;
    /* unserialize array bounds checking (i.e. avoid strict left to right */
    /* evaluation of && which serializes evaluation) */
    register int c1 = (low[0] <= i1);
    register int c2 = (low[1] <= i2);
    register int c3 = (low[2] <= i3);
    register int c4 = (low[3] <= i4);
    register int c5 = (low[4] <= i5);
    register int c6 = (low[5] <= i6);
    HELPER_VARIABLE;
    c1 = c1 && (up[0] >= i1);
    c2 = c2 && (up[1] >= i2);
    c3 = c3 && (up[2] >= i3);
    c4 = c4 && (up[3] >= i4);
    c5 = c5 && (up[4] >= i5);
    c6 = c6 && (up[5] >= i6);
    c1 = c1 && c2;
    c3 = c3 && c4;
    c5 = c5 && c6;
    c1 = c1 && c3;
    if (c1 && c5) {
      DESTROY_VALUE(*(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4] +
        (i6 - low[5])*stride[5]));
      *(array->d_firstElement +
        (i1 - low[0])*stride[0] +
        (i2 - low[1])*stride[1] +
        (i3 - low[2])*stride[2] +
        (i4 - low[3])*stride[3] +
        (i5 - low[4])*stride[4] +
        (i6 - low[5])*stride[5]) =
         COPY_VALUE(value);
    }
  }
}

void
sidl_string__array_set7(struct sidl_string__array* array,
                        const int32_t i1,
                        const int32_t i2,
                        const int32_t i3,
                        const int32_t i4,
                        const int32_t i5,
                        const int32_t i6,
                        const int32_t i7,
                        const char * value)
{
  if (array) {
    switch(array->d_metadata.d_dimen) {
    case 1: sidl_string__array_set1(array, i1, value); break;
    case 2: sidl_string__array_set2(array, i1, i2, value); break;
    case 3: sidl_string__array_set3(array, i1, i2, i3, value); break;
    case 4: sidl_string__array_set4(array, i1, i2, i3, i4, value); break;
    case 5: sidl_string__array_set5(array, i1, i2, i3, i4, i5, value); break;
    case 6: sidl_string__array_set6(array, i1, i2, i3, i4, i5, i6, value); break;
    case 7:
      {
        const int32_t * const low = array->d_metadata.d_lower;
        const int32_t * const up = array->d_metadata.d_upper;
        const int32_t * const stride = array->d_metadata.d_stride;
        /* unserialize array bounds checking (i.e. avoid strict left to right */
        /* evaluation of && which serializes evaluation) */
        register int c1 = (low[0] <= i1);
        register int c2 = (low[1] <= i2);
        register int c3 = (low[2] <= i3);
        register int c4 = (low[3] <= i4);
        register int c5 = (low[4] <= i5);
        register int c6 = (low[5] <= i6);
        register int c7 = (low[6] <= i7);
        HELPER_VARIABLE;
        c1 = c1 && (up[0] >= i1);
        c2 = c2 && (up[1] >= i2);
        c3 = c3 && (up[2] >= i3);
        c4 = c4 && (up[3] >= i4);
        c5 = c5 && (up[4] >= i5);
        c6 = c6 && (up[5] >= i6);
        c7 = c7 && (up[6] >= i7);
        c1 = c1 && c2;
        c3 = c3 && c4;
        c5 = c5 && c6;
        c1 = c1 && c3;
        c5 = c5 && c7;
        if (c1 && c5) {
           DESTROY_VALUE(*(array->d_firstElement +
            (i1 - low[0])*stride[0] +
            (i2 - low[1])*stride[1] +
            (i3 - low[2])*stride[2] +
            (i4 - low[3])*stride[3] +
            (i5 - low[4])*stride[4] +
            (i6 - low[5])*stride[5] +
            (i7 - low[6])*stride[6]));
          *(array->d_firstElement +
            (i1 - low[0])*stride[0] +
            (i2 - low[1])*stride[1] +
            (i3 - low[2])*stride[2] +
            (i4 - low[3])*stride[3] +
            (i5 - low[4])*stride[4] +
            (i6 - low[5])*stride[5] +
            (i7 - low[6])*stride[6])
             = COPY_VALUE(value);
        }
      }
    }
  }
}

void
sidl_string__array_set(struct sidl_string__array* array,
                       const int32_t indices[],
                       const char * value)
{
  if (array) {
    char * *result = array->d_firstElement;
    int32_t i = 0;
    HELPER_VARIABLE;
    while (i < array->d_metadata.d_dimen) {
      if ((indices[i] < array->d_metadata.d_lower[i]) ||
          (indices[i] > array->d_metadata.d_upper[i])) return;
      result += ((indices[i] - array->d_metadata.d_lower[i])*
       array->d_metadata.d_stride[i]);
      ++i;
    }
    DESTROY_VALUE(*result);
    *result = COPY_VALUE(value);
  }
}

int32_t
sidl_string__array_dimen(const struct sidl_string__array* array)
{
  return sidl__array_dimen((const struct sidl__array*)array);
}

int32_t
sidl_string__array_lower(const struct sidl_string__array* array,
                         const int32_t ind)
{
  return sidl__array_lower((const struct sidl__array*)array, ind);
}

int32_t
sidl_string__array_upper(const struct sidl_string__array* array,
                         const int32_t ind)
{
  return sidl__array_upper((const struct sidl__array*)array, ind);
}

int32_t
sidl_string__array_length(const struct sidl_string__array* array,
                          const int32_t ind)
{
  return sidl__array_length((const struct sidl__array*)array, ind);
}

int32_t
sidl_string__array_stride(const struct sidl_string__array* array,
                          const int32_t ind)
{
  return sidl__array_stride((const struct sidl__array*)array, ind);
}

sidl_bool
sidl_string__array_isColumnOrder(const struct sidl_string__array* array)
{
  return sidl__array_isColumnOrder((const struct sidl__array*)array);
}

sidl_bool
sidl_string__array_isRowOrder(const struct sidl_string__array* array)
{
  return sidl__array_isRowOrder((const struct sidl__array*)array);
}

void
sidl_string__array_copy(const struct sidl_string__array* src,
                              struct sidl_string__array* dest)
{
  if (src && dest && (src != dest) &&
     (src->d_metadata.d_dimen == dest->d_metadata.d_dimen) &&
      src->d_metadata.d_dimen) {
    const int32_t dimen = src->d_metadata.d_dimen;
    int32_t * restrict overlap = (int32_t *)malloc(sizeof(int32_t)*(size_t)dimen*4);
    HELPER_VARIABLE;
    if (overlap) {
      register char * const * restrict srcFirst =
        src->d_firstElement;
      register char * * restrict destFirst =
        dest->d_firstElement;
      register int32_t i;
      int32_t * restrict current = overlap + dimen;
      int32_t * restrict src_stride = current + dimen;
      int32_t * restrict dst_stride = src_stride + dimen;
      int32_t lower, upper, fastMover = dimen - 1, moverRank = 0;
      for(i = 0; i < dimen; ++i){
        lower = MAX(src->d_metadata.d_lower[i],dest->d_metadata.d_lower[i]);
        upper = MIN(src->d_metadata.d_upper[i],dest->d_metadata.d_upper[i]);
        overlap[i] = 1 + upper - lower;
        if (overlap[i] <= 0) goto cleanup;
        srcFirst += (src->d_metadata.d_stride[i]*
           (lower - src->d_metadata.d_lower[i]));
        destFirst += (dest->d_metadata.d_stride[i]*
           (lower - dest->d_metadata.d_lower[i]));
        current[i] = 0;
        src_stride[i] = src->d_metadata.d_stride[i];
        dst_stride[i] = dest->d_metadata.d_stride[i];
        if (((src_stride[i] == 1) || (src_stride[i] == -1) ||
             (dst_stride[i] == 1) || (dst_stride[i] == -1)) &&
            (overlap[i] >= moverRank)) {
          moverRank = overlap[i];
          fastMover = i;
        }
      }
      if (fastMover != dimen - 1) { /* move stride 1 to inner loop */
        /* this *might* improve cache performance */
        swap_i32(&overlap[fastMover], &overlap[dimen-1]);
        swap_i32(&src_stride[fastMover], &src_stride[dimen-1]);
        swap_i32(&dst_stride[fastMover], &dst_stride[dimen-1]);
      }
      switch(dimen) {
      case 1: /* handle a common special case */
        {
          const int32_t bound = overlap[0];
          const int32_t dstride = dst_stride[0];
          const int32_t sstride = src_stride[0];
          for(i = 0; i < bound; ++i) {
            DESTROY_VALUE(*destFirst);
            *destFirst = COPY_VALUE(*srcFirst);
            destFirst += dstride;
            srcFirst += sstride;
          }
        }
        break;
      case 2: /* handle a common special case (2-d arrays) */
        {
          const int32_t bound0 = overlap[0];
          const int32_t bound1 = overlap[1];
          const int32_t dstride1 = dst_stride[1];
          const int32_t sstride1 = src_stride[1];
          const int32_t dstride0 = dst_stride[0] - bound1*dstride1;
          const int32_t sstride0 = src_stride[0] - bound1*sstride1;
          int32_t j;
          for(i = 0; i < bound0; ++i) {
            for(j = 0; j < bound1; ++j) {
              DESTROY_VALUE(*destFirst);
              *destFirst = COPY_VALUE(*srcFirst);
              destFirst += dstride1;
              srcFirst += sstride1;
            }
            destFirst += dstride0;
            srcFirst += sstride0;
          }
        }
        break;
      case 3: /* handle a common special case (3-d arrays) */
        {
          const int32_t bound0 = overlap[0];
          const int32_t bound1 = overlap[1];
          const int32_t bound2 = overlap[2];
          const int32_t dstride2 = dst_stride[2];
          const int32_t sstride2 = src_stride[2];
          const int32_t dstride1 = dst_stride[1] - bound2*dstride2;
          const int32_t sstride1 = src_stride[1] - bound2*sstride2;
          const int32_t dstride0 = dst_stride[0] - bound1*(dstride1 + bound2*dstride2);
          const int32_t sstride0 = src_stride[0] - bound1*(sstride1 + bound2*sstride2);
          
          int32_t j, k;
          for(i = 0; i < bound0; ++i) {
            for(j = 0; j < bound1; ++j) {
              for(k = 0; k < bound2; ++k) {
                DESTROY_VALUE(*destFirst);
                *destFirst = COPY_VALUE(*srcFirst);
                destFirst += dstride2;
                srcFirst += sstride2;
              }
              destFirst += dstride1;
              srcFirst += sstride1;
            }
            destFirst += dstride0;
            srcFirst += sstride0;
          }
        }
        break;
      default: /* handle the general case */
        do {
          DESTROY_VALUE(*destFirst);
          *destFirst = COPY_VALUE(*srcFirst);
          /* the whole point of this for-loop is to move forward one element */
          for(i = dimen - 1; i >= 0; --i) {
            ++(current[i]);
            if (current[i] >= overlap[i]) {
            /* this dimension has been enumerated already reset to beginning */
              current[i] = 0;
              /* prepare to next iteration of for-loop for i-1 */
              destFirst -= ((overlap[i]-1) * dst_stride[i]);
              srcFirst -= ((overlap[i]-1) * src_stride[i]);
            }
            else {
              /* move forward one element in dimension i */
              destFirst += dst_stride[i];
              srcFirst += src_stride[i];
              break; /* exit for loop */
            }
          }
        } while (i >= 0);
        break;
      }
cleanup:
      free(overlap);
    }
  }
}

struct sidl_string__array*
sidl_string__array_ensure(struct sidl_string__array* src,
                          int32_t                dimen,
                          int                    ordering)
{
  struct sidl_string__array* result = NULL;
  if (src && (src->d_metadata.d_dimen == dimen)) {
    switch(ordering) {
    case sidl_column_major_order:
      if (sidl_string__array_isColumnOrder(src)) {
        sidl_string__array_addRef(src);
        result = src;
      }
      else {
        result = sidl_string__array_createCol
          (dimen, src->d_metadata.d_lower, src->d_metadata.d_upper);
        sidl_string__array_copy(src, result);
      }
      break;
    case sidl_row_major_order:
      if (sidl_string__array_isRowOrder(src)) {
        sidl_string__array_addRef(src);
        result = src;
      }
      else {
        result = sidl_string__array_createRow
          (dimen, src->d_metadata.d_lower, src->d_metadata.d_upper);
        sidl_string__array_copy(src, result);
      }
      break;
    default:
      sidl_string__array_addRef(src);
      result = src;
      break;
    }
  }
  return result;
}

