<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="index.css">
<TITLE>Creating Objects with Pre-Initialized State</TITLE>
</HEAD>
<BODY >
<A HREF="index021.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index023.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc96">Chapter 20</A>  Creating Objects with Pre-Initialized State</H1><UL>
<LI><A HREF="index022.html#toc81">Introduction to the Backdoor Initializer</A>
</LI><LI><A HREF="index022.html#toc82">Motivation</A>
</LI><LI><A HREF="index022.html#toc83">Example</A>
</LI><LI><A HREF="index022.html#toc84">The Backdoor Initializer in C</A>
</LI><LI><A HREF="index022.html#toc85">The Backdoor Initializer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN></A>
</LI><LI><A HREF="index022.html#toc86">The Backdoor Initializer in Fortran 90/95</A>
</LI><LI><A HREF="index022.html#toc87">The Backdoor Initializer in C++</A>
</LI><LI><A HREF="index022.html#toc88">The Backdoor Initializer in Java</A>
</LI><LI><A HREF="index022.html#toc89">The Backdoor Initializer in Python</A>
</LI></UL>
<P><A NAME="c:backdoor"></A>
</P><DIV CLASS="center">
<FONT SIZE=7>or<BR>
Wrapping Native objects with Babel
</FONT>
</DIV><P><A NAME="@default1904"></A><A NAME="@default1905"></A><A NAME="@default1906"></A> 
<A NAME="@default1907"></A> <A NAME="@default1908"></A> 
<A NAME="@default1909"></A> <A NAME="@default1910"></A> 
<A NAME="@default1911"></A> <A NAME="@default1912"></A></P><P><BR>
</P><H2 CLASS="section"><A NAME="toc81"></A><A NAME="htoc97">20.1</A>  Introduction to the Backdoor Initializer</H2><P><A NAME="s:intro"></A></P><P>Internally, every Babel object holds an implementation language
specific pointer to the object’s private state data. If the object is
implemented in C, the pointer points to a struct named <TT>struct
package_Class__data</TT>. In Java, the private data pointer points to a
Java object of the implementation type, <TT>Class_Impl</TT>, which calls
are made on, and which actually holds the object state. The type of
the private data is entirely implementation language dependent. The
data is usually created or set by the Babel objects user-implemented constructor.</P><P>With the Backdoor Initializer, Babel allows a Babel user to set
this private data pointer at construction with pre-initialized state.
Of course, this is very dangerous. This can only be done if the
client language creating the Babel object is the same as the language
the object is implemented in, and if the pre-initialized state is of
the correct type. If either of these constraints is unsatisfied, the
behavior of the backdoor initializer in undefined.</P><P><A NAME="@default1913"></A>
Object construction is a very language specific problem, and therefore
this Babel feature is exposed differently in each language. However,
in every language, there is some way provided for the class implementor
to determine in the constructor code whether the object is being
constructed normally, or if the user provided pre-initialized state.
In most languages there is a second constructor provided<A NAME="@default1914"></A>, only in
Python is an argument used to determine if the user provided
pre-initialized state or not. Most class implementers will not need to do anything
with the new constructor. In the case of Backdoor Initialization,
usually the right thing to do in a constructor is to do nothing, since
the object state was preinitialized by the client. The constructor
only needs to be used if the state of the object cannot fully be
represented by its private data. For example, an object that opens a
TCP/IP connection during construction would almost certainly need that
code in the backdoor constructor as well.</P><H2 CLASS="section"><A NAME="toc82"></A><A NAME="htoc98">20.2</A>  Motivation</H2><P><A NAME="s:modivation"></A></P><P>The Backdoor Initializer is not a feature that most Babel users will
need. However, there are certain cases where the Backdoor Initializer
is absolutely required. The most obvious usage case is for wrapping
up native objects in a Babelized interface. The allows the
implementation language to access the data directly, but other
languages must use the provided Babel interface. It was exactly this
usage case that inspired the creation of the Backdoor Initializer.</P><P>A customer needed to use a Java visualization program to view a graph
generated by a C++ library. The customer did not want to modify the
Java program significantly. Instead, he created the graph data
structure used by the visualizer in Java, and wrapped it in a Babel
interface. He was then able to pass the Babelized object to the C++
library, which made calls on the Babel interface to add nodes and
edges to the graph. When the C++ library finished, the Java visualizer
was able to use the graph as if it was created natively in Java. The
visualizer code did not have to be modified in any way to use the graph!</P><H2 CLASS="section"><A NAME="toc83"></A><A NAME="htoc99">20.3</A>  Example</H2><P><A NAME="s:example"></A></P><P>In this chapter we will use a single example for all Babel supported
languages. This example is taken from the wrapper regression test.
In this test, there are two sidl classes, <TT>wrapper.Data</TT> and
<TT>wrapper.User</TT>. </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> wrapper <B>version</B> 1.0 {

  <B>class</B> Data {
    <B>void</B> setString(<B>in string</B> s);
    <B>void</B> setInt(<B>in int</B> i);
  }

  <B>class</B> User {
     <B>void</B> accept(<B>in</B> wrapper.Data data);
  }
}</I></FONT></TD></TR>
</TABLE><P><TT>wrapper.Data</TT> wraps up some native data, which will be modified by
the <TT>wrapper.User.accept()</TT> call. In this case, the data is just a
string and an integer. In order to show the new constructor
functionality, we set string called d_ctortest to “ctor was run” in
the new constructor. </P><P>To reiterate, the client program creates and wraps language specific data in a
<TT>wrapper.Data</TT> babel object. The alternate constructor code is
run, which sets the d_ctortest string. The object is then passed to
<TT>wrapper.User.accept()</TT>, which sets the data. The client program
can then directly access the data and read what was set by User.accept().</P><H2 CLASS="section"><A NAME="toc84"></A><A NAME="htoc100">20.4</A>  The Backdoor Initializer in C</H2><P><A NAME="s:c"></A></P><P><A NAME="@default1915"></A><A NAME="@default1916"></A>
In C, the Backdoor Initializer is used through a new <TT>_create</TT>
like static method, <TT>_wrapObj</TT>. <TT>_wrapObj</TT> takes a
pointer to the private data to be wrapped (a simple struct defined in
<TT>wrapper_Data__Impl.h</TT>).</P><P>from wrapper_Data_Impl.h:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>struct</B> wrapper_Data__data {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data._data) */</I></FONT>
  <B>char</B>* d_ctortest;
  <B>char</B>* d_string;
  <B>int</B> d_int;
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data._data) */</I></FONT>
};</TD></TR>
</TABLE><P>From wrapper_Data_Impl.c; notice the new constructor <TT>ctor2</TT><A NAME="@default1917"></A>,
which is only called with backdoor initialization.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B> impl_wrapper_Data__ctor2(
  <FONT COLOR="blue"><I>/* in */</I></FONT> wrapper_Data self,
  <FONT COLOR="blue"><I>/* in */</I></FONT> <B>void</B>* private_data,
  <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex) {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2) */</I></FONT>
  <B>struct</B> wrapper_Data__data *dptr = (<B>struct</B> wrapper_Data__data *) private_data;
  dptr-&gt;d_ctorTest = "ctor was run";
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data._ctor2) */</I></FONT>
}

<B>void</B> impl_wrapper_Data_setString(
  <FONT COLOR="blue"><I>/* in */</I></FONT> wrapper_Data self,
  <FONT COLOR="blue"><I>/* in */</I></FONT> <B>const char</B>* s,
  <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex) {
  *_ex = 0;
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data.setString) */</I></FONT>
  <B>struct</B> wrapper_Data__data *dptr =
    wrapper_Data__get_data(self);
  <B>if</B> (dptr) {
    dptr-&gt;d_string = "Hello World!";
  }
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data.setString) */</I></FONT>
}

<B>void</B> impl_wrapper_Data_setInt(
  <FONT COLOR="blue"><I>/* in */</I></FONT> wrapper_Data self,
  <FONT COLOR="blue"><I>/* in */</I></FONT> int32_t i,
  <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex) {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data.setInt) */</I></FONT>
  <B>struct</B> wrapper_Data__data *dptr =
    wrapper_Data__get_data(self);
  <B>if</B> (dptr) {
    dptr-&gt;d_int = 3;
  }
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data.setInt) */</I></FONT>
}</TD></TR>
</TABLE><P>from the client program wraptest.c: (Note that we must include wrapper_Data_Impl.h)
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "wrapper_User.h"
<B>#include</B> "wrapper_Data.h"
<B>#include</B> "wrapper_Data_Impl.h"
<B>int</B> main(<B>int</B> argc, <B>char</B>** argv) {

  sidl_BaseInterface exception = NULL;
  wrapper_Data data = NULL;
  wrapper_User user = NULL;
  <B>struct</B> wrapper_Data__data *d_data = NULL;
  <B>struct</B> wrapper_Data__data *dptr = NULL;

  <FONT COLOR="blue"><I>/*Create the data*/</I></FONT>
  dptr = malloc(<B>sizeof</B>(<B>struct</B> wrapper_Data__data));
  <FONT COLOR="blue"><I>/*Wrap the data*/</I></FONT>
  data = wrapper_Data__wrapObj(dptr, &amp;exception);
  user = wrapper_User__create(&amp;exception);

  ASSERT( strcmp(d_data-&gt;d_ctortest, "ctor was run") == 0);

  <FONT COLOR="blue"><I>/* Test the data setting*/</I></FONT>
  wrapper_User_accept(user, data, &amp;exception);

  ASSERT( strcmp(d_data-&gt;d_string, "Hello World!") == 0);
  ASSERT( d_data-&gt;d_int == 3);

  <B>return</B> 0;
}</TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc85"></A><A NAME="htoc101">20.5</A>  The Backdoor Initializer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN></H2><P><A NAME="s:f77"></A>
<A NAME="@default1918"></A><A NAME="@default1919"></A>
In <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, using the Backdoor Initializer is similar to using it
in C. There is a special new constructor named <TT>_wrapObj</TT> that
takes the private data pointer. </P><P>Of course, dynamically allocating data in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> is tricky, and
requires very close cooperation with the Impl class that uses the
data. Most of the complexity of this example code is caused by those
problems, not so much the Backdoor Initializer itself.</P><P><A NAME="@default1920"></A>
Since we need to store 2 strings and an integer, we create 3 sidl arrays to
hold the private data. We create an opaque array of 2 elements called pdata to hold
the other two arrays. Then we create a string array of 2 elements
called a_string, and an integer array of 1 element called a_int.
d_string is element 0 of the string array, and d_ctortest is element
1. We then place a_string into pdata as element 0, and a_int in pdata
as element 1. We then call <TT>_wrapObj</TT>, which takes pdata as an
in argument as the first argument, and the object we are creating,
data, as an out argument as the second argument. </P><P>Notice that we don’t have to include an Impl files to <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
since, there aren’t actually any types.</P><P>Fairly complex, but here’s the client code from wraptest.f:
</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      program wraptest
      implicit none
      integer*8 data, user, pdata, backup, throwaway
      integer*8 a_string, a_int
      integer*4 d_int
      character*80 d_string
      character*80 d_ctortest
      character*80 d_silly

c     pdata is the internal data, and holds two arrays, string an int.
      call sidl_opaque__array_create1d_f(2, pdata)
      call sidl_string__array_create1d_f(2, a_string)
      call sidl_int__array_create1d_f(1, a_int)

c     initialize the data arrays
      call sidl_string__array_set1_f(a_string, 0, d_string)
      call sidl_string__array_set1_f(a_string, 1, d_ctortest)
      call sidl_int__array_set1_f(a_int, 0, d_int)

c     initilize pdata
      call sidl_opaque__array_set1_f(pdata, 0, a_string)
      call sidl_opaque__array_set1_f(pdata, 1, a_int)

      call wrapper_User__create_f(user, throwaway)

c     private data first, then the object being created
      call wrapper_Data__wrapObj_f(pdata, data, throwaway)

      call sidl_opaque__array_get1_f(pdata, 0, a_string)
      call sidl_string__array_get1_f(a_string, 1, d_ctortest)

      print *, d_ctortest

      call wrapper_User_accept_f(user, data, throwaway)

      call sidl_string__array_get1_f(a_string, 0, d_string)
      call sidl_int__array_get1_f(a_int, 0, d_int)

      print *, d_string, ' ', d_int

      call wrapper_User_deleteRef_f(user, throwaway)
      call wrapper_Data_deleteRef_f(data, throwaway)
      end</TD></TR>
</TABLE><P> 	</P><P>and the Impl side code from wrapper_Data_Impl.f
</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine wrapper_Data__ctor2_fi(self, private_data, exception)
        implicit none
        integer*8 self
        integer*8 private_data
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2)
        integer*8 a_string, pdata
        character*80 d_string, d_ctortest
        call sidl_opaque__array_get1_f(private_data, 0, a_string)
        call sidl_string__array_set1_f(a_string, 1, 'ctor was run')
C       DO-NOT-DELETE splicer.end(wrapper.Data._ctor2)
        end

        subroutine wrapper_Data_setString_fi(self, s, exception)
        implicit none
        integer*8 self
        character*(*) s
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(wrapper.Data.setString)
        integer*8 data, a_string
        call wrapper_Data__get_data_f(self, data)
        if (data .ne. 0) then
           call sidl_opaque__array_get1_f(data, 0, a_string)
           call sidl_string__array_set1_f(a_string, 0, s)
        endif
C       DO-NOT-DELETE splicer.end(wrapper.Data.setString)
        end

        subroutine wrapper_Data_setInt_fi(self, i, exception)
        implicit none
        integer*8 self
        integer*4 i
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)
        integer*8 data, a_int
        call wrapper_Data__get_data_f(self, data)
        if (data .ne. 0) then
           call sidl_opaque__array_get1_f(data, 1, a_int)
           call sidl_int__array_set1_f(a_int, 0, i)
        endif
C       DO-NOT-DELETE splicer.end(wrapper.Data.setInt)
        end</TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc86"></A><A NAME="htoc102">20.6</A>  The Backdoor Initializer in Fortran 90/95</H2><P><A NAME="s:f90"></A></P><P><A NAME="@default1921"></A><A NAME="@default1922"></A>
The Fortran 90/95 backdoor initializer is very similar to C. Fortran 90/95
also has a <TT>_wrapObj</TT>, but it is actually defined in
the wrapper_Data_Mod.F90 file, along with the private data type
definition. </P><P>Here is the private data definition from wrapper_Data_Mod.F90:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  type wrapper_Data_priv
    <B>sequence</B>
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(wrapper.Data.private_data)
    ! Insert-Code-Here {wrapper.Data.private_data} (private data members)</I></FONT>
     character(<B>len</B>=256)     :: d_ctortest
     character(<B>len</B>=256)     :: d_string
     integer(<B>kind</B>=sidl_int) :: d_int
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data.private_data)</I></FONT>
  end type wrapper_Data_priv</TD></TR>
</TABLE><P>Here is the client code from wraptest.F90. Notice wrapper_Data_impl
is used. From wraptest.F90:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#<B>include</B> "wrapper_User_fAbbrev.h"
#<B>include</B> "wrapper_Data_fAbbrev.h"
#<B>include</B> "synch_RegOut_fAbbrev.h"
#<B>include</B> "synch_ResultType_fAbbrev.h"

program wraptest
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> wrapper_User
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  type(sidl_BaseInterface_t) :: throwaway_exception
  type(wrapper_Data_wrap) :: pd

  type(wrapper_Data_t) :: data
  type(wrapper_User_t) :: user

  <B>allocate</B>(pd%d_private_data)
  pd%d_private_data%d_int = 0
  pd%d_private_data%d_string = 'place holder'
  pd%d_private_data%d_ctortest = 'place holder'

  call new(user, throwaway_exception)
  call wrapObj(pd, data, throwaway_exception)

  print *, pd%d_private_data%d_ctortest

  call accept(user, data, throwaway_exception)

  print *, pd%d_private_data%d_string, ' ', pd%d_private_data%d_int

  call deleteRef(user, throwaway_exception)
  call deleteRef(data, throwaway_exception)
  <FONT COLOR="blue"><I>! Private data [should be] deallocated by the Impl dtor.</I></FONT>

  call close(tracker, throwaway_exception)
  call deleteRef(tracker, throwaway_exception)
end program wraptest</TD></TR>
</TABLE><P>Finally, the Impl code from wrapper_Data_Impl.F90: 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine wrapper_Data__ctor2_mi(self, private_data, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  implicit <B>none</B>
  type(wrapper_Data_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  type(wrapper_Data_wrap) :: private_data
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2)</I></FONT>
  private_data%d_private_data%d_ctortest = 'ctor was run'
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data._ctor2)</I></FONT>
end subroutine wrapper_Data__ctor2_mi

<B>recursive</B> subroutine wrapper_Data_setString_mi(self, s, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  implicit <B>none</B>
  type(wrapper_Data_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  character (<B>len</B>=*) :: s <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out
! DO-NOT-DELETE splicer.begin(wrapper.Data.setString)</I></FONT>
  type(wrapper_Data_wrap) :: dp
  call wrapper_Data__get_data_m(self, dp)
  dp%d_private_data%d_string = s
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data.setString)</I></FONT>
end subroutine wrapper_Data_setString_mi

<B>recursive</B> subroutine wrapper_Data_setInt_mi(self, i, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  implicit <B>none</B>
  type(wrapper_Data_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: i <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)</I></FONT>
  type(wrapper_Data_wrap) :: dp
  call wrapper_Data__get_data_m(self, dp)
  dp%d_private_data%d_int = i

<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data.setInt)</I></FONT>
end subroutine wrapper_Data_setInt_mi</TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc87"></A><A NAME="htoc103">20.7</A>  The Backdoor Initializer in C++</H2><P><A NAME="s:Cxx"></A>
<A NAME="@default1923"></A></P><P>In Object Oriented languages there is no <TT>_wrapObj</TT> method
exposed to the user. Instead, the same functionality is achieved
simply by calling “new” on the Impl class. Interestingly, this
means the constructor functionality is NOT placed in a Babel
<TT>ctor</TT> method, but is, instead, actually in the default object constructor.</P><P>Here is the private data definition from wrapper_Data_Impl.hxx:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
namespace wrapper {
  class Data_impl : public virtual ::wrapper::Data

....
  public:
    char* d_string;
    int d_int;
    char* d_ctorTest;

....
  };  // end class Data_impl
} // end namespace wrapper</TD></TR>
</TABLE><P>Here is the client code from wraptest.cxx. Notice wrapper_Data_Impl
is included.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#include "wrapper_User.hxx"
#include "wrapper_Data.hxx"
#include "wrapper_Data_Impl.hxx"

int main(int argc, char **argv) {
  wrapper::Data_impl data;
  wrapper::User user = wrapper::User::_create();

  ASSERT( data.d_ctorTest == "ctor was run");

  /* Test the data setting*/
  user.accept(data);

  ASSERT( data.d_string == "Hello World!");
  ASSERT( data.d_int == 3);
  return 0;
}</TD></TR>
</TABLE><P>Finally, the Impl code from wrapper_Data_Impl.cxx, notice where the
constructor code is placed. 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">// speical constructor, used for data wrapping(required).
// Do not put code here unless you really know what you're doing!
wrapper::Data_impl::Data_impl() : StubBase(reinterpret_cast&lt;
  void*&gt;(::wrapper::Data::_wrapObj(this)),false) , _wrapped(true) {
  // DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2)
  d_ctorTest = "ctor was run";
  // DO-NOT-DELETE splicer.end(wrapper.Data._ctor2)
}

void wrapper::Data_impl::setString_impl (
  /* in */const ::std::string&amp; s ) {
  // DO-NOT-DELETE splicer.begin(wrapper.Data.setString)
  d_string = "Hello World!";
  // DO-NOT-DELETE splicer.end(wrapper.Data.setString)
}

void wrapper::Data_impl::setInt_impl (
  /* in */int32_t i )
{
  // DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)
  d_int = 3;
  // DO-NOT-DELETE splicer.end(wrapper.Data.setInt)
}</TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc88"></A><A NAME="htoc104">20.8</A>  The Backdoor Initializer in Java</H2><P><A NAME="s:Java"></A>
<A NAME="@default1924"></A></P><P>In Object Oriented languages there is no <TT>_wrapObj</TT> method
exposed to the user. Instead, the same functionality is achieved
simply by calling “new” on the Impl class. Interestingly, this
means the constructor functionality is NOT placed in a Babel
<TT>ctor</TT> method, but is, instead, actually in the default object constructor.</P><P>Here is an excerpt from the class definition for wrapper.Data_Impl:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>public</B> String d_string;
  <B>public int</B> d_int;
  <B>public</B> String d_ctorTest;

  <B>public</B> Data_Impl(){
    d_ior = _wrap(<B>this</B>);
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(wrapper.Data._wrap)</I></FONT>
    d_ctorTest = "ctor was run";
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(wrapper.Data._wrap)</I></FONT>
  }

  <B>public void</B> setString_Impl (
    <FONT COLOR="blue"><I>/*in*/</I></FONT> java.lang.String s )
    <B>throws</B> sidl.RuntimeException.Wrapper
  {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(wrapper.Data.setString)</I></FONT>
    d_string = s;
    <B>return</B> ;
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(wrapper.Data.setString)</I></FONT>
  }

  <B>public void</B> setInt_Impl (
    <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> i )
    <B>throws</B> sidl.RuntimeException.Wrapper
  {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)</I></FONT>
    d_int = i;
    <B>return</B> ;
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(wrapper.Data.setInt)</I></FONT>
  }</TD></TR>
</TABLE><P>Here is the client code from WrapTest.java: 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public static void</B> main(String args[]) {
  wrapper.Data_Impl d_data = <B>new</B> wrapper.Data_Impl();
  wrapper.User d_user = <B>new</B> wrapper.User();
  System.out.println(d_data.d_ctorTest);
  d_user.accept(d_data);
  System.out.println(d_data.d_string, d_data.d_int);
}</TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc89"></A><A NAME="htoc105">20.9</A>  The Backdoor Initializer in Python</H2><P><A NAME="s:Java"></A>
<A NAME="@default1925"></A></P><P>In Object Oriented languages there is no <TT>_wrapObj</TT> method
exposed to the user. Instead, the same functionality is achieved
simply by calling “new” on the Impl class. </P><P>However, writing the Python backdoor constructor is a little trickier
than Java or C++. This is because there is no overloading in Python,
so multiple constructors were a problem. Instead, the class
implementor needs to determine if the object is being constructed
directly by the user, or through the normal Babel process. This can
be achieved with an if statement. If the argument <TT>IORself ==
None</TT>, then the user has called the backdoor constructor, if
<TT>IORself != None</TT>, it is a normal Babel construction.</P><P>Here is an excerpt from the class definition for wrapper.Data_Impl.Data:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>class</B> Data:
  <B>def</B> __init__(self, IORself = None):
    <B>if</B> (IORself == None):
      self.__IORself = wrapper.Data.Data(impl = self)
    <B>else</B>:
      self.__IORself = IORself
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(__init__)</I></FONT>
    <B>if</B>(IORself == None):
      self.d_string = "placeholder value"
      self.d_ctortest = "ctor was run"
      self.d_int = 0
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(__init__)</I></FONT>

  <B>def</B> setString(self, s):
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(setString)</I></FONT>
    self.d_string = s
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(setString)</I></FONT>

  <B>def</B> setInt(self, i):
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(setInt)</I></FONT>
    self.d_int = i
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(setInt)</I></FONT></TD></TR>
</TABLE><P>Here is the client code from WrapTest.java: 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> wrapper.User
<B>import</B> wrapper.Data
<B>import</B> wrapper.Data_Impl

<B>if</B> __name__ == '__main__':
  user = wrapper.User.User()
  data = wrapper.Data_Impl.Data()

  <B>print</B> data.d_ctortest
  user.accept(data._getStub())
  <B>print</B> data.d_string + " " + d_int
0</TD></TR>
</TABLE><HR>
<A HREF="index021.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index023.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
