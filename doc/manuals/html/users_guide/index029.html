<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="index.css">
<TITLE>Glossary</TITLE>
</HEAD>
<BODY >
<A HREF="index028.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index030.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc129">Appendix D</A>  Glossary</H1><UL>
<LI><A HREF="index029.html#toc106">abstract</A>
</LI><LI><A HREF="index029.html#toc107">array</A>
</LI><LI><A HREF="index029.html#toc108">BLAS</A>
</LI><LI><A HREF="index029.html#toc109">Babel Object Server</A>
</LI><LI><A HREF="index029.html#toc110">BNF</A>
</LI><LI><A HREF="index029.html#toc111">bool</A>
</LI><LI><A HREF="index029.html#toc112">borrowed arrays</A>
</LI><LI><A HREF="index029.html#toc113">CCA</A>
</LI><LI><A HREF="index029.html#toc114">char</A>
</LI><LI><A HREF="index029.html#toc115">class</A>
</LI><LI><A HREF="index029.html#toc116">concrete class</A>
</LI><LI><A HREF="index029.html#toc117">COM</A>
</LI><LI><A HREF="index029.html#toc118">component</A>
</LI><LI><A HREF="index029.html#toc119">component architecture</A>
</LI><LI><A HREF="index029.html#toc120">copy</A>
</LI><LI><A HREF="index029.html#toc121">CORBA</A>
</LI><LI><A HREF="index029.html#toc122">dcomplex</A>
</LI><LI><A HREF="index029.html#toc123">dense</A>
</LI><LI><A HREF="index029.html#toc124">developer</A>
</LI><LI><A HREF="index029.html#toc125">DLL</A>
</LI><LI><A HREF="index029.html#toc126">double</A>
</LI><LI><A HREF="index029.html#toc127">DTD</A>
</LI><LI><A HREF="index029.html#toc128">dynamic linking</A>
</LI><LI><A HREF="index029.html#toc129">enum</A>
</LI><LI><A HREF="index029.html#toc130">enumeration</A>
</LI><LI><A HREF="index029.html#toc131">exception</A>
</LI><LI><A HREF="index029.html#toc132">extends</A>
</LI><LI><A HREF="index029.html#toc133">external stubs</A>
</LI><LI><A HREF="index029.html#toc134">external types</A>
</LI><LI><A HREF="index029.html#toc135">fcomplex</A>
</LI><LI><A HREF="index029.html#toc136">final</A>
</LI><LI><A HREF="index029.html#toc137">float</A>
</LI><LI><A HREF="index029.html#toc138">full name</A>
</LI><LI><A HREF="index029.html#toc139">fundamental types</A>
</LI><LI><A HREF="index029.html#toc140">glue</A>
</LI><LI><A HREF="index029.html#toc141">HTML</A>
</LI><LI><A HREF="index029.html#toc142">implementation</A>
</LI><LI><A HREF="index029.html#toc143">implements</A>
</LI><LI><A HREF="index029.html#toc144">implements-all</A>
</LI><LI><A HREF="index029.html#toc145">import</A>
</LI><LI><A HREF="index029.html#toc146">in</A>
</LI><LI><A HREF="index029.html#toc147">independent arrays</A>
</LI><LI><A HREF="index029.html#toc148">inheritance</A>
</LI><LI><A HREF="index029.html#toc149">inout</A>
</LI><LI><A HREF="index029.html#toc150">instance method</A>
</LI><LI><A HREF="index029.html#toc151">int</A>
</LI><LI><A HREF="index029.html#toc152">int32_t and int64_t</A>
</LI><LI><A HREF="index029.html#toc153">interface</A>
</LI><LI><A HREF="index029.html#toc154">interprocess</A>
</LI><LI><A HREF="index029.html#toc155">IOR</A>
</LI><LI><A HREF="index029.html#toc156">JNI</A>
</LI><LI><A HREF="index029.html#toc157">language interoperability</A>
</LI><LI><A HREF="index029.html#toc158">local</A>
</LI><LI><A HREF="index029.html#toc159">long</A>
</LI><LI><A HREF="index029.html#toc160">method</A>
</LI><LI><A HREF="index029.html#toc161">namespace</A>
</LI><LI><A HREF="index029.html#toc162">nonblocking</A>
</LI><LI><A HREF="index029.html#toc163">non-strided</A>
</LI><LI><A HREF="index029.html#toc164">Object model</A>
</LI><LI><A HREF="index029.html#toc165">OMG</A>
</LI><LI><A HREF="index029.html#toc166">oneway</A>
</LI><LI><A HREF="index029.html#toc167">opaque</A>
</LI><LI><A HREF="index029.html#toc168">out</A>
</LI><LI><A HREF="index029.html#toc169">package</A>
</LI><LI><A HREF="index029.html#toc170">pass-by-copy</A>
</LI><LI><A HREF="index029.html#toc171">pass-by-reference</A>
</LI><LI><A HREF="index029.html#toc172">pass-by-value</A>
</LI><LI><A HREF="index029.html#toc173">PIC</A>
</LI><LI><A HREF="index029.html#toc174">preprocessing</A>
</LI><LI><A HREF="index029.html#toc175">private data</A>
</LI><LI><A HREF="index029.html#toc176">process</A>
</LI><LI><A HREF="index029.html#toc177">protocol</A>
</LI><LI><A HREF="index029.html#toc178">reference counting</A>
</LI><LI><A HREF="index029.html#toc179">Remote Method Invocation</A>
</LI><LI><A HREF="index029.html#toc180">reverse engineering</A>
</LI><LI><A HREF="index029.html#toc181">RMI</A>
</LI><LI><A HREF="index029.html#toc182">RPC</A>
</LI><LI><A HREF="index029.html#toc183">serialization</A>
</LI><LI><A HREF="index029.html#toc184">shared library</A>
</LI><LI><A HREF="index029.html#toc185">short name</A>
</LI><LI><A HREF="index029.html#toc186">SIDL</A>
</LI><LI><A HREF="index029.html#toc187">single process</A>
</LI><LI><A HREF="index029.html#toc188">skeleton</A>
</LI><LI><A HREF="index029.html#toc189">SO</A>
</LI><LI><A HREF="index029.html#toc190">SPMD</A>
</LI><LI><A HREF="index029.html#toc191">state (of an object)</A>
</LI><LI><A HREF="index029.html#toc192">static</A>
</LI><LI><A HREF="index029.html#toc193">static linking</A>
</LI><LI><A HREF="index029.html#toc194">string</A>
</LI><LI><A HREF="index029.html#toc195">stub</A>
</LI><LI><A HREF="index029.html#toc196">SWIG</A>
</LI><LI><A HREF="index029.html#toc197">tarball</A>
</LI><LI><A HREF="index029.html#toc198">throws</A>
</LI><LI><A HREF="index029.html#toc199">type</A>
</LI><LI><A HREF="index029.html#toc200">URL</A>
</LI><LI><A HREF="index029.html#toc201">user</A>
</LI><LI><A HREF="index029.html#toc202">version</A>
</LI><LI><A HREF="index029.html#toc203">virtual</A>
</LI><LI><A HREF="index029.html#toc204">VM</A>
</LI><LI><A HREF="index029.html#toc205">void</A>
</LI><LI><A HREF="index029.html#toc206">VPATH</A>
</LI><LI><A HREF="index029.html#toc207">XML</A>
</LI></UL>
<P><A NAME="c:glossary"></A></P><H2 CLASS="section"><A NAME="toc106"></A>abstract</H2><P><A NAME="@default2051"></A></P><P><B>OOP concept:</B> Abstract describes something
that is declared but not fully defined. For example, an abstract
method is a method that is declared as a part of a class, but has no
implementation. It cannot be called, it is only meant to be
inherited by derived classes.<BR>

<B>SIDL keyword:</B> Abstract is an optional modifier for both
<FONT COLOR=maroon><I><TT>class</TT></I></FONT>es and <FONT COLOR=maroon><I><TT>method</TT></I></FONT>s. An abstract method is a method
that has no implementation, it’s a way of declaring a method that
every subclass must implement for itself. An abstract class has one
or more abstract methods, and therefore cannot be instantiated.</P><H2 CLASS="section"><A NAME="toc107"></A>array</H2><P><A NAME="@default2052"></A></P><P><B>Datastructure:</B> An array is a fixed size, numerically
indexed, set of variables. Arrays have in language support in almost
all modern programming languages.</P><P><B>Babel:</B> Babel has built in support for arrays of
every data type, including objects. Babel allows these arrays such that they may be
shared by differing languages.</P><H2 CLASS="section"><A NAME="toc108"></A>BLAS</H2><P><A NAME="@default2053"></A></P><P>Basic Linear Algebra Subprograms.
BLAS is a famous library for doing matrix and vector algebra. 
More information may be found at: http://www.netlib.org/blas/ </P><H2 CLASS="section"><A NAME="toc109"></A>Babel Object Server</H2><P><A NAME="@default2054"></A></P><P>A Babel Object Server (BOS) is a network server process or thread that
provides babel objects via Remote Method Invocation (RMI). Normally a
BOS is run as a background thread on a normal Babel process to allow
the process to publish objects for access by RMI enabled clients. There is not
a single protocol that a BOS must use to communicate over Babel RMI, but
clients and BOSs must use the same protocol if they are expected to communicate.</P><H2 CLASS="section"><A NAME="toc110"></A>BNF</H2><P><A NAME="@default2055"></A></P><P>BackusNaur Form. BNF is a formal
way to describe computer languages and other formal languages. </P><H2 CLASS="section"><A NAME="toc111"></A>bool</H2><P><A NAME="@default2056"></A></P><P><B>Definition:</B> bool is a short form of the word
boolean. A boolean is a logical data type that holds 1 bit of data, i. e. it
is either true or false. It is used for Boolean Algebra.</P><P><B>SIDL keyword:</B> bool is a data type built into SIDL, an
instance of which is either true or false. For efficiency sake, the underlying storage
of bool is not 1 bit. </P><H2 CLASS="section"><A NAME="toc112"></A>borrowed arrays</H2><P><A NAME="@default2057"></A></P><P><B>Babel:</B> A borrowed array is a SIDL array that does not manage its own data.
The data is provided by some third party, who is also in charge of
deallocating the data. It is useful for sending data through Babel, but the
developer must beware in case the third party deallocates the
array data before the program has finished with it.</P><H2 CLASS="section"><A NAME="toc113"></A>CCA</H2><P><A NAME="@default2058"></A></P><P>Common Component Architecture http://www.ccaforum.org/ </P><H2 CLASS="section"><A NAME="toc114"></A>char</H2><P><A NAME="@default2059"></A></P><P><B>Definition:</B> char is a short form of the word
character. A character is a letter, number, puctuation mark, or other
such symbol use in writing. In programming, a character is often
defined by the 8 bit ASCII encoding.</P><P><B>SIDL keyword:</B> char is a data type built into SIDL. It stores 1 byte of data, or
enough for 1 ASCII character. </P><H2 CLASS="section"><A NAME="toc115"></A>class</H2><P><A NAME="@default2060"></A></P><P><B>OOP concept:</B> A class is a definition for a
particular kind of object. It may define the data and methods that
will be included in an actual instance of the object.</P><P><B>SIDL keyword:</B> class is a SIDL keyword. 
In SIDL a class definition only defines 
methods. Methods may be static or instance methods. (They are
instance methods by default.) If any instance method in a class is
declared abstract, the class cannot be instantiated as an object, and
is called an abstract class. Otherwise, it can be instantiated and is
called a concrete class.</P><H2 CLASS="section"><A NAME="toc116"></A>concrete class</H2><P><A NAME="@default2061"></A></P><P><B>OOP concept:</B> A concrete class is a class where 
all the class’s instance methods have
implementations. (ie. there are no abstract methods) A concrete class may
be instantiated as an object.</P><H2 CLASS="section"><A NAME="toc117"></A>COM</H2><P><A NAME="@default2062"></A></P><P>Common Object Model http://www.microsoft.com/ Microsoft’s IDL based
language interoperability suite.</P><H2 CLASS="section"><A NAME="toc118"></A>component</H2><P><A NAME="@default2063"></A></P><P><B>OOP concept:</B> Components are “plug-and-play” 
software libraries designed with standard,
clearly defined interfaces. They are the epitome of modular design. 
Because components communicate only through well-defined interfaces, 
when an application needs to be modified, a single component can be
modified (or exchanged for a similar component), without fear of 
disrupting the other components making up the application.</P><H2 CLASS="section"><A NAME="toc119"></A>component architecture</H2><P><A NAME="@default2064"></A></P><P><B>OOP concept:</B> A component architecture defines the
specifics of setting up a system for programming with components in
that architecture. For example, how components are
imported and how they communicate are some of the questions that must
be answered in a component architecture design.</P><H2 CLASS="section"><A NAME="toc120"></A>copy</H2><P><A NAME="@default2065"></A></P><P><B>SIDL keyword:</B> copy is a SIDL keyword. It is planned
that in future version of
babel it will be used as a parameter modifier for parameters passed to
RMI functions, currently however, this feature is unimplemented. </P><H2 CLASS="section"><A NAME="toc121"></A>CORBA</H2><P><A NAME="@default2066"></A></P><P>Common Object Request Broker Architecture http://www.omg.org CORBA
allows different programs by different vendors to communicate though
an IDL interface specification. In CORBA this glue code is called the
“Broker.”</P><H2 CLASS="section"><A NAME="toc122"></A>dcomplex</H2><P><A NAME="@default2067"></A></P><P><B>Definition:</B> The sum of a real number and an
imaginary number is called a complex number. Babel supports complex
numbers as a basic type via the basic types “fcomplex” and “dcomplex.”</P><P><B>SIDL keyword:</B> dcomplex is a data type built into SIDL. The name is short for
“double complex.” It stores a complex number via 2 64-bit floating
point variables, one for the real part, and one for the imaginary
part. </P><H2 CLASS="section"><A NAME="toc123"></A>dense</H2><P> <A NAME="@default2068"></A></P><P><B>Definition:</B> A dense array is an array where all the dimensions are “densely
packed,” or, in terms of memory addressing, there are no “spaces”
between array elements. For example, if a one-dimensional SIDL array
of 10 elements is created, it will be densely packed. However, if a
slice of the array is taken with a stride of 2, the resulting array
will use the same data as the original array. However, the new array
will be only five elements long, and will only consist of the even
elements of the original array. This is not densely packed. Example:</P><P>Array 1: 0 1 2 3 4 5 6 7 8 9</P><P>Array 2: 0 – 2 – 4 – 6 – 8 – </P><H2 CLASS="section"><A NAME="toc124"></A>developer</H2><P><A NAME="@default2069"></A></P><P><B>Babel:</B> There are two anticipated user types for Babel, both are kinds of
programmers. The person referred to as the “developer” is the person
developing a Babelized library. The “user” is the person who writes
a program using a Babelized library.</P><H2 CLASS="section"><A NAME="toc125"></A>DLL</H2><P><A NAME="@default2070"></A></P><P><B>Definition:</B> Dynamically Linked Library. A type of library that can be linked to
dynamically at runtime by passing its name as a string to the
dlopen() function.</P><H2 CLASS="section"><A NAME="toc126"></A>double</H2><P><A NAME="@default2071"></A></P><P><B>Definition:</B> A double is a 64-bit floating point number.</P><P><B>SIDL keyword:</B> SIDL support double as a basic type.</P><H2 CLASS="section"><A NAME="toc127"></A>DTD</H2><P><A NAME="@default2072"></A></P><P>Document Type Definition. Defines the grammar of the XML
files. http://www.w3.org/2002/xmlspec/</P><H2 CLASS="section"><A NAME="toc128"></A>dynamic linking</H2><P><A NAME="@default2073"></A></P><P><B>Definition:</B> The action of dynamically linking to DLLs at runtime. </P><H2 CLASS="section"><A NAME="toc129"></A>enum</H2><P><A NAME="@default2074"></A></P><P><B>Definition:</B> Enum is a shortend form of the word
enumeration. An enumeration is used to assign numbers to a set of
variable names, that is, enumerate the set of variable names. </P><P><B>SIDL keyword:</B> enum is a reserved word in SIDL. It is used for defining
enumerations. In Babel, enumerations are a way of binding
integer constants to names.</P><H2 CLASS="section"><A NAME="toc130"></A>enumeration</H2><P> <A NAME="@default2075"></A></P><P>In Babel, enumerations are a way of binding integer constants to names.
See subsection <A HREF="index008.html#ssec:basics:fundamental:enums">6.3</A>.</P><H2 CLASS="section"><A NAME="toc131"></A>exception</H2><P><A NAME="@default2076"></A></P><P><B>Definition:</B> The idea of an exception is that if a method encounters a problem it
cannot handle, it interrupts its execution and “throws” and
exception. Hopefully some function up the call stack will “catch”
the exception and know what to do about the problem. It is a useful
form of error handing that SIDL supports. Exception is not a reserved word
in SIDL (but <FONT COLOR=maroon><I><TT>throw</TT></I></FONT> is).</P><H2 CLASS="section"><A NAME="toc132"></A>extends</H2><P><A NAME="@default2077"></A></P><P><B>OOP concept:</B> See inheritance.</P><P><B>SIDL keyword:</B> extends is a SIDL reserved word. It is used to declare “like-type”
inheritance. For example, a class may extend another class, or an
interface may extend multiple interfaces, but a class cannot extend an
interface, nor can an interface extend a class.</P><H2 CLASS="section"><A NAME="toc133"></A>external stubs</H2><P> <A NAME="@default2078"></A></P><P>When building a Babelized library, its also important to note if your code has 
dependencies to other Babel types not in your library. These types often appear as
base classes, argument types, or even exception types. Your library will need
stubs corresponding to all these types, so it is best to put these in your library
as well. We call these external stubs. See subsection <A HREF="index021.html#ss:IORsinglepointaccess">19.2.3</A></P><H2 CLASS="section"><A NAME="toc134"></A>external types</H2><P><A NAME="@default2079"></A></P><P>External Types are variable or object types that are not defined in
the current class. In a class foo.Bar, sidl.Integer, or
sidl.BaseClass would be external types.</P><H2 CLASS="section"><A NAME="toc135"></A>fcomplex</H2><P><A NAME="@default2080"></A></P><P>fcomplex is a data type built into SIDL. The name is short for
“float complex.” It stores a complex number via 2 32-bit floating
point variables, one for the real part, and one for the imaginary
part. </P><H2 CLASS="section"><A NAME="toc136"></A>final</H2><P><A NAME="@default2081"></A></P><P>final is a SIDL reserved word. It is a method modifier. A final
method is inherited by subclasses, but its implementation can never
be overwritten. It is the “final” version of the implementation.</P><H2 CLASS="section"><A NAME="toc137"></A>float</H2><P><A NAME="@default2082"></A></P><P>float is a data type built into SIDL. It is a 32-bit floating point
number. float is short for floating point.</P><H2 CLASS="section"><A NAME="toc138"></A>full name</H2><P><A NAME="@default2083"></A></P><P>Overloaded Babelized methods called from non-object oriented
languages, such as C and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, have 2 method names. The full
name consists of the concatenation of the package name, class name, 
method name and type extension. The short name is missing the type
extension. See subsection <A HREF="index008.html#sec:overloading">6.7</A>.</P><H2 CLASS="section"><A NAME="toc139"></A>fundamental types</H2><P><A NAME="@default2084"></A></P><P>Fundamental types are the basic types that SIDL supports natively.
bool, int, char, long, float, double, fcomplex, dcomplex, opaque, and string.</P><H2 CLASS="section"><A NAME="toc140"></A>glue</H2><P><A NAME="@default2085"></A></P><P>Most of the code that Babel generates is “glue” code. “Glue” code
sits between the caller and the implementation to allow communication
between them. We use the term glue to refer to the stub, IOR, and skel
files.</P><H2 CLASS="section"><A NAME="toc141"></A>HTML</H2><P><A NAME="@default2086"></A></P><P>Hypertext Markup Language http://www.w3.org/MarkUp/</P><H2 CLASS="section"><A NAME="toc142"></A>implementation</H2><P><A NAME="@default2087"></A></P><P>In Babel, the implementation is the code placed in the server side
Impl files. It is the code that Babel used glue code to allow you to
call to.</P><H2 CLASS="section"><A NAME="toc143"></A>implements</H2><P><A NAME="@default2088"></A></P><P>implements is a SIDL reserved word. It is used when a class inherits
from one or more interfaces. However, in this case the word
“to implement” is not quite taken seriously. If a class implements
an interface it inherits its methods, and may be cast to that
interface, but if the programmer actually wished to implement any of
the interface methods, he must redeclare them in the SIDL class. Any
un-redeclared method is assumed abstract and will not appear in the
Impl files. If there are any abstract methods in a class, that class
is automatically abstract. </P><H2 CLASS="section"><A NAME="toc144"></A>implements-all</H2><P><A NAME="@default2089"></A></P><P>implements-all is a SIDL reserved word. It takes the place of
“implements.” It is used when a class inherits
from one or more interfaces, and the programmer
definitely wants to write implementation code for each method in the
named interfaces. If the programmer uses “implements-all” he does
not have to redeclare the interface methods. See Section <A HREF="index008.html#sec:basics:objects:babelom">6.7</A>.</P><H2 CLASS="section"><A NAME="toc145"></A>import</H2><P><A NAME="@default2090"></A></P><P>import is a SIDL reserved word. It is used to bring other packages
into scope. Packages may be accompanied by a version number.</P><H2 CLASS="section"><A NAME="toc146"></A>in</H2><P><A NAME="@default2091"></A></P><P>in is a SIDL reserved word. Each parameter passed though Babel must
be declared as in, out, or inout. Each of these modes has certain
rules and implication associated with it. In means “pass this variable by
value to the implementation.” See Section <A HREF="index008.html#s:basics_sidl">6.2</A>. </P><H2 CLASS="section"><A NAME="toc147"></A>independent arrays</H2><P><A NAME="@default2092"></A></P><P>Independent arrays are arrays that manage their own data. When all
the references to an independent are deleted, the array data is
garbage collected. The other kind of array is a borrowed array.</P><H2 CLASS="section"><A NAME="toc148"></A>inheritance</H2><P> 
<A NAME="@default2093"></A></P><P>In normal object-oriented programming, inheritance is the ability 
of a “super” or “parent” class or interface to pass its characteristics 
(methods and instance variables) on to its subclasses, 
allowing subclasses to reuse these characteristics.</P><P>Of course, in SIDL we cannot define instance variables, so in SIDL
inheritance only refers to method inheritance. In SIDL inheritance is
is declared with the reserved words <FONT COLOR=maroon><I><TT>extends</TT></I></FONT> and <FONT COLOR=maroon><I><TT>implements</TT></I></FONT>.</P><H2 CLASS="section"><A NAME="toc149"></A>inout</H2><P><A NAME="@default2094"></A></P><P>inout is a SIDL reserved word. Each parameter passed though Babel must
be declared as in, out, or inout. Each of these modes has certain
rules and implication associated with it. Inout means “pass this variable by
reference to the implementation. The implementation may do whatever
it wants with the reference, but it should return something. Possibly
a new variable.” See Section <A HREF="index008.html#s:basics_sidl">6.2</A>. </P><H2 CLASS="section"><A NAME="toc150"></A>instance method</H2><P><A NAME="@default2095"></A></P><P>An instance method is a method that must be associated with an object
instance. These methods probably rely on some state in the instance, so
they cannot be divorced from it. In Object Oriented languages, you
call these methods on an instance, in Babelized non-OO languages like
C, you pass an instance in as the first argument to one of these methods.</P><H2 CLASS="section"><A NAME="toc151"></A>int</H2><P><A NAME="@default2096"></A></P><P>int is a data type built into SIDL. It is a 32-bit integer variable
int is short for integer. </P><H2 CLASS="section"><A NAME="toc152"></A>int32_t and int64_t</H2><P><A NAME="@default2097"></A><A NAME="@default2098"></A></P><P>The ANSI C standard way of declaring an integer that is definitely 32
or 64 bits.</P><H2 CLASS="section"><A NAME="toc153"></A>interface</H2><P><A NAME="@default2099"></A></P><P>An interface is a declaration of a set of methods with no information 
given about their implementation. All interface methods are
abstract. An interface cannot be instantiated. However, a class may
inherit from multiple interfaces. The purpose of interfaces is to
give objects that are conceptually similar but internally different a
common interface so that code may treat them the same, or seamlessly
exchange them.</P><H2 CLASS="section"><A NAME="toc154"></A>interprocess</H2><P><A NAME="@default2100"></A></P><P>Interprocess means “between processes.” It is normally used to
refer to “interprocess communication,” where two or more processes
find some way to communicate. Interprocess communication is one
of the goals of babel with RMI. </P><H2 CLASS="section"><A NAME="toc155"></A>IOR</H2><P><A NAME="@default2101"></A></P><P>Intermediate Object Representation. IOR code is where Babel does all
its work maintaining arrays, Babel objects, reference counting, etc.</P><H2 CLASS="section"><A NAME="toc156"></A>JNI</H2><P><A NAME="@default2102"></A></P><P>Java Native Interface. The JNI is what allows Java to call to C and
C++. It is referred to as calling native code because while Java runs in a
virtual machine, but C and C++ run on the real machine, or run “natively.”</P><H2 CLASS="section"><A NAME="toc157"></A>language interoperability</H2><P><A NAME="@default2103"></A></P><P>Language interoperability is Babel’s main purpose. Language 
interoperability technology allows different computer languages to
call each other methods and communicate despite problems with calling
conventions and differing variable types.</P><H2 CLASS="section"><A NAME="toc158"></A>local</H2><P><A NAME="@default2104"></A></P><P>A method (or other identifier) is considered local if it is defined or
declared in the current class or method. Sometimes a more specific
term like, “local to the method” or “local to the class” is used.
There is also a SIDL keyword local that modifies methods. If a method
is local is can only be called in-process, and cannot be exported over RMI.</P><H2 CLASS="section"><A NAME="toc159"></A>long</H2><P><A NAME="@default2105"></A></P><P>long is a data type built into SIDL. It is a 64-bit integer variable
long is short for long integer. Note: Python sometimes has trouble
with longs, see Section <A >??</A> for more details. </P><H2 CLASS="section"><A NAME="toc160"></A>method</H2><P><A NAME="@default2106"></A></P><P>Method is the word commonly used in Java for what is called, in some
other languages, a function, subroutine, or procedure. Methods are a
piece a code that is called by a name. Instance methods depend on an
object instance, and are allowed to read and manipulate that objects
data. A static method does not depend on an instance, and therefore
can only access class data and what data is passed in to the method. </P><H2 CLASS="section"><A NAME="toc161"></A>namespace</H2><P><A NAME="@default2107"></A></P><P>A namespace is a way of logically divvying up globally accessible names.
This helps in avoiding conflicts between globally
accessible methods, classes, data, etc. They are mainly a feature of C++.</P><H2 CLASS="section"><A NAME="toc162"></A>nonblocking</H2><P><A NAME="@default2108"></A></P><P>nonblocking is a SIDL method attribute. A nonblocking method is split into
two parts. The invocation, method_send(), makes the call and
immediately returns a sidl.rmi.Ticket. Later, the Ticket can be
used to check if the method has returned, and retrieve the out
arguments if it has with method_recv(). Nonblocking methods are
really only useful with RMI where it allows the client to mix
computation and communication more freely. </P><H2 CLASS="section"><A NAME="toc163"></A>non-strided</H2><P><A NAME="@default2109"></A></P><P>A non-strided array is a dense array. See the glossary entry for dense.</P><H2 CLASS="section"><A NAME="toc164"></A>Object model</H2><P><A NAME="@default2110"></A></P><P>The Object Model is the of rules that regulates the definition,
creation, and use of classes and objects in a language. To read about
the SIDL object model see Section <A HREF="index008.html#sec:basics:objects">6.7</A>.</P><H2 CLASS="section"><A NAME="toc165"></A>OMG</H2><P><A NAME="@default2111"></A></P><P>Object Management Group http://www.omg.org/</P><H2 CLASS="section"><A NAME="toc166"></A>oneway</H2><P><A NAME="@default2112"></A></P><P>oneway is a SIDL method attribute. A oneway method is guaranteed to
have no out arguments at all, it cannot even throw exceptions. This
is so it can be invoked by a oneway message on RMI. oneway is really
only useful with RMI.</P><H2 CLASS="section"><A NAME="toc167"></A>opaque</H2><P><A NAME="@default2113"></A></P><P>opaque ia a data type build into SIDL. The word opaque is an
adjective meaning “not transparent.” In SIDL, an opaque is
a 64-bit variable that cannot be touched or modified by the
holder. It is normally used to hold pointers that cannot be
understood by the current language or in the current context. </P><H2 CLASS="section"><A NAME="toc168"></A>out</H2><P><A NAME="@default2114"></A></P><P>out is a SIDL reserved word. Each parameter passed though Babel must
be declared as in, out, or out. Each of these modes has certain
rules and implication associated with it. Out means “pass this (null)
variable by reference to the implementation. The implementation is
expected to fill the reference with a new variable to be passed back
to the client.” See Section <A HREF="index008.html#s:basics_sidl">6.2</A>. </P><H2 CLASS="section"><A NAME="toc169"></A>package</H2><P><A NAME="@default2115"></A></P><P>A package is a container and namespace for conceptually linked
classes and interfaces. Generally it is good practice to have one
package per SIDL file.</P><H2 CLASS="section"><A NAME="toc170"></A>pass-by-copy</H2><P><A NAME="@default2116"></A></P><P>Pass-by-copy referes to one of the two major ways arguments are passed
to methods (the other is pass-by-reference). In a pass-by-copy
scheme, arguments are always copied when they are passed, so that
changeing the value of argument in the callee does not effect the
value of the caller’s variable. 
This is particularly important to Babel RMI, where object can be
passed either by copy or reference. </P><H2 CLASS="section"><A NAME="toc171"></A>pass-by-reference</H2><P><A NAME="@default2117"></A></P><P>Pass-by-reference referes to one of the two major ways arguments are passed
to methods (the other is pass-by-copy). In a pass-by-reference
scheme, arguments remain in their original memory localtion and a
pointer to them is passed to the callee method. This means that if the
callee changes the value of an argument, the value of the caller’s
variable changes as well. 
This is particularly important to Babel RMI, where object can be
passed either by copy or reference. </P><H2 CLASS="section"><A NAME="toc172"></A>pass-by-value</H2><P><A NAME="@default2118"></A></P><P>See pass-by-copy</P><H2 CLASS="section"><A NAME="toc173"></A>PIC</H2><P><A NAME="@default2119"></A></P><P>Position Independent Code is for making dynamically loadable
libraries. PIC contains and extra level of indirection to allow the
correct methods to be found dynamically at runtime.</P><H2 CLASS="section"><A NAME="toc174"></A>preprocessing</H2><P><A NAME="@default2120"></A></P><P>Code preprocessing is a step, prior to compilation, where various
simple, automatic code modifications are made. For example, int C, #include
files are included, and #define macros are textually duplicated
throughout the code. In some cases, such as Babel Fortran 90/95, method
names are “mangled” to reduce their size under the method name
character limit.</P><H2 CLASS="section"><A NAME="toc175"></A>private data</H2><P><A NAME="@default2121"></A></P><P>Private data is data that is only accessible locally, inside an
object. In Babel, all Babel object data is private and cannot be
accessed by other SIDL objects.</P><H2 CLASS="section"><A NAME="toc176"></A>process</H2><P><A NAME="@default2122"></A></P><P>A process is a running program that exists in its own memory space
and can therefore run in parallel with other processes.</P><H2 CLASS="section"><A NAME="toc177"></A>protocol</H2><P><A NAME="@default2123"></A></P><P>A protocol is formal description of message formats and the rules
that two computers must follow in order to exchange messages.</P><P>Babel RMI may use any protocol that implements the Babel RMI API.
This API is defined in sidl.io.Serializer and sidl.io.Deserializer.</P><H2 CLASS="section"><A NAME="toc178"></A>reference counting</H2><P><A NAME="@default2124"></A></P><P>Reference counting is the form of garbage collection used in Babel.
Each object keeps a “reference count.” When that count reaches zero,
the object is destroyed and the memory reclaimed. In some languages
teh counting is handled automatically, in some, like C, the developer must
explicitly add and subtract from the reference count. (Using the
functions addRef and deleteRef.) The internal implementation of
deleteRef literally has an if statement that says “If the count is 0,
free this memory,” so if the reference count of an object goes below
one, all references to the object are immediately invalid.</P><H2 CLASS="section"><A NAME="toc179"></A>Remote Method Invocation</H2><P><A NAME="@default2125"></A></P><P>Remote Method Invocation (RMI) is Object Oriented Remote Procedure
Call (RPC). Where RPC allows a user to call procedures on remote
machines, RMI allows the user to call methods on objects that may or
may not exist on a remote machine. This has the advantage of being
more natural and makes local and remote object interchangeable.</P><H2 CLASS="section"><A NAME="toc180"></A>reverse engineering</H2><P><A NAME="@default2126"></A></P><P>Reverse Engineering is the practice of inspecting the behavior of an 
existing program to understand more about how it works. Babel does
not support this, or any forms of inspecting or modifying compiled code.</P><H2 CLASS="section"><A NAME="toc181"></A>RMI</H2><P><A NAME="@default2127"></A></P><P>See Remote Method Invocation</P><H2 CLASS="section"><A NAME="toc182"></A>RPC</H2><P><A NAME="@default2128"></A></P><P>See Remote Method Invocation</P><H2 CLASS="section"><A NAME="toc183"></A>serialization</H2><P><A NAME="@default2129"></A></P><P>Serialization is a process to encode a data structure as a sequence of
bytes. This is the method used by most object oriented system to save objects to
files or pass objects over a network connection. Babel RMI uses
serialization to pass objects by copy over the network. </P><H2 CLASS="section"><A NAME="toc184"></A>shared library</H2><P><A NAME="@default2130"></A></P><P>A shared library is a set of methods that may be used by multiple
different programs without recompilation of the library. </P><H2 CLASS="section"><A NAME="toc185"></A>short name</H2><P><A NAME="@default2131"></A></P><P>Overloaded Babelized methods called from non-object oriented
languages, such as C and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, have 2 method names. The full
name consists of the concatenation of the package name, class name, 
method name and type extension. The short name is missing the type
extension. See subsection <A HREF="index008.html#sec:overloading">6.7</A>.</P><H2 CLASS="section"><A NAME="toc186"></A>SIDL</H2><P><A NAME="@default2132"></A></P><P>Scientific Interface Definition Language. The language used by Babel
to describe how Babel glue code should be generated. 
See Chapter <A HREF="index008.html#c:basics">6</A>.</P><H2 CLASS="section"><A NAME="toc187"></A>single process</H2><P><A NAME="@default2133"></A></P><P>A single process program is a program that only uses one process to
complete its work. One of the features of Babel is that it is able
to facilitate language interoperability in a single process, which
saves the extra overhead of interprocess communication.</P><H2 CLASS="section"><A NAME="toc188"></A>skeleton</H2><P><A NAME="@default2134"></A></P><P>The Babel skeleton code is the opposite of the Babel stub code. The
Stub code facilitates the method call from client to IOR, and the
skeleton code facilitates the method call from IOR to implementation.</P><H2 CLASS="section"><A NAME="toc189"></A>SO</H2><P><A NAME="@default2135"></A></P><P>Shared Object. A Unix catch all term for shared and dynamically
loadable libraries.</P><H2 CLASS="section"><A NAME="toc190"></A>SPMD</H2><P><A NAME="@default2136"></A></P><P>Single Program Multiple Data. The term used to describe parallel
programs that use multiple processes running the same code working on
different data to solve a problem.</P><H2 CLASS="section"><A NAME="toc191"></A>state (of an object)</H2><P><A NAME="@default2137"></A></P><P>Object state refers to the data that an object holds. For example, if
an object holds one integer, that integer holds the objects state. It
is assumed that instance methods modify or use an object’s state in
some way. If a method does not use the object state in any way, it should
probably be a static method.</P><H2 CLASS="section"><A NAME="toc192"></A>static</H2><P><A NAME="@default2138"></A></P><P>A static method is a method that does not depend on an object instance
to run. It should have no need of any data of any particular object,
it should only depend on the data that is passed into it. As such,
unlike instance methods, it does not need to run on an instance of the
class it is associated with. In Babelized C, this means the first
argument to the function is not an object instance. In Java, this
means the function not called on an object, but referenced by the
class name. </P><H2 CLASS="section"><A NAME="toc193"></A>static linking</H2><P><A NAME="@default2139"></A></P><P>Static linking refers to the practice of linking code at compile time,
rather than dynamically at runtime. It has a speed advantage over
dynamically linked code, but lack flexibility.</P><H2 CLASS="section"><A NAME="toc194"></A>string</H2><P><A NAME="@default2140"></A></P><P>string is a data type built into SIDL. It stores a set of characters.
It has no predefined length.</P><H2 CLASS="section"><A NAME="toc195"></A>stub</H2><P><A NAME="@default2141"></A></P><P>The Babel stub code is the opposite of the Babel skeleton code. The
Stub code facilitates the method call from client to IOR, and the
skeleton code facilitates the method call from IOR to implementation.</P><H2 CLASS="section"><A NAME="toc196"></A>SWIG</H2><P><A NAME="@default2142"></A></P><P>Simplified Wrapper and Interface Generator http://www.swig.org/
SWIG is a language interoperability tool that is not IDL based, but
has certain other drawbacks.</P><H2 CLASS="section"><A NAME="toc197"></A>tarball</H2><P><A NAME="@default2143"></A></P><P>Tarball is a common way to refer to a set of directories and files
organized into a single file using the Unix tar command. It is often gzipped.</P><H2 CLASS="section"><A NAME="toc198"></A>throws</H2><P><A NAME="@default2144"></A></P><P>throws is a SIDL reserved word. It is used the tell SIDL that a
method may throw the named SIDL exception, and code should be
generated to pass it to the client.</P><H2 CLASS="section"><A NAME="toc199"></A>type</H2><P><A NAME="@default2145"></A></P><P>A type describes what sort of information a variable stores, and usually 
how much space that information takes up. Classes and interfaces are
user defined types, there are also fundamental types like int and bool.</P><H2 CLASS="section"><A NAME="toc200"></A>URL</H2><P><A NAME="@default2146"></A></P><P>Uniform Resource Locater. Often thought of as a pointer to a web resource.</P><H2 CLASS="section"><A NAME="toc201"></A>user</H2><P><A NAME="@default2147"></A></P><P>There are two anticipated user types for Babel, both are kinds of
programmers. The person referred to as the “developer” is the person
developing a Babelized library. The “user” is the person who writes
a program using a Babelized library.</P><H2 CLASS="section"><A NAME="toc202"></A>version</H2><P><A NAME="@default2148"></A></P><P>version is a reserved word in Babel that is used to declare a version
for a given package, or to declare what version of a given package
should be used.</P><H2 CLASS="section"><A NAME="toc203"></A>virtual</H2><P><A NAME="@default2149"></A></P><P>Virtual is the opposite of final. All SIDL methods are virtual by
default. A virtual method is a method that may be overridden in
subclasses. </P><H2 CLASS="section"><A NAME="toc204"></A>VM</H2><P><A NAME="@default2150"></A></P><P>Virtual Machine</P><H2 CLASS="section"><A NAME="toc205"></A>void</H2><P><A NAME="@default2151"></A></P><P>a reserved word in Babel, used to state that a function has no return type.</P><H2 CLASS="section"><A NAME="toc206"></A>VPATH</H2><P><A NAME="@default2152"></A></P><P>If you want to build software in a separate directory from
where the tarball was untarred, this is called a “VPATH build”.
VPATH<A NAME="@default2153"></A> builds are useful if you want to 
build Babel multiple times 
with various compilers, flags, or you have a shared file system 
across multiple platforms. It separates the code you generate
from things that you were given. </P><H2 CLASS="section"><A NAME="toc207"></A>XML</H2><P><A NAME="@default2154"></A></P><P>Extensible Markup Language. http://www.w3.org/XML/ A standardized
data exchange format.</P><HR>
<A HREF="index028.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index030.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
