<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Babel 
Users' Guide
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.textboxed{border:1px solid black}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -fix -O -o ./html/users_guide/index.html users_guide -->
<!--CUT DEF chapter 1 --><HR SIZE=2><DIV CLASS="flushright">
<FONT SIZE=7>Babel<BR>
Users’ Guide</FONT></DIV><HR SIZE=2><DIV CLASS="center">
<FONT SIZE=5> <BR>
 
<SPAN STYLE="font-variant:small-caps">Tamara Dahlgren  Dietmar Ebner 
  Thomas Epperly<BR>
 Gary Kumfert   James Leek 
  Adrian Prantl</SPAN><BR>
 </FONT><FONT SIZE=4><I>Center For Applied Scientific Computing<BR>
 Lawrence Livermore National Laboratory<BR>
 P.O. Box 808<BR>
 Livermore, California, USA<BR>
</I></FONT></DIV><DIV CLASS="center">
</DIV><P>

  </P><P><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</P><P>
<FONT SIZE=5><B>Disclaimer</B></FONT><BR>
</P><P>This work was performed under the auspices of the U. S. Department of
Energy by Lawrence Livermore National Laboratory in part under
Contract W-7405-Eng-48 and in part under Contract DE-AC52-07NA27344.<BR>

This document was prepared as an account of work sponsored by an 
agency of the United States Government. Neither the United States
Government nor the University of California nor any of their 
employees, makes any warranty, express or implied, or assumes 
any legal liability or responsibility for the accuracy, completeness, 
or usefulness of any information, apparatus, product, or process 
disclosed, or represents that its use would not infringe privately 
owned rights. Reference herein to any specific commercial product, 
process, or service by trade name, trademark, manufacturer, or 
otherwise, does not necessarily constitute or imply its endorsement, 
recommendation, or favoring by the United States Government or the 
University of California. The views and opinions of authors 
expressed herein do not necessarily state or reflect those of the 
United States Government or the University of California, and shall 
not be used for advertising or product endorsement purposes.</P><P><BR>
<BR>
<BR>

</P><DIV CLASS="center">
<FONT SIZE=5><B>Release Information</B></FONT><BR>

<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>Babel Users’ Guide (this document)</TD><TD ALIGN=right NOWRAP>UCRL-SM-230026</TD></TR>
<TR><TD ALIGN=left NOWRAP>Babel Source Code (associated software)</TD><TD ALIGN=right NOWRAP>UCRL-CODE-2002-054</TD></TR>
</TABLE>
</DIV><!--TOC chapter Preface-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter 1</A>  Preface</H1><!--SEC END --><P><A NAME="c:preface"></A></P><DIV CLASS="center">
<EM>This document applies to Babel 2.0.0.
It, like the software it documents, is a work in progress.<BR>
</EM>
– The Babel Development Team
</DIV><!--TOC section Babel in a Nutshell-->
<H2 CLASS="section"><!--SEC ANCHOR -->Babel in a Nutshell</H2><!--SEC END --><P><A NAME="s:preface-nutshell"></A><A NAME="@default0"></A>
</P><P>Babel is a tool that enables software written in different 
languages to communicate. It accomplishes this task by
using an Interface Definition Language (IDL) similar to 
COM and CORBA. Babel relies on the Scientific Interface Definition
Language (SIDL) that is specifically tuned for scientific applications.
By expressing software interfaces, or APIs<SUP><A NAME="text1" HREF="#note1">1</A></SUP>, in SIDL the appropriate glue code stubs and
skeletons can be generated to facilitate language interoperability.
Features unique to SIDL are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Dynamic multi-dimensional arrays
</LI><LI CLASS="li-itemize">Complex numbers (e. g. 2 + 3<I>i</I>)
</LI><LI CLASS="li-itemize">In-process optimizations
</LI><LI CLASS="li-itemize">Syntax for specifying executable interface contracts
</LI><LI CLASS="li-itemize">Special directives for large-scale parallel distributed programming (future)
</LI></UL><P>Babel enables true object-oriented techniques even in 
non object-oriented languages. The object model that SIDL
supports is similar to Java and Objective C where a class
can extend at most one class, but implement many interfaces.
In C++ speak, an interface is simply a class of all pure-virtual 
methods. Furthermore, if library developers want object-oriented
features but are required to be 100% ANSI C compliant,
Babel can meet those constraints. Although the Babel code 
generator is implemented in Java, the runtime libraries and 
generated files for C bindings are 100% ANSI C compliant.</P><P>Babel can be used as the basis for a component framework, but it is
<EM>not</EM> a complete framework by itself. We’ve added a tiny CCA-compliant framework, called
<EM>Decaf</EM><A NAME="@default1"></A><A NAME="@default2"></A>, in our examples/ directory.
Decaf demonstrates how Babel can be used to implement a component 
framework. </P><P>SIDL is also a useful communications tool for code development teams since
it only expresses the public API. That is, implementation details, which
often prove distracting during collaborative design, can be safely avoided
by restricting discussions to the interfaces described in SIDL.
Furthermore, since SIDL is simple and clean it can be used by Computer
Scientists, Math Programmers, and 
Application Scientists to debate APIs even using only email.</P><!--TOC section Scope of this Manual-->
<H2 CLASS="section"><!--SEC ANCHOR -->Scope of this Manual</H2><!--SEC END --><P><A NAME="s:preface-purpose"></A></P><P>This document is intended as an introduction and tutorial on the use of
Babel tools for the generation and use of component
software. The Babel tools were designed specifically
for scientific applications, therefore most of 
the examples and exercises here also deal with
scientific applications.</P><P>This manual assumes the reader is a programmer who is proficient in
two or more of the following languages: C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
Fortran 90/95, Fortran 2003/2003, Java, or Python. Furthermore, this
manual assumes the reader is familiar with the SPMD<SUP><A NAME="text2" HREF="#note2">2</A></SUP> programming model that pervades the
scientific computing community. Knowledge of and experience with MPI
programming is helpful, but not strictly required.</P><!--TOC section Getting the Software-->
<H2 CLASS="section"><!--SEC ANCHOR -->Getting the Software</H2><!--SEC END --><P><A NAME="@default3"></A></P><P>Babel source is available free of charge on the web. Developed
by the Components Project at the Lawrence Livermore National Laboratory
Center for Applied Scientific Computing (CASC), 
it is licensed under the Lesser GNU Public License (LGPL). See the
source distribution for details.</P><P>The homepage for the Components Project is 
</P><BLOCKQUOTE CLASS="quote">
<TT><A HREF="http://www.llnl.gov/CASC/components">http://www.llnl.gov/CASC/components</A></TT>
</BLOCKQUOTE><!--TOC section Conventions-->
<H2 CLASS="section"><!--SEC ANCHOR -->Conventions</H2><!--SEC END --><P><A NAME="s:preface-conventions"></A></P><P>The following typographic conventions are used throughout
this manual.</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><EM>Italic</EM>		</TD><TD VALIGN=top ALIGN=left>is used for file and command names. It
			 is also used to highlight comments in
			examples and to define terms the first time
			they appear in a document.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><TT>Constant Width</TT></TD><TD VALIGN=top ALIGN=left>is used in examples to show the text that
			is generated, and in regular text to show operators,
			variables, and the output from commands or programs.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>Constant Slanted</TT></I></FONT></TD><TD VALIGN=top ALIGN=left>is used for displaying for SIDL source code.
			We use a separate font to distinguish SIDL code
			from generated code.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><B><TT>Constant Bold</TT></B></TD><TD VALIGN=top ALIGN=left>is used to show user’s modifications to generated
				code and in examples to show user’s actual input
				at a terminal.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=left>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP><FONT COLOR=maroon><I>Sans Serif Slanted</I></FONT></TD><TD VALIGN=top ALIGN=left>is used in examples to show variables for
				which a context-specific substitution should be made.
				The variable <FONT COLOR=maroon><I>filename</I></FONT>, for example, 
				would be replaced by the actual filename.</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE><P>Additionally, we may use specific blocks of text as sidebars
to call the readers attention to particular information.
Here’s one kind.</P><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
Often when listing restrictions or requirements, 
we find it helpful to also explain and document
the rationale behind a design decision. In time,
the context in which the rationale was based
may become irrelevant, making the rationale blocks
very useful for understanding when to change a decision.
</EM></BLOCKQUOTE><!--TOC section We Appreciate Your Feedback-->
<H2 CLASS="section"><!--SEC ANCHOR -->We Appreciate Your Feedback</H2><!--SEC END --><P><A NAME="s:preface-corrections"></A><A NAME="@default4"></A></P><P>We have tested and verified the information in this
manual. Nonetheless, features may have changed or oversights may exist.
Please contact us with any issues, corrections, or suggestions
for future versions of this manual through snail mail at:
</P><BLOCKQUOTE CLASS="quotation">
Components Project<BR>
Center for Applied Scientific Computing<BR>
Lawrence Livermore National Laboratory<BR>
P. O. Box 808, L–561<BR>
Livermore, CA 94551
</BLOCKQUOTE><P>
or through email to:
</P><BLOCKQUOTE CLASS="quotation">
<TT><A HREF="mailto:components@llnl.gov">components@llnl.gov</A></TT>
</BLOCKQUOTE><P>
To find out more about Babel, feel free to subscribe to one or more of the
associated distribution lists given below.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>babel-announce@llnl.gov</TT> is a moderated email forum
to which anyone can subscribe (though no-one can post). This is a low-volume 
alternative for people who want to know about releases and major announcements.
</LI><LI CLASS="li-itemize"><TT>babel-dev@llnl.gov</TT> is an open discussion forum 
about Babel for serious babel users who want to talk about the internal workings of the tools. Anyone can subscribe or send email to this list.
</LI><LI CLASS="li-itemize"><TT>babel-users@llnl.gov</TT> is an open discussion forum 
about Babel for users. Anyone can subscribe or send email to this list.
</LI></UL><P>
To subscribe, simply send email to 
<TT><A HREF="mailto:majordomo@lists.llnl.gov">majordomo@lists.llnl.gov</A></TT>
with the appropriate line(s):
</P><BLOCKQUOTE CLASS="quotation">	<B><TT>subscribe babel-announce</TT></B> <FONT COLOR=maroon><I>[email-address]</I></FONT><BR>
	<B><TT>subscribe babel-dev     </TT></B> <FONT COLOR=maroon><I>[email-address]</I></FONT><BR>
	<B><TT>subscribe babel-users   </TT></B> <FONT COLOR=maroon><I>[email-address]</I></FONT><BR>
</BLOCKQUOTE><P>
where you can explicitly state your email address in
<FONT COLOR=maroon><I>email-address</I></FONT> or, if you leave <FONT COLOR=maroon><I>email-address</I></FONT> blank,
majordomo will use your email ReplyTo: field.</P><!--TOC section Acknowledgments-->
<H2 CLASS="section"><!--SEC ANCHOR -->Acknowledgments</H2><!--SEC END --><!--TOC paragraph Active Team Members:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Active Team Members:</H5><!--SEC END --><P>Tom Epperly (Project Lead),
Tamara Dahlgren, and
Adrian Prantl.</P><!--TOC paragraph Project Alumni:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Project Alumni:</H5><!--SEC END --><P>
Bill Bosl,
Kevin Durrenberger,
Nathan Dykman,
Dietmar Ebner,
Scott Kohn,
Gary Kumfert,
James Leek,
Steve Smith, and
Brent Smolinsky.</P><!--TOC paragraph Interns:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Interns:</H5><!--SEC END --><P>
Irina Abramova, <EM>USC (Summer 2009)</EM>,
Jewel Watts, <EM>NCAT (Summer 2009)</EM>,
Monica Porsche, <EM>Central State University (Summer 2008)</EM>,
Nija Shi, <EM>UC Davis (Summer/Fall 2004)</EM>,
Kirk Kelsey, <EM>(Summer 2004)</EM>,
Sarah Knoop, <EM>UW Madison (Summer 2003)</EM>, and
Melvina Blackgoat, <EM>NAU (Summer 2001)</EM>.</P><!--TOC paragraph Alpha Testers:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Alpha Testers:</H5><!--SEC END --><P>
Andy Cleary, 
Jeff Painter, 
and
Cal Ribbens</P><!--TOC paragraph Contributors (Ideas, Bug Reports, Patches, &amp; Code):-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Contributors (Ideas, Bug Reports, Patches, &amp; Code):</H5><!--SEC END --><P>
Rob Armstrong, 
Ben Allan, 
Wael Elwasif, 
Matt Knepley, 
Boyana Norris,
Barry Smith,
Jody Winston, 
and 
many more.</P><!--TOC paragraph Sponsors:-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Sponsors:</H5><!--SEC END --><P>
Babel development originally started as a Strategic Initiative (SI)
in the LDRD (Lab Directed R&amp;D) portfolio of Lawrence Livermore National 
Laboratory.
Follow-on funding comes through collaborations with the Common Component 
Architecture (CCA) Forum (<TT><A HREF="http://www.cca-forum.org/wiki">http://www.cca-forum.org/wiki</A></TT>).
Specifically, the U.S. Department of Energy (<TT><A HREF="http://www.doe.gov/">http://www.doe.gov/</A></TT>)
supports the project through the Office of Science (<TT><A HREF="http://sc.doe.gov/">http://sc.doe.gov/</A></TT>)
SciDAC program (<TT><A HREF="http://www.scidac.gov/">http://www.scidac.gov/</A></TT>).
Initial follow-on SciDAC funding came as part of the Center for 
Common Component Technology for Terascale Scientific Simulation (CCTTSS).
Current SciDAC II funding is part of the Center for Technology for 
Advanced Scientific Component Software (TASCS) 
(<TT><A HREF="http://tascs-scidac.org/">http://tascs-scidac.org/</A></TT>).

</P><!--TOC section Software Notices-->
<H2 CLASS="section"><!--SEC ANCHOR -->Software Notices</H2><!--SEC END --><P><A NAME="s:preface-sharedcode"></A>
Babel depends on a great deal of third-party software. </P><UL CLASS="itemize"><LI CLASS="li-itemize"><B>JavaCC</B> is used to generate the SIDL Parser. This is a
java.net community project. JavaCC is available under a 
	BSD-style license here: <TT><A HREF="https://javacc.dev.java.net/">https://javacc.dev.java.net/</A></TT>).</LI><LI CLASS="li-itemize"><B>gnu.getopt</B> is an implementation of GNU Getopt in Java
	and is distributed with Babel as a JAR file.
	It can be downloaded (along with sourcecode) from either the GNU 
website 
	<BLOCKQUOTE CLASS="quote"><PRE CLASS="verbatim">http://www.gnu.org/software/java/packages.html
 </PRE>	</BLOCKQUOTE>
	or the author’s website
	<BLOCKQUOTE CLASS="quote"><PRE CLASS="verbatim">http://www.urbanophile.com/arenn/hacking/download.html.
 </PRE>	</BLOCKQUOTE>
	The following is the copyright notice for gnu.getopt:
	<BLOCKQUOTE CLASS="quote">	<PRE CLASS="verbatim">/**************************************************************************
/* Getopt.java -- Java port of GNU getopt from glibc 2.0.6
/*
/* Copyright (c) 1987-1997 Free Software Foundation, Inc.
/* Java Port Copyright (c) 1998 by Aaron M. Renn (arenn@urbanophile.com)
/*
/* This program is free software; you can redistribute it and/or modify
/* it under the terms of the GNU Library General Public License as published 
/* by  the Free Software Foundation; either version 2 of the License or
/* (at your option) any later version.
/*
/* This program is distributed in the hope that it will be useful, but
/* WITHOUT ANY WARRANTY; without even the implied warranty of
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/* GNU Library General Public License for more details.
/*
/* You should have received a copy of the GNU Library General Public License
/* along with this program; see the file COPYING.LIB.  If not, write to 
/* the Free Software Foundation Inc., 59 Temple Place - Suite 330, 
/* Boston, MA  02111-1307 USA
/**************************************************************************/
 </PRE>	</BLOCKQUOTE>
	The text for the GNU Library GPL is available at 
	<TT><A HREF="http://www.gnu.org/copyleft/library.html">http://www.gnu.org/copyleft/library.html</A></TT>.</LI></UL><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Application 
Programming Interfaces
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">Single
Program Multiple Data
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter 1  Preface</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">Chapter 2  Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1  Babel Facilitates Language Interoperability</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2.2  Scientific Interface Definition Language (SIDL)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">2.3  Benefits to Customers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">2.4  Beyond Babel’s Scope</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">2.5  Summary</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">2.6  Organization</A>
</LI></UL>
</LI></UL><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc9">Part I  Foundations</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc10">Chapter 3  Installation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc11">3.1  Simple Installation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">3.2  External Software
Requirements</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">Chapter 4  Basic Babel Code Generation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc14">4.1  Babel is a Compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">4.2  Command Line Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">Chapter 5  Hello World Tutorial</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc17">5.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">5.2  Minimal Makefiles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">5.3  Portable Makefiles: using <TT>babel-config</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">5.4  Final Remarks</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">Chapter 6  SIDL Basics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc22">6.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">6.2  SIDL Files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">6.3  Fundamental Types</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">6.4  Arrays</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">6.5  Interface Contracts</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">6.6  SIDL Runtime</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">6.7  Objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">6.8  XML Repositories</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">Chapter 7  Upgrade Notes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc31">7.1  Upgrading from Babel 1.0 to 1.4</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">Part II  Supported Language Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc33">Chapter 8  C Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc34">8.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">8.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">8.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">8.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">Chapter 9  C++ Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc39">9.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">9.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">9.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">9.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">Chapter 10  FORTRAN 77 Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc44">10.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">10.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">10.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">10.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">Chapter 11  Fortran 90/95 Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">11.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">11.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">11.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">11.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">Chapter 12  Fortran 2003/2008 Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc54">12.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">12.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">12.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">12.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">Chapter 13  Java Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc59">13.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">13.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">13.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">13.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">Chapter 14  Python Bindings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc64">14.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">14.2  Basics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">14.3  Client-side</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">14.4  Implementation-side</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">Chapter 15  SIDL Backend</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc69">15.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">15.2  Purpose</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">15.3  Generated versus Original SIDL files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">15.4  XML File Comparison</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">15.5  Babel Command Line Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">Chapter 16  XML Backend</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc75">16.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">16.2  Purpose</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">16.3  Basic Structure</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">16.4  Command Line Options</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">Chapter 17  HTML Interface Documentation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc80">17.1  Introduction</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">Part III  Advanced Topics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc82">Chapter 18  Remote Method Invocation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc83">18.1  What is RMI?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">18.2  Babel RMI Concepts</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">18.3  Babel RMI Usage</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">18.4  Babel Object Servers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">18.5  Non-Blocking Babel RMI</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">Chapter 19  Building Portable Polyglot Software</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc89">19.1  Layout of Generated Files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">19.2  Grouping compiled assets into Libraries</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">19.3  Dynamic vs. Static Linking</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">19.4  SIDL Library Issues</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">19.5  Language Bindings for the <TT>sidl</TT> Package</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">19.6  SCL Files for Dynamic Loading</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">19.7  Deployment of Babel-Enabled Libraries</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">Chapter 20  Creating Objects with Pre-Initialized State</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc97">20.1  Introduction to the Backdoor Initializer</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">20.2  Motivation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">20.3  Example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">20.4  The Backdoor Initializer in C</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">20.5  The Backdoor Initializer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">20.6  The Backdoor Initializer in Fortran 90/95</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">20.7  The Backdoor Initializer in C++</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">20.8  The Backdoor Initializer in Java</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">20.9  The Backdoor Initializer in Python</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">Chapter 21  Interface Contracts</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc107">21.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">21.2  Specifications</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">21.3  Enforcement</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">21.4  Summary</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">Chapter 22  Troubleshooting</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc112">22.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">22.2  Common Errors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">22.3  Common Warnings</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">Chapter 23  Lessons Learned</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc116">23.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">23.2  Compilation Consistency is Key</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">Part IV  Appendices</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc119">Appendix A  Reserved Words</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc120">A.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">A.2  Reserved Words</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">A.3  Suggested Things To Avoid</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">Appendix B  SIDL Grammar</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc124">B.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">B.2  Backus-Naur Form</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">Appendix C  Extensible Markup Language (XML)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc127">C.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">C.2  SIDL Document Type Declaration (DTD)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">Appendix D  Glossary</A>
</LI><LI CLASS="li-toc">ibliography
</LI></UL>
</LI></UL><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc2">Chapter 2</A>  Introduction</H1><!--SEC END --><P><A NAME="c:intro"></A></P><P><BR>
</P><!--TOC section Babel Facilitates Language Interoperability-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">2.1</A>  Babel Facilitates Language Interoperability</H2><!--SEC END --><P>
Babel was conceived, designed, and built to solve a problem; namely,
to make scientific software libraries equally 
accessible from all of the standard languages. Hence, its goal is language
interoperability. The vision goes far beyond
calling BLAS<SUP><A NAME="text3" HREF="#note3">1</A></SUP>
implemented in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> from a C program. At its heart, Babel
lets programmers use their tool of choice in developing
complete applications using components implemented in one or more
distinct programming languages.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><A NAME="@default5"></A>
<IMG SRC="index001.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.1: Example Babel multi-language application</TD></TR>
</TABLE></DIV>
<A NAME="fig:intro:exampleapp"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>For instance<A NAME="@default6"></A>, let us say that an application scientist
is running a sophisticated C++ code from a Python scripting
environment. This can already be easily accomplished with
technologies like SWIG<A NAME="@default7"></A>. Now let’s say that the simulation
is showing some erratic behavior and the application scientist
wants to extend the <TT>ConvergenceCheck</TT> class to also report some
information to a log file. Let’s also assume that this
application scientist doesn’t want to write a new C++ class
much less rewrite the current application. What this individual
wants to do is derive and utilize a new class in Python from the C++ 
<TT>ConvergenceCheck</TT> class.
Thus, the C++ simulation code will now have to invoke a 
method on a class implemented in Python, which then dispatches
back to the C++ base class after doing its additional logging. In
Babel, this situation is normal and expected. In SWIG, one must use
special settings to enable the director feature to have this level of
flexibility, which increases the code size and
complexity. Figure <A HREF="#fig:intro:exampleapp">2.1</A> shows a high level view 
of what Babel’s solution looks like. The developers write the
application in Python, the library in C++, and the extended
<TT>ConvergenceCheck</TT> in Python. All the glue code is generated by
running Babel on a SIDL file.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><A NAME="@default8"></A>
<IMG SRC="index002.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.2: Language Interoperability Using Current Technology.</TD></TR>
</TABLE></DIV>
<A NAME="fig:intro:currentlanginterop"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>Figure <A HREF="#fig:intro:currentlanginterop">2.2</A> lists many of
the primary languages that are of interest to scientific
simulation software developers and users. The good news
is that there is a path from each language to every other;
meaning that calling from one to another is possible.
However, the technologies to get from one language to 
another vary widely, are fraught with pitfalls, and may require
calling through a completely different language.</P><P>Babel works by providing the technology to define and support the
multi-language interoperation of a common subset of functionality 
through programming language-neutral interface specifications.
See Fig. <A HREF="#fig:intro:babellanginterop">2.3</A>
to see a graphical representation of the supported languages. 
It is important to note that this common functionality subset 
is <EM>far</EM> from a lowest common denominator solution in that
Babel actually adds functionality when it is lacking in the host language.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<IMG SRC="index003.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.3: Language Interoperability Using Babel.</TD></TR>
</TABLE></DIV>
<A NAME="fig:intro:babellanginterop"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><!--TOC section Scientific Interface Definition Language (SIDL)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">2.2</A>  Scientific Interface Definition Language (SIDL)</H2><!--SEC END --><P><A NAME="@default9"></A> </P><P>In order to support multi-language interoperability, Babel relies 
on the specification of interfaces in the
Scientific Interface Definition Language (SIDL) (pronounced
“SIGH-dull”). SIDL is similar to COM<A NAME="@default10"></A> and CORBA<A NAME="@default11"></A> IDLs, 
but was designed with an emphasis on scientific computing.
Specifically, SIDL supports dynamic multi-dimensional arrays and
has built-in complex numbers. 
SIDL also supports interface contracts<A NAME="@default12"></A>, which 
define properties that must hold true during execution — before and/or 
after method invocation — when contract enforcement is enabled.
It will acquire a set of directives to aid in the description of 
massively parallel distributed objects.</P><P>When it comes to deciding what programming idioms
to support across all languages and which ones to reject,
SIDL strikes a careful balance between minimalism and 
completeness. It is <EM>not</EM> a lowest common denominator solution.
SIDL is minimal to keep the learning curve as low as possible.
It is complete so developers do not feel 
constrained in how to express their solutions.</P><P>SIDL is object-oriented<A NAME="@default13"></A>. Its object
model closely resembles that of Java and Objective C. In this model
there is single inheritance of implementation and multiple inheritance
of interfaces. It supports the typical notions of virtual, static, and
final methods. SIDL also provides a basic set of features by defining
and implementing the basic types for interfaces, classes and
exceptions. All types implicitly inherit from these basic types.</P><P>The most important concept to grasp about SIDL is that SIDL only
defines a public interface that other programs may use to access your code.
As a result, all methods defined as part of a SIDL file are public;
if you do not want a method to be globally usable, simply do not
define it in your SIDL file. Furthermore, all object and class data
is implicitly private. There is no way to declare or define data in a
SIDL file. Instead, any data required for your code should be declared
in the implementation language files. This way, the languages that use
your code through Babel may create your objects and pass them around
just like any normal piece of data, but they may only access the data
through the provided interface.</P><P>SIDL also has a complete set of fundamental data types<A NAME="@default14"></A>, from 
booleans to double precision complex numbers. It also supports
more sophisticated types such as enumerations, strings, 
objects, and dynamic multi-dimensional arrays.</P><P>SIDL is still a work in progress.
Of particular research interest are directives that will be 
added for parallel distributed object interaction and features 
to specify computational quality of service semantics associated 
with the interfaces.</P><!--TOC section Benefits to Customers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">2.3</A>  Benefits to Customers</H2><!--SEC END --><P>Babel has two types of customers<A NAME="@default15"></A>:
<EM>developer</EM><A NAME="@default16"></A> and <EM>user</EM><A NAME="@default17"></A>. The
developer implements a library that will be used by one or more users,
and the user uses libraries via their Babel generated interfaces.
Babel provides value to developers by making their software accessible
to a larger customer base because their software can be used from more
different programming languages. Users, on the other hand, may not
care or even know that they are interacting with a library through
Babel. Babel provides value to users by making more software
accessible to them.</P><P>Babel provides some features that benefits user and developer alike.
The most important aspect to note here is that all Babel objects are
reference counted<A NAME="@default18"></A>. This feature is critical
to encapsulate the memory allocation<A NAME="@default19"></A> library
(e. g. C’s malloc/free<A NAME="@default20"></A> or C++’s new/delete) used in the
implementation of the object. Users never need concern themselves
with when to free up a resource, they only declare when they’re done
with their reference to that resource. Developers are free to use
different memory allocation subsystems in different parts of their
code if need be.</P><P>Babel also provides a consistent type system.
This is particularly important when you want to make
object-oriented libraries written in C++, Python or Java accessible in
procedural languages like <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, Fortran 90/95 and C. Babel maps the
object-oriented concepts like inheritance, polymorphism and object
identity into all supported languages.</P><P>Interface contracts
<A NAME="@default21"></A><A NAME="@default22"></A>, which 
identify conditions that must hold at the interface boundary, can be used 
to improve the quality of software for both developers and users.
Interface contracts consist of precondition, postcondition, and/or 
invariant clauses belonging to the interface, not the underlying 
implementation(s). 
<A NAME="@default23"></A>
<EM>Precondition</EM>
<A NAME="@default24"></A>
<A NAME="@default25"></A><A NAME="@default26"></A>
clauses<A NAME="@default27"></A> consist of assertions 
on properties which must hold prior to method execution.
<EM>Postcondition</EM>
<A NAME="@default28"></A>
<A NAME="@default29"></A><A NAME="@default30"></A>
clauses<A NAME="@default31"></A> contain assertions 
which must hold upon method completion. 
<EM>Invariant</EM>
<A NAME="@default32"></A>
<A NAME="@default33"></A><A NAME="@default34"></A>
clauses<A NAME="@default35"></A> apply before and after 
method execution. 
Consequently, in addition to providing useful documentation, SIDL interface 
contracts are enforceable.
So developers can enable contract enforcement as an aid to testing and
debugging.
Users can enable full or partial contract enforcement during deployment
to gain confidence in unfamiliar software.</P><!--TOC section Beyond Babel’s Scope-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">2.4</A>  Beyond Babel’s Scope</H2><!--SEC END --><P>The language interoperability problem is a large one, 
and though the Babel tools address much of it, there is
still a lot that is beyond the scope of our tool.
Babel is at its heart a code generator and a runtime
library. Consequently, the following features are currently
limitations of the Babel tool kit:</P><DL CLASS="description"><DT CLASS="dt-description"><A NAME="@default36"></A>
<B>Reverse engineering</B></DT><DD CLASS="dd-description"> is not supported. That is, 
there is no support for inspecting or modifying compiled
code. In addition, scanning existing software to 
generate SIDL wrappers is not supported.
There are other groups who are pursuing a C++ 
to SIDL converter. Since SIDL contains different information
than what is in a C++ header file, however, such a 
converter cannot be fully automated without additional help.</DD><DT CLASS="dt-description"><B>Library compatibility</B></DT><DD CLASS="dd-description"><A NAME="@default37"></A> is limited.
Since Python and Java dynamically
load libraries into their virtual machines, using these
languages requires the ability to build shared libraries. 
In general, building shared libraries (particularly from C++)
is difficult and error prone. This is compounded by the
fact that compiler vendors have no standard way of doing
this, and many tools that help building shared libraries don’t
support C++. One can build a legitimate
shared library that still won’t work because there are
unresolved symbols, or the library was loaded in the
wrong mode. </DD><DT CLASS="dt-description"><B>Compiler compatibility</B></DT><DD CLASS="dd-description"><A NAME="@default38"></A> is limited.
Since the C++ standard does not specify a binary interface and uses a lot of
hashing in their symbol tables, there have been no attempts to get libraries 
from dissimilar C++ compilers to work together. Similarly, although we support
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> and Fortran 90/95, all libraries of Fortran code must be compiled
with the same compiler…again because of the lack of a
standard binary interface.</DD></DL><P>Despite the aforementioned limitations, Babel does facilitate the development
of language interoperable software. However, issues of robust packaging, 
building, and deployment of language interoperable software still loom 
on the horizon.</P><!--TOC section Summary-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">2.5</A>  Summary</H2><!--SEC END --><P>
Babel consists of a set of tools intended to facilitate
language interoperability in the scientific computing community. Using 
interfaces for libraries or components specified in Scientific Interface 
Definition Language (SIDL) files, Babel can generate corresponding XML 
representations as well as the source code for the corresponding stubs, 
intermediate object representations, and implementation skeletons. The 
generated source code then becomes the foundation for the glue code 
used for language interoperability between callers of libraries and components.</P><P>In addition to providing generated code automatically handling mapping 
fundamental data type parameters between different languages, Babel has 
built-in support for complex numbers and multi-dimensional arrays. 
Additional benefits include object reference counting to facilitate memory 
management.</P><P>Optional SIDL interface contract features are also provided.
Interface contracts aid in improving the quality of software.
Contracts added to interfaces document constraints and can be
used to enhance testing.
When enabled at runtime, contracts can also be used to help
users gain confidence in unfamiliar software.</P><P>Finally, Babel’s primary goal is to facilitate the development of
language interoperable libraries and components. Hence, support for
reverse engineering is not provided. Given that Babel has been
developed by a research team, there are also limitations associated
with shared library and programming language-specific compiler
interoperability support that have been looked into but probably will
not be addressed in the foreseeable future. Regardless, Babel has
proved to be useful to its stakeholders to the point that it is
becoming an integral part of the Common Component Architecture (CCA).
Refer to papers and presentations on our web site for more
information.</P><!--TOC section Organization-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">2.6</A>  Organization</H2><!--SEC END --><P>
The remainder of this document is separated into two parts: foundations 
and supported language bindings. Part I is devoted to describing the SIDL and
the Babel tools. It starts with a tutorial to gently introduce the reader to 
the development of glue code from both the implementation (or server) and user 
(or client) sides. The following chapter introduces SIDL and Babel basics. 
Finally, a chapter on advanced topics, such as linking options, is provided.</P><P>Part II describes the language bindings currently supported by Babel.
Most of the bindings are programming languages. In
which case, most have both client- and server-side bindings. However,
Babel also supports textual language backends. At this time,
Extensible Markup Language (XML), Hypertext Markup Language (HTML) and
Scientific Interface Definition Language (SIDL) are the only textual
backends.</P><P>Appendices are included to provide more information on topics such as 
acronyms, the SIDL Grammar, and SIDL XML. In addition, sections are included 
that provide advice and tips on troubleshooting.
	 </P><!--BEGIN NOTES part-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note3" HREF="#text3">1</A></DT><DD CLASS="dd-thefootnotes">BLAS: Basic Linear Algebra Subroutines
</DD></DL>
<!--END NOTES-->
<!--TOC part Foundations-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc9">Part I</A><BR>
Foundations</H1></TD></TR>
</TABLE><!--SEC END --><P><A NAME="p:foundations"></A></P><!--TOC chapter Installation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc10">Chapter 3</A>  Installation</H1><!--SEC END --><P><A NAME="c:install"></A>
<EM>Ideally, Babel will configure and make “out-of-the-box” on most 
Unix-like machines. If the configuration process detects that 
certain resources are unavailable, it will correctly disable support
for languages or features needing those resources. If this instance
of correct behavior is not the intended behavior, then the installer 
is left to install the external resources and then re-configure, make, 
and install Babel. This chapter is intended to provide help and
reassurance that Babel is indeed configured and installed correctly.
</EM></P><P><BR>
<BR>
<BR>

<BR>
</P><!--TOC section Simple Installation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">3.1</A>  Simple Installation</H2><!--SEC END --><P><A NAME="s:simpleInstall"></A></P><P>These instructions assume you have a “tarball” 
(e. g. *.tar.gz file). We have volunteers 
who put together and manage RedHat RPMs<A NAME="@default39"></A> and
Debian *.deb<A NAME="@default40"></A> distributions of Babel. If you have one of
these distros, read their documentation first as it
may have details that supersede our own.</P><P>A typical build is a simple sequence of
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>./configure -C</B><BR>
 # lots of stuff<BR>
 ...<BR>
	 Fortran77 enabled.<BR>
 	 C++ enabled.<BR>
 	 Java enabled.<BR>
 	 Python enabled.<BR>
	 Fortran90 enabled.<BR>
 % <B>make</B><BR>
 # lots more stuff<BR>
 ...<BR>
 % <B>make install</B><BR>
 # not so much stuff<BR>
 ...
</TT></BLOCKQUOTE><P>
The <B><TT>-C</TT></B> tells configure to cache its results in a
file. This improves the overall speed of configuration because the
runtime configure script reuses the results of the top-level configure.</P><P>There are many circumstances where the configuration step will
properly terminate with an error, but if the configuration works, the
build and installation shouldn’t terminate abnormally. If you have
problems or note bugs during configuration, installation or later
Babel usage, please send an email to
<TT><A HREF="mailto:babel-bugs@cca-forum.org">babel-bugs@cca-forum.org</A></TT>
including the version of babel you are working with, if possible the
output from <B><TT>babel-config --version-full</TT></B>, and the exact
output that indicates the presence of a bug. <B><TT>babel-config</TT></B> is
Bourne shell script that the configure creates in the <TT>bin</TT>
directory. If your current directory is the top directory of the Babel
distribution, normally you can invoke <B><TT>babel-config</TT></B> as
follows: 
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>bin/babel-config --version-full</B><BR>
</TT></BLOCKQUOTE><!--TOC subsection Configure-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.1  Configure</H3><!--SEC END --><P><A NAME="s:configure"></A><A NAME="@default41"></A></P><P>There are two main choices to be made at configure time:
“Where does the software get built?” and 
“Where does the software get installed?”. The mechanisms
for effecting these choices are quite different.</P><P>If you want to build software in a separate directory from
where the tarball was untarred, this is called a “VPATH build”.
VPATH<A NAME="@default42"></A> builds are useful if you want to build Babel multiple times 
with various compilers, flags, or you have a shared filesystem 
across multiple platforms. It separates the code you generate
from things that you were given. The downside is that it is more
complex to remember where to edit what since original sources will
be in the source directory tree and the generated sources and 
compiled assets will be in the build directory tree.</P><P>If you run configure in the directory it appears, (i. e. you typed
<B><TT>./configure</TT></B>) you are performing an “non-VPATH build”.
To do a VPATH build, simply cd to the directory you want to be
the build directory root, then launch configure from there.
The following sequence demonstrates a vpath build
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>tar zxvf babel-x.x.x.tar.gz</B><BR>
 % <B>mkdir babel-linux-build</B><BR>
 % <B>cd babel-linux-build</B><BR>
 % <B>../babel-x.x.x/configure -C</B><BR>
</TT></BLOCKQUOTE><P>Note that the directory where you build Babel should be
different from the directory where you install Babel.
The default install directory is <TT>/usr/local</TT>, but can
be set to any directory that you have read/write access to.
To change the install directory<A NAME="@default43"></A>, run configure with the 
<B><TT>--prefix</TT></B><A NAME="@default44"></A> option. Since many people do not
have root access on their machine (or prefer to install in
a local directory when dealing with unfamiliar software), 
this option is probably the second most heavily used
option for configure (first being <B><TT>--help</TT></B>, which
is a good one to try also.)</P><P>At the time of this writing (1.1.0), there are two configure
scripts in Babel, about 47K lines of shell script each.
These configure scripts will then propagate the information they
acquire to Makefiles by performing approximately 190 sed substitutions 
(per Makefile), to the source code by setting approximately
170 preprocessor macros in babel_config.h, and various bits of
shell script in the build that do not get propagated to the install
directory. The configure script does not modify any source code in 
Babel’s runtime system or code generator. This means that source
code generated by a different Babel installation is usable as long
as it gets compiled against the local babel_config.h and linked
with the local Babel runtime libraries.</P><!--TOC subsection Make-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.2  Make</H3><!--SEC END --><P><A NAME="@default45"></A></P><P>The makefiles are generated by the configure script from Makefile.in<A NAME="@default46"></A> 
templates. The configure script is generated by a tool called 
autoconf<A NAME="@default47"></A>. The Makefile.in’s are generated from Makefile.am<A NAME="@default48"></A> files
by a separate, related tool called automake<A NAME="@default49"></A>. We also use a tool
called libtool<A NAME="@default50"></A> to help with libraries. Libtool is written in shell, 
automake in perl<A NAME="@default51"></A>, and autoconf in m4<A NAME="@default52"></A>.</P><P>After a successful configuration step, if your build fails it is
most likely that there is a bug in Babel, autoconf, libtool, or 
a library of m4 macros from any of the above. It is less likely 
to be an issue with automake, but possible. Perl and m4 themselves
are no longer involved in the process after the configure script
is produced, so while there may be a nascent bug in the files they
generated, it is unlikely.</P><!--TOC subsection Make Check (Optional)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.3  Make Check (Optional)</H3><!--SEC END --><P><A NAME="@default53"></A><A NAME="@default54"></A>
This is an exhaustive check that can take hours to complete on an
average workstation. The number of actual tests run depends on the
number of languages that are enabled. In general a driver and an
implementation of each test is generated in each enabled language.
Then each combination of driver and implementation are run (both
statically linked libraries and dynamically loaded libraries, as
appropriate) and tested. A test script can actually launch multiple
tests, and tests can have multiple parts. At the time of this writing
(babel-0.9.3) there are over 13,000 parts tested when all languages
are enabled.</P><!--TOC subsection Make Install-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.4  Make Install</H3><!--SEC END --><P><A NAME="@default55"></A><A NAME="@default56"></A></P><P>This transfers built software to the final installation directory.
Examples and tests are not installed, nor are Makefiles or
dozens of other types of files. Make install also builds javadoc
documentation for Babel’s code generator. Since some libraries are
built with install paths in mind, libtool uses a lot of scripts
to make things work in their build directory with binaries actually
hidden in .lib subdirectories. Make install strips this extra scaffolding
away as well.</P><!--TOC subsection Make Installcheck (Optional)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.1.5  Make Installcheck (Optional)</H3><!--SEC END --><P><A NAME="@default57"></A></P><P>This is the same test suite as with make check. The only
difference is that it is run against the code in the 
install directories, not the build directories.</P><!--TOC section External Software
Requirements-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc12">3.2</A>  External Software
Requirements</H2><!--SEC END --><P><A NAME="s:swreqts"></A><A NAME="@default58"></A></P><P>Babel builds on a lot of available software; some optional, 
some required. Some we ship in our tarball, some we require
users to install separately.</P><!--TOC subsection Required &amp; Included-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.1  Required &amp; Included</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Java GetOpt:</B><A NAME="@default59"></A>
This is a Java rewrite of GNU GetOpt available at
<TT><A HREF="http://www.urbanophile.com/arenn/hacking/download.html">http://www.urbanophile.com/arenn/hacking/download.html</A></TT>
The Babel code generator uses this to parse command line arguments. 
The JAR file, 
download information, and licensing details are in the lib/ subdirectory
of the Babel distribution.</LI><LI CLASS="li-itemize"><B>Xerces-J:</B><A NAME="@default60"></A><A NAME="@default61"></A>
Xerces-J is a Java implementation of SAX and DOM XML parsers
available from the Apache Software Foundation at
<TT><A HREF="http://www.apache.org">http://www.apache.org</A></TT>.
The Babel code generator uses this for XML I/O.
The JAR file, 
download information, and licensing details are in the lib/ subdirectory
of the Babel distribution.</LI><LI CLASS="li-itemize"><B>libparsifal:</B> libparsifal is a lightweight XML parser implemented in C, and Babel uses
it to parse its <TT>.scl</TT> files.</LI><LI CLASS="li-itemize"><B>libchasmlite:</B><A NAME="@default62"></A>
Babel uses a simplified form of the Fortran array descriptor library from Chasm (see 
<TT><A HREF="http://chasm-interop.sourceforge.net">http://chasm-interop.sourceforge.net</A></TT>).
Chasm is a language interoperability tool in its own right, 
but as of version 1.0.1, only the array library is considered complete.
Without libchasmlite, the configuration script will disable Fortran 90/95 support.</LI><LI CLASS="li-itemize"><B>libltdl:</B> The libtool dynamic loading library.
</LI></UL><!--TOC subsection Required but Separate-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.2  Required but Separate</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Unix shell &amp; bintools:</B><A NAME="@default63"></A>
On early 64bit Linux<A NAME="@default64"></A> boxes, we found it necessary
to rebuild even these basic tools with all 64bit options enabled.
Apparently they were originally installed with less attention to
detail than necessary. Bintools includes things like cp and mv.</LI><LI CLASS="li-itemize"><B>C/C++ compiler:</B><A NAME="@default65"></A>
The Babel runtime library and much of the code generated by the
Babel code generator will be ANSI C. So that must be available.
The C++ compiler should be optional, but at the time of this
writing the configure and makefiles didn’t reliably support disabling
C++.</LI><LI CLASS="li-itemize"><B>Java:</B><A NAME="@default66"></A>
The Babel code generator is implemented in Java.
One can disable the support for Java language bindings, but
a working Java would still be needed for just about everything else.
We generally stick with Sun’s java developer kits (available at
<TT><A HREF="http://java.sun.com">http://java.sun.com</A></TT>).
Others have run Babel with Kaffe and GCJ.
</LI></UL><!--TOC subsection Recommended-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.3  Recommended</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Python:</B><A NAME="@default67"></A>
Needed for the python language binding (obviously) and for the testing harness.
Since the Linux kernel is often configured with a Python-based tool, its
hard to find a Linux without python already installed. Python can be 
downloaded from 
<TT><A HREF="http://www.python.org">http://www.python.org</A></TT>.<P>One important gotcha is a special case where non-python applications create
Babel objects implemented in python. In this case, the Babel runtime 
needs to dynamically load the python virtual machine (libpython.so).
Unfortunately, python does not always build a dynamically loadable version
of this library by default. If the Babel configure script cannot find
a libpython.so, it will disable server-side Python support.</P><P>At the time of this writing, Python cannot be coerced to build a 
libpython.so on AIX.</P></LI><LI CLASS="li-itemize"><B>NumPy:</B><A NAME="@default68"></A><A NAME="@default69"></A>
This is a scientific array python extension module. It 
provides native C arrays (and the ability to manipulate very
big arrays) similar to python lists. Babel’s python
language binding requires this extension module available
at <TT><A HREF="http://numpy.scipy.ord">http://numpy.scipy.ord</A></TT>.</LI><LI CLASS="li-itemize"><B>Python Meta Widgets (Pmw):</B><A NAME="@default70"></A>
This is a library of GUI widgets built on top of Python’s native
tcl/tk interface (tkinter). Its available on SourceForge
<TT><A HREF="http://pmw.sourceforge.net">http://pmw.sourceforge.net</A></TT>
Pmw is only needed by the GUI in the
babel-life supercomputing demo. This Babel implementation of Conway’s
Game of Life is a separate tarball found in the contrib/ directory of 
the Babel distro. There is no test for Pmw in Babel’s configuration script.</LI><LI CLASS="li-itemize"><B>pthreads:</B><A NAME="@default71"></A> Needed for Java language binding.</LI></UL><!--TOC subsection Optional-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->3.2.4  Optional</H3><!--SEC END --><P>
These packages are used by Babel maintainers in the course of normal
development. You’ll need these only if you start rewriting code in
Babel’s distribution.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B>Automake:</B><A NAME="@default72"></A> Part of GNU Autotools (see
<TT><A HREF="http://www.gnu.org/software/automake">http://www.gnu.org/software/automake</A></TT>).
Check the configure.ac
file to determine exactly which version we use. The configure script
will disable autoconf if it detects the slightest variation from 
the version we prescribe.</LI><LI CLASS="li-itemize"><B>Autoconf:</B><A NAME="@default73"></A> Part of GNU Autotools (see
<TT><A HREF="http://www.gnu.org/software/automake">http://www.gnu.org/software/automake</A></TT>).
Check the configure.ac
file to determine exactly which version we use. The configure script
will disable autoconf if it detects the slightest variation from 
the version we prescribe.</LI><LI CLASS="li-itemize"><B>Libtool:</B><A NAME="@default74"></A> Part of GNU Autotools (see
<TT><A HREF="http://www.gnu.org/software/libtool">http://www.gnu.org/software/libtool</A></TT>).
Note that we often find need to make minor tweeks to ltmain.sh
so a fresh download may generate slightly worse results on 
some platforms.</LI><LI CLASS="li-itemize"><B>m4:</B><A NAME="@default75"></A> Contact us for a patched version that we use
(we overflow buffers in the distributed version).</LI><LI CLASS="li-itemize"><B>JavaCC:</B><A NAME="@default76"></A> This Java Compiler Compiler is what we
use to generate the SIDL parser in Babel. If you are interested
in experimenting with changing the SIDL grammar, then edit
the compiler/gov/llnl/babel/parsers/sidl2/SIDLParser.jj file and
rebuilt the parser with this tool. Information available at
<TT><A HREF="https://javacc.dev.java.net">https://javacc.dev.java.net</A></TT>.</LI><LI CLASS="li-itemize"><B>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A:</B><A NAME="@default77"></A> This is used to generate the HTML
version of our manuals (see <TT><A HREF="http://hevea.inria.fr/">http://hevea.inria.fr/</A></TT>).</LI><LI CLASS="li-itemize"><B>rst2man:</B><A NAME="@default78"></A> This is used to generate man page 
(see <TT><A HREF="http://docutils.sourceforge.net/">http://docutils.sourceforge.net/</A></TT>).</LI><LI CLASS="li-itemize"><B>perl:</B><A NAME="@default79"></A> Needed by automake and other bits and pieces.</LI></UL><!--TOC chapter Basic Babel Code Generation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc13">Chapter 4</A>  Basic Babel Code Generation</H1><!--SEC END --><P><A NAME="c:babel_basics"></A>
<EM>This chapter describes the Babel code generator and its command line options.
</EM></P><P><BR>
</P><!--TOC section Babel is a Compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">4.1</A>  Babel is a Compiler</H2><!--SEC END --><P>
Babel is a compiler. It takes symbols and their interfaces as input and 
generates either code or a given textual representation. These
interfaces may be specified in either Scientific Interface Definition Language 
(SIDL) or Extensible Markup Language (XML). The form the output takes depends 
upon the options specified on the command line. Refer to the 
Section <A HREF="#s:basics_commandline">4.2</A> for details on command line options. More
information on the supported bindings can be found in 
Part <A HREF="#p:supported_langs">II</A> of this document. </P><!--TOC section Command Line Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">4.2</A>  Command Line Options</H2><!--SEC END --><P><A NAME="s:basics_commandline"></A>
<A NAME="@default80"></A><A NAME="@default81"></A>	</P><P>The entire Babel code generator is written in Java and
compiled into a jar file. For convenience, a small script
called <B><TT>babel</TT></B> is provided that <EM>should</EM>
set the appropriate environment variables and invoke
the Java Virtual Machine on the jar file. To test that
the script and jar file are working together properly, 
simply type <B><TT>babel <CODE>--</CODE>help</TT></B>.</P><!--TOC subsection Using Babel-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Using Babel</H3><!--SEC END --><P>Babel requires exactly one of the following 
mutually exclusive arguments on the command line unless you use the 
<B><TT><CODE>--</CODE>multi</TT></B> option.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B><TT><CODE>--</CODE>help</TT></B>   :   Print options to stdout.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>version</TT></B>   :   Print version of Babel.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>text=</TT><FONT COLOR=maroon><I>form</I></FONT></B>   :   
	Generate text equivalent (“sidl” or “xml”) of associated
	package(s) or generate interface documentation with “html”.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>client=</TT><FONT COLOR=maroon><I>lang</I></FONT></B>   :   
	Generate client, or proxy, classes to access library.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>server=</TT><FONT COLOR=maroon><I>lang</I></FONT></B>   :   
	Generate the server and client classes to implement the library.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>parse-check</TT></B>   :   
	Check the SIDL file only.
</LI></UL><P>
By far, the three most common uses of Babel will be 
to generate the Client-side proxies, Server-side
implementations, and XML associated with the SIDL file.
The last option is essentially used internally when the Babel runtime 
library is being developed.</P><P>The <B><TT><CODE>--</CODE>multi</TT></B> option lets you generate multiple
targets for a given set of files in a single run. Put it first on the
command line, each <B><TT><CODE>--</CODE>client</TT></B> or <B><TT><CODE>--</CODE>server</TT></B> can have a different set of settings.</P><P>Additionally, there are a few supplemental arguments
that complete the picture.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B><TT><CODE>--</CODE>output-directory=</TT><FONT COLOR=maroon><I>dir</I></FONT></B>   :  
	Specifies the root directory associated with the
	generated files. The default setting is 
	the current working directory.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>generate-hooks</TT></B>   :  
Generate additional methods in the implementation files that
	allow developers to put additional code to be called before 
	and after the actual method call. These hooks are useful for
	implementation-specific method invocation instrumentation. 
Their execution can be disabled at run-time.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>generate-subdirs</TT></B>   :  
	Generates files in a directory tree
	matching the packaging scope of the SIDL file. This
	is on by default for languages that have this
	requirement, such as Java and Python, but off
	by default for languages that have no such
	requirement. Hence, code generation for only the 
latter languages (e. g. C, C++, F77, F90) is affected
	by this option.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>generate-subdirs-off</TT></B>   :  
Turn the <B><TT><CODE>--</CODE>generate-subdirs</TT></B>
	feature off. This is useful with 
	<B><TT><CODE>--</CODE>multi</TT></B> option.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>short-file-name</TT></B>   :   
When the <CODE>--</CODE>generate-subdirs and
<CODE>--</CODE>short-file-names options are
used simultaneously, the generated file names will not include
package names, just the class or interface symbol. Thus,
either long or short names must be used in all clients or
servers that have interdependencies; mixing short and long
names will result in compile and/or runtime errors.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>repository-path=</TT><FONT COLOR=maroon><I>path</I></FONT></B>   :  
	Specifies a semicolon-separated list of directories,
	or URLs<SUP><A NAME="text4" HREF="#note4">1</A></SUP>
	to search for XML Type descriptions. The need for
	these XML types is to resolve references in the 
	SIDL file.
	This option can be used multiple times on the same 
command line. If appropriate, the Babel script 
adds the default repository path to the command line 
before dispatching to the Java Virtual Machine.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>no-default-repository</TT></B>   :   
	Prohibits the use of the default repository
	in resolving symbols.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>rename-splicers</TT></B>   :  
	To improve some of the Babel 1.0 splicer blocks names were changed
in Babel 1.4. This switch will automatically rename Babel 1.0 
	splicer blocks to their new Babel 1.4 names.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>suppress-contracts</TT></B>   :  
	Refrain from generating checks associated with contracts 
	specified in the SIDL file.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>suppress-ior</TT></B>   :  
Refrain from generating IOR source and header files.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>suppress-timestamp</TT></B>   :  
Suppresses the insertion of meta-information that 
could result in generated files that would otherwise
not differ from prior executions on the same, unchanged
input file.
	Typically Babel inserts meta-information such as
	creation time into files it generates. Although
	this information is useful, it does result in the 
creation of excessive changes when using version control systems. 
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>exclude=</TT><FONT COLOR=maroon><I>regex</I></FONT></B>   :  
	This options can be used multiple times. Each time you
	add a regular expression that will be used to exclude
	symbols from code generation. No code or XML will be
	generated for any symbol matching the user provided
	regular expression. This command line option requires
	version 1.4.0 or later of the Java runtime environment.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>cca-mode</TT></B>   :  
This flag changes the contents of splicer blocks to
	match the requirements for the Common Component Architecture (CCA).
	Unimplemented methods throw exceptions, and there are some
	extra indications for Bocca about which sections still
	require editing.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>comment-local-only</TT></B>   :  
	This option reduces the amount of comments in stub
	C header files. It will only include the doc comments
	for locally defined methods. It will not include doc
	comments for inherited methods.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>hide-glue</TT></B>   :  
This option causes all non-impl files to be generated
	in a <TT>glue/</TT> subdirectory. This reduces the
	“clutter” in the current directory.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>hide-glue-off</TT></B>   :  
Turn off the <B><TT><CODE>--</CODE>hide-glue</TT></B> setting.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>language-subdir</TT></B>   :  
This options causes all generated files to be stored in a 
	language-dependent subdirectory; if the <B><TT><CODE>--</CODE>generate-subdirs</TT></B> option is also used, the language
directory will be at the bottom of the hierarchy.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>language-subdir-off</TT></B>   :  
Turn the <B><TT><CODE>--</CODE>language-subdir</TT></B> setting
	off.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>make-prefix=</TT><FONT COLOR=maroon><I>prefix</I></FONT></B>   :  
The string <FONT COLOR=maroon><I>prefix</I></FONT> is prepended to the name of
	<TT>babel.make</TT> and the symbols defined inside <TT>babel.make</TT>
	to allow Babel to be run multiple times in a single directory without
	overwriting files.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>makefile</TT></B>   :  
This instructs Babel to generate a sample GNU Makefile named <TT>GNUmakefile</TT>.
	The sample GNU Makefile uses <TT>babel-config</TT> to determine the appropriate build
	flags. It’s meant to be a simple, example Makefile, and it will likely require
	editing before incorporating it in a larger project build. It may not work 
	correctly with other options that change where files are
generated such as the <CODE>--</CODE><TT>hide-glue</TT> option.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>exclude-external</TT></B>   :  
This option causes code to be generated only for the symbols
	specified on the command line. If you list a SIDL file
	on the command line, all the symbols it contains will be 
	included. No code is generated for symbols
	on which the users symbols depend. This behavior is now the default 
	behavior, so this option is not usually required.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>include-referenced</TT></B>   :  
This option causes code to be generated for symbols specified
	on the command line and for all symbols referenced by symbols
	on the command line. It is the opposite behavior to 
	<B><TT><CODE>--</CODE>exclude-external</TT></B>.
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>cxx-ior-exception</TT></B>   :  
	Earlier versions of the Babel C++ bindings checked the IOR
	pointer in a given stub before making any calls on it. If the IOR was
	null, a NullIORException was thrown. It was later found that in
	certain cases these checks were taking an inordinent amount of time,
	and since C++ does not normally check pointers before dereferencing
	them, it was decided that this feature was out of line with the spirit
	of C++. However, since some code had already been written that used
	this feature, we could not completely eliminate the checks.
	Therefore, this command line option was added. Calling babel
	with it will generate C++ stubs with the
	checks in them. This option has no effect on other languages. 
</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>vpath=</TT><FONT COLOR=maroon><I>dir</I></FONT></B>   :   This
option sets the root directory Babel searches first when trying to
load implementation files to preserve splicer block contents in the hand
edited implementation files. If you are generating server-side C for
a concrete class <TT>x.y.z</TT> and you used <B><TT><CODE>--</CODE>vpath=/tmp</TT></B>, Babel would try to read splicer blocks from
<TT>/tmp/x_y_z_Impl.h</TT> and <TT>/tmp/x_y_z_Impl.c</TT>. If it does
not find either file in <TT>/tmp</TT>, it also checks the current
directory. If you are using <B><TT><CODE>--</CODE>generate-subdirs</TT></B> with <B><TT><CODE>--</CODE>vpath</TT></B>, the
vpath directory is the root of the tree, so for the example, Babel
would search for <TT>/tmp/x/y/z_Impl.h</TT> and
<TT>/tmp/x/y/z_Impl.c</TT>. When appropriate, Babel inserts
<TT>#line</TT> directives to refer debuggers to the original
file. As its name suggests, this option is useful when making vpath
builds using make. Some people also use it to avoid spurious changes
to the files managed by their revision control system.
</LI></UL><!--TOC subsection Long and Short Forms-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Long and Short Forms</H3><!--SEC END --><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 4.1: Command Line Arguments.</TD></TR>
</TABLE></DIV><A NAME="tbl:basics_commandline_args"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><B>SHORT FORM</B></TD><TD ALIGN=left NOWRAP><B>LONG FORM</B></TD><TD ALIGN=left NOWRAP><B>NOTES</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>-h</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>help</TD><TD ALIGN=left NOWRAP>Print options to stdout.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-v</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>version</TD><TD ALIGN=left NOWRAP>Print version of Babel.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-t<FONT COLOR=maroon><I>form</I></FONT></TD><TD ALIGN=left NOWRAP><CODE>--</CODE>text=<FONT COLOR=maroon><I>form</I></FONT></TD><TD ALIGN=left NOWRAP>Generate text.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-c<FONT COLOR=maroon><I>lang</I></FONT></TD><TD ALIGN=left NOWRAP><CODE>--</CODE>client=<FONT COLOR=maroon><I>lang</I></FONT></TD><TD ALIGN=left NOWRAP>Generate client classes.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-s<FONT COLOR=maroon><I>lang</I></FONT></TD><TD ALIGN=left NOWRAP><CODE>--</CODE>server=<FONT COLOR=maroon><I>lang</I></FONT></TD><TD ALIGN=left NOWRAP>Generate server and client classes.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-p</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>parse-check</TD><TD ALIGN=left NOWRAP>Only check parsing of the SIDL file.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>cca-mode</TD><TD ALIGN=left NOWRAP>New splicer blocks get CCA-required content.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-i</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>generate-hooks</TD><TD ALIGN=left NOWRAP>Generate pre-/post-method hooks.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>generate-sidl-stdlib</TD><TD ALIGN=left NOWRAP>Regenerate the Babel runtime library.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-o<FONT COLOR=maroon><I>dir</I></FONT></TD><TD ALIGN=left NOWRAP><CODE>--</CODE>output-directory=<FONT COLOR=maroon><I>dir</I></FONT></TD><TD ALIGN=left NOWRAP>Root directory to contain generated files.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-g</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>generate-subdirs</TD><TD ALIGN=left NOWRAP>Generate sources in directory tree matching</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>SIDL packaging.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>generate-subdirs-off</TD><TD ALIGN=left NOWRAP>Turn off generate-subdirs.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-m</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>make-prefix=<FONT COLOR=maroon><I>prefix</I></FONT></TD><TD ALIGN=left NOWRAP>Prepend <FONT COLOR=maroon><I>prefix</I></FONT> to names for babel.make.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>makefile</TD><TD ALIGN=left NOWRAP>Generate a simple GNU Makefile.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>multi</TD><TD ALIGN=left NOWRAP>Generate multiple targets in a single run.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-R<FONT COLOR=maroon><I>path</I></FONT></TD><TD ALIGN=left NOWRAP><CODE>--</CODE>repository-path=<FONT COLOR=maroon><I>path</I></FONT></TD><TD ALIGN=left NOWRAP>Use specified XML repository(ies) to resolve</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>symbols.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-e<FONT COLOR=maroon><I>regex</I></FONT></TD><TD ALIGN=left NOWRAP><CODE>--</CODE>exclude=<FONT COLOR=maroon><I>regex</I></FONT></TD><TD ALIGN=left NOWRAP>Do not generate output for matching symbol(s).</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>no-default-repository</TD><TD ALIGN=left NOWRAP>Do not use the default repository to resolve</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>symbols.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>rename-splicers</TD><TD ALIGN=left NOWRAP>Rename Babel 1.0 splicer blocks to their 1.4 names.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>suppress-contracts</TD><TD ALIGN=left NOWRAP>Don’t generate contract checks in IOR files.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>suppress-ior</TD><TD ALIGN=left NOWRAP>Don’t generate IOR files.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>suppress-stubs</TD><TD ALIGN=left NOWRAP>Don’t generate client-side stub files.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>suppress-timestamp</TD><TD ALIGN=left NOWRAP>Suppress time-related metadata generation.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>comment-local-only</TD><TD ALIGN=left NOWRAP>Reduce doc comments in C stub
header.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-E</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>exclude-external</TD><TD ALIGN=left NOWRAP>Do not generate code for
dependencies.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>include-referenced</TD><TD ALIGN=left NOWRAP>Generate code for dependencies.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-u</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>hide-glue</TD><TD ALIGN=left NOWRAP>Put glue code in a subdirectory.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>hide-glue-off</TD><TD ALIGN=left NOWRAP>Turn off hide-glue.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-l</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>language-subdir</TD><TD ALIGN=left NOWRAP>Put code in a language dependent directory.</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>language-subdir-off</TD><TD ALIGN=left NOWRAP>Turn off language-subdir.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-x</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>cxx-ior-exception</TD><TD ALIGN=left NOWRAP>Include Null IOR checks in C++ Stubs.</TD></TR>
<TR><TD ALIGN=left NOWRAP>-V</TD><TD ALIGN=left NOWRAP><CODE>--</CODE>vpath</TD><TD ALIGN=left NOWRAP>Set the impl (splicer block) root directory.</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>So far, we’ve shown described the long forms of command line
arguments, starting with two hyphens “<B><TT><CODE>--</CODE></TT></B>”.
There are also short forms for many of the more frequently<A NAME="@default82"></A> 
used commands. See Table <A HREF="#tbl:basics_commandline_args">4.1</A>
for details.</P><!--TOC subsection Examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Examples</H3><!--SEC END --><P><A NAME="@default83"></A></P><P>To create a new XML version of a
SIDL file, use the following command:
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -tXML -omydepot mystuff.sidl</B><BR>
</TT></BLOCKQUOTE><P>To exclude code generation for types whose name begins with “MPI.”,
use the following command:
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -sC++ –exclude=’^MPI\.’ mystuff.sidl</B><BR>
</TT></BLOCKQUOTE><P>Now suppose a developer wants to implement a library
in C++ that corresponds to these types in the SIDL file.
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -sC++ mystuff.sidl</B><BR>
</TT></BLOCKQUOTE><P>Alternatively, the developer could also create C++ implementation
files based on the XML repository. In this case, 
a list of symbols to be implemented would need to be specified. Assuming that
all of the types are in a package called “mystuff”, the following command can
be issued: 
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -sC++ -Rmydepot mystuff</B><BR>
</TT></BLOCKQUOTE><P>Now suppose a second developer wants to extend this
software. A second SIDL file is created then 
the implementation files in Fortran 90/95 are generated with the following command:
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -sf90 -Rmydepot newstuff.sidl</B><BR>
</TT></BLOCKQUOTE><P>A user now can download both SIDL files and create their
Python bindings to use both libraries with the following
command:
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -cPython 
-Rhttp://localhost/mystuff/mydepot;<BR>
http://www.otherhost.com/newstuff
mystuff newstuff</B><BR>
</TT></BLOCKQUOTE><P>Finally, to generate SIDL files for each package based on the XML stored in the 
repository, the following command is used:
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -tSIDL
-Rhttp://localhost/mystuff/mydepot;<BR>
http://www.otherhost.com/newstuff
mystuff newstuff</B><BR>
</TT></BLOCKQUOTE><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note4" HREF="#text4">1</A></DT><DD CLASS="dd-thefootnotes">URLs have colons in them, so this
	path has to be semi-colon separated, even though
	UNIX paths are traditionally colon separated.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Hello World Tutorial-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc16">Chapter 5</A>  Hello World Tutorial</H1><!--SEC END --><P><A NAME="c:helloworld"></A><A NAME="@default84"></A></P><BLOCKQUOTE CLASS="quote">
<EM>For the things we have to learn before we can do them, 
we learn by doing them.</EM><BR>
— Aristotle (384 BCE – 322 BCE)
</BLOCKQUOTE><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">5.1</A>  Introduction</H2><!--SEC END --><P>
This tutorial guides you through the process of writing the classic
“Hello World!” example using the Babel tools. 
In the process, you will learn that the most vexing problem is
getting the compiler and linker flags set up properly.
Closely followed by the hassles of encoding this information
in portable Makefiles.</P><P>This section offers a spectrum of possible solutions, from 
the minimalist but not portable, to the very robust and portable
but not trivial, and a few options in between. The following 
sections start from the simplest setup, and work up in terms
of complexity and features.</P><P>Assuming Babel is built, installed and your PATH environment
variable has been set, we need to set up a few directories
for this exercise. 
One can verify it was built and installed properly by 
going to the directory where it was built and typing
<TT>make installcheck</TT>. (Warning: It can take
a few hours on a good workstation for Babel’s exhaustive tests to complete.)
To verify Babel is in your path, simply try running it with the 
<TT>--version</TT> or <TT>--help</TT> option.
Now pick a starting directory and issue
the following commands to create some directories
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>mkdir -p hello/minimal/libCxx</B><BR>
% <B>mkdir -p hello/minimal/libF90</B><BR>
% <B>cd hello</B><BR>
</TT></BLOCKQUOTE><P>Now we write a SIDL file to describe the calling interface.
It will be used by the Babel tools to generate glue code that 
hooks together different programming languages. 
A complete description of SIDL can be found in Chapter <A HREF="#c:basics">6</A>.
We will use the same SIDL file for several different coding exercises
and Makefile setups, so the SIDL file need not be large or complex
for our purposes.</P><P>For this particular application, we will write a SIDL file 
that contains a class World in a package Hello. 
Method getMsg() in class World returns a string containing 
the traditional computer greeting. 
Using your favorite text editor, create a file called 
hello.sidl in the hello/ directory containing the following:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"> <FONT COLOR=maroon><I>   1 <B>package</B> Hello <B>version</B> 1.0 {
    2   <B>class</B> World {
    3     <B>string</B> getMsg();
    4   }
    5 }</I></FONT></TD></TR>
</TABLE><P>The package statement provides a scope (or namespace) for class
World, which contains only one method, getMsg(). The version clause of the
statement identifies this as version 1.0 of the Hello package. </P><!--TOC section Minimal Makefiles-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc18">5.2</A>  Minimal Makefiles</H2><!--SEC END --><P>Babel has the ability to generate simple, minimal GNU Makefiles using the
<CODE>--</CODE><TT>makefile</TT> command-line option. The generated GNU Makefiles
require GNU <TT>make</TT> and are intended primarily as an aid to get you
started. They assume that <TT>babel</TT> and <TT>babel-config</TT> are in your
path.</P><!--TOC subsection Writing the C++ Implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.2.1  Writing the C++ Implementation</H3><!--SEC END --><P><A NAME="@default85"></A></P><P>We will write the C++ implementation in the minimal/libCxx/ subdirectory of hello/. 
The first step is to run the Babel code generator on the SIDL file and have
it generate the appropriate code.<A NAME="@default86"></A> 
The simplified command to generate the Babel library code (assuming Babel is in 
your PATH) is <SUP><A NAME="text5" HREF="#note5">1</A></SUP>: </P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>cd minimal/libCxx</B><BR>
% <B>babel -sC++ –makefile ../../hello.sidl</B><BR>
</TT></BLOCKQUOTE><P>In this Babel command, the “<TT>-sC++</TT>” flag, or its long form 
“<TT>--server=C++</TT>”, indicates that we wish to generate C++
bindings for an implementation<SUP><A NAME="text6" HREF="#note6">2</A></SUP>. 
This command will generate a large number of C and C++ header 
and source files. It is often surprising to newcomers just how
much code is generated by Babel. Rest assured, each file
has a purpose and there is a lot of important things being
done as efficiently as possible under the hood.</P><P>Files are named after the fully-qualified
class-name. For instance, a package <FONT COLOR=maroon><I><TT>Hello</TT></I></FONT> and class
<FONT COLOR=maroon><I><TT>World</TT></I></FONT> would have a fully qualified name (in SIDL) as
<FONT COLOR=maroon><I><TT>Hello.World</TT></I></FONT>. This corresponds to file names
beginning with <TT>Hello_World</TT><SUP><A NAME="text7" HREF="#note7">3</A></SUP>. For each class, 
there will be files with <TT>_IOR</TT>, 
<TT>_Skel</TT>, or <TT>_Impl</TT> appended after the
fully qualified name. 
Stubs often go without the <TT>_Stub</TT> suffix.
<EM>IOR files</EM><A NAME="@default87"></A> are always in ANSI C (source and headers), 
containing Babel’s Intermediate Object Representation.
<EM>Impl files</EM><A NAME="@default88"></A> contain the actual implementation, and 
can be in any language that Babel supports, in this 
case, they’re C++ files. Impl files are the only files
that a developer need look at or touch after generating
code from the SIDL source. 
<EM>Skel files</EM><A NAME="@default89"></A> perform translations
between the IORs and the Impls. 
In some cases (like Fortran)
the Skels are split into a few files: some in C, some in 
the Impl language. 
In the case of C++, the Skels are pure
C++ code wrapped in <TT>extern "C" {}</TT> declarations.
If the file is neither an IOR, Skel, nor Impl, then it
is likely a <EM>Stub</EM><A NAME="@default90"></A>. Stubs are the proxy classes
of Babel, performing translations
between the caller language and the IOR. 
Finally, the file <TT>babel.make</TT> is a Makefile fragment that is used by
<TT>GNUmakefile</TT> or to simplify making your own custom build.
You may ignore the babel.make file if you wish. 
There are also babel.make.depends and babel.make.package files.
These were added by external contributors, and we will ignore
them in this document.</P><P>The only files that should be modified by the developer
(that’s you since you’re implementing Hello World)
are the “Impls”, which are in this case
files ending with <TT>_Impl.hxx</TT> or <TT>_Impl.cxx</TT>
Babel generates these implementation files as a starting 
point for developers. 
These files will contain the implementation of the Hello library.
Every implementation file contains many pairs of comment “splicer”
lines<A NAME="@default91"></A> 
such lines 4 and 6 in the following sample:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    1 ::std::string
    2 Hello::World_impl::getMsg_impl ()
    3 {
    4   // DO-NOT-DELETE splicer.begin(Hello.World.getMsg)
    5   // Insert-Code-Here {Hello.World.getMsg} (getMsg method)
    6   // DO-NOT-DELETE splicer.end(Hello.World.getMsg)
    7 }</TD></TR>
</TABLE><P>Any modifications between these splicer lines will be
saved after subsequent invocations of the Babel tool. 
Any changes outside the splicer lines will be lost. 
This splicer feature was developed to make it
easy to do incremental development using Babel.
By keeping your edits within the splicer blocks, 
you can add new methods to the hello.sidl file
and rerun Babel without the loss of your previous 
method implementations. You shouldn’t ever need to edit the file
outside the splicer blocks.</P><P>For our hello application, the implementation is trivial. 
Add the following return statement between the splicer lines 
in the <TT>lib/Hello_World_Impl.cxx</TT> file:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">::std::string
Hello::World_impl::getMsg_impl ()
{
  // DO-NOT-DELETE splicer.begin(Hello.World.getMsg)
  return "Hello from C++!";
  // DO-NOT-DELETE splicer.end(Hello.World.getMsg)
}</TD></TR>
</TABLE><P>The following is a listing of the generated GNUmakefile
<A NAME="@default92"></A> excluding the boilerplate copyright
notice. It uses some of the tools installed along with Babel to
automated generating a static and shared library provided that the
machine supports both. The <TT>babel-config</TT> provides information
about which compilers and compiler flags to use, and
<TT>babel-libtool</TT> manages the building of object files and
libraries.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>make</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    1 include babel.make
    2 <FONT COLOR="blue"><I># please name the server library here</I></FONT>
    3 LIBNAME=hello
    4 <FONT COLOR="blue"><I># please name the SIDL file here</I></FONT>
    5 SIDLFILE=../../hello.sidl
    6 <FONT COLOR="blue"><I># extra include/compile flags </I></FONT>
    7 EXTRAFLAGS=
    8 <FONT COLOR="blue"><I># extra librarys that the implementation needs to link against</I></FONT>
    9 EXTRALIBS=
   10 <FONT COLOR="blue"><I># library version number</I></FONT>
   11 VERSION=0.1.1
   12 <FONT COLOR="blue"><I># PREFIX specifies the top of the installation directory</I></FONT>
   13 PREFIX=/usr/local
   14 <FONT COLOR="blue"><I># the default installation installs the .la and .scl (if any) into the</I></FONT>
   15 <FONT COLOR="blue"><I># LIBDIR</I></FONT>
   16 LIBDIR=$(PREFIX)/lib
   17 <FONT COLOR="blue"><I># the default installation installs the stub header and IOR header files</I></FONT>
   18 <FONT COLOR="blue"><I># in INCLDIR</I></FONT>
   19 INCLDIR=$(PREFIX)/include
   20 
   21 <FONT COLOR="blue"><I># most of the rest of the file should not require editing</I></FONT>
   22 
   23 ifeq ($(IMPLSRCS),)
   24   SCLFILE=
   25   BABELFLAG=--client=cxx
   26   MODFLAG=
   27 else
   28   SCLFILE=lib$(LIBNAME).scl
   29   BABELFLAG=--server=cxx
   30   MODFLAG=-module
   31 endif
   32 
   33 all : lib$(LIBNAME).la $(SCLFILE)
   34 
   35 CC=`babel-config --query-var=CC`
   36 CXX=`babel-config --query-var=CXX`
   37 INCLUDES=`babel-config --includes-cxx`
   38 CFLAGS=`babel-config --flags-c`
   39 CXXFLAGS=`babel-config --flags-cxx`
   40 LIBS=`babel-config --libs-cxx-client`
   41 
   42 STUBOBJS=$(STUBSRCS:.cxx=.lo)
   43 IOROBJS=$(IORSRCS:.c=.lo)
   44 SKELOBJS=$(SKELSRCS:.cxx=.lo)
   45 IMPLOBJS=$(IMPLSRCS:.cxx=.lo)
   46 
   47 PUREBABELGEN=$(IORHDRS) $(IORSRCS) $(STUBSRCS) $(STUBHDRS) $(SKELSRCS)
   48 BABELGEN=$(IMPLHDRS) $(IMPLSRCS)
   49 
   50 $(IMPLOBJS) : $(STUBHDRS) $(IORHDRS) $(IMPLHDRS)
   51 
   52 lib$(LIBNAME).la : $(STUBOBJS) $(IOROBJS) $(IMPLOBJS) $(SKELOBJS)
   53         babel-libtool --mode=link --tag=CXX $(CXX) -o lib$(LIBNAME).la \
   54           -rpath $(LIBDIR) -release $(VERSION) \
   55           -no-undefined $(MODFLAG) \
   56           $(CXXFLAGS) $(EXTRAFLAGS) $^ $(LIBS) \
   57           $(EXTRALIBS)
   58 
   59 $(PUREBABELGEN) $(BABELGEN) : babel-stamp
   60         @if test -f <B>$@</B>; then \
   61             touch <B>$@</B>; \
   62         else \
   63             rm -f babel-stamp ; \
   64             $(<B>MAKE</B>) babel-stamp; \
   65         fi
   66 
   67 babel-stamp: $(SIDLFILE)
   68         @rm -f babel-temp
   69         @touch babel-temp
   70         babel $(BABELFLAG) $(SIDLFILE)
   71         @mv -f babel-temp <B>$@</B>
   72 
   73 lib$(LIBNAME).scl : $(IORSRCS)
   74 ifeq ($(IORSRCS),)
   75         echo "lib$(LIBNAME).scl is not needed for client-side C bindings."
   76 else
   77         -rm -f <B>$@</B>
   78         echo '&lt;?xml version="1.0" ?&gt;' &gt; <B>$@</B>
   79         echo '&lt;scl&gt;' &gt;&gt; <B>$@</B>
   80         if test `uname` = "Darwin"; then scope="global"; else scope="local"; \
   81            fi ; \
   82           echo ' &lt;library uri="'`pwd`/lib$(LIBNAME).la'" scope="'"$$scope"'" resolution="lazy" &gt;' &gt;&gt; <B>$@</B>
   83         grep __set_epv $^ /dev/null | awk 'BEGIN {FS=":"} { print $$1}' | sort -u | sed -e 's/_IOR.c//g' -e 's/_/./g' | awk ' { printf "    &lt;class name=\"%s\" desc=\"ior/impl\" /&gt;\n", $$1 }' &gt;&gt;<B>$@</B>
   84         echo "  &lt;/library&gt;" &gt;&gt;<B>$@</B>
   85         echo "&lt;/scl&gt;" &gt;&gt;<B>$@</B>
   86 endif
   87 
   88 .SUFFIXES: .lo .cxx .c
   89 
   90 .c.lo:
   91         babel-libtool --mode=compile --tag=CC $(CC) $(INCLUDES) $(CFLAGS) $(EXTRAFLAGS) -c -o <B>$@</B> $&lt;
   92 
   93 .cxx.lo:
   94         babel-libtool --mode=compile --tag=CXX $(CXX) $(INCLUDES) $(CXXFLAGS) $(EXTRAFLAGS) -c -o <B>$@</B> $&lt;
   95 
   96 clean :
   97         -rm -f $(PUREBABELGEN) babel-temp babel-stamp *.o *.lo
   98 
   99 realclean : clean
  100         -rm -f lib$(LIBNAME).la lib$(LIBNAME).scl
  101         -rm -rf .libs
  102 
  103 install : install-libs install-headers install-scl
  104 
  105 
  106 install-libs : lib$(LIBNAME).la
  107         -mkdir -p $(LIBDIR)
  108         babel-libtool --mode=install install -c lib$(LIBNAME).la \
  109           $(LIBDIR)/lib$(LIBNAME).la
  110 
  111 install-scl : $(SCLFILE)
  112 ifneq ($(IORSRCS),)
  113         -rm -f $(LIBDIR)/lib$(LIBNAME).scl
  114         -mkdir -p $(LIBDIR)
  115         echo '&lt;?xml version="1.0" ?&gt;' &gt; $(LIBDIR)/lib$(LIBNAME).scl
  116         echo '&lt;scl&gt;' &gt;&gt; $(LIBDIR)/lib$(LIBNAME).scl
  117         if test `uname` = "Darwin"; then scope="global"; else scope="local"; \
  118            fi ; \
  119           echo ' &lt;library uri="'$(LIBDIR)/lib$(LIBNAME).la'" scope="'"$$scope"'" resolution="lazy" &gt;' &gt;&gt; $(LIBDIR)/lib$(LIBNAME).scl
  120         grep __set_epv $^ /dev/null | awk 'BEGIN {FS=":"} { print $$1}' | sort -u | sed -e 's/_IOR.c//g' -e 's/_/./g' | awk ' { printf "    &lt;class name=\"%s\" desc=\"ior/impl\" /&gt;\n", $$1 }' &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  121         echo "  &lt;/library&gt;" &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  122         echo "&lt;/scl&gt;" &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  123 endif
  124 
  125 install-headers : $(IORHDRS) $(STUBHDRS)
  126         -mkdir -p $(INCLDIR)
  127         for i in $^ ; do \
  128           babel-libtool --mode=install cp $$i $(INCLDIR)/$$i ; \
  129         done
  130 
  131 .PHONY: all clean realclean install install-libs install-headers install-scl</TD></TR>
</TABLE><P>The details of this makefile deserve careful explanation.
</P><BLOCKQUOTE CLASS="quote">
<DL CLASS="description"><DT CLASS="dt-description">
<B>line 1:</B></DT><DD CLASS="dd-description"> <TT>babel.make</TT> is a file that Babel generates when it
generates code. It defines some standard names so our makefiles
don’t have to know every SIDL type declared in the file.
</DD><DT CLASS="dt-description"><B>line 3:</B></DT><DD CLASS="dd-description"> <TT>LIBNAME</TT> defines the name of the library file
that will be generated. <EM>This is the only line that I had to
edit in the babel-generated GNUmakefile.</EM>
</DD><DT CLASS="dt-description"><B>line 7:</B></DT><DD CLASS="dd-description"> Use <TT>EXTRAFLAGS</TT> to define additional compile flags
to be used when compiling files. For this example, it should be empty.
</DD><DT CLASS="dt-description"><B>line 9:</B></DT><DD CLASS="dd-description"> <TT>EXTRALIBS</TT> should hold any extra libraries
needed for your application. For this example, it should be empty.
</DD><DT CLASS="dt-description"><B>line 11:</B></DT><DD CLASS="dd-description"> The <TT>VERSION</TT> should be three numbers separated
by periods.
</DD><DT CLASS="dt-description"><B>line 13:</B></DT><DD CLASS="dd-description"> The <TT>PREFIX</TT> is for libraries that will be
installed.
</DD><DT CLASS="dt-description"><B>line 21–end:</B></DT><DD CLASS="dd-description"> This part of the <TT>GNUmakefile</TT> works from
the definitions above and usually does not require changes unless
you are incorporating it into a more complex build system.
</DD><DT CLASS="dt-description"><B>line 33:</B></DT><DD CLASS="dd-description"> The first build target in a Makefile is also the default target.
Common convention is to make this target’s name “all.”
</DD><DT CLASS="dt-description"><B>lines 35–40:</B></DT><DD CLASS="dd-description"> Note that we use a script called <TT>babel-config</TT> to
hand us some information. This tool is very useful for getting the same
information that Babel’s configure script was given as Babel configuring
itself.
Increasingly, it is being used to also get information about tools and 
flags used in Babel’s makefiles, and its utility for getting at this level
of information is limited…mostly because we rely on a multilayered stack
of tools and some are less forthcoming than others.
</DD><DT CLASS="dt-description"><B>lines 42–45:</B></DT><DD CLASS="dd-description"> Here you see some of the variables defined in <TT>babel.make</TT>
and some fancy suffix substitution to define <TT>STUBOBJS</TT>,
<TT>IOROBJS</TT>, <TT>SKELOBJS</TT>, and <TT>IMPLOBJS</TT>.
</DD><DT CLASS="dt-description"><B>lines 53:</B></DT><DD CLASS="dd-description"> This is the rule to combine the <TT>.o</TT> files into
a static and dynamic library using <TT>babel-libtool</TT>.
</DD><DT CLASS="dt-description"><B>line 88:</B></DT><DD CLASS="dd-description"> This is a often misunderstood detail. To override the default
suffix rules, one must give the list of new suffices to consider.
</DD><DT CLASS="dt-description"><B>line 90–94:</B></DT><DD CLASS="dd-description"> Here we start to override make’s default suffix rules for
converting C and C++ sourcecode into <TT>.o</TT> files.
</DD><DT CLASS="dt-description"><B>lines 96 &amp; 99:</B></DT><DD CLASS="dd-description"> How you go about various levels of cleanliness in your
makefiles largely depends on matters of taste. The important point here
is what is <EM>not</EM> removed. One thing not cleaned up is <TT>babel.make</TT>
it is generated by Babel, but the makefile won’t work without the file
present because of the include in line 5. Another important thing to 
<EM>not</EM> remove is the Impl files, since they have hand-edited regions
in the generated file.
</DD><DT CLASS="dt-description"><B>line 103–129:</B></DT><DD CLASS="dd-description"> Here we define some simple rules for installing
libraries into standard system locations.
</DD><DT CLASS="dt-description"><B>line 131:</B></DT><DD CLASS="dd-description"> Technically, any phony targets like “clean” and “new” are
supposed to be listed in this variable. Many makefile implementations will
work well if you skip this line, but.
</DD></DL>
</BLOCKQUOTE><P>With the GNUmakefile in place we can simply go to that directory and build
everything by typing make.</P><!--TOC subsection Writing the Fortran 90/95 Implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.2.2  Writing the Fortran 90/95 Implementation</H3><!--SEC END --><P><A NAME="@default93"></A></P><P>Before writing the client, let’s generate a Fortran implementation as well.
It is highly instructive to see how the makefiles differ between 
the different language bindings. From within the <TT>minimal/libCxx</TT>
directory we do.</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>cd ../libF90</B><BR>
% <B>babel –makefile -sF90 ../../hello.sidl</B><BR>
</TT></BLOCKQUOTE><P>This time there’s even more files generated (Fortran 90/95 bindings are harder
after all), and we need to add our implementation to the <TT>Hello_World_Impl.F90</TT> file.
The modified code will look like this.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    1 <FONT COLOR="blue"><I>!</I></FONT>
    2 <FONT COLOR="blue"><I>! Method:  getMsg[]</I></FONT>
    3 <FONT COLOR="blue"><I>!</I></FONT>
    4 
    5 <B>recursive</B> subroutine Hello_World_getMsg_mi(self, retval, exception)
    6   <B>use</B> sidl
    7   <B>use</B> sidl_BaseInterface
    8   <B>use</B> sidl_RuntimeException
    9   <B>use</B> Hello_World
   10   <B>use</B> Hello_World_impl
   11   <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Hello.World.getMsg.use)</I></FONT>
   12   <FONT COLOR="blue"><I>! Insert-Code-Here {Hello.World.getMsg.use} (use statements)</I></FONT>
   13   <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Hello.World.getMsg.use)</I></FONT>
   14   implicit <B>none</B>
   15   type(Hello_World_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
   16   character (<B>len</B>=*) :: retval <FONT COLOR="blue"><I>! out</I></FONT>
   17   type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out</I></FONT>
   18 
   19 <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Hello.World.getMsg)</I></FONT>
   20 retval='Hello from Fortran 90<FONT COLOR="blue"><I>!'</I></FONT>
   21 <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Hello.World.getMsg)</I></FONT>
   22 end subroutine Hello_World_getMsg_mi</TD></TR>
</TABLE><P>Note that the C function appears as a subroutine in Fortran. 
What was the return value appears here as the argument <TT>retval</TT> (line 5). 
For Fortran 90/95 there are also two splicer blocks per subroutine, 
one for use statements (lines 11–13) and another for the actual
implementation (lines 19–21). This is where we put our implementation
by setting <TT>retval</TT> to the string we want.</P><P>There are important differences in this Makefile from the C++ 
implementation, so we reproduce it in its entirety here.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>make</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    1 include babel.make
    2 <FONT COLOR="blue"><I># please name the server library here</I></FONT>
    3 LIBNAME=hello
    4 <FONT COLOR="blue"><I># please name the SIDL file here</I></FONT>
    5 SIDLFILE=../../hello.sidl
    6 <FONT COLOR="blue"><I># extra include/compile flags </I></FONT>
    7 EXTRAFLAGS=
    8 <FONT COLOR="blue"><I># extra librarys that the implementation needs to link against</I></FONT>
    9 EXTRALIBS=
   10 <FONT COLOR="blue"><I># library version number</I></FONT>
   11 VERSION=0.1.1
   12 <FONT COLOR="blue"><I># PREFIX specifies the top of the installation directory</I></FONT>
   13 PREFIX=/usr/local
   14 <FONT COLOR="blue"><I># the default installation installs the .la and .scl (if any) into the</I></FONT>
   15 <FONT COLOR="blue"><I># LIBDIR</I></FONT>
   16 LIBDIR=$(PREFIX)/lib
   17 <FONT COLOR="blue"><I># the default installation installs the stub header and IOR header files</I></FONT>
   18 <FONT COLOR="blue"><I># in INCLDIR</I></FONT>
   19 INCLDIR=$(PREFIX)/include
   20 
   21 <FONT COLOR="blue"><I># most of the rest of the file should not require editing</I></FONT>
   22 
   23 ifeq ($(IMPLSRCS),)
   24   SCLFILE=
   25   BABELFLAG=--client=f90
   26   MODFLAG=
   27 else
   28   SCLFILE=lib$(LIBNAME).scl
   29   BABELFLAG=--server=f90
   30   MODFLAG=-module
   31 endif
   32 
   33 all : lib$(LIBNAME).la $(SCLFILE)
   34 
   35 CC=`babel-config --query-var=CC`
   36 CPP=`babel-config --query-var=CPP`
   37 FC=`babel-config --query-var=FC`
   38 INCLUDES=`babel-config --includes` `babel-config --includes-f90`
   39 CFLAGS=`babel-config --flags-c`
   40 FCFLAGS=`babel-config --flags-f90`
   41 MODINCLUDES=`babel-config --includes-f90-mod`
   42 LIBS=`babel-config --libs-f90-client`
   43 F90CPPSUFFIX=`babel-config --query-var=F90CPPSUFFIX`
   44 
   45 STUBOBJS=$(STUBSRCS:.c=.lo)
   46 STUBMODULEOBJS=$(STUBMODULESRCS:.F90=.lo)
   47 TYPEMODULEOBJS=$(TYPEMODULESRCS:.F90=.lo)
   48 IOROBJS=$(IORSRCS:.c=.lo)
   49 SKELOBJS=$(SKELSRCS:.c=.lo)
   50 IMPLOBJS=$(IMPLSRCS:.F90=.lo)
   51 IMPLMODULEOBJS=$(IMPLMODULESRCS:.F90=.lo)
   52 BASICMODULEOBJ=$(BASICMODULESRC:.F90=.lo)
   53 ARRAYMODULEOBJS=$(ARRAYMODULESRCS:.F90=.lo)
   54 ALLOBJS=$(STUBOBJS) $(STUBMODULEOBJS) $(TYPEMODULEOBJS) $(IOROBJS) \
   55         $(SKELOBJS) $(IMPLOBJS) $(IMPLMODULEOBJS) $(BASICMODULEOBJ) \
   56         $(ARRAYMODULEOBJS)
   57 
   58 PUREBABELGEN=$(ARRAYMODULESRCS) $(BASICMODULESRC) $(STUBMODULESRCS) \
   59         $(TYPEMODULESRCS) \
   60         $(IORHDRS) $(IORSRCS) $(STUBSRCS) $(STUBHDRS) $(SKELSRCS)
   61 BABELGEN=$(IMPLSRCS) $(IMPLMODULESRCS)
   62 
   63 $(TYPEMODULEOBJS)  : $(BASICMODULEOBJ)
   64 $(ARRAYMODULEOBJS)  : $(TYPEMODULEOBJS)
   65 $(STUBMODULEOBJS) : $(ARRAYMODULEOBJS) $(TYPEMODULEOBJS)
   66 $(IMPLMODULEOBJS) : $(STUBMODULEOBJS)
   67 $(IMPLOBJS) : $(IMPLMODULEOBJS) $(STUBMODULEOBJS) \
   68 
   69 lib$(LIBNAME).la : $(ALLOBJS)
   70         babel-libtool --mode=link --tag=FC $(FC) -o lib$(LIBNAME).la \
   71           -rpath $(LIBDIR) -release $(VERSION) \
   72           -no-undefined $(MODFLAG) \
   73           $(FCFLAGS) $(EXTRAFLAGS) $^ $(LIBS) \
   74           $(EXTRALIBS)
   75 
   76 $(PUREBABELGEN) $(BABELGEN) : babel-stamp
   77         @if test -f <B>$@</B>; then \
   78             touch <B>$@</B>; \
   79         else \
   80             rm -f babel-stamp ; \
   81             $(<B>MAKE</B>) babel-stamp; \
   82         fi
   83 
   84 babel-stamp: $(SIDLFILE)
   85         @rm -f babel-temp
   86         @touch babel-temp
   87         babel $(BABELFLAG) $(SIDLFILE)
   88         @mv -f babel-temp <B>$@</B>
   89 
   90 lib$(LIBNAME).scl : $(IORSRCS)
   91 ifeq ($(IORSRCS),)
   92         echo "lib$(LIBNAME).scl is not needed for client-side C bindings."
   93 else
   94         -rm -f <B>$@</B>
   95         echo '&lt;?xml version="1.0" ?&gt;' &gt; <B>$@</B>
   96         echo '&lt;scl&gt;' &gt;&gt; <B>$@</B>
   97         if test `uname` = "Darwin"; then scope="global"; else scope="local"; \
   98            fi ; \
   99           echo ' &lt;library uri="'`pwd`/lib$(LIBNAME).la'" scope="'"$$scope"'" resolution="lazy" &gt;' &gt;&gt; <B>$@</B>
  100         grep __set_epv $^ /dev/null | awk 'BEGIN {FS=":"} { print $$1}' | sort -u | sed -e 's/_IOR.c//g' -e 's/_/./g' | awk ' { printf "    &lt;class name=\"%s\" desc=\"ior/impl\" /&gt;\n", $$1 }' &gt;&gt;<B>$@</B>
  101         echo "  &lt;/library&gt;" &gt;&gt;<B>$@</B>
  102         echo "&lt;/scl&gt;" &gt;&gt;<B>$@</B>
  103 endif
  104 
  105 .SUFFIXES: .lo .F90 .c
  106 
  107 .c.lo:
  108         babel-libtool --mode=compile --tag=CC $(CC) $(INCLUDES) $(CFLAGS) $(EXTRAFLAGS) -c -o <B>$@</B> $&lt;
  109 
  110 .F90.lo:
  111         $(CPP) -traditional $(INCLUDES) -P -o $(@:.lo=.tmp) -x c $&lt;
  112         sed -e 's/^<FONT COLOR="blue"><I>#pragma.*$$//' &lt; $(@:.lo=.tmp) &gt; $(@:.lo=$(F90CPPSUFFIX))</I></FONT>
  113         babel-libtool --mode=compile --tag=FC $(FC) $(MODINCLUDES) $(FCFLAGS) -c -o <B>$@</B> $(@:.lo=$(F90CPPSUFFIX))
  114         rm -f $(@:.lo=$(F90CPPSUFFIX)) $(@:.lo=.tmp)
  115 
  116 clean :
  117         -rm -f $(PUREBABELGEN) babel-temp babel-stamp *.o *.lo *.mod
  118 
  119 realclean : clean
  120         -rm -f lib$(LIBNAME).la lib$(LIBNAME).scl
  121         -rm -rf .libs
  122 
  123 install : install-libs install-headers install-scl
  124 
  125 
  126 install-libs : lib$(LIBNAME).la
  127         -mkdir -p $(LIBDIR)
  128         babel-libtool --mode=install install -c lib$(LIBNAME).la \
  129           $(LIBDIR)/lib$(LIBNAME).la
  130 
  131 install-scl : $(SCLFILE)
  132 ifneq ($(IORSRCS),)
  133         -mkdir -p $(LIBDIR)
  134         -rm -f $(LIBDIR)/lib$(LIBNAME).scl
  135         echo '&lt;?xml version="1.0" ?&gt;' &gt; $(LIBDIR)/lib$(LIBNAME).scl
  136         echo '&lt;scl&gt;' &gt;&gt; $(LIBDIR)/lib$(LIBNAME).scl
  137         if test `uname` = "Darwin"; then scope="global"; else scope="local"; \
  138            fi ; \
  139           echo ' &lt;library uri="'$(LIBDIR)/lib$(LIBNAME).la'" scope="'"$$scope"'" resolution="lazy" &gt;' &gt;&gt; $(LIBDIR)/lib$(LIBNAME).scl
  140         grep __set_epv $^ /dev/null | awk 'BEGIN {FS=":"} { print $$1}' | sort -u | sed -e 's/_IOR.c//g' -e 's/_/./g' | awk ' { printf "    &lt;class name=\"%s\" desc=\"ior/impl\" /&gt;\n", $$1 }' &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  141         echo "  &lt;/library&gt;" &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  142         echo "&lt;/scl&gt;" &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  143 endif
  144 
  145 install-headers : $(IORHDRS) $(STUBHDRS) $(STUBDOCS)
  146         -mkdir -p $(INCLDIR)
  147         for i in $^ ; do \
  148           babel-libtool --mode=install cp $$i $(INCLDIR)/$$i ; \
  149         done
  150 
  151 .PHONY: all clean realclean install install-libs install-headers install-scl</TD></TR>
</TABLE><BLOCKQUOTE CLASS="quote">
<DL CLASS="description"><DT CLASS="dt-description">
<B>line 1:</B></DT><DD CLASS="dd-description"> Again Babel will generate a <TT>babel.make</TT> file, but we 
will see that its contents are different.
</DD><DT CLASS="dt-description"><B>line 3:</B></DT><DD CLASS="dd-description"> The name of the library will be <TT>libhello.la</TT>
again. <EM>This is the only line that I had to edit in the
babel-generated GNUmakefile.</EM>
</DD><DT CLASS="dt-description"><B>lines 7–19:</B></DT><DD CLASS="dd-description"> These variables have the same meanings as above.
<TT>EXTRAFLAGS</TT> are extra compile flags, and <TT>EXTRALIBS</TT>
defines extra libraries to list when linkings. <TT>PREFIX</TT> defines
where the library should be installed.
</DD><DT CLASS="dt-description"><B>lines 35–43:</B></DT><DD CLASS="dd-description"> Note that we use <TT>babel-config</TT> to generate
the proper flag for the preprocessor to find the Babel Fortran headers, 
and the compiler to find the Babel MOD files.
</DD><DT CLASS="dt-description"><B>lines 45–56:</B></DT><DD CLASS="dd-description"> Are building a <TT>$(OBJS)</TT> variable like before, 
but this time we see suffix substitutions for more kinds of files.
</DD><DT CLASS="dt-description"><B>lines 63–67:</B></DT><DD CLASS="dd-description"> The order that files are compiled is important
because Fortran 90/95’s use of MOD files<SUP><A NAME="text8" HREF="#note8">4</A></SUP> makes the ordering of these items
very important. 
(Not Babel’s fault, blame the Fortran 90/95 language designers.)
C/C++ has no such constraint on the order that 
individual units of compilation are performed. 
As long as Fortran 90/95 programmers stick with the ordering shown
in these lines, they should not encounter compiler complaints about 
dependent MOD files not found.
</DD><DT CLASS="dt-description"><B>lines 110–114:</B></DT><DD CLASS="dd-description"> This bit of code admittedly looks very strange, 
but the explanation is simple. 
We preprocess our Fortran 90/95 source to workaround the 31 character
limit specified in the language.
Check out Chapter <A HREF="#c:f90">11</A> for more details about this issue.
</DD></DL>
</BLOCKQUOTE><P>Again, we simply type make, and should end up with another <TT>libhello.la</TT>
file.</P><!--TOC subsection Writing the C Client-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.2.3  Writing the C Client</H3><!--SEC END --><P><A NAME="@default94"></A></P><P>Now, finally, we are ready to write a client. For this
exercise, we wrote our driver in C and built two executables; 
each one linking in one of the two implementation libraries.
We will put our driver in the <TT>minimal/</TT> directory
(which happens to be the parent directory of where the 
C++ and Fortran 90/95 implementations are, though this detail
is only relevant to makefile construction).
From our Fortran 90/95 subdirectory, we go up one and 
generate the client-side C bindings.</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>cd ..</B><BR>
% <B>babel –makefile -cC ../hello.sidl</B><BR>
</TT></BLOCKQUOTE><P>The “<TT>-cC</TT>” flag,
or its equivalent long-form “<TT>--client=C</TT>”, tells the 
Babel code generator to create only the C stub calling code, 
not the entire library implementation. </P><P>There are a few details worth noting here. The C bindings
generate function names by combining packages, classes, and method names 
with underscores (e. g. <TT>Hello_World_getMsg()</TT>. Whenever you 
see double underscores<A NAME="@default95"></A> in Babel generated symbols, they indicate something
built-in to (and sometimes specific to) the language binding. 
The <TT>_create()</TT> method is built-in to every instantiatable class 
defined in SIDL, triggering the creation of Babel internal data structures
as well as the constructor of the actual object implementation.</P><P>The code listing below shows a well crafted driver
with full error checking. To try this example, use your favorite text
editor to copy this text into a file named <TT>main.c</TT>.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    1 <B>#include</B> &lt;stdio.h&gt;
    2 <B>#include</B> "Hello_World.h"
    3 <B>#include</B> "sidl_BaseInterface.h"
    4 <B>#include</B> "sidl_Exception.h"
    5 <B>#include</B> "sidl_String.h"
    6 
    7 <B>int</B> main() {
    8   Hello_World h;
    9   sidl_BaseInterface ex;
   10   <B>char</B> * msg;
   11 
   12   <FONT COLOR="blue"><I>/* create instance of Hello World */</I></FONT>
   13   h = Hello_World__create(&amp;ex); SIDL_CHECK(ex);
   14   <B>if</B> ( h == NULL ) {
   15     fprintf(stderr,"%s:%d Failed to create an instance of Hello_World!\n",
   16             __FILE__,__LINE__);
   17     <B>return</B> 2;
   18   }
   19 
   20   <FONT COLOR="blue"><I>/* get the message from the object */</I></FONT>
   21   msg = Hello_World_getMsg(h, &amp;ex); SIDL_CHECK(ex);
   22   <B>if</B> ( msg == NULL ) {
   23     fprintf(stderr, "%s:%d Hello_World_getMsg() returned a NULL instead "
   24                     "of a string!\n",__FILE__,__LINE__);
   25     <B>return</B> 3;
   26   }
   27 
   28   <FONT COLOR="blue"><I>/* done with object so we can release it */</I></FONT>
   29   Hello_World_deleteRef(h,&amp;ex); SIDL_CHECK(ex);
   30 
   31   <FONT COLOR="blue"><I>/* print the string */</I></FONT>
   32   printf("%s\n",msg);
   33 
   34   <FONT COLOR="blue"><I>/* release the string */</I></FONT>
   35   sidl_String_free(msg);
   36 
   37   <B>return</B> 0;
   38 
   39  EXIT: <FONT COLOR="blue"><I>/* this is error handling code for any exceptions that were thrown */</I></FONT>
   40   {
   41     fprintf(stderr,"%s:%d: Error, exception caught\n",__FILE__,__LINE__);
   42     sidl_BaseInterface ignore = NULL;
   43     sidl_BaseException be = sidl_BaseException__cast(ex,&amp;ignore);
   44 
   45     msg = sidl_BaseException_getNote(be, &amp;ignore);
   46     fprintf(stderr,"%s\n",msg);
   47     sidl_String_free(msg);
   48 
   49     msg = sidl_BaseException_getTrace(be, &amp;ignore);
   50     fprintf(stderr,"%s\n",msg);
   51     sidl_String_free(msg);
   52 
   53     sidl_BaseException_deleteRef(be, &amp;ignore);
   54     SIDL_CLEAR(ex);
   55     <B>return</B> 1;
   56   }
   57 }</TD></TR>
</TABLE><P>As with other examples, we will go through this one
line by line. It is important to note that nowhere
in this file is any indication of what language the
Babel object is implemented in. When you see the makefile, 
we will show that this code can be linked against multiple
implementations in different languages.
</P><BLOCKQUOTE CLASS="quote">
<DL CLASS="description"><DT CLASS="dt-description">
<B>line 2:</B></DT><DD CLASS="dd-description"> This line includes the C stub for the <FONT COLOR=maroon><I><TT>Hello.World</TT></I></FONT> type.
</DD><DT CLASS="dt-description"><B>line 3:</B></DT><DD CLASS="dd-description"> We also include the C stub for the <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> type
which all classes and interfaces ultimately inherit from. In C, we often
use this type to hold the exception argument.
</DD><DT CLASS="dt-description"><B>line 4:</B></DT><DD CLASS="dd-description"> There is no <FONT COLOR=maroon><I><TT>sidl.Exception</TT></I></FONT> type. This header actually 
introduces some useful macros for dealing with exception handling in C.
</DD><DT CLASS="dt-description"><B>line 13:</B></DT><DD CLASS="dd-description"> This is where the object is <TT>_create()</TT>’ed. Note
that the creation may fail, so we use the <TT>SIDL_CHECK</TT> macro 
introduced from <TT>sidl_Exception.h</TT> to test the exception and 
goto <TT>EXIT</TT> (line 39), if necessary.
</DD><DT CLASS="dt-description"><B>line 21:</B></DT><DD CLASS="dd-description"> With a live reference to the object, we now try to 
get the message out of it. Note that we check if the exception is thrown
<EM>and</EM> if the string is <TT>NULL</TT>.
</DD><DT CLASS="dt-description"><B>line 29:</B></DT><DD CLASS="dd-description"> Once we have the message, we can dispose of our reference
to the object.
</DD><DT CLASS="dt-description"><B>line 32:</B></DT><DD CLASS="dd-description"> Print the message
</DD><DT CLASS="dt-description"><B>line 35:</B></DT><DD CLASS="dd-description"> Free the string. Return values have the same semantics as
out parameters which is the caller always recieves a reference count and
is obligied to dispose of it when done.
</DD><DT CLASS="dt-description"><B>line 37:</B></DT><DD CLASS="dd-description"> Normal termination. 
</DD><DT CLASS="dt-description"><B>lines 39–56:</B></DT><DD CLASS="dd-description"> This is exception handling code. Its hard to imagine
so many possibilities for failure in our little example, but it
is useful to see how exception classes can be cast to appropriate 
types (line 43), and be queried for both original error message and
the trace of the call stack from which it was thrown.
</DD><DT CLASS="dt-description"><B>line 42:</B></DT><DD CLASS="dd-description"> Note that Babel generated methods always throw exceptions, 
but in exception handling code, we often ignore them. Do not call
<TT>SIDL_CHECK</TT> after the <TT>EXIT</TT> as this can easily result
in an infinite loop.
</DD></DL>
</BLOCKQUOTE><P>Now we need to edit the GNUmakefile that builds the code in
this directory and links it with the C++ or Fortran 90/95 
implementations in the two subdirectories. This case requires
more editing that the previous two examples.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>make</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    1 include babel.make
    2 <FONT COLOR="blue"><I># please name the server library here</I></FONT>
    3 LIBNAME=client
    4 <FONT COLOR="blue"><I># please name the SIDL file here</I></FONT>
    5 SIDLFILE=../hello.sidl
    6 <FONT COLOR="blue"><I># extra include/compile flags </I></FONT>
    7 EXTRAFLAGS=
    8 <FONT COLOR="blue"><I># extra libraries that the implementation needs to link against</I></FONT>
    9 EXTRALIBS=
   10 <FONT COLOR="blue"><I># library version number</I></FONT>
   11 VERSION=0.1.1
   12 <FONT COLOR="blue"><I># PREFIX specifies the top of the installation directory</I></FONT>
   13 PREFIX=/usr/local
   14 <FONT COLOR="blue"><I># the default installation installs the .la and .scl (if any) into the</I></FONT>
   15 <FONT COLOR="blue"><I># LIBDIR</I></FONT>
   16 LIBDIR=$(PREFIX)/lib
   17 <FONT COLOR="blue"><I># the default installation installs the stub header and IOR header files</I></FONT>
   18 <FONT COLOR="blue"><I># in INCLDIR</I></FONT>
   19 INCLDIR=$(PREFIX)/include
   20 
   21 
   22 <FONT COLOR="blue"><I># most of the rest of the file should not require editing</I></FONT>
   23 
   24 ifeq ($(IMPLSRCS),)
   25   SCLFILE=
   26   BABELFLAG=--client=c
   27   MODFLAG=
   28 else
   29   SCLFILE=lib$(LIBNAME).scl
   30   BABELFLAG=--server=c
   31   MODFLAG=-module
   32 endif
   33 
   34 all : lib$(LIBNAME).la $(SCLFILE) runC2Cxx runC2F90
   35 
   36 CXX=`babel-config --query-var=CXX`
   37 runC2Cxx: lib$(LIBNAME).la libCxx/libhello.la main.lo
   38         babel-libtool --mode=link --tag=CXX $(CXX) -static main.lo \
   39             lib$(LIBNAME).la libCxx/libhello.la -o runC2Cxx
   40 
   41 runC2F90: lib$(LIBNAME).la libF90/libhello.la main.lo
   42         babel-libtool --mode=link --tag=CC $(CC) -static main.lo  \
   43             lib$(LIBNAME).la libF90/libhello.la -o runC2F90
   44 
   45 CC=`babel-config --query-var=CC`
   46 INCLUDES=`babel-config --includes`
   47 CFLAGS=`babel-config --flags-c`
   48 LIBS=`babel-config --libs-c-client`
   49 
   50 STUBOBJS=$(STUBSRCS:.c=.lo)
   51 IOROBJS=$(IORSRCS:.c=.lo)
   52 SKELOBJS=$(SKELSRCS:.c=.lo)
   53 IMPLOBJS=$(IMPLSRCS:.c=.lo)
   54 
   55 PUREBABELGEN=$(IORHDRS) $(IORSRCS) $(STUBSRCS) $(STUBHDRS) $(SKELSRCS)
   56 BABELGEN=$(IMPLHDRS) $(IMPLSRCS)
   57 
   58 $(IMPLOBJS) : $(STUBHDRS) $(IORHDRS) $(IMPLHDRS)
   59 
   60 lib$(LIBNAME).la : $(STUBOBJS) $(IOROBJS) $(IMPLOBJS) $(SKELOBJS)
   61         babel-libtool --mode=link --tag=CC $(CC) -o lib$(LIBNAME).la \
   62           -rpath $(LIBDIR) -release $(VERSION) \
   63           -no-undefined $(MODFLAG) \
   64           $(CFLAGS) $(EXTRAFLAGS) $^ $(LIBS) \
   65           $(EXTRALIBS)
   66 
   67 $(PUREBABELGEN) $(BABELGEN) : babel-stamp
   68         @if test -f <B>$@</B>; then \
   69             touch <B>$@</B>; \
   70         else \
   71             rm -f babel-stamp ; \
   72             $(<B>MAKE</B>) babel-stamp; \
   73         fi
   74 
   75 babel-stamp: $(SIDLFILE)
   76         @rm -f babel-temp
   77         @touch babel-temp
   78         babel $(BABELFLAG) $(SIDLFILE)
   79         @mv -f babel-temp <B>$@</B>
   80 
   81 lib$(LIBNAME).scl : $(IORSRCS)
   82 ifeq ($(IORSRCS),)
   83         echo "lib$(LIBNAME).scl is not needed for client-side C bindings."
   84 else
   85         -rm -f <B>$@</B>
   86         echo '&lt;?xml version="1.0" ?&gt;' &gt; <B>$@</B>
   87         echo '&lt;scl&gt;' &gt;&gt; <B>$@</B>
   88         if test `uname` = "Darwin"; then scope="global"; else scope="local"; \
   89            fi ; \
   90           echo '  &lt;library uri="'`pwd`/lib$(LIBNAME).la'" scope="'"$$scope"'" resolution="lazy" &gt;' &gt;&gt; <B>$@</B>
   91         grep __set_epv $^ /dev/null | awk 'BEGIN {FS=":"} { print $$1}' | sort -u | sed -e 's/_IOR.c//g' -e 's/_/./g' | awk ' { printf "    &lt;class name=\"%s\" desc=\"ior/impl\" /&gt;\n", $$1 }' &gt;&gt;<B>$@</B>
   92         echo "  &lt;/library&gt;" &gt;&gt;<B>$@</B>
   93         echo "&lt;/scl&gt;" &gt;&gt;<B>$@</B>
   94 endif
   95 
   96 .SUFFIXES: .lo
   97 
   98 .c.lo:
   99         babel-libtool --mode=compile --tag=CC $(CC) $(INCLUDES) $(CFLAGS) $(EXTRAFLAGS) -c -o <B>$@</B> $&lt;
  100 
  101 clean :
  102         -rm -f $(PUREBABELGEN) babel-temp babel-stamp *.o *.lo
  103 
  104 realclean : clean
  105         -rm -f lib$(LIBNAME).la lib$(LIBNAME).scl
  106         -rm -rf .libs
  107 
  108 install : install-libs install-headers install-scl
  109 
  110 
  111 install-libs : lib$(LIBNAME).la
  112         -mkdir -p $(LIBDIR)
  113         babel-libtool --mode=install install -c lib$(LIBNAME).la \
  114           $(LIBDIR)/lib$(LIBNAME).la
  115 
  116 install-scl : $(SCLFILE)
  117 ifneq ($(IORSRCS),)
  118         -rm -f $(LIBDIR)/lib$(LIBNAME).scl
  119         -mkdir -p $(LIBDIR)
  120         echo '&lt;?xml version="1.0" ?&gt;' &gt; $(LIBDIR)/lib$(LIBNAME).scl
  121         echo '&lt;scl&gt;' &gt;&gt; $(LIBDIR)/lib$(LIBNAME).scl
  122         if test `uname` = "Darwin"; then scope="global"; else scope="local"; \
  123            fi ; \
  124           echo '  &lt;library uri="'$(LIBDIR)/lib$(LIBNAME).la'" scope="'"$$scope"'" resolution="lazy" &gt;' &gt;&gt; $(LIBDIR)/lib$(LIBNAME).scl
  125         grep __set_epv $^ /dev/null | awk 'BEGIN {FS=":"} { print $$1}' | sort -u | sed -e 's/_IOR.c//g' -e 's/_/./g' | awk ' { printf "    &lt;class name=\"%s\" desc=\"ior/impl\" /&gt;\n", $$1 }' &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  126         echo "  &lt;/library&gt;" &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  127         echo "&lt;/scl&gt;" &gt;&gt;$(LIBDIR)/lib$(LIBNAME).scl
  128 endif
  129 
  130 install-headers : $(IORHDRS) $(STUBHDRS)
  131         -mkdir -p $(INCLDIR)
  132         for i in $^ ; do \
  133           babel-libtool --mode=install cp $$i $(INCLDIR)/$$i ; \
  134         done
  135 
  136 .PHONY: all clean realclean install install-libs install-headers install-scl</TD></TR>
</TABLE><BLOCKQUOTE CLASS="quote">
<DL CLASS="description"><DT CLASS="dt-description">
<B>line 1:</B></DT><DD CLASS="dd-description"> Again we include the Babel-generated makefile fragment.
Again we see that its contents depend on the language being generated.
</DD><DT CLASS="dt-description"><B>line 3:</B></DT><DD CLASS="dd-description"> Here we edit the name to be <TT>client</TT>.
</DD><DT CLASS="dt-description"><B>lines 5–19:</B></DT><DD CLASS="dd-description"> These have the same meanings as in the examples
above.
</DD><DT CLASS="dt-description"><B>lines 34–43:</B></DT><DD CLASS="dd-description"> Here we must modify the <TT>all</TT> target
definition and add lines to link <TT>runC2Cxx</TT> and
<TT>runC2F90</TT>. Note that when linking C to C++, we must use the
C++ compiler.
</DD></DL>
</BLOCKQUOTE><P>At last, we can make the two executables and run them.
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>make all</B><BR>
% <B>./runC2Cxx</B><BR>
Hello from C++!<BR>
% <B>./runC2F90</B><BR>
Hello from Fortran 90/95!
</TT></BLOCKQUOTE><!--TOC section Portable Makefiles: using <TT>babel-config</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">5.3</A>  Portable Makefiles: using <TT>babel-config</TT></H2><!--SEC END --><P><A NAME="sec:static-miniconfig"></A></P><P>Since Babelized software must be built the same way
that Babel itself was configured, it seems reasonable
to lean on <TT>babel-config</TT> quite heavily.
By now you are probably wondering how many 
secrets <TT>babel-config</TT> holds and can provide on request.
The simplest way to find out is to ask it. (Though you
may get a slightly different result than what is shown
here depending on the version of Babel.)
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel-config --dump-vars | wc -l</B><BR>
128
</TT></BLOCKQUOTE><P><TT>babel-config</TT> can provide a wealth of information determined by
Babel during its configuration and installation. Even if you do not
use the GNUmakefile’s that Babel can generate, you will likely end up
using <TT>babel-config</TT> to determine important information about
Babel’s installation</P><!--TOC section Final Remarks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">5.4</A>  Final Remarks</H2><!--SEC END --><P>
Congratulations! You are now ready to develop a parallel 
scalable linear solver package. </P><P>The preceding process may seem to be the most complicated way to write
the world’s simplest program but, of course, the same process will
also work for significantly more complex applications. “Hello
World” is small enough to experiment with in the language of your
choice. Parallel, multithreaded, scientific simulation codes are
another matter entirely.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note5" HREF="#text5">1</A></DT><DD CLASS="dd-thefootnotes">For information on additional command line options, 
refer to Section <A HREF="#s:basics_commandline">4.2</A>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">2</A></DT><DD CLASS="dd-thefootnotes">You can also try the “<TT>--help</TT>” flag 
to list all of the Babel command-line options.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">3</A></DT><DD CLASS="dd-thefootnotes">Note: dots are
converted to underscores for file naming.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">4</A></DT><DD CLASS="dd-thefootnotes">A
kind of precompiled header.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter SIDL Basics-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc21">Chapter 6</A>  SIDL Basics</H1><!--SEC END --><P><A NAME="c:basics"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">6.1</A>  Introduction</H2><!--SEC END --><P>
This chapter describes the basics of the Scientific Interface Definition 
Language (SIDL). The goal is to provide sufficient information to enable 
most library and component developers to begin using SIDL to wrap 
their software. It begins with an overview of SIDL files followed by an 
introduction to the fundamental data types. More complex topics such as
the object arrays, exceptions, objects, and the XML repository are then 
addressed.</P><!--TOC section SIDL Files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">6.2</A>  SIDL Files</H2><!--SEC END --><P><A NAME="s:basics_sidl"></A><A NAME="@default96"></A></P><P>SIDL files are human-readable, language- and platform- independent
interface specifications for objects and their methods. SIDL allows
you to specify classes, interfaces, and the methods therein. All
methods defined in SIDL are public, since the developer is writing
them as part of an interface description. Any data you wish a SIDL
object to hold is not declared in the SIDL file, and is
private.<A NAME="@default97"></A> Data should be placed in the implementation
skeleton files, and cannot be publicly exported.</P><P>Babel reads the SIDL files to generate the appropriate programming language 
bindings. These bindings, in the form of stub, intermediate object 
representation (IOR), and implementation skeleton sources, provide the basis 
for language interoperable software using Babel. In addition, SIDL files
are used to populate the XML symbol repository that can serve as an 
alternate source of interface specifications during the generation of 
programming language bindings.</P><!--TOC subsection Basic Structure-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Basic Structure</H3><!--SEC END --><P><A NAME="@default98"></A></P><P>The basic structure of a SIDL file is illustrated below.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> &lt;identifier&gt; [<B>version</B> &lt;<B>version</B>&gt;]
{
  <B>interface</B> &lt;identifier&gt; [ &lt;inheritance&gt; ]
  {
    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]

      .
      .
      .


    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]
  }


  <B>class</B> &lt;identifier&gt; [ &lt;inheritance&gt; ]
  {
    [&lt;type&gt;] &lt;identifier&gt; (&lt;parameters&gt;) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]
      .
      .
      .


    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]
  }


  <B>package</B> &lt;identifier&gt; [<B>version</B> &lt;<B>version</B>&gt;]
  {
      .
      .
      .
  }
}</I></FONT></TD></TR>
</TABLE><P>The main elements are <EM>packages</EM>, <EM>interfaces</EM>, <EM>classes</EM>, 
<EM>methods</EM>, <EM>types</EM>, and <EM>contract clauses</EM>. For a more 
detailed description, refer to Appendix <A HREF="#c:grammar">B</A>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Packages</B></DT><DD CLASS="dd-description"><A NAME="@default99"></A><A NAME="@default100"></A>provide a mechanism for specifying name space hierarchies. 
That is, it enables grouping sets of interface and/or class descriptions as 
well as nested packages. Identified by the <EM>package</EM> keyword, packages 
have a <EM>scoped</EM> name that consists of one or more identifiers, or name 
strings, separated by a period (“.”). A package can contain multiple 
interfaces, classes and nested packages. By default, packages are now 
re-entrant<A NAME="@default101"></A>. In order to make them non-re-entrant, they must be declared as
<FONT COLOR=maroon><I><TT>final</TT></I></FONT>.<A NAME="@default102"></A><A NAME="@default103"></A></DD><DT CLASS="dt-description"><B>Interfaces</B></DT><DD CLASS="dd-description"> <A NAME="@default104"></A><A NAME="@default105"></A>define a set of methods that a caller can invoke on an 
object of a class that implements the methods. Multiple inheritance of 
interfaces is supported, which means an interface or a class can be derived from one 
or more interfaces. </DD><DT CLASS="dt-description"><B>Classes</B></DT><DD CLASS="dd-description"> <A NAME="@default106"></A><A NAME="@default107"></A> also define a set of methods that a caller can invoke on an 
object. A class can extend only one other class but it can implement multiple
interfaces. So we have single inheritance of classes and multiple inheritance 
of interfaces.</DD><DT CLASS="dt-description"><B>Methods</B></DT><DD CLASS="dd-description"> <A NAME="@default108"></A><A NAME="@default109"></A> define services
that are available for invocation by a caller. The signature of the
method consists of the return <EM>type</EM>, identifier, arguments, and
exceptions. Each parameter has a <EM>type</EM> and a
<EM>mode</EM><A NAME="@default110"></A>. The <EM>mode</EM> indicates whether the value
of the specified <EM>type</EM> is passed from caller to callee
(<EM>in</EM><A NAME="@default111"></A>), from callee to caller (<EM>out</EM><A NAME="@default112"></A>),
or both (<EM>inout</EM><A NAME="@default113"></A>). All methods are implicitly
capable of throwing a <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT> exception.
<A NAME="@default114"></A><A NAME="@default115"></A>
A <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT> is used to indicate an error
in the Babel generated code or potentially a network exception. Each
additional exception that a method can <EM>throw</EM><A NAME="@default116"></A> when
it detects an error must be listed. These exceptions can be either
interfaces or classes so long as they inherit
from<A NAME="@default117"></A>
<FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT><A NAME="@default118"></A><A NAME="@default119"></A>.
For a default implementation of the exception interfaces, the
exception classes should extend
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT><A NAME="@default120"></A><A NAME="@default121"></A>.
Methods and parameter passing modes are discussed in greater detail in
Section <A HREF="#sec:basics:objects:methods">6.7</A>.</DD><DT CLASS="dt-description"><B>Types</B></DT><DD CLASS="dd-description"> <A NAME="@default122"></A><A NAME="@default123"></A> are used to constrain the the values of parameters, exceptions, 
and return values associated with methods. SIDL supports basic types such as
<FONT COLOR=maroon><I><TT>int</TT></I></FONT>, <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, and <FONT COLOR=maroon><I><TT>long</TT></I></FONT> as well as strings, complex
numbers, classes, and arrays.</DD><DT CLASS="dt-description"><B>Contract clauses</B></DT><DD CLASS="dd-description"> 
<A NAME="@default124"></A><A NAME="@default125"></A> are used 
to define properties that must hold before and/or after method invocation.</DD></DL><!--TOC subsection Comments and Doc-Comments-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Comments and Doc-Comments</H3><!--SEC END --><P><A NAME="@default126"></A><A NAME="@default127"></A></P><P>SIDL has the same commenting style as C++/Java
and even has a special documentation comment
(so called <EM>doc-comment</EM>) similar to those
used in Javadoc. 
One can embed comments anywhere in their SIDL file. 
Documentation comments should immediately precede
the class, interface, or method with which they are associated.
Babel replicates documentation comments in the files it generates.
It does not replicate plain comments.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/*
 *  1. This is a multi-line comment.
 *
 */

//  2. This comment fits entirely on a single line.

/*  3. This comment can fill less than a line. */

/** 4. This is a documentation comment. */

/**
 *  5. Documentation comments can span
 *     multiple lines without the beginning
 *     space-asterisk-space combinations
 *     getting in the way.
 */</I></FONT></TD></TR>
</TABLE><P>Consider the above SIDL file fragment. 
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
This comment is a regular multi-line comment that is
delimited by a slash-star , star-slash 
	(“<TT>/*</TT>”, “<TT>*/</TT>”) pair.
</LI><LI CLASS="li-enumerate">This is a single-line comment that starts 
	with a double slash “<TT>//</TT>” and continues 
	to the end of the line.
</LI><LI CLASS="li-enumerate">This comment is the same as # 1 except that it
	is completely contained on a single line. It can
	be embedded in the middle of a line anywhere 
	a space naturally occurs.
</LI><LI CLASS="li-enumerate">This is a documentation comment. In keeping with
	Javadoc, Doc++, and other tools, it is delimited by
	slash-star-star and star-slash 
	(“<TT>/**</TT>”, “<TT>*/</TT>”) combinations.
	Documentation comments are important because their
	contents are preserved by Babel in the corresponding
	generated files. Doc-comments must directly
	precede the interface, class, or method that they
	document.
</LI><LI CLASS="li-enumerate">This is a multi-line variant of a doc-comment. Note
	that initial asterisks on a line are assumed to
	be for human readers only and are discarded by
	Babel when it reads in the text. The multi-line
	doc-comment is the preferred way of documenting
	SIDL.
</LI></OL><!--TOC subsection Packages and Versions-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Packages and Versions</H3><!--SEC END --><P><A NAME="@default128"></A><A NAME="@default129"></A><A NAME="@default130"></A></P><P>SIDL has both a packaging and versioning mechanism built in. 
Packages are essentially named scopes, serving a similar function
as Java packages or C++ namespaces. Versions
are decimal separated integer values where it is assumed
larger numbers imply more recent versions. All classes 
and interfaces in that package get that same 
version number. If subpackages are specified, they can have their own version 
number assigned. If a package is declared without a version, it can only 
contain other packages. If a package declares interfaces or classes,
a version number for that package is required.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg {

}</I></FONT></TD></TR>
</TABLE><P>
This SIDL file represents the minimum needed for each and every SIDL
file. The package statement defines a scope where all
classes within the package must reside. Since no version clause is included, 
the version number defaults to 0.</P><P>Packages can be nested.<A NAME="@default131"></A> This is shown in the example below. The version 
numbers assigned to all the types is determined by the package, or subpackage, 
in which it resides. In the design of the SIDL file, remember that
some languages get very long function names from excessively nested packages
or excessively long package names.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg <B>version</B> 1.0 {

  <B>package</B> thisIsAReallyLongPackageName {
  }

  <B>package</B> this <B>version</B> 0.6 {
    <B>package</B> is {
      <B>package</B> a {
        <B>package</B> really {
          <B>package</B> deeply <B>version</B> 0.4 {
            <B>package</B> nested {
              <B>package</B> packageName <B>version</B> 0.1 {
              }
            }
          }
        }
      }
    }
  }
}</I></FONT></TD></TR>
</TABLE><P>In SIDL you can use as much or as little of a type name as necessary 
to uniquely identify it. If absolute specificity is required, a leading
dot can be used to identify the global (top) package.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"> <FONT COLOR=maroon><I>   1 <B>package</B> foo {
    2   <B>class</B> A {}
    3   <B>package</B> foo {
    4     <B>class</B> A {
    5       foo.A bar();  //which foo.A?
    6       .foo.A wuux(); //first foo.A.
    7       .foo.foo.A wuxx(); //second foo.A.
    8     }
    9   }
   10 }</I></FONT></TD></TR>
</TABLE><P>External types can be expressed in one of two ways. The fully
scoped<A NAME="@default132"></A>
external type can be used anywhere in the class description. Alternatively, 
an <FONT COLOR=maroon><I><TT>import</TT></I></FONT><A NAME="@default133"></A><A NAME="@default134"></A> statement can be used to put the type in the local
package-space. <FONT COLOR=maroon><I><TT>import</TT></I></FONT> statements can request a specific
version of the package, if that version is not found, Babel will print
an error. If no version is specified, Babel will take whatever
version it is being run on. Babel can not be run on two versions of
a given package at the same time, even if you only import or require
one of them. </P><P>Another way to restrict the package version you use is the
<FONT COLOR=maroon><I><TT>restrict</TT></I></FONT><A NAME="@default135"></A><A NAME="@default136"></A> statement.
<FONT COLOR=maroon><I><TT>restrict</TT></I></FONT> does not import the package, but if you do later
import the package or refer to something in that package by it’s fully
scoped name, Babel will guarantee that the correct version of the
package will be used. Also note that all restrict statements must
come before the first import statement.</P><P>Below is a sample SIDL file, that should help bring all of these concepts
together.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>require</B> pkgC <B>version</B> 2.0; // restrict pkgC to version 2.0, not imported

<B>import</B> pkgA <B>version</B> 1.0; // restrict pkgA version 1.0. Includes class pkgA.A

<B>import</B> pkgB;      // import pkgB regaurdless of version.  Includes class pkgB.B

<B>package</B> mypkg <B>version</B> 2.0 {
  <B>class</B> foo {
    setA( A ); // imported from pkgA, must be pkgA.A-v1.0
    setB( B ); // imported from pkgB, must be pkgB.B, no version restriction
    setC( pkgC.C ); // must be pkgC.C-v2.0
    setD( pkgD.D ); // no version restriction
  }
}</I></FONT></TD></TR>
</TABLE><!--TOC subsection Re-entrant Packages-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Re-entrant Packages</H3><!--SEC END --><P><A NAME="@default137"></A><A NAME="@default138"></A></P><P>By default, SIDL packages are re-entrant. This means that Babel allows sub-packages to be 
broken into separate files, but you’d still have to run Babel on 
all the files at the same time. Here’s how it works.</P><P>First define the outermost package in a file.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg <B>version</B> 2.0 {

}</I></FONT></TD></TR>
</TABLE><P>Then define a sub-package in a second file.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg.subpkg <B>version</B> 2.0 {

}</I></FONT></TD></TR>
</TABLE><P>Note that both files begin with the identical version statement.
Now as long as you run Babel on both SIDL files at the same time
(with the outermost one first on the commandline), all is fine.</P><P>This works because the package statement takes a scoped identifier
as an argument. As long as Babel knows that a package <FONT COLOR=maroon><I><TT>mypkg</TT></I></FONT>
exists, it can handle a new package called <FONT COLOR=maroon><I><TT>subpkg</TT></I></FONT>. (This would
also work if <FONT COLOR=maroon><I><TT>subpkg</TT></I></FONT> were a class. Version 
statements require an identifier for the outermost package. Since
packages cannot have dots “.” in their names, the only dots in 
version statements should appear at the numbers, not the package names.</P><P>Running the second file without the first will (and should) generate
an error since the enclosing package was not declared. Re-entrance 
should be used judiciously. This feature may be disabled by labeling
a given package as <FONT COLOR=maroon><I><TT>final</TT></I></FONT>.</P><!--TOC subsection The From Clause-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The From Clause</H3><!--SEC END --><P><A NAME="@default139"></A></P><P>The from clause is a special SIDL statement that allows an implementor
of multiple interfaces to add or rename the extensions of conflicting
methods from interfaces. However, only method extensions
can be changed, and the methods must have different signatures. For
example, one can change the name of conflicting methods from two interfaces:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>interface</B> A {
  <B>void</B> set(<B>in int</B> i);
}
<B>interface</B> B{
  <B>void</B> set(<B>in float</B> i);
}
<B>class</B> C <B>implements</B> A, B {
  <B>void</B> set[Int](<B>in int</B> i) from A.set;
  <B>void</B> set[Float](<B>in float</B> i) from B.set;
}</I></FONT></TD></TR>
</TABLE><P>Or change the name of an interface method that conflicts with your
inherited class methods:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>interface</B> A {
  <B>void</B> set(<B>in int</B> i);
}
<B>class</B> B {
  <B>void</B> set(<B>in float</B> i);
}
<B>class</B> C <B>extends</B> B <B>implements</B> A  {
  <B>void</B> set[Int](<B>in int</B> i) from A.set;
  <B>void</B> set(<B>in float</B> i); //Cannot use the from clause on class methods
}</I></FONT></TD></TR>
</TABLE><P>But it doesn’t work for methods that have the same signature:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/* X THIS WILL NOT COMPILE X */

<B>interface</B> A {
  <B>void</B> set(<B>in int</B> i);
}
<B>interface</B> B{
  <B>void</B> set(<B>in int</B> i);
}
<B>class</B> C <B>implements</B> A, B {
  <B>void</B> set[A](<B>in int</B> i) from A.set; //ERROR
  <B>void</B> set[B](<B>in int</B> i) from B.set; //signature conflict
}

/* X THIS WILL NOT COMPILE X */</I></FONT></TD></TR>
</TABLE><!--TOC section Fundamental Types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">6.3</A>  Fundamental Types</H2><!--SEC END --><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 6.1: SIDL Types</TD></TR>
</TABLE></DIV><A NAME="tbl:basics:fundamental_types"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><B>SIDL TYPE</B></TD><TD ALIGN=right NOWRAP><B>SIZE (BITS)</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=right NOWRAP>1</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=right NOWRAP>8</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=right NOWRAP>32</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=right NOWRAP>32</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=right NOWRAP>128</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=right NOWRAP>32</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>array&lt;Type,Dim&gt;</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>array&lt; &gt;</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>rarray&lt;Type,Dim&gt;(index variables)</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Table <A HREF="#tbl:basics:fundamental_types">6.1</A><A NAME="@default140"></A><A NAME="@default141"></A> briefly 
shows the different data types that are supported 
in Babel. Refer to each chapter for the language specific bindings
for each SIDL type. The “S” in SIDL stands for 
“Scientific.” This emphasis is reflected in the
fundamental support for complex numbers (<FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>
and <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>) and dynamic multidimensional arrays
(<FONT COLOR=maroon><I><TT>array&lt;Type,Dim&gt;</TT></I></FONT>).</P><P>C++ developers looking at the SIDL syntax for arrays, 
might think that SIDL is a templated IDL, but this
is not so. Although the syntax for SIDL arrays looks
like a template, it is specific only to the array type.
Developers cannot create templated classes or methods
in SIDL.
</P><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
Although C++ templates are a very powerful programming 
mechanism, they apply only to C++. For Babel to implement
similar hashing routines, method names in languages other
than C++ would become prohibitively (thousands of characters) 
long. Moreover, this C++ template hashing mechanism is
compiler specific so while C++ is very good at hiding
the expanded template names (unless there is an error to report)
we would have to add babel C++ bindings on a compiler by compiler basis.
</EM></BLOCKQUOTE><P>Discussion of the various types is broken up into sections.
Numeric types such as <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, <FONT COLOR=maroon><I><TT>char</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>long</TT></I></FONT>, <FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>, <FONT COLOR=maroon><I><TT>string</TT></I></FONT>s, as well as information about
enumerated types and the opaque type are all covered in this Subsection <A HREF="#ssec:basics:fundamental:numbers">6.3</A>.</P><P>Information about extended types such as
Interfaces and Classes along with the methods they contain are described in Section <A HREF="#sec:basics:objects">6.7</A>, and Section <A HREF="#s:arrays">6.4</A> covers Array.</P><!--TOC subsection Numeric Types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Numeric Types</H3><!--SEC END --><P><A NAME="ssec:basics:fundamental:numbers"></A>
<A NAME="@default142"></A><A NAME="@default143"></A></P><P>The SIDL types <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, <FONT COLOR=maroon><I><TT>char</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>long</TT></I></FONT>, <FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>, 
and <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT> are the smallest and easiest data
types to transfer between languages transparently.
They all have a fixed size and can just as 
reasonably be copied as passed by reference.</P><P>Most languages natively support all of these data types
(though perhaps less so with complex types). There are 
a few notable exceptions that may be of interest. </P><P>ANSI C does not define the size of 
<TT>int</TT> and <TT>long</TT>, only that the latter be at least
as big as the former. As of the C99 standard, there
are types <TT>int32_t</TT> and <TT>int64_t</TT> that
are signed integers that explicitly support a fixed number of bits. 
Most compilers already have these symbols defined appropriately
in <TT>sys/types.h</TT> (pre C99 standard) or <TT>inttypes.h</TT>.</P><P>Python defines its <TT>int</TT> and <TT>long</TT> to be equivalent
to C, and therefore suffers the same platform dependent 
integer size problem with less flexibility for a workaround.
It is not uncommon for regression tests involving longs and 
Python to fail on certain platforms. Python 2.2 has a patch to make
SIDL long support better.</P><!--TOC subsection Strings-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Strings</H3><!--SEC END --><P><A NAME="ssec:basics:fundamental:strings"></A>
<A NAME="@default144"></A><A NAME="@default145"></A></P><P>Strings are an interesting datatype because they are fundamental
to many pieces of software, but represented differently by
practically every single programming language. Strings
can have a high overhead to support language interoperability 
because there is invariably so much copying involved.</P><P><SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> and Fortran 90/95 support for strings is limited to a predetermined 
buffer size. Since the results of a string assignment into
that buffer in Fortran does not propagate the length of the
string, trailing whitespace is always trimmed for any string
begin passed out from a Fortran implementation.</P><!--TOC subsection Opaque-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Opaque</H3><!--SEC END --><P><A NAME="ssec:basics:fundamental:opaque"></A>
<A NAME="@default146"></A><A NAME="@default147"></A></P><P>The <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> type is dangerous and rarely useful. However, there
are particular times when an opaque type is the only way to solve a
problem; for example, it is one of the few portable ways to implement
an object with state in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. When a SIDL file uses an
<FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> type, Babel guarantees only bits will be relayed exactly
between caller and callee. If there is a need to pass more
information than an opaque provides, than the developer can simply
pass a pointer to that information.</P><P>Use of a <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> carries a heavy penalty. Method calls with
<FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> types in the argument list (or return type) are
restricted to in-process calls only.
</P><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
Since <FONT COLOR=maroon><TT><I>opaque</I></TT></FONT> is typically used for a pointer to memory, 
this sequence of bits has no meaning outside of its own
process space.
</EM></BLOCKQUOTE><!--TOC subsection Enumerations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Enumerations</H3><!--SEC END --><P><A NAME="ssec:basics:fundamental:enums"></A>
<A NAME="@default148"></A><A NAME="@default149"></A></P><P>An enumeration is typically used in programming
languages to specify a limited range of states
to enable dealing with them by names instead of hard-coded values.
For language interoperability purposes — especially to 
support this concept on languages with no native support — 
we’ve had to create specific rules for the integer values
associated with enumerated types.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> enumSample <B>version</B> 1.0 {

  // undefined integer values
  <B>enum</B> color {
    red, orange, yellow, green, blue, violet
  };

  // completely defined integer values
  <B>enum</B> car {
    /**
     * A sports car.
     */
    porsche = 911,
    /**
     * A family car.
     */
    ford = 150,
    /**
     * A luxury car.
     */
    mercedes = 550
  };

  // partially defined integer value
  <B>enum</B> number {
    notZero,    // This non-doc comment will not be retained.
    notOne,
    zero=0,
    one=1,
    negOne=-1,
    notNeg
  };
}</I></FONT></TD></TR>
</TABLE><P>Above is a sample of enumerations taken directly from 
our regression tests. It defines a package <FONT COLOR=maroon><I><TT>enumSample</TT></I></FONT>
that contains three enumerations. C/C++ developers
will find the syntax very familiar.
When defining an enumeration, the actual integer values
assigned can be undefined, completely defined, or
partially defined.</P><P>SIDL defines the following rules for adding integer
values to enumerated states that don’t have a value
explicitly defined.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Error if two states are explicitly assigned the same value
</LI><LI CLASS="li-enumerate">Assign all explicit values to their named state.
</LI><LI CLASS="li-enumerate">Assign smallest unused non-negative value to first 
	unassigned state in enumeration.
</LI><LI CLASS="li-enumerate">Repeat 3 until all states have assigned (unique) values.
</LI></OL><P>To verify the application of these rules, 
the <FONT COLOR=maroon><I><TT>enumSample.number</TT></I></FONT> enumeration
will have the following values assigned to
its states: <FONT COLOR=maroon><I><TT>NotZero</TT></I></FONT>=2, <FONT COLOR=maroon><I><TT>NotOne</TT></I></FONT>=3,
<FONT COLOR=maroon><I><TT>zero</TT></I></FONT>=0; <FONT COLOR=maroon><I><TT>one</TT></I></FONT>=1, <FONT COLOR=maroon><I><TT>negOne</TT></I></FONT>=-1,
<FONT COLOR=maroon><I><TT>notNeg</TT></I></FONT>=4.
</P><!--TOC section Arrays-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">6.4</A>  Arrays</H2><!--SEC END --><P><A NAME="s:arrays"></A></P><P>Support for multi-dimensional arrays is one of the features that 
separates SIDL/Babel language interoperability from Microsoft’s
COM/DCOM<A NAME="@default150"></A> and the OMG’s CORBA<A NAME="@default151"></A>. 
SIDL supports two kinds of arrays: normal and raw.
Normal SIDL arrays provide all the features of a normal SIDL type, while
raw SIDL arrays, called r-arrays, exist to provide more 
efficient, lower level access to numeric arrays.
For example, a one-dimensional r-array in C appears as a
double pointer and a length parameter. To highlight the contrast,
normal SIDL arrays appear as a struct in C, a template class in C++,
an 64-bit integer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, and a derived type in Fortran 90/95.</P><P>The SIDL array API and data structure can be used in client code to
prepare arguments for passing to a SIDL method. It is used inside
the implementation code to get data and meta-data from incoming
array arguments.
The remainder of this section will focus on the C API for arrays
because it is the basis for the other language APIs.</P><!--TOC subsection SIDL Arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->SIDL Arrays</H3><!--SEC END --><P><A NAME="ss:arrays"></A>
<A NAME="@default152"></A><A NAME="@default153"></A></P><P>Normal SIDL arrays provide all the features of a normal SIDL type.
They are meant to generalize the array types built into many languages.
They are not parallel array classes or particularly sophisticated, but 
are very, very general. It is expected that developers requiring 
parallel array libraries build them on top of the SIDL array type. </P><P>Characteristics of normal SIDL arrays are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
reference counted;
</LI><LI CLASS="li-itemize">can be passed as <TT>in</TT>, <TT>inout</TT>, or <TT>out</TT> parameters;
</LI><LI CLASS="li-itemize">can be returned from a method;
</LI><LI CLASS="li-itemize">can be allocated or borrowed;
</LI><LI CLASS="li-itemize">can be set to <TT>NULL</TT>; and
</LI><LI CLASS="li-itemize">can be “row-major”<A NAME="@default154"></A> or<A NAME="@default155"></A> 
“column-major”<A NAME="@default156"></A>.
</LI></UL><!--TOC subsubsection Generic Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Generic Arrays</H4><!--SEC END --><P><A NAME="sss:basics:genericarrays"></A>
<A NAME="@default157"></A><A NAME="@default158"></A></P><P>The design of the (normal) array data structure enables the concept of a
generic array, an array whose data type and dimension are
unspecified. In SIDL, a generic array is indicated with the type
<FONT COLOR=maroon><I><TT>array&lt; &gt;</TT></I></FONT>. There is no type or dimension information
between the &lt; and &gt;. </P><P>Generic arrays are useful for making interfaces that are very flexible
without requiring numerous methods to be defined. For example, if you
were writing an interface to serialize an array, you could write one
method <FONT COLOR=maroon><I><TT>void serialize(in array&lt; &gt; array);</TT></I></FONT> to handle an
array of any type or dimension. Without generic arrays, you would have
to define 77 different <FONT COLOR=maroon><I><TT>serialize</TT></I></FONT> methods to handle each
possible array type and dimension.</P><P>In C, you can use the macro API to determine the dimension, bounds on
each dimension and stride for a generic array. All other languages
except Python provide a function API to determine the same information
for a generic array. </P><P>Starting with Babel 1.1.0, Babel’s Python binding now uses either the
Python NumPy or Numeric Python array API. This switch in Babel follows
a switch in the Python community where the Python community has
deprecated Numeric Python and appointed NumPy as its successor. If you
need examples about how to write code that can work with either Python
array API look at Babel’s array regression tests, arrays and ordering.</P><P>The function API for generic arrays includes the following methods:
<TT>addRef</TT>, <TT>smartCopy</TT>, <TT>deleteRef</TT>, <TT>dimen</TT>,
<TT>lower</TT>, <TT>upper</TT>, <TT>length</TT>, <TT>stride</TT>,
<TT>isColumnOrder</TT>, <TT>isRowOrder</TT>, and <TT>type</TT>. With the
exception of <TT>type</TT>, these methods have all been presented
above. The name of the method has the type left
empty. Where the name for <TT>addRef</TT> in C on a double array is
<TT>sidl_double_array_addRef</TT>, its name is
<TT>sidl__array_addRef</TT> for a generic array. Note, there are two
underscores between <TT>sidl</TT> and <TT>array</TT> in the generic array
case.</P><P>The <TT>type</TT> method is defined as follows in the case of C.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/**
 * Return an integer indicating the type of elements held by the
 * array. Zero is returned if array is NULL.
 */</I></FONT>
int32_t
sidl__array_type(<B>const struct</B> sidl__array* array);</TD></TR>
</TABLE><P>
It returns a value that indicates what the underlying type of the
array actually is. The return value is either zero or one of the
values in <TT>sidl_array_type</TT>.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>enum</B> sidl_array_type {
  <FONT COLOR="blue"><I>/* these values must match values used in F77 &amp; F90 too */</I></FONT>
  sidl_bool_array      = 1,
  sidl_char_array      = 2,
  sidl_dcomplex_array  = 3,
  sidl_double_array    = 4,
  sidl_fcomplex_array  = 5,
  sidl_float_array     = 6,
  sidl_int_array       = 7,
  sidl_long_array      = 8,
  sidl_opaque_array    = 9,
  sidl_string_array    = 10,
  sidl_interface_array = 11 <FONT COLOR="blue"><I>/* an array of sidl.BaseInterface's */</I></FONT>
};</TD></TR>
</TABLE><P>
Once you’ve discovered the underlying type of the generic array, you
can safely cast its pointer to the actual pointer type (in languages
like C). Each language binding provides a way to cast generic array
pointers to specific types and vice versa.</P><P>In the case of a <TT>sidl_interface_array</TT>, you can case the array
to an array of <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> interface references. Your
code should treat it as such. You can downcast individual elements of
the array as you need. Your code should consider the possibility that
downcasting may fail. Babel can only guarantee that the elements of
the array are <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>’s.</P><!--TOC subsection R-arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->R-arrays</H3><!--SEC END --><P><A NAME="ss:r-arrays"></A>
<A NAME="@default159"></A><A NAME="@default160"></A><A NAME="@default161"></A></P><P>Since SIDL was designed to serve the high performance computing
community, both SIDL object developers and clients may require direct
access to the underlying array data structure for optimization
purposes, such as instruction pipelining or cache performance. Hence,
support for raw SIDL arrays was introduced for low level access to
numeric arrays. At present, they are available in C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
Fortran 90/95 and Fortran 2003/2008. In all other languages R-arrays are
implemented as regular SIDL arrays with no particular performance
advantage.</P><P>Unlike normal SIDL arrays, the use of r-arrays are more restricted.
More specifically, they have the following constraints:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Only the <TT>in</TT> and <TT>inout</TT> parameter modes are
available for r-arrays. R-arrays cannot be used as return values or as 
<TT>out</TT> parameters.
</LI><LI CLASS="li-enumerate">R-arrays must be contiguous in memory, and multi-dimensional
arrays must be in column-major order (i. e., Fortran order).
</LI><LI CLASS="li-enumerate"><TT>NULL</TT> is not an allowable value for an r-array parameter.
</LI><LI CLASS="li-enumerate">The semantics for <TT>inout</TT> r-array parameters are
different. The implementation is not allowed to deallocate the array
and return a new r-array. <TT>inout</TT> means that the array data is
transferred from caller to callee at the start of a method
invocation and from callee to caller at the end of the a method
invocation.
</LI><LI CLASS="li-enumerate">The implementation of a method taking an r-array parameter
cannot change the shape of the array.
</LI><LI CLASS="li-enumerate">The lower index is always 0, and the upper index is <I>n</I>−1 where
<I>n</I> is the length in a particular dimension. This is contrary to the
normal convention for Fortran arrays.
</LI><LI CLASS="li-enumerate">It can only be used for arrays of SIDL <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, <TT>double</TT>, <TT>fcomplex</TT>, and <TT>dcomplex</TT> types.
</LI></OL><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
The way r-arrays are passed to the server-side code, particularly
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, makes it impossible for them to be allocated or deallocated. This
makes <TT>out</TT> and return values impossible. Because the data has to
be accessible directly from <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> without any additional
meta-data, the array data must be in column-major order.</EM><P><EM>Arrays of char are not currently supported for r-arrays because in
some languages characters are treated as 16-bit Unicode characters.
</EM></P></BLOCKQUOTE><P>The advantages of r-arrays include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Arrays appear more “natural” in C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, Fortran 90/95 and
future low level languages.
</LI><LI CLASS="li-itemize">Developers need less or no code to translate between their array
data structure and SIDL’s array data structure.
</LI><LI CLASS="li-itemize">SIDL generated APIs can have signatures very similar if not
identical to well known legacy APIs.
</LI><LI CLASS="li-itemize">Less performance overhead because r-arrays can avoid a call to
<TT>malloc</TT> and <TT>free</TT>.
</LI></UL><P>When you declare an r-array, you also declare the index variables that
will hold the size of the array in each dimension. For example, here
is a method to solve one of the fundamental problems of linear
algebra, <I>A x</I> = <I>b</I>: </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    <FONT COLOR=maroon><I><B>void</B> solve(<B>in    rarray</B>&lt;<B>double</B>,2&gt; A(m,n),
               <B>inout rarray</B>&lt;<B>double</B>&gt;   x(n),
               <B>in    rarray</B>&lt;<B>double</B>&gt;   b(m),
               <B>in    int</B>              m,
               <B>in    int</B>              n);</I></FONT></TD></TR>
</TABLE><P>In this example, <TT>A</TT> is a 2-D array of doubles with <TT>m</TT> rows
and <TT>n</TT> columns. <TT>x</TT> is a 1-D array of doubles of length
<TT>n</TT>, and <TT>b</TT> is a 1-D array of doubles of length
<TT>m</TT>. Note that by explicitly declaring the index variables, SIDL
takes avoid using extra array size parameters by taking advantage of
the fact that the sizes of <TT>A</TT>, <TT>x</TT> and <TT>b</TT> are all
inter-related. The explicit declaration also allows the developer to
control where the index parameters appear in the argument list. In
many cases, the argument types and order can match existing APIs.</P><P>The mapping for the solve method will be shown for C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>
and Fortran 90/95 in the following chapters. In languages that do not
support low level access such as Python and Java, r-arrays are treated
just like normal SIDL arrays, and the redundant index arguments are
dropped from the argument list. The indexing information is available
from the SIDL array data structure.</P><!--TOC subsection SIDL Language Features-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->SIDL Language Features</H3><!--SEC END --><P><A NAME="ss:sidl_arrays"></A>
<A NAME="@default162"></A></P><P>As of release 0.6.5, interface definitions can specify that an
array argument or return value must have a particular ordering for a
method. The type <TT>array&lt;int, 2, row-major&gt;</TT> indicates a dense,
<SUP><A NAME="text9" HREF="#note9">1</A></SUP>
two-dimensional array of 32 bit integers in row-major order; and
likewise, the type <TT>array&lt;int, 2, column-major&gt;</TT> indicates an
dense array in column-major order. Some numerical routines can only
provide high performance with a particular type of array. The ordering
is part of the interface definition to give clients the information
they need to use the underlying code efficiently. The ordering
specification is optional.</P><P>For one-dimensional arrays, specifying <TT>row-major</TT> or
<TT>column-major</TT> allows you to specify that the array must be
dense, that is stride 1. Otherwise, for one-dimensional arrays
row-major and column-major are identical.</P><P>If you pass an array into a method and the array does not have the
specified ordering, the skeleton code will make a copy of the array
with the required ordering and pass the copy to the method. This
copying is necessary for correctness, but it will cause a decrease in
performance. The implementor of the method can count on an incoming
array to have the required ordering.</P><P>For <TT>out</TT> parameters and return values, an ordering
specification means that the method promises to return an array with
the specified ordering. The implementation should create the
<TT>out</TT> arrays with the proper ordering; because if it does not,
the skeleton code will have to copy the outgoing array into a new
array with the required ordering.</P><P>For <TT>inout</TT> parameters, an ordering specification means the
ordering specification will be enforced by the skeleton code for the
incoming and outgoing array value.</P><P>At the time of writing this, the ordering constraints are enforced for
Python implementation because Python uses NumPy or Numeric Python arrays, so
Babel cannot control the array ordering as fully. The Python
skeletons do force outgoing arrays (i. e., arrays passed back from
Python) to have the required ordering.</P><!--TOC subsection Independent and borrowed arrays-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Independent and borrowed arrays</H3><!--SEC END --><P>
<A NAME="@default163"></A><A NAME="@default164"></A></P><P>From a memory perspective, there are two main kinds of arrays:
independent and borrowed. The independent arrays owns and manages its
data. It allocates space for the array elements when the array is
created, and it deallocates that space when the array is finally
destroyed.</P><P>The borrowed array does not own or manage its data. It borrows its
array element data from another source that it cannot manage, and it
only allocates space for the index bounds and stride information. The
rationale for borrowed arrays is to allow data from another source to
temporarily appear as a SIDL array without requiring data be copied.</P><P>If you <TT>slice</TT> an independent array, the resulting array is also
considered independent even though it borrows data from the original
independent array. The resulting array can still manage its data by
retaining a reference to the original array; hence, its element data
cannot disappear until the resulting array is destroyed.
If you <TT>slice</TT> a borrowed array, the resulting array is also
borrowed because like its original array, it doesn’t manage the
underlying data.</P><P>In the Babel generated code, r-arrays are converted to borrowed
arrays. These borrowed arrays are allocated on the stack rather than
on the heap to improve performance of r-arrays.</P><!--TOC subsection The Life of an Array-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The Life of an Array</H3><!--SEC END --><P>
<A NAME="@default165"></A></P><P>The existence of borrowed arrays causes the arrays to deviate from the
normal reference counting pattern. You may recall that all arrays are reference counted,
and an array’s resources are reclaimed when the reference count goes to
zero. However, a borrowed array’s array element data will disappear
whenever the source of the borrowed data determines that it should
regardless of the reference count in corresponding the SIDL array.
This behavior means that developers should consider any SIDL array
that they did not create themselves, for example incoming arguments to
methods, as potential borrowed arrays. When a method wants to keep a
copy of an array that might be a borrowed array, it should use the
<TT>smartCopy</TT><A NAME="@default166"></A><A NAME="@default167"></A> method documented below.</P><P>Here are some rules of thumb about the use of borrowed arrays:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The creator of a borrowed array should guarantee that the data for the
borrowed array will exist through the duration of any method calls
using the borrowed array.
</LI><LI CLASS="li-itemize">Methods should not return a borrowed array as a return value or
<TT>out</TT> parameter unless the method can guarantee that the array
element data will be available until the process shuts down.
</LI><LI CLASS="li-itemize">There is a negligible performance cost when using <TT>smartCopy</TT>
when the array is not borrowed, and there is a huge correctness
benefit when the array is borrowed.
</LI></UL><!--TOC subsection The <TT>NULL</TT> Array-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The <TT>NULL</TT> Array</H3><!--SEC END --><P>
<A NAME="@default168"></A></P><P><TT>NULL</TT> is a special array reference value that refers to no
array. It’s used to indicate that an array reference currently points
to nothing. The way you refer to <TT>NULL</TT> varies from language to
language, but the concept is the same. In C++ and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
<TT>0</TT> (numeral zero) is the value of the <TT>NULL</TT> array. In C,
the preprocessor symbol <TT>NULL</TT> is the value for the <TT>NULL</TT>
array. In Python, it’s the special constant <TT>None</TT>, and in Java
it’s <TT>null</TT>. In Fortran 90/95, there is a function <TT>set_null</TT>,
to initialize a pointer to the <TT>NULL</TT> value, and there is a
logical function <TT>is_null</TT> to test whether an array is equal to
<TT>NULL</TT>.</P><!--TOC subsection The Language Bindings-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The Language Bindings</H3><!--SEC END --><P>The C++ binding for array provides access to the C API in case you<A NAME="@default169"></A>
need to take the gloves off and revel in the data directly. But the
C++ binding also provides a templated wrapper class to provide a more
natural look and feel for C++ programmers.</P><P>In some cases, the Python binding for arrays must copy SIDL arrays
to/from NumPy or Numeric Python arrays; it should not happen for normally
strided arrays except when an ordering constraint requires it. Arrays
in Python<A NAME="@default170"></A><A NAME="@default171"></A> don’t have the
SIDL methods available. They just have the NumPy or Numeric Python API
available.</P><P>The <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> API mimics the C API; all the C functions have been
Fortran’ified and have _f appended to their names. The 
Fortran 90/95 API uses function overloading to allow programmers to use
the short array method names.</P><!--TOC subsection The Array API-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The Array API</H3><!--SEC END --><P><A NAME="ss:basics:array:api"></A></P><P>In the following presentation, we use the SIDL <FONT COLOR=maroon><I><TT>double</TT></I></FONT> type; however,
everything in this section applies to all types except where noted.
The basic types are in the SIDL
namespace. Table <A HREF="#tbl:basics:arraytypes">6.2</A><A NAME="@default172"></A> shows the prefix for SIDL
base types and the actual value type held by the array...</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 6.2: SIDL types to array function prefixes</TD></TR>
</TABLE></DIV>
<A NAME="tbl:basics:arraytypes"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B>ARRAY FUNCTION PREFIX</B></TD><TD ALIGN=left NOWRAP><B>VALUE TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_bool</TT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_bool</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_char</TT>	</TD><TD ALIGN=left NOWRAP><TT>char</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_dcomplex</TT></TD><TD ALIGN=left NOWRAP><TT>struct sidl_dcomplex</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_double</TT> 	</TD><TD ALIGN=left NOWRAP><TT>double</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_fcomplex</TT>	</TD><TD ALIGN=left NOWRAP><TT>struct sidl_fcomplex</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_float</TT> 	</TD><TD ALIGN=left NOWRAP><TT>float</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_int</TT> 	</TD><TD ALIGN=left NOWRAP><TT>int32_t</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_long</TT> 	</TD><TD ALIGN=left NOWRAP><TT>int64_t</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_opaque</TT> 	</TD><TD ALIGN=left NOWRAP><TT>void *</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_string</TT> 	</TD><TD ALIGN=left NOWRAP><TT>char *</TT></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>For arrays of interfaces or classes, the name of the 
array function prefix is derived from the fully qualified type name. 
For example, for the type <FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT>, the
array functions all begin with <TT>sidl_BaseClass</TT>. 
For <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>, they all begin with
<TT>sidl_BaseInterface</TT>.</P><P>When you add an object or interface to an array,
the reference count of the element being overwritten is
decremented, and the reference count of the element being added is
incremented. When you get an object or interface from an array,
the caller owns the returned reference.</P><P>For arrays of strings<A NAME="@default173"></A> when you add a string to any array, the array
will store a copy of the string. When you retrieve a string from an
array, you will receive a copy of the string. You should
<TT>sidl_String_free</TT> the returned string when you are done with it.</P><P>When you create an array of interfaces, classes, or strings, all
elements of the array are initialized<A NAME="@default174"></A> to NULL. Other arrays are not
initialized. When an array of interfaces, classes, or strings is
destroyed, it releases any held references in the case of objects or
interfaces. In the case of strings, it frees any non-NULL pointers.</P><P>The name of the data structure that holds the array if double is 
<TT>struct sidl_double__array</TT>. For some types, the data structure 
is an opaque type, and for others, it is defined in a public C header
file.</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 6.3: SIDL Array Functions</TD></TR>
</TABLE></DIV>
<A NAME="tbl:basics:arrayfuncs"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SHORT NAME</B></TD><TD ALIGN=left NOWRAP><B>DESCRIPTION</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>createCol</TT>	</TD><TD ALIGN=left NOWRAP>Creates a column-major order SIDL array <A NAME="@default175"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>createRow</TT>	</TD><TD ALIGN=left NOWRAP>Creates a row-major order SIDL array <A NAME="@default176"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>create1d</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a dense one-dimensional SIDL array <A NAME="@default177"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>create2dCol</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a dense, column-major, two-dimensional SIDL array <A NAME="@default178"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>create2dRow</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a dense, column-major, two-dimensional SIDL array <A NAME="@default179"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>slice</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a sub-array of another array. Takes
parameters to define array properties. <A NAME="@default180"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>borrow</TT> 	</TD><TD ALIGN=left NOWRAP>Makes a SIDL array from third party data
without copying it <A NAME="@default181"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>smartCopy</TT> 	</TD><TD ALIGN=left NOWRAP>Copies a borrowed array or addRefs a
non-borrowed array <A NAME="@default182"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>addRef</TT>		</TD><TD ALIGN=left NOWRAP>Increments the reference count. <A NAME="@default183"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>deleteRef</TT>	</TD><TD ALIGN=left NOWRAP>Decrements the reference count. <A NAME="@default184"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get1</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
one-dimensional array <A NAME="@default185"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get2</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
two-dimensional array <A NAME="@default186"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get3</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
three-dimensional array <A NAME="@default187"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get4</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
four-dimensional array <A NAME="@default188"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get5</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
five-dimensional array <A NAME="@default189"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get6</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
six-dimensional array <A NAME="@default190"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get7</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
seven-dimensional array <A NAME="@default191"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from 
an array of any dimension <A NAME="@default192"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set1</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
one-dimensional array <A NAME="@default193"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set2</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
two-dimensional array <A NAME="@default194"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set3</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
three-dimensional array <A NAME="@default195"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set4</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
four-dimensional array <A NAME="@default196"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set5</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
five-dimensional array <A NAME="@default197"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set6</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
six-dimensional array <A NAME="@default198"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set7</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
seven-dimensional array <A NAME="@default199"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in 
an array of any dimension <A NAME="@default200"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>dimen</TT>		</TD><TD ALIGN=left NOWRAP>Returns the dimension of the array <A NAME="@default201"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>lower</TT>		</TD><TD ALIGN=left NOWRAP>Returns the lower bound of the specified dimension <A NAME="@default202"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>upper</TT>		</TD><TD ALIGN=left NOWRAP>Returns the upper bound of the specified dimension <A NAME="@default203"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>stride</TT>		</TD><TD ALIGN=left NOWRAP>Returns the stride of the specified
dimension <A NAME="@default204"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>length</TT>		</TD><TD ALIGN=left NOWRAP>Returns the length of the Array in the
specified dimension <A NAME="@default205"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>isColumnOrder</TT>	</TD><TD ALIGN=left NOWRAP>Returns true if the array is a dense
column-major order array, false otherwise <A NAME="@default206"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>isRowOrder</TT>	</TD><TD ALIGN=left NOWRAP>Returns true if the array is a dense
row-major order array, false otherwise <A NAME="@default207"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>copy</TT>		</TD><TD ALIGN=left NOWRAP>Copies the contents of source array to dest
array <A NAME="@default208"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>ensure</TT>		</TD><TD ALIGN=left NOWRAP>Returns an array with guaranteed ordering
and dimension from any array. <A NAME="@default209"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>first</TT>		</TD><TD ALIGN=left NOWRAP>Provides direct access to the element data of
the array. <A NAME="@default210"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The functions are listed succinctly in
Table <A HREF="#tbl:basics:arrayfuncs">6.3</A><A NAME="@default211"></A> as well as in detail over the next
few pages.</P><!--TOC subsubsection Function: createCol-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: createCol</H4><!--SEC END --><P><A NAME="@default212"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/* C */
<B>struct</B> sidl_double__array*
sidl_double__array_createCol(int32_t       dimen,
                             const int32_t lower[],
                             const int32_t upper[]);
//
// C++
<B>static</B> sidl::<B>array</B>&lt;<B>double</B>&gt;
sidl::<B>array</B>&lt;<B>double</B>&gt;::createCol(int32_t       dimen,
                               const int32_t lower[],
                               const int32_t upper[]);
C
C FORTRAN 77
       subroutine sidl_double__array_createCol_f(dimen, lower, upper, result)
       integer*4 dimen
       integer*4 lower(dimen), upper(dimen)
       integer*8 result
!
! FORTRAN 90
subroutine createCol(lower, upper, result)
  integer (selected_int_kind(9)), dimension(:), intent(<B>in</B>) :: lower, upper
  type (sidl_double_3d), intent(<B>out</B>) :: result ! type depends on dimension
! dimension of result is inferred from the size of lower

// Java
// (isRow should be false to get a column order array) 
  public Array(<B>int</B> dim, <B>int</B>[] lower, <B>int</B>[] upper, boolean isRow);</I></FONT></TD></TR>
</TABLE><P>This method creates a column-major, multi-dimensional array in a
contiguous block of memory. <TT>dimen</TT> should be strictly greater
than zero, and <TT>lower</TT> and <TT>upper</TT> should have <TT>dimen</TT>
elements. <TT>lower[i]</TT> must be less than or equal to
<TT>upper[i]-1</TT> for <TT>i ≥ 0</TT> and <TT>i &lt; dimen</TT>. If
this function fails for some reason, it returns
<TT>NULL</TT>. <TT>lower[i]</TT> specifies the smallest valid index for
dimension <TT>i</TT>, and <TT>upper[i]</TT> specifies the largest. Note
this definition is somewhat un-C like where the upper bound is often
one past the end. In SIDL, the size of dimension <TT>i</TT> is <TT>1
+ upper[i] - lower[i]</TT>.</P><P>The function makes copies of the information provided by <TT>dimen</TT>,
<TT>lower</TT>, and <TT>upper</TT>, so the caller is not obliged to
maintain those values after the function call.</P><P>For Fortran, the new array is returned in the last parameter,
<TT>result</TT>. A zero value in <TT>result</TT> indicates that the
operation failed. For Fortran 90/95, you can use the function
<TT>not_null</TT> to verify that <TT>result</TT> is a valid array.</P><!--TOC subsubsection Function: createRow-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: createRow</H4><!--SEC END --><P><A NAME="@default213"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_createRow(int32_t       dimen,
                             <B>const</B> int32_t lower[],
                             <B>const</B> int32_t upper[]);
//
// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::createRow(int32_t       dimen,
                               <B>const</B> int32_t lower[],
                               <B>const</B> int32_t upper[]);
C
C FORTRAN 77
       subroutine sidl_double__array_createRow_f(dimen, lower, upper, result)
       integer*4 dimen
       integer*4 lower(dimen), upper(dimen)
       integer*8 result
!
! FORTRAN 90
subroutine createRow(lower, upper, result)
  integer (selected_int_kind(9)), dimension(:), intent(in) :: lower, upper
  type(sidl_double_3d), intent(out) :: result ! type depends on dimension
! dimension of result is inferred from the size of lower

// Java
// (isRow should be true to get a row order array)
  public Array(<B>int</B> dim, <B>int</B>[] lower, <B>int</B>[] upper, boolean isRow);</TD></TR>
</TABLE><P>This method creates a row-major, multi-dimensional array in a
contiguous block of memory. Other than the difference in the
ordering of the array elements, this method is identical to
<TT>createCol</TT>.</P><!--TOC subsubsection Function: create1d-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: create1d</H4><!--SEC END --><P><A NAME="@default214"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_create1d(int32_t len);

// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::create1d(int32_t len);

C FORTRAN 77
       subroutine sidl_double__array_create1d_f(len, result)
       integer*4 len
       integer*8 result

! FORTRAN 90
subroutine create1d(len, result)
  integer (selected_int_kind(9)), intent(in) :: len
  type(sidl_double_1d), intent(out) :: result

// Java
  public Array1(<B>int</B> s0, boolean isRow);</TD></TR>
</TABLE><P>This method creates a dense, one-dimensional vector of ints with a lower
index of 0 and an upper index of <I>len</I> − 1. This is defined primarily
as a convenience for C and C++ programmers; Fortran programmers should note
that this subroutine creates arrays whose lower index is <EM>0</EM> not like
standard Fortran arrays whose lower index is 1. If <I>len</I> ≤ 0, this
routine returns NULL.</P><!--TOC subsubsection Function: create2dCol-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: create2dCol</H4><!--SEC END --><P><A NAME="@default215"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_create2dCol(int32_t m, int32_t n);

// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::create2dCol(int32_t m, int32_t n);

C FORTRAN 77
       subroutine sidl_double__array_create2dCol_f(m, n, result)
       integer*4 m, n
       integer*8 result

! FORTRAN 90
subroutine create2dCol(m, n, result)
  integer (selected_int_kind(9)), intent(in) :: m, n
  type(sidl_double_2d), intent(out) :: result

// Java
// isRow should be false to get a column order array
  public Array2(<B>int</B> s0, <B>int</B> s1, boolean isRow);</TD></TR>
</TABLE><P>This method creates a dense, column-major, two-dimensional array of
ints with a lower index of (0, 0) and an upper index of (<I>m</I> − 1, <I>n</I> −
1). If <I>m</I> ≤ 0 or <I>n</I> ≤ 0, this method returns NULL. This is
defined primarily as a convenience for C and C++ programmers; Fortran
programmers should note that this subroutine creates arrays whose
lower index is <EM>0</EM> not like standard Fortran arrays whose lower
index is 1.</P><!--TOC subsubsection Function: create2dRow-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: create2dRow</H4><!--SEC END --><P><A NAME="@default216"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_create2dRow(int32_t m, int32_t n);

// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::create2dRow(int32_t m, int32_t n);

C FORTRAN 77
       subroutine sidl_double__array_create2dRow_f(m, n, result)
       integer*4 m, n
       integer*8 result

! FORTRAN 90
subroutine create2dRow(m, n, result)
  integer (selected_int_kind(9)), intent(in) :: m, n
  type(sidl_double_2d), intent(out) :: result

// Java
// isRow should be false to get a column order array
  public Array2(<B>int</B> s0, <B>int</B> s1, boolean isRow);</TD></TR>
</TABLE><P>This method creates a dense, row-major, two-dimensional array of ints
with a lower index of (0, 0) and an upper index of (<I>m</I> − 1, <I>n</I> − 1).
If <I>m</I> ≤ 0 or <I>n</I> ≤ 0, this method returns NULL. This is defined
primarily as a convenience for C and C++ programmers; Fortran
programmers should note that this subroutine creates arrays whose
lower index is <EM>0</EM> not like standard Fortran arrays whose lower
index is 1.</P><!--TOC subsubsection Function: slice-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: slice</H4><!--SEC END --><P><A NAME="@default217"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array *
sidl_double__array_slice(<B>struct</B> sidl_double__array *src,
                         int32_t                    dimen,
                         <B>const</B> int32_t              numElem[],
                         <B>const</B> int32_t             *srcStart,
                         <B>const</B> int32_t             *srcStride,
                         <B>const</B> int32_t             *newStart);
//
// C++
array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::slice(<B>int</B> dimen,
                           <B>const</B> int32_t numElem[],
                           <B>const</B> int32_t *srcStart = 0,
                           <B>const</B> int32_t *srcStride = 0,
                           <B>const</B> int32_t *newStart = 0);
C
C FORTRAN 77
       subroutine sidl_double__array_slice_f(src, dimen, numElem, srcStart,
      $                       srcStride, newStart, result)
       integer*8 src, result
       integer*4 dimen
       integer*4 numElem(srcDimen), srcStart(srcDimen)
       integer*4 srcStride(srcDimen),  newStart(dimen)
!
! FORTRAN 90
subroutine slice(src, dimen, numElem, srcStart, srcStride, newStart, result)
  type(sidl_double_3d), intent(in) :: src     ! type depends on dimension
  type(sidl_double_2d), intent(out) :: result ! type depends on dimension
  integer (selected_int_kind(9)), intent(in) :: dimen
  integer (selected_int_kind(9)), intent(in), dimension(:) :: &amp;
     numElem, srcStart, srcStride, newStart

// Java
  public native Array _slice(<B>int</B> dimen, <B>int</B>[] numElem, <B>int</B>[] srcStart,
                             <B>int</B>[] srcStride, <B>int</B>[] newStart);</TD></TR>
</TABLE><P>This method will create a sub-array of another array. The resulting
array shares data with the original array. The new array can be of
the same dimension or potentially less than the original array. If
you are removing a dimension, indicate the dimensions to remove by
setting <TT>numElem[i]</TT> to zero for any dimension <TT>i</TT> that
should go away in the new array. The meaning of each argument is
covered below.
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>src</B></DT><DD CLASS="dd-description"> the array to be created will be a subset of this array. If
this argument is NULL, NULL will be returned. The returned array
borrows data from <TT>src</TT>, so modifying one array modifies both.
In C++, the <TT>this</TT> pointer takes the place of <TT>src</TT>.
</DD><DT CLASS="dt-description"><B>dimen</B></DT><DD CLASS="dd-description"> this argument must be greater than zero and less than or
equal to the dimension of <TT>src</TT>. An illegal value will cause a
NULL return value.
</DD><DT CLASS="dt-description"><B>numElem</B></DT><DD CLASS="dd-description"> this specifies how many elements from src should be
in the new array in each dimension. A zero entry indicates that the 
dimension should not appear in the new array. This argument should
be an array with an entry for each dimension of <TT>src</TT>. 
<TT>NULL</TT> will be returned for <TT>src</TT> if either<BR>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TT>srcStart[i] + numElem[i] * srcStride[i]</TT></TD><TD ALIGN=center NOWRAP>&gt;</TD><TD ALIGN=left NOWRAP><TT>upper[i]</TT>, or</TD></TR>
<TR><TD ALIGN=right NOWRAP><TT>srcStart[i] + numElem[i] * srcStride[i]</TT></TD><TD ALIGN=center NOWRAP>&lt;</TD><TD ALIGN=left NOWRAP><TT>lower[i]</TT></TD></TR>
</TABLE>
</DIV></DD><DT CLASS="dt-description"><B>srcStart</B></DT><DD CLASS="dd-description">this parameter specifies which element of <TT>src</TT>
will be the first element of the new array. If this argument is NULL,
the first element of <TT>src</TT> will be the first element of the new
array. If non-NULL, this argument provides the coordinates of an
element of <TT>src</TT>, so it must have an entry for each dimension of
<TT>src</TT>. <TT>NULL</TT> will be returned for <TT>src</TT> if either
<DIV CLASS="center">
<TT>srcStart[i] &lt; lower[i]</TT>, or <TT>srcStart[i] &gt; upper[i]</TT>.
</DIV></DD><DT CLASS="dt-description"><B>srcStride</B></DT><DD CLASS="dd-description">this argument lets you specify the stride between
elements of <TT>src</TT> for each dimension. For example with a stride
of 2, you could create a sub-array with only the odd or even elements
of <TT>src</TT>. If this argument is NULL, the stride is taken to be
one in each dimension. If non-NULL, this argument should be an array
with an entry for each dimension of <TT>src</TT>. The stride values are
relative to the original source array, <TT>src</TT>, so the default
stride of one in each dimension is appropriate for cases where you
want a dense subsection of the original array.
</DD><DT CLASS="dt-description"><B>newLower</B></DT><DD CLASS="dd-description"> this argument is like the <TT>lower</TT> argument in a
create method. It sets the coordinates for the first element in the
new array. If this argument is NULL, the values indicated by
<TT>srcStart</TT> will be used. If non-NULL, this should be an array
with <TT>dimen</TT> elements.
</DD></DL><P>
Assuming the method is successful and the return value is named
newArray, <TT>src[srcStart]</TT> refers to the same underlying element
as <TT>newArray[newStart]</TT>.</P><P>If <TT>src</TT> is not a borrowed array (i. e., it manages its own data),
the returned array can manage its by keeping a reference to
<TT>src</TT>. It is not considered a borrowed array for purposes of
<TT>smartCopy</TT>.</P><!--TOC subsubsection Function: borrow-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: borrow</H4><!--SEC END --><P><A NAME="@default218"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_borrow(<B>double</B>*       firstElement,
                          int32_t       dimen,
                          <B>const</B> int32_t lower[],
                          <B>const</B> int32_t upper[],
                          <B>const</B> int32_t stride[]);
//
// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::borrow(<B>double</B>*       firstElement,
                            int32_t       dimen,
                            <B>const</B> int32_t lower[],
                            <B>const</B> int32_t upper[],
                            <B>const</B> int32_t stride[]);
C
C FORTRAN 77
       subroutine sidl_double__array_borrow_f(firstElement, dimen, lower,
     $      upper, stride, result)
       real*8 firstElement()
       integer*4 dimen, lower(dimen), upper(dimen), stride(dimen)
       integer*8 result
!
! FORTRAN 90
subroutine borrow(firstElement, dimen, lower, upper, stride, &amp;
                                    result)
  real (selected_real_kind(17,308)), intent(in) :: firstElement
  integer (selected_int_kind(9)), intent(in) :: dimen
  integer (selected_int_kind(9)), dimension(:), intent(in) :: lower, upper,&amp;
                                              stride
  type(sidl_double_1d), intent(out) :: result ! type depends on array dimension</TD></TR>
</TABLE><P>This method creates a proxy SIDL multi-dimensional array using data
provided by a third party. In some cases, this routine can be used to
avoid making a copy of the array data. <TT>dimen</TT>, <TT>lower</TT>, and
<TT>upper</TT> have the same meaning and constraints as in
<TT>SIDL_double__array_createCol</TT>. The <TT>firstElement</TT> argument
should be a pointer to the first element of the array; in this
context, the first element is the one whose index is <TT>lower</TT>.</P><P><TT>stride[i]</TT> specifies the signed offset from one element in
dimension <TT>i</TT> to the next element in dimension <TT>i</TT>. For a
one dimensional array, the first element has the address
<TT>firstElement</TT>, the second element has the address
<TT>firstElement + stride[0]</TT>, the third element has the address
<TT>firstElement + 2 * stride[0]</TT>, etc. The algorithm for
determining the address of the element in a multi-dimensional
array whose index is in array <TT>ind[]</TT> is as follows:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">int32_t* addr = firstElement;
<B>for</B>(<B>int</B> i = 0; i &lt; dimen; ++i) {
  addr += (ind[i] - lower[i])*stride[i];
}
<FONT COLOR="blue"><I>/* now addr is the address of element ind */</I></FONT></TD></TR>
</TABLE><P>Note elements of stride need not be positive.</P><P>The function makes copies of the information provided by <TT>dimen</TT>, 
<TT>lower</TT>, <TT>upper</TT>, and <TT>stride</TT>. 
The type of <TT>firstElement</TT> is changed depending on the array value type
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>).</P><!--TOC subsubsection Function: smartCopy-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: smartCopy</H4><!--SEC END --><P><A NAME="@default219"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_smartCopy(<B>struct</B> sidl_double__array *array);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::smartCopy();

C FORTRAN 77
       subroutine sidl_double__array_smartCopy_f(array, result)
       integer*8 array, result

! FORTRAN 90
subroutine smartCopy(array, result)
  type(sidl_double_1d), intent(in) :: array   ! type depends on dimension
  type(sidl_double_1d), intent(out) :: result ! type depends on dimension

// Java
  public native Array _smartCopy();</TD></TR>
</TABLE><P>This method will copy a borrowed array or increment the reference
count of an array that is able to manage its own data. This method is
useful when you want to keep a copy of an incoming array. The C++
method operates on <TT>this</TT>.</P><!--TOC subsubsection Function: addRef-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: addRef</H4><!--SEC END --><P><A NAME="@default220"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_addRef(<B>struct</B> sidl_double__array* array);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::addRef() throw ( NullIORException );

C FORTRAN 77
       subroutine sidl_double__array_addRef_f(array)
       integer*8 array

! FORTRAN 90
subroutine addRef(array)
  type(sidl_double_1d), intent(in) :: array ! type depends on array dimension</TD></TR>
</TABLE><P>This increments the reference count by one. In C++, this method
should be avoided because the C++ wrapper class manages the reference
count for you.</P><!--TOC subsubsection Function: deleteRef-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: deleteRef</H4><!--SEC END --><P><A NAME="@default221"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_deleteRef(<B>struct</B> sidl_double__array* array);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::deleteRef() throw ( NullIORException );

C FORTRAN 77
       subroutine sidl_double__array_deleteRef_f(array)
       integer*8 array

! FORTRAN 90
subroutine deleteRef(array)
  type(sidl_double_1d), intent(out) :: array ! type depends on dimension</TD></TR>
</TABLE><P>This decreases the reference count by one. If this reduces the
reference count to zero, the resources associated with the array are
reclaimed. In C++, this method should be avoided because the C++
wrapper class manages the reference count for you.</P><!--TOC subsubsection Function: get1-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: get1</H4><!--SEC END --><P><A NAME="@default222"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get1(<B>const struct</B> sidl_double__array* array,
                        int32_t                          i1);

// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1);

C FORTRAN 77
       subroutine sidl_double__array_get1_f(array, i1, result)
       integer*8 array
       integer*4 i1
       real*8 result

! FORTRAN 90
subroutine get(array, i1, result)
  type(sidl_int_1d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i);</TD></TR>
</TABLE><P>This method returns the element with index <TT>i1</TT> for a one 
dimensional array. 
The return type of this method is the value type for the 
SIDL type being held (see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for one dimensional 
arrays. 
For objects and interfaces, the client owns the 
returned reference (i. e., the client is obliged to call
<TT>deleteRef()</TT> when they are done with the reference 
unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string 
(i. e., the client is obliged to call
free on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value 
cases when i1 is out of bounds.</P><!--TOC subsubsection Function: get2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: get2</H4><!--SEC END --><P><A NAME="@default223"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get2(<B>const struct</B> sidl_double__array* array,
                        int32_t                       i1,
                        int32_t                       i2);

// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1, int32_t i2);

C FORTRAN 77
       subroutine sidl_int__array_get2_f(array, i1, i2, result)
       integer*8 array
       integer*4 i1, i2
       real*8 result

! FORTRAN 90
subroutine get(array, i1, i2, result)
  type(sidl_int_2d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i, <B>int</B> j);</TD></TR>
</TABLE><P>This method returns the element with indices (<TT>i1</TT>, <TT>i2</TT>) for 
a two dimensional array. 
The return type of this method is the value type for the SIDL type being held 
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>.
This method must only be called for two dimensional arrays. 
For objects and interfaces, the client owns the returned reference 
(i. e., the client is obliged to
call <TT>deleteRef</TT> when they are done with the reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string 
(i. e., the client is obliged to call
free on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when 
<TT>i1</TT>, <TT>i2</TT> are out of bounds.</P><!--TOC subsubsection Function: get3-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: get3</H4><!--SEC END --><P><A NAME="@default224"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get3(<B>const struct</B> sidl_double__array* array,
                        int32_t                          i1,
                        int32_t                          i2,
                        int32_t                          i3);
// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1, int32_t i2, int32_t i3);

C FORTRAN 77
       subroutine sidl_double__array_get3_f(array, i1, i2, i3, result)
       integer*8 array
       integer*4 i1, i2, i3
       real*8 result

! FORTRAN 90
subroutine get(array, i1, i2, i3, result)
  type(sidl_double_3d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i, <B>int</B> j, <B>int</B> k);</TD></TR>
</TABLE><P>This method returns the element with indices (<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>) for
a three dimensional array. 
The return type of this method is the value type for the SIDL type being held
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for three dimensional arrays. 
For objects and interfaces, the client owns the returned reference (i. e., the client is
obliged to call <TT>deleteRef()</TT> when they are done with the 
reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string (i. e., the client is
obliged to call <TT>free()</TT> on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when i1, i2, i3 
are out of bounds.</P><!--TOC subsubsection Function: get4-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: get4</H4><!--SEC END --><P><A NAME="@default225"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get4(<B>const struct</B> sidl_double__array* array,
                     int32_t                       i1,
                     int32_t                       i2,
                     int32_t                       i3,
                     int32_t                       i4);
// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1, int32_t i2, int32_t i3, int32_t i4);

C FORTRAN 77
       subroutine sidl_double__array_get4_f(array, i1, i2, i3, i4, result)
       integer*8 array
       integer*4 i1, i2, i3, i4
       real*8 result

! FORTRAN 90
subroutine get(array, i1, i2, i3, i4, result)
  type(sidl_double_4d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3, i4
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l);</TD></TR>
</TABLE><P>This method returns the element with indices(<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>, <TT>i4</TT>) 
for a four dimensional array. 
The return type of this method is the value type for the SIDL type being
held (see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for four dimensional arrays. 
For objects and interfaces, the client owns the returned reference 
(i. e., the client is
obliged to call <TT>deleteRef()</TT> when they are done with the 
reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string (i. e., the client is
obliged to call <TT>free()</TT> on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when 
<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>, or <TT>i4</TT> are out of bounds.</P><!--TOC subsubsection Function: get5-7-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: get5-7</H4><!--SEC END --><P><A NAME="@default226"></A></P><P>Methods <TT>get5</TT>–<TT>get7</TT> are defined in an analogous way.</P><!--TOC subsubsection Function: get-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: get</H4><!--SEC END --><P><A NAME="@default227"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get(<B>const struct</B> sidl_double__array* array,
                    <B>const</B> int32_t                 indices[]);

// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(<B>const</B> int32_t indices[]);

C FORTRAN 77
       subroutine sidl_double__array_get_f(array, indices, result)
       integer*8 array
       integer*4 indices()
       real*8 result

! FORTRAN 90
subroutine get(array, indices, result)
  type(sidl_real_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)), dimension(:), intent(in) ::indices
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public native <B>double</B> _get(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l, <B>int</B> m, <B>int</B> n, <B>int</B> o);</TD></TR>
</TABLE><P>This method returns the element whose index is indices for an array of any dimension. 
The return type of this method is the value type for the SIDL type being held
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method can be called for any positively dimensioned array. 
For objects and interfaces, the client owns the returned reference 
(i. e., the client is obliged to call <TT>deleteRef()</TT> when they are 
done with the reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string (i. e., the client is
obliged to call <TT>free()</TT> on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when indices
has an element out of bounds.</P><!--TOC subsubsection Function: set1-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: set1</H4><!--SEC END --><P><A NAME="@default228"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set1(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        <B>double</B>                     value));

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set1_f(array, i1, value)
       integer*8 array
       integer*4 i1
       real*8 value

! FORTRAN 90
subroutine set(array, i1, value)
  type(sidl_double_1d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1,
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index <TT>i1</TT> of a one dimensional array to value. 
The type of the argument value is the value type for the SIDL type being held 
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for one dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by calling
<TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string, 
so the client retains ownership of the value pointer.</P><!--TOC subsubsection Function: set2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: set2</H4><!--SEC END --><P><A NAME="@default229"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set2(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        int32_t                    i2,
                        <B>double</B>                     value));

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, int32_t i2, <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set2_f(array, i1, i2, value)
       integer*8 array
       integer*4 i1, i2
       real*8 value

! FORTRAN 90
subroutine set(array, i1, i2, value)
  type(sidl_int_2d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>int</B> j, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index (<TT>i1</TT>, <TT>i2</TT>) of 
a two dimensional array to value. 
The type of the argument value is the value type for the SIDL type being held (see
table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for two dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by calling
<TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string, 
so the client retains ownership of the value pointer.</P><!--TOC subsubsection Function: set3-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: set3</H4><!--SEC END --><P><A NAME="@default230"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set3(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        int32_t                    i2,
                        int32_t                    i3,
                        <B>double</B>                     value));

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, int32_t i2, int32_t i3, <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set3_f(array, i1, i2, i3, value)
       integer*8 array
       integer*4 i1, i2, i3
       real*8 value

! FORTRAN 90
subroutine set(array, i1, i2, i3, value)
  type(sidl_double_3d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index (<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>) 
of a three dimensional array to value. 
The type of the argument value is the value type for the SIDL type being held
(see table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for three dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by calling
<TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string,
so the client retains ownership of the value pointer.</P><!--TOC subsubsection Function: set4-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: set4</H4><!--SEC END --><P><A NAME="@default231"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set4(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        int32_t                    i2,
                        int32_t                    i3,
                        int32_t                    i4,
                        <B>double</B>                     value));
//
// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, int32_t i2,
                         int32_t i3, int32_t i4, <B>double</B> value);
C
C FORTRAN 77
       subroutine sidl_double__array_set4_f(array, i1, i2, i3, i4, value)
       integer*8 array
       integer*4 i1, i2, i3, i4
       real*8 value
!
! FORTRAN 90
subroutine set(array, i1, i2, i3, i4, value)
  type(sidl_double_4d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3, i4
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index (<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>, <TT>i4</TT>) 
of a four dimensional array to value. 
The type of the argument value is the value type for the SIDL type being
held (see table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for four dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by
calling <TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string, 
so the client retains ownership of the value pointer.</P><!--TOC subsubsection Function: set5-7-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: set5-7</H4><!--SEC END --><P><A NAME="@default232"></A></P><P>Methods <TT>set5</TT>–<TT>set7</TT> are defined in an analogous way.</P><!--TOC subsubsection Function: set-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: set</H4><!--SEC END --><P><A NAME="@default233"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set(<B>struct</B> sidl_double__array* array,
                       <B>const</B> int32_t              indices[],
                       <B>double</B>                     value);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(<B>const</B> int32_t indices[], <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set_f(array, indices, value)
       integer*8 array
       integer*4 indices()
       real*8 value

! FORTRAN 90
subroutine set(array, indices, value)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)), intent(in), dimension(:) :: indices
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public native <B>void</B> _set(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l, <B>int</B> m, <B>int</B> n,
                          <B>int</B> o, <B>double</B> value);</TD></TR>
</TABLE><P>This method sets the value in index indices for an array of any dimension to value. 
The type of the argument value is the value type for the SIDL type being held (see
table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
For arrays of objects and interfaces, the array will make its own reference 
by calling <TT>addRef()</TT> on value, so the client retains its reference to value.
For arrays of strings, the array will make a copy of the string, so the client 
retains ownership of the value pointer.</P><!--TOC subsubsection Function: dimen-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: dimen</H4><!--SEC END --><P><A NAME="@default234"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_dimen(<B>const struct</B> sidl_double__array *array);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::dimen() <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_dimen_f(array, result)
       integer*8 array
       integer*4 result

! FORTRAN 90
integer (selected_int_kind(9)) dimen(array)
  type(sidl_double_1d) :: array ! type depends on dimension

// Java
public native <B>int</B> _dim();</TD></TR>
</TABLE><P>This method returns the dimension of the array.</P><!--TOC subsubsection Function: lower-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: lower</H4><!--SEC END --><P><A NAME="@default235"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_lower(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::lower(int32_t ind) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_lower_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function lower(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)) :: ind

// Java
  public native <B>int</B> _lower(<B>int</B> dim);</TD></TR>
</TABLE><P>This method returns the lower bound on the index for dimension <TT>ind</TT> of array.</P><!--TOC subsubsection Function: upper-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: upper</H4><!--SEC END --><P><A NAME="@default236"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_upper(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::upper(int32_t ind) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_upper_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function upper(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)), intent(in) :: ind

// Java
  public native <B>int</B> _upper(<B>int</B> dim);</TD></TR>
</TABLE><P>This method returns the upper bound on the index for dimension ind of array. 
If the upper bound is greater than or equal to the lower bound, the upper bound is a valid
index (i. e., it is not one past the end).</P><!--TOC subsubsection Function: stride-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: stride</H4><!--SEC END --><P><A NAME="@default237"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_stride(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::stride(int32_t ind) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_stride_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function stride(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)) :: ind

// Java
  public native <B>int</B> _stride(<B>int</B> dim);</TD></TR>
</TABLE><P>This method returns the stride for a particular dimension. This
stride indicates how much to add to a pointer to get for the current
element this the particular dimension to the next.</P><!--TOC subsubsection Function: length-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: length</H4><!--SEC END --><P><A NAME="@default238"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_length(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++ Default dimension is 1.
int32_t
sidl::array&lt;int32_t&gt;::length(int32_t ind = 0) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_length_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function length(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)) :: ind

// Java
  public native <B>int</B> _length(<B>int</B> dim);

// For one dimensional Java arrays. Array1:
  public <B>int</B> lenth();</TD></TR>
</TABLE><P>This method returns the length for a particular dimension. It is
equivalent to the statement <TT>upper(dim) - lower(dim) + 1</TT>.</P><P>There is also a shortcut for one-dimensional arrays available in C++ 
and Java. In C++, if <TT>length</TT> is called with no arguments, it
defaults to the first dimension. In Java <TT>Array1</TT>
one-dimensional Java arrays have a length function that takes no arguments.</P><!--TOC subsubsection Function: isColumnOrder-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: isColumnOrder</H4><!--SEC END --><P><A NAME="@default239"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
sidl_bool
sidl_double__array_isColumnOrder(<B>const struct</B> sidl_double__array *array);

// C++
bool
sidl::array&lt;<B>double</B>&gt;::isColumnOrder() <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_isColumnOrder_f(array, result)
       integer*8 array
       logical   result

! FORTRAN 90
logical function isColumnOrder(array)
  type(sidl_double_2d), intent(in) :: array ! type depends on dimension

// Java
  public native boolean _isColumnOrder();</TD></TR>
</TABLE><P>This method returns a true value if and only if <TT>array</TT> is dense,
column-major ordered array. It does not modify the array at all.</P><!--TOC subsubsection Function: isRowOrder-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: isRowOrder</H4><!--SEC END --><P><A NAME="@default240"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
sidl_bool
sidl_double__array_isRowOrder(<B>const struct</B> sidl_double__array *array);

// C++
bool
sidl::array&lt;<B>double</B>&gt;::isRowOrder() <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_isRowOrder_f(array, result)
       integer*8 array
       logical   result

! FORTRAN 90
logical function isRowOrder(array)
  type(sidl_double_1d), intent(<B>int</B>) :: array ! type depends on dimension

// Java
  public native boolean _isRowOrder();</TD></TR>
</TABLE><P>This method returns a true value if and only if <TT>array</TT> is dense,
row-major ordered array. It does not modify the array at all.</P><!--TOC subsubsection Function: copy-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: copy</H4><!--SEC END --><P><A NAME="@default241"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_copy(<B>const struct</B> sidl_double__array *src
                              <B>struct</B> sidl_double__array *dest);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::copy(<B>const</B> sidl::array&lt;<B>double</B>&gt; &amp;src);

C FORTRAN 77
       subroutine sidl_double__array_copy_f(array, dest)
       integer*8 array, dest

! FORTRAN 90
subroutine copy(array, dest)
  type(sidl_double_1d), intent(in) :: array ! type depends on array dimension
  type(sidl_double_1d), intent(in) :: dest  ! type depends on array dimension

// Java
  public <B>void</B> _copy(sidl.Double.Array dest);</TD></TR>
</TABLE><P>This method copies the contents of <TT>src</TT> to <TT>dest</TT>. For the
copy to take place, both arrays must exist and be of the same
dimension. This method will not modify <TT>dest</TT>’s size, index
bounds, or stride; only the array element values of <TT>dest</TT> may be
changed by this function. No part of <TT>src</TT> is changed by this
method.</P><P>If <TT>dest</TT> has different index bounds than <TT>src</TT>, this method
only copies the elements where the two arrays overlap. If <TT>dest</TT>
and <TT>src</TT> have no indices in common, nothing is copied. For
example, if <TT>src</TT> is a 1-d array with elements 0-5 and dest is a
1-d array with element 2-3, this function will copy element 2 and 3
from <TT>src</TT> to <TT>dest</TT>. If <TT>dest</TT> had elements 4-10,
this method could copy elements 4 and 5.</P><!--TOC subsubsection Function: ensure-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: ensure</H4><!--SEC END --><P><A NAME="@default242"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array *
sidl_double__array_ensure(<B>const struct</B> sidl_double__array *src,
                          int32_t                          dimen,
                          <B>int</B>                              ordering);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::ensure(int32_t dimen, <B>int</B> ordering);

C FORTRAN 77
       subroutine sidl_double__array_ensure_f(src, dimen, ordering, result)
       integer*8 src, result
       integer*4 dimen, ordering

! FORTRAN 90
subroutine ensure(src, dimen, ordering, result)
   type(sidl_double_1d), intent(in) :: src    ! type depends on array dimension
   type(sidl_double_1d), intent(out) :: result! type depends on array dimension
   integer (selected_int_kind(9)) :: dimen, ordering</TD></TR>
</TABLE><P>This method is used to obtain a matrix with a guaranteed ordering and
dimension from an array with uncertain properties. If the incoming
array has the required ordering and dimension, its reference count is
incremented, and it is returned. If it doesn’t, a copy with the
correct ordering is created and returned. In either case, the caller
knows that the returned matrix (if not NULL) has the desired
properties.</P><P>This method is used internally to enforce the array ordering
constraints in SIDL. Clients can use it in similar ways. However,
because the method was intended as an internal Babel feature, 
is not available in Java or Python.</P><P>The ordering parameter should be one of the constants defined in
<TT>enum sidl_array_ordering</TT> (e. g.<BR>
<TT>sidl_general_order</TT>,
<TT>sidl_column_major_order</TT>, or <TT>sidl_row_major_order</TT>). If
you pass in<BR>
<TT>sidl_general_order</TT>, this routine will only check
the dimension of the matrix.</P><!--TOC subsubsection Function: first-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Function: first</H4><!--SEC END --><P><A NAME="@default243"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B> *
sidl_double__array_first(<B>const struct</B> sidl_double__array *src);

// C++
<B>double</B>* first() throw();

C FORTRAN 77
      subroutine sidl_double__array_access_f(array, ref, lower, upper,
     $   stride, index)
      integer*8 array, index
      integer*4 lower(), upper(), stride()
      integer*4 ref()</TD></TR>
</TABLE><P>This method provides direct access to the element data. Using this
pointer and the stride information, you can perform your own array
accesses without function calls. This method isn’t available for
arrays of strings, interface and objects because of memory/reference
management issues. There is no equivalent of this
function in Java or Python. To see how to get direct array access in
Fortran 90/95, see Chapter <A HREF="#c:f90">11</A>.<A NAME="@default244"></A><A NAME="@default245"></A></P><P>The Fortran versions of the method return the lower, upper and
stride information in three arrays, each with enough elements to hold
an entry for each dimension of <TT>array</TT>. Because <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> does
not have pointers, you must pass in a reference array, <TT>array</TT>.
Upon exit, <TT>ref(index)</TT> is the first element of the array. The
type of <TT>ref</TT> depends on the type of the array.</P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">WARNING:</DIV>
<A NAME="@default246"></A><A NAME="@default247"></A>
While calling the Fortran direct access routines, there is a
possibility of an alignment error between your reference pointer,
<TT>ref</TT>, and the pointer to the first element of the array data.
The problem is more likely with arrays of <TT>double</TT> or
<TT>dcomplex</TT>; although, it could occur with any type on some future
platform. If <TT>index</TT> is zero on return, an alignment error
occurred. If an alignment error occurs, you may be able to solve it
by recompiling your Fortran files with flags to force doubles to be
aligned on 8 byte boundaries. For example, the <TT>-malign-double</TT>
flag for g77 forces doubles to be aligned on 64-bit boundaries. An
alignment error occurs when <TT>(char *)ref</TT> minus <TT>(char
*)sidl_double__array_first(array)</TT> is not integer divisible by
<TT>sizeof(datatype)</TT> where <TT>ref</TT> refers to the address of the
reference array.
</BLOCKQUOTE><HR SIZE=2><P><BR>

Here is an example <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> subroutine to output each element of
a <A NAME="@default248"></A> 
1-dimensional array of doubles using the direct access
routine. Fortran 90/95 has a pointer in the array derived type when
direct access is possible.</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">C This subroutine will print each element of an array of doubles
      subroutine print_array(dblarray)
      implicit none
      integer*8 dblarray, index
      real*8 refarray(1)
      integer*4 lower(1), upper(1), stride(1), dimen, i
      if (dblarray .ne. 0) then
         call sidl_double__array_dimen_f(dblarray, dimen)
         if (dimen .eq. 1) then
            call sidl_double__array_access_f(dblarray, refarray,
     $           lower, upper, stride, index)
            if (index .ne. 0) then
               do i = lower(1), upper(1)
                  write(*,*) refarray(index + (i-lower(1))*stride(1))
               enddo
            else
               write(*,*) 'Alignment error occured'
            endif
         endif
      endif
      end</TD></TR>
</TABLE><P>For a 2-dimensional array, the loop and array access is</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      do i = lower(1), upper(1)
         do j = lower(2), upper(2)
            write(*,*) refarray(index+(i-lower(1))*stride(1)+
     $           (j - lower(2))*stride(2))
         enddo
      enddo</TD></TR>
</TABLE><P>Suppose you are wrapping a legacy Fortran application and you need to
pass a SIDL array to a Fortran subroutine. Further suppose there is
a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> and Fortran 90/95 version of the subroutine. For example,
the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> subroutine has a signature such as:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      subroutine TriedAndTrue(x, n)
      integer n
      real*8 x(n)
C insert wonderful, efficient, debugged code here
      end</TD></TR>
</TABLE><P>The Fortran 90/95 subroutine has basically the same signature as follows:
<A NAME="@default249"></A> 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">subroutine TriedAndTrue(x, n)
  integer (selected_int_kind(9))     :: n
  real (selected_real_kind(17, 308)) :: x(n)

  <FONT COLOR="blue"><I>! insert wonderful, efficient, debugged code here</I></FONT>
end subroutine TriedAndTrue</TD></TR>
</TABLE><P>Here is one way to wrap this method using SIDL. First of all, the
SIDL method definition specifies that the array must be a
1-dimensional, column-major ordered array. This forces the incoming
array to be a dense column.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    <FONT COLOR=maroon><I><B>static void</B> TriedAndTrue(<B>inout array</B>&lt;<B>double</B>,1,column-major&gt; arg);</I></FONT></TD></TR>
</TABLE><P>Given that method definition in a class named Class and a package
named Pkg, the implementation of the wrapper should look something
like the following for <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine Pkg_Class_TriedAndTrue_fi(arg)
        implicit none
        integer*8 arg
C       DO-NOT-DELETE splicer.begin(Pkg.Class.TriedAndTrue)
        real*8 refarray(1)
        integer*4 lower(1), upper(1), stride(1)
        integer*8 index
        integer n
        call sidl_double__array_access_f(arg, refarray,
     $       lower, upper, stride, index)
        if (index .ne. 0) then
c we can assume stride(1) = 1 because of column-major specification
           n = 1 + upper(1) - lower(1)
           call TriedAndTrue(refarray(index), n)
        else
           write(*,*) 'ERROR: array alignment'
        endif
C       DO-NOT-DELETE splicer.end(Pkg.Class.TriedAndTrue)
        end</TD></TR>
</TABLE><P>Similarly, it should look something like the following for Fortran 90/95, where
the include statements are required at the top of the “Impl” file to ensure
proper handling of subroutine names that have automatically been mangled
by the Babel compiler:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#<B>include</B> "Pkg_Class_fAbbrev.h"
#<B>include</B> "sidl_BaseClass_fAbbrev.h"
#<B>include</B> "sidl_BaseInterface_fAbbrev.h"
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(_miscellaneous_code_start)</I></FONT>
#<B>include</B> "sidl_double_fAbbrev.h"
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(_miscellaneous_code_start)</I></FONT>
.
.
.
subroutine Pkg_Class_TriedAndTrue_mi(arg)
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Pkg.Class.TriedAndTrue.use)</I></FONT>
  <B>use</B> SIDL_double_array
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Pkg.Class.TriedAndTrue.use)</I></FONT>
  implicit <B>none</B>
  type(sidl_double_a) :: arg

<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Pkg.Class.TriedAndTrue)</I></FONT>
  real (selected_real_kind(17,308)), dimension(1) :: refarray
  integer (selected_int_kind(8)), dimension(1)    :: low, up, str
  integer (selected_int_kind(8))    :: index, n
  call access(arg, refarray, low, up, str, index)
  if (index .ne. 0) then
    <FONT COLOR="blue"><I>! We can assume stride(1) = 1 because of column-major specification</I></FONT>
    n = 1 + upper(1) - lower(1)
    call TriedAndTrue(refarray(index), n)
  else
    write(*,*) 'ERROR: array alignment'
  <B>endif</B>
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Pkg.Class.TriedAndTrue)</I></FONT>
end subroutine Pkg_Class_TriedAndTrue_mi</TD></TR>
</TABLE><!--TOC subsection The C Macro API-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The C Macro API</H3><!--SEC END --><P><A NAME="@default250"></A><A NAME="@default251"></A></P><P>Many of the SIDL array access functions have a corresponding C macro 
API for those who fear the function overhead of the C function API. 
When efficiency is not a concern, we recommend using the function API, 
but the C macro API is preferable to the direct access to the data structure. 
Parts of the macro API are not available for arrays of strings,
interfaces or objects because the issues associated with memory and
object reference management.</P><P>The macro API is very similar to the function API; however, 
a single set of macros applies to all the supported array types. 
The macro names are independent of the type of array you’re accessing.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlArrayDim(array)</TD></TR>
</TABLE><P>
<A NAME="@default252"></A><A NAME="@default253"></A>
Return the dimension of array.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlLower(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default254"></A><A NAME="@default255"></A>
Return the lower bound on dimension ind.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlUpper(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default256"></A><A NAME="@default257"></A>
Return the upper bound on dimension ind.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlLength(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default258"></A><A NAME="@default259"></A>
Return the extent on dimension ind. The extent is equal to
<TT>sidlUpper(array,ind) - sidlLower(array,ind) + 1</TT>.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlStride(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default260"></A><A NAME="@default261"></A>
Return the stride for dimension ind. 
The stride is the offset between elements in a particular dimension. 
It can be positive or negative. It is in terms of number of value
types (i. e., it’s 1 means contiguous regardless of what data type).</P><P>The macros to access array elements of array elements
are unavailable for arrays of strings, classes and interfaces.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlArrayElem1(array, ind1)
sidlArrayElem2(array, ind1, ind2)
sidlArrayElem3(array, ind1, ind2, ind3)
sidlArrayElem4(array, ind1, ind2, ind3, ind4)
sidlArrayElem5(array, ind1, ind2, ind3, ind4, ind5)
sidlArrayElem6(array, ind1, ind2, ind3, ind4, ind5, ind6)
sidlArrayElem7(array, ind1, ind2, ind3, ind4, ind5, ind6, ind7)</TD></TR>
</TABLE><P>
<A NAME="@default262"></A><A NAME="@default263"></A>
Provide access to array elements to arrays of dimension 1–7. This
macro can appear on the left hand side of an assignment or on the
right hand side in an expression. These macros blindly assume that
the dimension and indices are correct.</P><P>The macros to access the address of array elements are unavailable for
arrays of strings, classes, and interfaces.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlArrayAddr1(array, ind1)
sidlArrayAddr2(array, ind1, ind2)
sidlArrayAddr3(array, ind1, ind2, ind3)
sidlArrayAddr4(array, ind1, ind2, ind3, ind4)
sidlArrayAddr5(array, ind1, ind2, ind3, ind4, ind5)
sidlArrayAddr6(array, ind1, ind2, ind3, ind4, ind5, ind6)
sidlArrayAddr7(array, ind1, ind2, ind3, ind4, ind5, ind6, ind7)</TD></TR>
</TABLE><P>
<A NAME="@default264"></A><A NAME="@default265"></A>
Return the address of elements in arrays of dimension 1–7. This
macro can appear on the left hand side of an assignment or on the
right hand side in an expression. These macros blindly assume that
the dimension and indices are correct.</P><!--TOC subsection The C Data Structure-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->The C Data Structure</H3><!--SEC END --><P>
<A NAME="@default266"></A><A NAME="@default267"></A></P><P>If even the macro interface is not fast enough for you, 
you can access the internal data structure for all the basic types except string. 
You cannot access the internal data structure for arrays of strings, 
interfaces and objects.</P><P>The basic form of the C data structure for type XXXX is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>struct</B> sidl__array_vtable {

  <FONT COLOR="blue"><I>/* Release resources associted with the array (refcount at zero) */</I></FONT>
  <B>void</B> (*d_destroy)(<B>struct</B> sidl__array *);

  <FONT COLOR="blue"><I>/* Clone or addRef depending on whether data is borrowed */</I></FONT>
  <B>struct</B> sidl__array *(*d_smartcopy)(<B>struct</B> sidl__array *);

  <FONT COLOR="blue"><I>/* Return the type of the array. */</I></FONT>
  int32_t (*d_arraytype)(<B>void</B>);
};

<B>struct</B> sidl__array {
  int32_t                         *d_lower;
  int32_t                         *d_upper;
  int32_t                         *d_stride;
  <B>const struct</B> sidl__array_vtable *d_vtable;
  int32_t                          d_dimen;
  int32_t                          d_refcount;
};


<B>struct</B> sidl_XXXX__array {
  <B>struct</B> sidl__array       d_metadata;
  &lt;value type <B>for</B> XXXX&gt;   *d_firstElement;
};</TD></TR>
</TABLE><P>The string “&lt;value type for XXXX&gt;” should be replaced by something like 
<TT>sidl_bool</TT>for an array of <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, 
<TT>int32_t</TT> for any array of <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, 
<TT>double</TT> for an array of <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, 
<TT>int64_t</TT> for an array of <FONT COLOR=maroon><I><TT>long</TT></I></FONT>, etc. (See Table <A HREF="#tbl:basics:arraytypes">6.2</A>)</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>d_dimen</B></TT></DT><DD CLASS="dd-description"> tells the dimension of the multi-dimensional array. 
<TT>d_lower</TT>, <TT>d_upper</TT>, and <TT>d_stride</TT> each point to arrays 
of <TT>d_dimen int32_t</TT>’s. <TT>d_lower[i]</TT> provides the lower bound 
for the index in dimension <TT>i</TT>, and <TT>d_upper[i]</TT> provides the upper 
bound for the index in dimension <TT>i</TT>. Both the lower and upper bounds 
are valid index values; the upper bound is not one past the end.</DD><DT CLASS="dt-description"><TT><B>d_borrowed</B></TT></DT><DD CLASS="dd-description"> is true if the array does not managed the data 
that <TT>d_firstElement</TT> points too, and it is false otherwise. This 
mainly influences the behavior of the destructor.<P>Clients should not modify <TT>d_lower</TT>, <TT>d_upper</TT>, <TT>d_stride</TT>, 
<TT>d_dimen</TT>, <TT>d_borrowed</TT> or (in the case of pointers) the values 
to which they point.</P></DD><DT CLASS="dt-description"><TT><B>d_stride[i]</B></TT></DT><DD CLASS="dd-description"> determines how elements are packed in dimension 
<TT>i</TT>. A value of 1 means that to get from element <TT>j</TT> to <TT>j+1</TT> 
in dimension <TT>i</TT>, you add one to the data pointer. Negative values for 
<TT>d_stride</TT> can be used to express a transposed matrix. The definition 
also allows either column or row major ordering for the data, and it also 
allows treating a subsection of an array as an array.</DD></DL><P>The data structure was inspired by the data structure used by Numeric Python; 
although, in Numeric Python, the stride is in terms of bytes. In SIDL, the 
stride is in terms of number of objects. One can convert to the Numeric 
Python view of things by multiplying the stride by the sizeof the value type.</P><!--TOC section Interface Contracts-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">6.5</A>  Interface Contracts</H2><!--SEC END --><P><A NAME="s:ifc_contracts"></A>
<A NAME="@default268"></A>
<A NAME="@default269"></A></P><P>Interface contracts define behaviors expected of callers (or clients) 
and callees (or servers) of methods.
These behaviors are specified within clauses of SIDL interfaces
and classes and may be checked at runtime through options used to establish
an enforcement policy. 
Executable interface contracts thereby provide a mechanism for helping 
ensure software is implemented and used correctly.
This section focuses on specification basics and traditional interface 
contract enforcement options.</P><!--TOC subsection Contract Clauses-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Contract Clauses</H3><!--SEC END --><P><A NAME="ss:intro_contract_clauses"></A>
<EM>Contract clauses</EM> define constraints on properties of methods (including 
argument and return 
values)<SUP><A NAME="text10" HREF="#note10">2</A></SUP> and objects.
Babel supports three types of clauses using SIDL syntax borrowed from 
Eiffel [<A HREF="#meyer97"></A>]. 
Those clauses are:
preconditions,
<A NAME="@default270"></A>
<A NAME="@default271"></A><A NAME="@default272"></A>
postconditions,
<A NAME="@default273"></A>
<A NAME="@default274"></A><A NAME="@default275"></A> and
class invariants.
<A NAME="@default276"></A>
<A NAME="@default277"></A><A NAME="@default278"></A></P><P>Each clause corresponds to a different set of enforcement points.
<EM>Precondition</EM>
<A NAME="@default279"></A>
<A NAME="@default280"></A><A NAME="@default281"></A> 
and <EM>postcondition</EM>
<A NAME="@default282"></A>
<A NAME="@default283"></A><A NAME="@default284"></A> 
clauses are specified on a method basis.
A <EM>precondition</EM> declares constraints on invocation of a method while
a <EM>postcondition</EM> constrains its effects. In some cases, there may
be properties needing to hold throughout the life of an instance of a
class. 
Rather than require the assertions be specified in the precondition and 
postcondition clauses of every method, the 
<EM>class invariant</EM>
<A NAME="@default285"></A>
<A NAME="@default286"></A><A NAME="@default287"></A> 
clause, which can also be specified on interfaces, should be used.</P><P>The general structure of a SIDL method specification is provided below.
The specification defines the method signature; that is, it provides 
the name, parameter list, return type, and any exceptions thrown (or raised) 
by the method.
The SIDL specification can also include the definition of preconditions in 
the <TT>require</TT> clause and postconditions in the <TT>ensure</TT> clause.</P><P><A NAME="@default288"></A><A NAME="@default289"></A>
<A NAME="@default290"></A>
<A NAME="@default291"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [throws &lt;exception&gt;];
      [require &lt;contract-clause-expressions&gt;]
      [ensure &lt;contract-clause-expressions&gt;]</TD></TR>
</TABLE><P>When contract clauses are added to the specification, each method’s 
<TT>throws</TT> clause <EM>must</EM> explicitly list the appropriate 
contract clause violation exception.
The exceptions, as defined in <TT>sidl.sidl</TT>, are shown below.
The need for explicitly declaring the exceptions is based on Babel’s current 
SIDL-to-C++ exceptions mapping in the generated middleware.</P><P><A NAME="@default292"></A>
<A NAME="@default293"></A>
<A NAME="@default294"></A>
<A NAME="@default295"></A>
<A NAME="@default296"></A>
<A NAME="@default297"></A>
<A NAME="@default298"></A>
<A NAME="@default299"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;PreViolation&lt;/code&gt; indicates an assertion within a precondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PreViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {}

  /**
   * &lt;code&gt;PostViolation&lt;/code&gt; indicates an assertion within a postcondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PostViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {}

  /**
   * &lt;code&gt;InvViolation&lt;/code&gt; indicates an assertion within a invariant
   * clause of the interface contract has been violated.
   */
  <B>class</B> InvViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }</I></FONT></TD></TR>
</TABLE><P>The basic structure of a contract clause, including the clause type
(i. e., <TT>require</TT>, <TT>ensure</TT>, or <TT>invariants</TT>),
<A NAME="@default300"></A><A NAME="@default301"></A><A NAME="@default302"></A>
is provided below.
Each clause, when present, contains a list of assertions. 
Each assertion may be preceded by a label. 
The label serves two purposes. First, if thoughtfully written, it provides 
a succinct “description” of the purpose of the assertion in the specification.
Second, through its automatic inclusion in the exception message of a violated
contract, the label helps identify the offended assertion.</P><P><A NAME="@default303"></A>
<A NAME="@default304"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">   &lt;clause-type&gt;
      [label-1:]  &lt;assertion-expression-1&gt;;
     [[label-2:]  &lt;assertion-expression-2&gt;;
                           ...
      [label-n:]  &lt;assertion-expression-n&gt;;]</TD></TR>
</TABLE><P>For example, the SIDL specification of a vector dot product method with a 
contract is:</P><P><A NAME="@default305"></A>
<A NAME="@default306"></A>
<A NAME="@default307"></A>
<A NAME="@default308"></A><A NAME="@default309"></A>
<A NAME="@default310"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/**
 * Return the dot (, inner, or scalar) product of the specified vectors.
 */
<B>double</B> vuDot(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v, <B>in double</B> tol)
  <B>throws</B>
     sidl.PreViolation, sidl.PostViolation;
  <B>require</B>
     not_null_u : u != null;
     u_is_1d : dimen(u) == 1;
     not_null_v : v != null;
     v_is_1d : dimen(v) == 1;
     same_size : size(u) == size(v);
     non_neg_tolerance : tol &gt;= 0.0;
  <B>ensure</B>
     no_side_effects : is pure;
     vuAreEqual(u, v, tol) implies (result &gt;= 0.0);
     (vuIsZero(u, tol) and vuIsZero(v, tol))
       implies nearEqual(result, 0.0, tol);</I></FONT></TD></TR>
</TABLE><P>This specification includes both precondition and postcondition 
clauses.
The precondition clause, identified by <TT>require</TT>, contains six 
executable assertions. 
The first five assertions require the two normal SIDL arrays,
<TT>u</TT> and <TT>v</TT>, be non-null, one-dimensional arrays of the same 
size. The fifth assertion requires the tolerance argument, <TT>tol</TT>, 
be non-negative. 
The postconditions clause, identified by <TT>ensure</TT>, contains three 
assertions.
The <TT>is pure</TT> assertion indicates implementations <EM>should</EM> be 
side-effect free<SUP><A NAME="text11" HREF="#note11">3</A></SUP>.
This allows the method to be included in the contract of another method.
The remaining assertions indicate all implementations of the method must 
ensure the following, assuming the preconditions are satisfied: </P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
if <TT>u</TT> and <TT>v</TT> are equal then the result of calling 
<TT>vuDot</TT> should be non-negative; and
</LI><LI CLASS="li-enumerate">if <TT>u</TT> and <TT>v</TT> are both zero vectors then the result 
should be within the provided tolerance. 
</LI></OL><P>The tolerance argument, <TT>tol</TT>, was only added here to support 
assertions in the postconditions clause. That is, the argument is not 
expected to be needed or used by any implementation of the method.</P><P>It is important to keep in mind that the assertions within interface contracts
only need to hold at the method call boundary.
The implementations of some methods may have to temporarily violate the 
contract during processing.
However, as long as the corresponding assertions hold at the call boundary, 
the contract is not actually violated.</P><P>Optional interface contracts consist of clauses defining obligations on 
callers and callees.
Clauses, when specified, must contain assertions required to hold at the 
appropriate point(s) during execution.
Assertions within precondition (and invariant) clauses must hold immediately
before the method is executed; whereas, postcondition (and invariant) clause
assertions must hold immediately after control returns from the method.
More information on SIDL specifications, including supported operators and
built-in functions, can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC subsection Contract Enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Contract Enforcement</H3><!--SEC END --><P><A NAME="ss:intro_contract_enforcement"></A>
<A NAME="@default311"></A>
<A NAME="@default312"></A>
The options used to establish an interface contract enforcement policy 
should be based on the goals of a particular application run.
During testing and debugging, contract enforcement tends to focus on 
determining whether the caller and callee conform to the specification.
Historically, contract enforcement is disabled during deployment.
Consequently, traditional interface contract enforcement tends to be 
all-or-nothing for one or more type of contract clause.</P><P>The simplest approach is to always enforce all contract clauses.
SIDL provides the <TT>setEnforceAll</TT> helper method, whose specification 
is provided below, for setting the associated enforcement options.
While this strategy makes testing straightforward, it is important
to keep in mind that it carries the risk of not fully testing the compliance
of the codes.
For example, if the test suite is not sufficiently thorough, there is a risk 
of not exposing non-compliance of contract clauses in downstream methods 
when there can be dependencies involving sequences of method calls.</P><P><A NAME="@default313"></A>
<A NAME="@default314"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /**
     * Sets the enforcement policy to always check the specified
     * type(s) of contracts.  This is equivalent to calling
     * setPolicy() with ALWAYS as the enforcement frequency
     * and the specified (or default) contract class.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceAll(<B>in</B> ContractClass contractClass,
                              <B>in bool</B>          clearStats);

    /* ... */
  }</I></FONT></TD></TR>
</TABLE><P>A traditional alternative for test suites singling out callers from 
callees involves separately enforcing precondition and postcondition 
clauses.
For example, when testing whether one or more implementations of an interface
comply with their specification, enforcement is generally limited to
postconditions (with test codes satisfying the preconditions).
Once confidence is gained in the implementation, the callers may be 
tested with only precondition enforcement enabled (with test codes
violating the preconditions).
The full range of clause type-based <TT>ContractClass</TT> options 
are provided below.
Separating clause enforcement in this manner therefore allows test 
suites to distinguish between caller and callee contract compliance.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * Contract classification.  The classification is used to filter
   * contract clauses by the corresponding characteristic(s).
   */
  <B>enum</B> ContractClass {
    /**
     * All classifications of interface contract clauses.
     */
    ALLCLASSES,

    /* ... */

    /**
     * Only invariant clauses.
     */
    INVARIANTS,
    /**
     * Invariant plus postcondition clauses.
     */
    INVPOST,
    /**
     * Invariant plus precondition clauses.
     */
    INVPRE,

    /* ... */

    /**
     * Only postcondition clauses.
     */
    POSTCONDS,
    /**
     * Only precondition clauses.
     */
    PRECONDS,
    /**
     * Precondition plus postcondition clauses.
     */
    PREPOST,

    /* ... */
  };</I></FONT></TD></TR>
</TABLE><P>Assertion enforcement has historically been considered to be too time 
consuming to allow during deployment.
So the traditional approach has been to disable their enforcement.
SIDL provides the <TT>setEnforceNone</TT> helper method, whose specification 
is shown below, for disabling contract enforcement at runtime.</P><P><A NAME="@default315"></A>
<A NAME="@default316"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /* ... */

    /**
     * Sets the policy options to disable all contract enforcement.
     * This is equivalent to calling setPolicy() with NEVER as the
     * enforcement frequency.
     *
     * @param clearStats  TRUE if enforcement statistics are to be
     *                      cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceNone(<B>in bool</B> clearStats);

    /* ... */
  }</I></FONT></TD></TR>
</TABLE><P>Enforcement policies in affect should be based on the goals of a given
execution. 
Testing and debugging with contracts tend to focus on caller and callee
compliance; therefore, enforcement can involve checking all or type-specific
subsets of contract clauses.
Contract enforcement is traditionally disabled during deployment, however.
All of these strategies are supported through two SIDL helper methods.
Language-specific examples of the use of these methods are provided in 
Part <A HREF="#p:supported_langs">II</A>.
Additional information, including advanced and experimental enforcement 
capabilities, can be found in Chapter <A HREF="#c:contracts">21</A>.
</P><!--TOC section SIDL Runtime-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">6.6</A>  SIDL Runtime</H2><!--SEC END --><P><A NAME="s:sidl_runtime"></A>
<A NAME="@default317"></A>
The runtime library supports a collection of interfaces and classes,
some of which form the basis of the SIDL object model while, as discussed
in other sections of this chapter, others provide enhanced capabilities.</P><!--TOC subsection Inheritance-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Inheritance</H3><!--SEC END --><P><A NAME="s:base_inheritance"></A>
<A NAME="@default318"></A>
The object model core consists of base interfaces, classes, and
exceptions.
All interfaces implicitly inherit from
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT><A NAME="@default319"></A><A NAME="@default320"></A>.
Classes implicitly inherit from
<FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT><A NAME="@default321"></A><A NAME="@default322"></A>, 
which implements 
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT><A NAME="@default323"></A><A NAME="@default324"></A>.
Hence, all objects can be cast to <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> and 
<FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT>.
Exceptions must <EM>explicitly</EM> implement the interfaces in 
<FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT><A NAME="@default325"></A><A NAME="@default326"></A>.
The easiest way to do this is to extend 
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT><A NAME="@default327"></A><A NAME="@default328"></A>,
which the basic Exception functionality, including <TT>getNote</TT> and
<TT>setNote</TT>. One or more of these functions can also be overriden.
If a method in SIDL claims to throw an object that does not
inherit from <FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT>, Babel will report it as an error.</P><!--TOC subsection Interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Interfaces</H3><!--SEC END --><P>
The SIDL runtime library supports the six interface categories described
below.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Base</B></DT><DD CLASS="dd-description"> The base class, interface, and exception upon which all 
Babel-enabled software builds.
</DD><DT CLASS="dt-description"><B>Contract Enforcement</B></DT><DD CLASS="dd-description"> Contract enforcement policy class and contract
clause exceptions used to establish enforcement options and identify, at
runtime, contract clause violations, respectively.
</DD><DT CLASS="dt-description"><B>Library Handler</B></DT><DD CLASS="dd-description"> The DLL and Loader classes facilitate dynamic loading
of objects at runtime.
</DD><DT CLASS="dt-description"><B>Introspection</B></DT><DD CLASS="dd-description"> The ClassInfo interface and ClassInfoI class enable
checking meta-data associated with a class.
</DD><DT CLASS="dt-description"><B>I/O</B></DT><DD CLASS="dd-description"> The input-output package used for serializing and deserializing 
SIDL types.
</DD><DT CLASS="dt-description"><B>RMI</B></DT><DD CLASS="dd-description"> The rmi package used for managing remote method invocations.
</DD></DL><P>The associated capabilities, as defined in <TT>sidl.sidl</TT>, are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>//
// File:        sidl.sidl
// Revision:    @(#) $Revision$
// Date:        $Date$
// Description: sidl interface description for the basic sidl run-time library
// 
// Copyright (c) 2001-2007, The Regents of the University of Calfornia.
// Produced at the Lawrence Livermore National Laboratory.
// Written by the Components Team &lt;components@llnl.gov&gt;
// UCRL-CODE-2002-054
// All rights reserved.
// 
// This file is part of Babel. For more information, see
// http://www.llnl.gov/CASC/components/. Please read the COPYRIGHT file
// for Our Notice and the LICENSE file for the GNU Lesser General Public
// License.
// 
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License (as published by
// the Free Software Foundation) version 2.1 dated February 1999.
// 
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
// conditions of the GNU Lesser General Public License for more details.
// 
// You should have recieved a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

/**
 * The &lt;code&gt;sidl&lt;/code&gt; package contains the fundamental type and interface
 * definitions for the &lt;code&gt;sidl&lt;/code&gt; interface definition language.  It
 * defines common run-time libraries and common base classes and interfaces.
 * Every interface implicitly inherits from &lt;code&gt;sidl.BaseInterface&lt;/code&gt;
 * and every class implicitly inherits from &lt;code&gt;sidl.BaseClass&lt;/code&gt;.
 *
 */
<B>final package</B> sidl <B>version</B> 0.9.17 {

  /**
   * Every interface in &lt;code&gt;sidl&lt;/code&gt; implicitly inherits
   * from &lt;code&gt;BaseInterface&lt;/code&gt;, and it is implemented
   * by &lt;code&gt;BaseClass&lt;/code&gt; below.
   */
  <B>interface</B> BaseInterface {

    /**
     * &lt;p&gt;
     * Add one to the intrinsic reference count in the underlying object.
     * Object in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Objects continue to exist as long as the reference count is
     * positive. Clients should call this method whenever they
     * create another ongoing reference to an object or interface.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This does not have a return value because there is no language
     * independent type that can refer to an interface or a
     * class.
     * &lt;/p&gt;
     */
    <B>void</B> addRef();

    /**
     * Decrease by one the intrinsic reference count in the underlying
     * object, and delete the object if the reference is non-positive.
     * Objects in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Clients should call this method whenever they remove a
     * reference to an object or interface.
     */
    <B>void</B> deleteRef();

    /**
     * Return true if and only if &lt;code&gt;obj&lt;/code&gt; refers to the same
     * object as this object.
     */
    <B>bool</B> isSame(<B>in</B> BaseInterface iobj);

    /**
     * Return whether this object is an instance of the specified type.
     * The string name must be the &lt;code&gt;sidl&lt;/code&gt; type name.  This
     * routine will return &lt;code&gt;true&lt;/code&gt; if and only if a cast to
     * the string type name would succeed.
     */
    <B>bool</B> isType(<B>in string</B> name);

    /**
     * Return the meta-data about the class implementing this interface.
     */
    ClassInfo getClassInfo();
  }

  /**
   * Every class implicitly inherits from &lt;code&gt;BaseClass&lt;/code&gt;.  This
   * class implements the methods in &lt;code&gt;BaseInterface&lt;/code&gt;.
   */
  <B>class</B> BaseClass <B>implements</B> BaseInterface {
    /**
     * &lt;p&gt;
     * Add one to the intrinsic reference count in the underlying object.
     * Object in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Objects continue to exist as long as the reference count is
     * positive. Clients should call this method whenever they
     * create another ongoing reference to an object or interface.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This does not have a return value because there is no language
     * independent type that can refer to an interface or a
     * class.
     * &lt;/p&gt;
     */
    <B>final void</B> addRef();

    /**
     * Decrease by one the intrinsic reference count in the underlying
     * object, and delete the object if the reference is non-positive.
     * Objects in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Clients should call this method whenever they remove a
     * reference to an object or interface.
     */
    <B>final void</B> deleteRef();

    /**
     * Return true if and only if &lt;code&gt;obj&lt;/code&gt; refers to the same
     * object as this object.
     */
    <B>final bool</B> isSame(<B>in</B> BaseInterface iobj);

    /**
     * Return whether this object is an instance of the specified type.
     * The string name must be the &lt;code&gt;sidl&lt;/code&gt; type name.  This
     * routine will return &lt;code&gt;true&lt;/code&gt; if and only if a cast to
     * the string type name would succeed.
     */
    <B>bool</B> isType(<B>in string</B> name);

    /**
     * Return the meta-data about the class implementing this interface.
     */
    <B>final</B> ClassInfo getClassInfo();
  }

  /**
   * This package has some I/O capability that's not core to the
   * SIDL object model, but still needed by parts of the generated code
   */
  <B>package</B> io {
    /**
     *   Objects that implement Serializable will be serializable (copyable)
     * over RMI, or storable to streams.  Classes that can pack or unpack
     *  themselves should implement this interface
     */
    <B>interface</B> Serializable {
      <B>void</B> packObj( <B>in</B> Serializer ser );
      <B>void</B> unpackObj( <B>in</B> Deserializer des );
    }
  }

  /**
   * Every exception implements &lt;code&gt;BaseException&lt;/code&gt;. This interface
   * declares the basic functionality to get and set error messages and stack
   * traces.
   */
  <B>interface</B> BaseException <B>extends</B> sidl.io.Serializable{

    /**
     * Return the message associated with the exception.
     */
    <B>string</B> getNote();

    /**
     * Set the message associated with the exception.
     */
    <B>void</B> setNote(<B>in string</B> message);

    /**
     * Returns formatted string containing the concatenation of all
     * tracelines.
     */
    <B>string</B> getTrace();

    /**
     * Adds a stringified entry/line to the stack trace.
     */
    <B>void</B> add[Line](<B>in string</B> traceline);

    /**
     * Formats and adds an entry to the stack trace based on the
     * file name, line number, and method name.
     */
    <B>void</B> add(<B>in string</B> filename, <B>in int</B> lineno, <B>in string</B> methodname);
  }

  /**
   * This exception type is the default exception for every method.
   *
   */
  <B>interface</B> RuntimeException <B>extends</B> BaseException {}

  /**
   * &lt;code&gt;SIDLException&lt;/code&gt; provides the basic functionality of the
   * &lt;code&gt;BaseException&lt;/code&gt; interface for getting and setting error
   * messages and stack traces.
   */
  <B>class</B> SIDLException <B>implements</B>-all BaseException {
  }

  /**
   * &lt;code&gt;PreViolation&lt;/code&gt; indicates an assertion within a precondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PreViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }

  /**
   * &lt;code&gt;PostViolation&lt;/code&gt; indicates an assertion within a postcondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PostViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }

  /**
   * &lt;code&gt;InvViolation&lt;/code&gt; indicates an assertion within a invariant
   * clause of the interface contract has been violated.
   */
  <B>class</B> InvViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }

  /**
   * Contract clause types.
   */
  <B>enum</B> ClauseType {
    INVARIANT,
    PRECONDITION,
    POSTCONDITION,
  };

  /**
   * Contract classification.  The classification is used to filter
   * contract clauses by the corresponding characteristic(s).
   */
  <B>enum</B> ContractClass {
    /**
     * All classifications of interface contract clauses.
     */
    ALLCLASSES,
    /**
     * Only constant-time complexity, or O(1), clauses.
     */
    CONSTANT,
    /**
     * Only cubic-time complexity, or O(n^3), clauses.
     */
    CUBIC,
    /**
     * Only invariant clauses.
     */
    INVARIANTS,
    /**
     * Invariant plus postcondition clauses.
     */
    INVPOST,
    /**
     * Invariant plus precondition clauses.
     */
    INVPRE,
    /**
     * Only linear-time complexity, or O(n), clauses.
     */
    LINEAR,
    /**
     * Method calls.  Only clauses containing at least one method call.
     */
    METHODCALLS,
    /**
     * Only postcondition clauses.
     */
    POSTCONDS,
    /**
     * Only precondition clauses.
     */
    PRECONDS,
    /**
     * Precondition plus postcondition clauses.
     */
    PREPOST,
    /**
     * Only quadratic-time complexity, or O(n^2), clauses.
     */
    QUADRATIC,
    /**
     * Only quartic-time complexity, or O(n^4), clauses.
     */
    QUARTIC,
    /**
     * Only quintic-time complexity, or O(n^5), clauses.
     */
    QUINTIC,
    /**
     * Results.  Only clauses containing at least one assertion on an
     * out, inout, or result argument.
     */
    RESULTS,
    /**
     * Only septic-time complexity, or O(n^7), clauses.
     */
    SEPTIC,
    /**
     * Only sextic-time complexity, or O(n^6), clauses.
     */
    SEXTIC,
    /**
     * Simple expressions.  Only clauses consisting solely of
     * simple expressions (i.e., no method calls).
     */
    SIMPLEEXPRS,
  };

  /**
   * Contract clause enforcement frequency.
   */
  <B>enum</B> EnforceFreq {
    /**
     * Never.  Disable enforcement by completely by-passing checks
     * regardless of the selected contract classification.
     */
    NEVER,
    /**
     * Always.  Every clause of the selected contract classification
     * is enforced.
     */
    ALWAYS,
    /**
     * Adaptive fit.  Check clauses of the selected contract classification
     * only if they will not result in exceeding the overhead limit based
     * on accumulations of estimated execution times.
     */
    ADAPTFIT,
    /**
     * Adaptive timing.  Check clauses of the selected contract classification
     * only if their estimated execution time is within the overhead limit
     * applied to the estimated time of the corresponding method.
     */
    ADAPTTIMING,
    /**
     * Periodic.  Check clauses of the selected contract classification
     * at the specified interval.
     */
    PERIODIC,
    /**
     * Random.  Check clauses of the selected contract classifcation on a
     * random basis using the specified maximum.
     */
    RANDOM,
    /**
     * Simulated Annealing.  Essentially Adaptive fit but checks are
     * allowed to randomly exceed the overhead limit with decreasing
     * probability over time.
     */
    SIMANNEAL,
  };

  /**
   * Contract enforcement tracing levels.  Enforcement traces rely on
   * runtime timing automatically inserted within the middleware.
   */
  <B>enum</B> EnfTraceLevel {
    /**
     * None.  No tracing is to be performed.
     */
    NONE,
    /**
     * Core.  Time trace start and end only.  This can be useful for
     * simple program timing.
     */
    CORE,
    /**
     * Basic enforcement tracing.  CORE plus interface contract clause timing.
     */
    BASIC,
    /**
     * Overhead of enforcement decisions.  BASIC plus timing of
     * enforcement decisions.  (Experimental feature.)
     */
    OVERHEAD,
  };

  /**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /**
     * Sets the enforcement policy to always check the specified
     * type(s) of contracts.  This is equivalent to calling
     * setPolicy() with ALWAYS as the enforcement frequency
     * and the specified (or default) contract class.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceAll(<B>in</B> ContractClass contractClass,
                              <B>in bool</B>          clearStats);

    /**
     * Sets the policy options to disable all contract enforcement.
     * This is equivalent to calling setPolicy() with NEVER as the
     * enforcement frequency.
     *
     * @param clearStats  TRUE if enforcement statistics are to be
     *                      cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceNone(<B>in bool</B> clearStats);

    /**
     * Sets enforcement policy and options.  This method should be
     * invoked directly to avoid the default enforcement behavior.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param enforceFreq    Enforcement frequency
     *                         [Default = ALWAYS]
     * @param interval       Sampling interval representing the
     *                         period (for PERIODIC) or maximum
     *                         random number/window (for RANDOM)
     *                         [Default = 0 if negative specified]
     * @param overheadLimit  Limit on performance overhead [0.0 .. 1.0)
     *                         [Default = 0.0 (or 0%) if negative]
     * @param appAvgPerCall  Average extra, application-specific
     *                         execution time, normalized by calls
     *                         to annotated methods
     *                         [Default = 0.0 if negative]
     * @param annealLimit    Limit on simulated annealing function
     *                         to ensure its termination
     *                         (0.0 .. 2.72]
     *                         [Default = 2.72 if negative specified]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setPolicy(<B>in</B> ContractClass contractClass,
                          <B>in</B> EnforceFreq   enforceFreq,
                          <B>in int</B>           interval,
                          <B>in double</B>        overheadLimit,
                          <B>in double</B>        appAvgPerCall,
                          <B>in double</B>        annealLimit,
                          <B>in bool</B>          clearStats);

    /**
     * Returns TRUE if contract enforcement is enabled; FALSE otherwise.
     */
    <B>static bool</B> areEnforcing();

    /**
     * Returns the contract classification policy option.
     */
    <B>static</B> ContractClass getContractClass();

    /**
     * Returns the enforcement frequency policy option.
     */
    <B>static</B> EnforceFreq getEnforceFreq();

    /**
     * Returns the interval for PERIODIC (i.e., the interval) or
     * RANDOM (i.e., the maximum random number).  Returns 0 by default.
     */
    <B>static int</B> getSamplingInterval();

    /**
     * Returns the desired enforcement overhead limit for
     * performance-driven frequency options (i.e., ADAPTFIT,
     * ADAPTTIMING, and SIMANNEAL).  Returns 0.0 by default.
     */
    <B>static double</B> getOverheadLimit();

    /**
     * Returns the average assumed execution time associated
     * with the program or application.  Returns 0.0 by default.
     */
    <B>static double</B> getAppAvgPerCall();

    /**
     * Returns the annealing limit for SIMANNEAL enforcement
     * frequency option.  Returns 0.0 by default.
     */
    <B>static double</B> getAnnealLimit();

    /**
     * Returns the name, or description, of the enforcement policy.
     * The caller is responsible for calling sidl_String_free()
     * on the name when done with it.
     *
     * @param useAbbrev   TRUE if the abbreviated name is to be
     *                    returned.
     */
    <B>static string</B> getPolicyName(<B>in bool</B> useAbbrev);

    /**
     * Prints statistics data to the file with the specified name.
     * The file is opened (for append) and closed on each call.
     *
     * @param filename   Name of the file to which the statistics
     *                     data should be written.
     * @param header     TRUE if the header line is to be printed
     *                     prior to the statistics line (for compressed
     *                     output only).
     * @param prefix     String description for identifying information,
     *                     if any, intended to preceed the statistics
     *                     data.  Useful for distinguishing between
     *                     different objects, for example.
     * @param compressed TRUE if the enforcer state is to be dumped
     *                     on a single line with semi-colon separators
     *                     between fields.
     */
    <B>static void</B> dumpStats(<B>in string</B> filename,
                          <B>in bool</B>   header,
                          <B>in string</B> prefix,
                          <B>in bool</B>   compressed);

    /**
     * Starts enforcement trace file generation.
     *
     * @param filename    Name of the destination trace file.
     * @param traceLevel  Level of trace timing and reporting required.
     *                      [Default = NONE]
     */
    <B>static void</B> startTrace(<B>in string</B>        filename,
                           <B>in</B> EnfTraceLevel traceLevel);

    /**
     * Returns TRUE if contract enforcement tracing is enabled;
     * FALSE otherwise.
     */
    <B>static bool</B> areTracing();

    /**
     * Returns the name of the trace file.  If one was not provided,
     * the default name is returned.
     */
    <B>static string</B> getTraceFilename();

    /**
     * Returns the level of enforcement tracing.
     */
    <B>static</B> EnfTraceLevel getTraceLevel();

    /**
     * Terminates enforcement trace file generation.  Takes a final
     * timestamp and logs the remaining trace information.
     */
    <B>static void</B> endTrace();
  }


  /**
   * When loading a dynamically linked library, there are three
   * settings: LOCAL, GLOBAL and SCLSCOPE.
   */
  <B>enum</B> Scope {
      /** Attempt to load the symbols into a local namespace. */
      LOCAL,
      /** Attempt to load the symbols into the global namespace. */
      GLOBAL,
      /** Use the scope setting from the SCL file. */
      SCLSCOPE
      }

  /**
   * When loading a dynmaically linked library, there are three
   * settings: LAZY, NOW, SCLRESOLVE
   */
  <B>enum</B> Resolve {
    /** Resolve symbols on an as needed basis. */
    LAZY,
      /** Resolve all symbols at load time. */
      NOW,
      /** Use the resolve setting from the SCL file. */
      SCLRESOLVE
      }

  /**
   * The &lt;code&gt;DLL&lt;/code&gt; class encapsulates access to a single
   * dynamically linked library.  DLLs are loaded at run-time using
   * the &lt;code&gt;loadLibrary&lt;/code&gt; method and later unloaded using
   * &lt;code&gt;unloadLibrary&lt;/code&gt;.  Symbols in a loaded library are
   * resolved to an opaque pointer by method &lt;code&gt;lookupSymbol&lt;/code&gt;.
   * Class instances are created by &lt;code&gt;createClass&lt;/code&gt;.
   */
  <B>class</B> DLL {

    /**
     * Load a dynamic link library using the specified URI.  The
     * URI may be of the form "main:", "lib:", "file:", "ftp:", or
     * "http:".  A URI that starts with any other protocol string
     * is assumed to be a file name.  The "main:" URI creates a
     * library that allows access to global symbols in the running
     * program's main address space.  The "lib:X" URI converts the
     * library "X" into a platform-specific name (e.g., libX.so) and
     * loads that library.  The "file:" URI opens the DLL from the
     * specified file path.  The "ftp:" and "http:" URIs copy the
     * specified library from the remote site into a local temporary
     * file and open that file.  This method returns true if the
     * DLL was loaded successfully and false otherwise.  Note that
     * the "ftp:" and "http:" protocols are valid only if the W3C
     * WWW library is available.
     *
     * @param uri          the URI to load. This can be a .la file
     *                     (a metadata file produced by libtool) or
     *                     a shared library binary (i.e., .so,
     *                     .dll or whatever is appropriate for your
     *                     OS)
     * @param loadGlobally &lt;code&gt;true&lt;/code&gt; means that the shared
     *                     library symbols will be loaded into the
     *                     global namespace; &lt;code&gt;false&lt;/code&gt;
     *                     means they will be loaded into a
     *                     private namespace. Some operating systems
     *                     may not be able to honor the value presented
     *                     here.
     * @param loadLazy     &lt;code&gt;true&lt;/code&gt; instructs the loader to
     *                     that symbols can be resolved as needed (lazy)
     *                     instead of requiring everything to be resolved
     *                     now (at load time).
     */
    <B>bool</B> loadLibrary(<B>in string</B> uri,
                     <B>in bool</B> loadGlobally,
                     <B>in bool</B> loadLazy);

    /**
     * Get the library name.  This is the name used to load the
     * library in &lt;code&gt;loadLibrary&lt;/code&gt; except that all file names
     * contain the "file:" protocol.
     */
    <B>string</B> getName();

    /**
     * Return true if the library was loaded into the global namespace.
     */
    <B>bool</B> isGlobal();

    /**
     * Return true if the library was loaded using lazy symbol resolution.
     */
    <B>bool</B> isLazy();

    /**
     * Unload the dynamic link library.  The library may no longer
     * be used to access symbol names.  When the library is actually
     * unloaded from the memory image depends on details of the operating
     * system.
     */
    <B>void</B> unloadLibrary();

    /**
     * Lookup a symbol from the DLL and return the associated pointer.
     * A null value is returned if the name does not exist.
     */
    <B>opaque</B> lookupSymbol(<B>in string</B> linker_name);

    /**
     * Create an instance of the sidl class.  If the class constructor
     * is not defined in this DLL, then return null.
     */
    BaseClass createClass(<B>in string</B> sidl_name);
  }

  /**
   * Interface &lt;code&gt;Finder&lt;/code&gt; is an interface for classes that resolve
   * dynamic libraries.
   * Class &lt;code&gt;Loader&lt;/code&gt; takes one of these interfaces through the
   * method &lt;code&gt;setFinder&lt;/code&gt;.  If NULL is passed to setFinder, the
   * class &lt;code&gt;DefaultFinder&lt;/code&gt; is used.
   */
  <B>interface</B> Finder {
    /**
     * Find a DLL containing the specified information for a sidl
     * class. This method searches through the files in set set path
     * looking for a shared library that contains the client-side or IOR
     * for a particular sidl class.
     *
     * @param sidl_name  the fully qualified (long) name of the
     *                   class/interface to be found. Package names
     *                   are separated by period characters from each
     *                   other and the class/interface name.
     * @param target     to find a client-side binding, this is
     *                   normally the name of the language.
     *                   To find the implementation of a class
     *                   in order to make one, you should pass
     *                   the string "ior/impl" here.
     * @param lScope     this specifies whether the symbols should
     *                   be loaded into the global scope, a local
     *                   scope, or use the setting in the file.
     * @param lResolve   this specifies whether symbols should be
     *                   resolved as needed (LAZY), completely
     *                   resolved at load time (NOW), or use the
     *                   setting from the file.
     * @return a non-NULL object means the search was successful.
     *         The DLL has already been added.
     */
    DLL findLibrary(<B>in string</B>  sidl_name,
                    <B>in string</B>  target,
                    <B>in</B> Scope   lScope,
                    <B>in</B> Resolve lResolve);

    /**
     * Set the search path, which is a semi-colon separated sequence of
     * URIs as described in class &lt;code&gt;DLL&lt;/code&gt;.  This method will
     * invalidate any existing search path.
     */
    <B>void</B> setSearchPath(<B>in string</B> path_name);

    /**
     * Return the current search path.  If the search path has not been
     * set, then the search path will be taken from environment variable
     * SIDL_DLL_PATH.
     */
    <B>string</B> getSearchPath();

    /**
     * Append the specified path fragment to the beginning of the
     * current search path.  If the search path has not yet been set
     * by a call to &lt;code&gt;setSearchPath&lt;/code&gt;, then this fragment will
     * be appended to the path in environment variable SIDL_DLL_PATH.
     */
    <B>void</B> addSearchPath(<B>in string</B> path_fragment);

  }

  /**
   *  This class is the Default Finder.  If no Finder is set in class Loader,
   *  this finder is used.  It uses SCL files from the filesystem to
   *  resolve dynamic libraries.
   *
   * The initial search path is taken from the SIDL_DLL_PATH
   * environment variable.
   */

  <B>class</B> DFinder <B>implements</B>-all Finder {
  }


  /**
   * Class &lt;code&gt;Loader&lt;/code&gt; manages dyanamic loading and symbol name
   * resolution for the sidl runtime system.  The &lt;code&gt;Loader&lt;/code&gt; class
   * manages a library search path and keeps a record of all libraries
   * loaded through this interface, including the initial "global" symbols
   * in the main program.
   *
   * Unless explicitly set, the &lt;code&gt;Loader&lt;/code&gt; uses the default
   * &lt;code&gt;sidl.Finder&lt;/code&gt; implemented in &lt;code&gt;sidl.DFinder&lt;/code&gt;.
   * This class searches the filesystem for &lt;code&gt;.scl&lt;/code&gt; files when
   * trying to find a class. The initial path is taken from the
   * environment variable SIDL_DLL_PATH, which is a semi-colon
   * separated sequence of URIs as described in class &lt;code&gt;DLL&lt;/code&gt;.
   */
  <B>class</B> Loader {

    /**
     * Load the specified library if it has not already been loaded.
     * The URI format is defined in class &lt;code&gt;DLL&lt;/code&gt;.  The search
     * path is not searched to resolve the library name.
     *
     * @param uri          the URI to load. This can be a .la file
     *                     (a metadata file produced by libtool) or
     *                     a shared library binary (i.e., .so,
     *                     .dll or whatever is appropriate for your
     *                     OS)
     * @param loadGlobally &lt;code&gt;true&lt;/code&gt; means that the shared
     *                     library symbols will be loaded into the
     *                     global namespace; &lt;code&gt;false&lt;/code&gt;
     *                     means they will be loaded into a
     *                     private namespace. Some operating systems
     *                     may not be able to honor the value presented
     *                     here.
     * @param loadLazy     &lt;code&gt;true&lt;/code&gt; instructs the loader to
     *                     that symbols can be resolved as needed (lazy)
     *                     instead of requiring everything to be resolved
     *                     now.
     * @return if the load was successful, a non-NULL DLL object is returned.
     */
    <B>static</B> DLL loadLibrary(<B>in string</B> uri,
                           <B>in bool</B> loadGlobally,
                           <B>in bool</B> loadLazy);

    /**
     * Append the specified DLL to the beginning of the list of already
     * loaded DLLs.
     */
    <B>static void</B> addDLL(<B>in</B> DLL dll);

    /**
     * Unload all dynamic link libraries.  The library may no longer
     * be used to access symbol names.  When the library is actually
     * unloaded from the memory image depends on details of the operating
     * system.
     */
    <B>static void</B> unloadLibraries();

    /**
     * Find a DLL containing the specified information for a sidl
     * class. This method searches SCL files in the search path looking
     * for a shared library that contains the client-side or IOR
     * for a particular sidl class.
     *
     * This call is implemented by calling the current
     * &lt;code&gt;Finder&lt;/code&gt;. The default finder searches the local
     * file system for &lt;code&gt;.scl&lt;/code&gt; files to locate the
     * target class/interface.
     *
     * @param sidl_name  the fully qualified (long) name of the
     *                   class/interface to be found. Package names
     *                   are separated by period characters from each
     *                   other and the class/interface name.
     * @param target     to find a client-side binding, this is
     *                   normally the name of the language.
     *                   To find the implementation of a class
     *                   in order to make one, you should pass
     *                   the string "ior/impl" here.
     * @param lScope     this specifies whether the symbols should
     *                   be loaded into the global scope, a local
     *                   scope, or use the setting in the SCL file.
     * @param lResolve   this specifies whether symbols should be
     *                   resolved as needed (LAZY), completely
     *                   resolved at load time (NOW), or use the
     *                   setting from the SCL file.
     * @return a non-NULL object means the search was successful.
     *         The DLL has already been added.
     */
    <B>static</B> DLL findLibrary(<B>in string</B>  sidl_name,
                           <B>in string</B>  target,
                           <B>in</B> Scope   lScope,
                           <B>in</B> Resolve lResolve);

    /**
     * Set the search path, which is a semi-colon separated sequence of
     * URIs as described in class &lt;code&gt;DLL&lt;/code&gt;.  This method will
     * invalidate any existing search path.
     *
     * This updates the search path in the current &lt;code&gt;Finder&lt;/code&gt;.
     */
    <B>static void</B> setSearchPath(<B>in string</B> path_name);

    /**
     * Return the current search path.  The default
     * &lt;code&gt;Finder&lt;/code&gt; initializes the search path
     * from environment variable SIDL_DLL_PATH.
     *
     */
    <B>static string</B> getSearchPath();

    /**
     * Append the specified path fragment to the beginning of the
     * current search path.  This method operates on the Loader's
     * current &lt;code&gt;Finder&lt;/code&gt;. This will add a path to the
     * current search path. Normally, the search path is initialized
     * from the SIDL_DLL_PATH environment variable.
     */
    <B>static void</B> addSearchPath(<B>in string</B> path_fragment);

    /**
     * This method sets the &lt;code&gt;Finder&lt;/code&gt; that
     * &lt;code&gt;Loader&lt;/code&gt; will use to find DLLs.  If no
     * &lt;code&gt;Finder&lt;/code&gt; is set or if NULL is passed in, the Default
     * Finder &lt;code&gt;DFinder&lt;/code&gt; will be used.
     *
     * Future calls to &lt;code&gt;findLibrary&lt;/code&gt;,
     * &lt;code&gt;addSearchPath&lt;/code&gt;, &lt;code&gt;getSearchPath&lt;/code&gt;, and
     * &lt;code&gt;setSearchPath&lt;/code&gt; are deligated to the
     * &lt;code&gt;Finder&lt;/code&gt; set here.
     */
    <B>static void</B> setFinder(<B>in</B> Finder f);

    /**
     * This method gets the &lt;code&gt;Finder&lt;/code&gt; that &lt;code&gt;Loader&lt;/code&gt;
     * uses to find DLLs.
     */
    <B>static</B> Finder getFinder();
  }

  /**
   * This provides an interface to the meta-data available on the
   * class.
   */
  <B>interface</B> ClassInfo {
    /**
     * Return the name of the class.
     */
    <B>string</B> getName();

    /**
     * Return the version number of the class. This should be a string
     * with a sequence of numbers separated by periods.
     */
    <B>string</B> getVersion();

    /**
     * Get the version of the intermediate object representation.
     * This will be in the form of major_version.minor_version.
     */
    <B>string</B> getIORVersion();
  }

  /**
   * An implementation of the &lt;code&gt;ClassInfo&lt;/code&gt; interface. This
   * provides methods to set all the attributes that are read-only in
   * the &lt;code&gt;ClassInfo&lt;/code&gt; interface.
   */
  <B>class</B> ClassInfoI <B>implements</B>-all ClassInfo {
    /**
     * Set the name of the class.
     */
    <B>final void</B> setName(<B>in string</B> name);

    /**
     * Set the version number of the class.
     */
    <B>final void</B> setVersion(<B>in string</B> ver);

    /**
     * Set the IOR major and minor version numbers.
     */
    <B>final void</B> setIORVersion(<B>in int</B> major, <B>in int</B> minor);
  }

  /**
   * Exception thrown from Babel internals when memory allocation
   * fails.  This exception is special in that it avoids any memory
   * allocation.  For this reason, the trace or note may be truncated
   * to fit in the preallocated buffers.
   */
  <B>class</B> MemAllocException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {

    /**
     * Returns the preallocated copy of this exception.  Any
     * failure of memory allocation should throw the exception returned
     * by this method to avoid further allocation failures.
     */
    <B>static</B> MemAllocException getSingletonException();

    /**
     * Return the message associated with the exception.
     */
    <B>string</B> getNote();

    /**
     * Set the message associated with the exception.
     */
    <B>void</B> setNote(<B>in string</B> message);

    /**
     * Returns formatted string containing the concatenation of all
     * tracelines.
     */
    <B>string</B> getTrace();

    /**
     * Adds a stringified entry/line to the stack trace.
     */
    <B>void</B> add[Line](<B>in string</B> traceline);

    /**
     * Formats and adds an entry to the stack trace based on the
     * file name, line number, and method name.
     */
    <B>void</B> add(<B>in string</B> filename, <B>in int</B> lineno, <B>in string</B> methodname);

  }

  /**
   * Exception is thrown when a cast fails and the failure needs to
   * be communicated up the call stack.  (Note: babel _cast does NOT
   * throw this exception)
   */
  <B>class</B> CastException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {
  }

  /**
   * This Exception is thrown by the Babel runtime when a non SIDL
   * exception is thrown from an exception throwing language such as
   * C++ or Java.
   */
  <B>class</B> LangSpecificException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {
  }

  /**
   * This Exception is thrown when a method is called that an
   * implmentation has not been written for yet.  The throw code is
   * placed into the _Impl files automatically when they are generated.
   */
  <B>class</B> NotImplementedException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {
  }


  /**
   * This package has some I/O capability that's not core to the SIDL
   * object model, but still needed by parts of the generated code
   */
  <B>package</B> io {

    /** generic exception for I/O issues */
    <B>class</B> IOException <B>extends</B> sidl.SIDLException
      <B>implements</B> RuntimeException {
    }


    /**
     * Standard interface for packing Babel types
     */
    <B>interface</B> Serializer {
      <B>void</B> packBool( <B>in string</B> key, <B>in bool</B> value )
         ;
      <B>void</B> packChar( <B>in string</B> key, <B>in char</B> value )
         ;
      <B>void</B> packInt( <B>in string</B> key, <B>in int</B> value )
         ;
      <B>void</B> packLong( <B>in string</B> key, <B>in long</B> value )
         ;
      <B>void</B> packOpaque(  <B>in string</B> key, <B>in opaque</B> value )
         ;
      <B>void</B> packFloat( <B>in string</B> key, <B>in float</B> value )
         ;
      <B>void</B> packDouble( <B>in string</B> key, <B>in double</B> value )
         ;
      <B>void</B> packFcomplex( <B>in string</B> key, <B>in fcomplex</B> value )
         ;
      <B>void</B> packDcomplex( <B>in string</B> key, <B>in dcomplex</B> value )
         ;
      <B>void</B> packString( <B>in string</B> key, <B>in string</B> value )
         ;
      <B>void</B> packSerializable( <B>in string</B> key, <B>in</B> Serializable value )
        ;

      /**
       * pack arrays of values.  It is possible to ensure an array is
       * in a certain order by passing in ordering and dimension
       * requirements.  ordering should represent a value in the
       * sidl_array_ordering enumeration in sidlArray.h If either
       * argument is 0, it means there is no restriction on that
       * aspect.  The boolean reuse_array flag is set to true if the
       * remote unserializer should try to reuse the array that is
       * passed into it or not.
       */
      <B>void</B> packBoolArray( <B>in string</B> key, <B>in array</B>&lt;<B>bool</B>&gt; value,
                          <B>in int</B> ordering, <B>in int</B> dimen,
                          <B>in bool</B> reuse_array );
      <B>void</B> packCharArray( <B>in string</B> key, <B>in array</B>&lt;<B>char</B>&gt; value,
                          <B>in int</B> ordering, <B>in int</B> dimen,
                          <B>in bool</B> reuse_array );
      <B>void</B> packIntArray( <B>in string</B> key, <B>in array</B>&lt;<B>int</B>&gt; value,
                         <B>in int</B> ordering, <B>in int</B> dimen,
                         <B>in bool</B> reuse_array );
      <B>void</B> packLongArray( <B>in string</B> key, <B>in array</B>&lt;<B>long</B>&gt; value,
                          <B>in int</B> ordering, <B>in int</B> dimen,
                          <B>in bool</B> reuse_array );
      <B>void</B> packOpaqueArray( <B>in string</B> key, <B>in array</B>&lt;<B>opaque</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> reuse_array );
      <B>void</B> packFloatArray( <B>in string</B> key, <B>in array</B>&lt;<B>float</B>&gt; value,
                           <B>in int</B> ordering, <B>in int</B> dimen,
                           <B>in bool</B> reuse_array );
      <B>void</B> packDoubleArray( <B>in string</B> key, <B>in array</B>&lt;<B>double</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> reuse_array );
      <B>void</B> packFcomplexArray( <B>in string</B> key, <B>in array</B>&lt;<B>fcomplex</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> reuse_array );
      <B>void</B> packDcomplexArray( <B>in string</B> key, <B>in array</B>&lt;<B>dcomplex</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> reuse_array );
      <B>void</B> packStringArray( <B>in string</B> key, <B>in array</B>&lt;<B>string</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> reuse_array );
      <B>void</B> packGenericArray( <B>in string</B> key, <B>in array</B>&lt;&gt; value,
                             <B>in bool</B> reuse_array );
      <B>void</B> packSerializableArray( <B>in string</B> key,
                                  <B>in array</B>&lt;Serializable&gt; value,
                                  <B>in int</B> ordering, <B>in int</B> dimen,
                                  <B>in bool</B> reuse_array );
    }

    /**
     * Standard interface for unpacking Babel types
     */
    <B>interface</B> Deserializer {
      /* unpack values */
      <B>void</B> unpackBool( <B>in string</B> key, <B>inout bool</B> value );
      <B>void</B> unpackChar( <B>in string</B> key, <B>inout char</B> value );
      <B>void</B> unpackInt( <B>in string</B> key, <B>inout int</B> value );
      <B>void</B> unpackLong( <B>in string</B> key, <B>inout long</B> value );
      <B>void</B> unpackOpaque( <B>in string</B> key, <B>inout opaque</B> value );
      <B>void</B> unpackFloat( <B>in string</B> key, <B>inout float</B> value );
      <B>void</B> unpackDouble( <B>in string</B> key, <B>inout double</B> value );
      <B>void</B> unpackFcomplex( <B>in string</B> key, <B>inout fcomplex</B> value );
      <B>void</B> unpackDcomplex( <B>in string</B> key, <B>inout dcomplex</B> value );
      <B>void</B> unpackString( <B>in string</B> key, <B>inout string</B> value );
      <B>void</B> unpackSerializable( <B>in string</B> key, <B>inout</B> Serializable value );

      /** unpack arrays of values
       * It is possible to ensure an array is
       * in a certain order by passing in ordering and dimension
       * requirements.  ordering should represent a value in the
       * sidl_array_ordering enumeration in sidlArray.h If either
       * argument is 0, it means there is no restriction on that
       * aspect.  The rarray flag should be set if the array being
       * passed in is actually an rarray.  The semantics are slightly
       * different for rarrays.  The passed in array MUST be reused,
       * even if the array has changed bounds.
       */
      <B>void</B> unpackBoolArray( <B>in string</B> key, <B>inout array</B>&lt;<B>bool</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> isRarray );
      <B>void</B> unpackCharArray( <B>in string</B> key, <B>inout array</B>&lt;<B>char</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> isRarray  );
      <B>void</B> unpackIntArray( <B>in string</B> key, <B>inout array</B>&lt;<B>int</B>&gt; value,
                           <B>in int</B> ordering, <B>in int</B> dimen,
                           <B>in bool</B> isRarray  );
      <B>void</B> unpackLongArray( <B>in string</B> key, <B>inout array</B>&lt;<B>long</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> isRarray  );
      <B>void</B> unpackOpaqueArray( <B>in string</B> key, <B>inout array</B>&lt;<B>opaque</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> isRarray  );
      <B>void</B> unpackFloatArray( <B>in string</B> key, <B>inout array</B>&lt;<B>float</B>&gt; value,
                             <B>in int</B> ordering, <B>in int</B> dimen,
                             <B>in bool</B> isRarray  );
      <B>void</B> unpackDoubleArray( <B>in string</B> key, <B>inout array</B>&lt;<B>double</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> isRarray  );
      <B>void</B> unpackFcomplexArray( <B>in string</B> key, <B>inout array</B>&lt;<B>fcomplex</B>&gt; value,
                                <B>in int</B> ordering, <B>in int</B> dimen,
                                <B>in bool</B> isRarray  );
      <B>void</B> unpackDcomplexArray( <B>in string</B> key,
                                <B>inout array</B>&lt;<B>dcomplex</B>&gt; value,
                                <B>in int</B> ordering, <B>in int</B> dimen,
                                <B>in bool</B> isRarray  );
      <B>void</B> unpackStringArray( <B>in string</B> key, <B>inout array</B>&lt;<B>string</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> isRarray  );
      <B>void</B> unpackGenericArray( <B>in string</B> key, <B>inout array</B>&lt;&gt; value);
      <B>void</B> unpackSerializableArray( <B>in string</B> key,
                                    <B>inout array</B>&lt;Serializable&gt; value,
                                    <B>in int</B> ordering, <B>in int</B> dimen,
                                    <B>in bool</B> isRarray  );
    }

  } //end package io

  /**
   * This package contains necessary interfaces for RMI protocols to
   * hook into Babel, plus a Protocol Factory class.  The intention is
   * that authors of new protocols will create classes that implement
   * InstanceHandle, Invocation and Response (they could even have one
   * object that implements all three interfaces).
   */
  <B>package</B> rmi {

    /**
     * Generic Network Exception
     */
    <B>class</B> NetworkException <B>extends</B> sidl.io.IOException {
      <B>int</B> getHopCount();
      <B>void</B> packObj( <B>in</B> sidl.io.Serializer ser );
      <B>void</B> unpackObj( <B>in</B> sidl.io.Deserializer des );
      <B>void</B> setErrno(<B>in int</B> err);
      <B>int</B> getErrno();
    }

    /**
     * This exception is thrown by the RMI library when a
     * host can not be found by a DNS lookup.
     */
    <B>class</B> UnknownHostException <B>extends</B> NetworkException {}

    /**
     * This exception is normally thrown by the RMI library when the
     * server is started up and the port it is assigned to use is
     * already in use.
     */
    <B>class</B> BindException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when an
     * attempt to connect to a remote host fails.
     */
    <B>class</B> ConnectException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when a host
     * can be found by DNS, but is not reachable.  It usually means
     * a router is down.
     */
    <B>class</B> NoRouteToHostException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when a request
     * times out.
     */
    <B>class</B> TimeOutException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when the network
     * unexpected loses it's connection.  Can be caused by reset,
     * software connection abort, connection reset by peer, etc.
     */
    <B>class</B> UnexpectedCloseException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by a server when a passed in object
     * id does not match any known object.
     */
    <B>class</B> ObjectDoesNotExistException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when a passed in URL
     * is malformed.
     */
    <B>class</B> MalformedURLException <B>extends</B> NetworkException {}

    /**
     * This is a base class for all protocol specific exceptions.
     */
    <B>class</B> ProtocolException <B>extends</B> NetworkException {}

    /**
     * This exception thrown when one attempts to pass a local object remotely but
     * there is no local server running to serve the object
     */
    <B>class</B> NoServerException <B>extends</B> NetworkException {}

    /**
     * This singleton class keeps a table of string prefixes
     * (e.g. "babel" or "proteus") to protocol implementations.  The
     * intent is to parse a URL (e.g. "babel://server:port/class") and
     * create classes that implement
     * &lt;code&gt;sidl.rmi.InstanceHandle&lt;/code&gt;.
     */
    <B>class</B> ProtocolFactory {
      /**
       * Associate a particular prefix in the URL to a typeName
       * &lt;code&gt;sidl.Loader&lt;/code&gt; can find.  The actual type is
       * expected to implement &lt;code&gt;sidl.rmi.InstanceHandle&lt;/code&gt;
       * Return true iff the addition is successful.  (no collisions
       * allowed)
       */
      <B>static bool</B> addProtocol( <B>in string</B> prefix, <B>in string</B> typeName );

      /**
       * Return the typeName associated with a particular prefix.
       * Return empty string if the prefix
       */
      <B>static string</B> getProtocol( <B>in string</B> prefix );

      /**
       * Remove a protocol from the active list.
       */
      <B>static bool</B> deleteProtocol( <B>in string</B> prefix );

      /**
       * Create a new remote object and return an instance handle for that
       * object.
       * The server and port number are in the url.  Return nil
       * if protocol unknown or InstanceHandle.init() failed.
       */
      <B>static</B> InstanceHandle createInstance( <B>in string</B> url,
                                            <B>in string</B> typeName );

      /**
       * Create an new connection linked to an already existing
       * object on a remote server.  The server and port number are in
       * the url, the objectID is the unique ID of the remote object
       * in the remote instance registry.  Return null if protocol
       * unknown or InstanceHandle.init() failed.  The boolean addRef
       * should be true if connect should remotely addRef
       */
      <B>static</B> InstanceHandle connectInstance( <B>in string</B> url,
                                             <B>in string</B> typeName,
                                             <B>in bool</B> ar);

      /**
       * Request that a remote object be serialized to you.  The server
       * and port number are in the url, the objectID is the unique ID
       * of the remote object in the remote instance registry.  Return
       * null if protocol unknown or InstanceHandle.init() failed.
       */
      <B>static</B> sidl.io.Serializable unserializeInstance( <B>in string</B> url);

    }

    /**
     * This interface holds the state information for handles to
     * remote objects.  Client-side messaging libraries are expected
     * to implement &lt;code&gt;sidl.rmi.InstanceHandle&lt;/code&gt;,
     * &lt;code&gt;sidl.rmi.Invocation&lt;/code&gt; and
     * &lt;code&gt;sidl.rmi.Response&lt;/code&gt;.
     *
     * Every stub with a connection to a remote object holds a pointer
     * to an InstanceHandle that manages the connection. Multiple
     * stubs may point to the same InstanceHandle, however.  Babel
     * takes care of the reference counting, but the developer should
     * keep concurrency issues in mind.
     *
     *  When a new remote object is created:
     *       sidl_rmi_InstanceHandle c =
     *         sidl_rmi_ProtocolFactory_createInstance( url, typeName,
     *               _ex );
     *
     *  When a new stub is created to connect to an existing remote
     * instance:
     *        sidl_rmi_InstanceHandle c =
     *          sidl_rmi_ProtocolFactory_connectInstance( url, _ex );
     *
     *  When a method is invoked:
     *       sidl_rmi_Invocation i =
     *          sidl_rmi_InstanceHandle_createInvocation( methodname );
     *       sidl_rmi_Invocation_packDouble( i, "input_val" , 2.0 );
     *       sidl_rmi_Invocation_packString( i, "input_str", "Hello" );
     *       ...
     *       sidl_rmi_Response r = sidl_rmi_Invocation_invokeMethod( i );
     *       sidl_rmi_Response_unpackBool( i, "_retval", &amp;succeeded );
     *       sidl_rmi_Response_unpackFloat( i, "output_val", &amp;f );
     *
     */
    <B>interface</B> InstanceHandle {

      /** initialize a connection (intended for use by the
       * ProtocolFactory, (see above).  This should parse the url and
       * do everything necessary to create the remote object.
       */
      <B>bool</B> initCreate( <B>in string</B> url, <B>in string</B> typeName );

      /**
       * initialize a connection (intended for use by the ProtocolFactory)
       * This should parse the url and do everything necessary to connect
       * to a remote object.
       */
      <B>bool</B> initConnect( <B>in string</B> url, <B>in string</B> typeName, <B>in bool</B> ar);


      /** Get a connection specifically for the purpose for requesting a
       * serialization of a remote object (intended for use by the
       * ProtocolFactory, (see above).  This should parse the url and
       * request the object.  It should return a deserializer..
       */
      sidl.io.Serializable initUnserialize( <B>in string</B> url);


      /** return the short name of the protocol */
      <B>string</B> getProtocol();

      /** return the object ID for the remote object*/
      <B>string</B> getObjectID();

      /**
       * return the full URL for this object, takes the form:
       * protocol://serviceID/objectID (where serviceID would = server:port
       * on TCP/IP)
       * So usually, like this: protocol://server:port/objectID
       */
      <B>string</B> getObjectURL();

      /** create a serializer handle to invoke the named method */
      Invocation createInvocation( <B>in string</B> methodName );

      /**
       * closes the connection (called by the destructor, if not done
       * explicitly) returns true if successful, false otherwise
       * (including subsequent calls)
       */
      <B>bool</B> close();
    }

    /**
     * This type is used to pack arguments and make the Client-&gt;Server
     * method invocation.
     */
    <B>interface</B> Invocation <B>extends</B> sidl.io.Serializer {

      /**
       * this method is one of a triad.  Only one of which
       * may be called, and it must the the last method called
       * in the object's lifetime.
       */
      Response invokeMethod();

      /**
       * This method is second of the triad.  It returns
       * a Ticket, from which a Response is later extracted.
       */
      Ticket invokeNonblocking();

      /**
       * This method is third of the triad.  It returns
       * and exception iff the invocation cannot be delivered
       * reliably.  It does not wait for the invocation to
       * be acted upon and returns no values from the invocation.
       */
      <B>void</B> invokeOneWay();
    }

    /**
     * This type is created when an invokeMethod is called on an
     * Invocation.  It encapsulates all the results that users will
     * want to pull out of a remote method invocation.
     */
    <B>interface</B> Response <B>extends</B> sidl.io.Deserializer {

      /**
       * May return a communication exception or an execption thrown
       * from the remote server.  If it returns null, then it's safe
       * to unpack arguments
       */
      sidl.BaseException getExceptionThrown();

    }

    /**
     * This interface is implemented by the Server side deserializer.
     * Deserializes method arguments in preperation for the method
     * call.
     */
    <B>interface</B> Call <B>extends</B> sidl.io.Deserializer { }

    /**
     * This interface is implemented by the Server side serializer.
     * Serializes method arguments after the return from the method
     * call.
     */
    <B>interface</B> Return <B>extends</B> sidl.io.Serializer {

      /**
       * This method serialized exceptions thrown on the server side
       * that should be returned to the client.  Assumed to invalidate
       * in previously serialized arguments.  (Also assumed that no
       * more arguments will be serialized.)
       */
      <B>void</B> throwException(<B>in</B> sidl.BaseException ex_to_throw);
    }

    /**
     * Used in lieu of a Response in nonblocking calls
     */
    <B>interface</B> Ticket {

      /** blocks until the Response is recieved */
      <B>void</B> block();

      /**
       * returns immediately: true iff the Response is already
       * received
       */
      <B>bool</B> test();

      /** creates an empty container specialized for Tickets */
      TicketBook createEmptyTicketBook();

      /** returns immediately: returns Response or null
       *  (NOTE: needed for implementors of communication
       *         libraries, not expected for general use).
       */
      Response getResponse();

    }

    /**
     * This is a collection of Tickets that itself can be viewed
     * as a ticket.
     */
    <B>interface</B> TicketBook <B>extends</B> Ticket {

      /** insert a ticket with a user-specified ID */
      <B>void</B> insertWithID( <B>in</B> Ticket t, <B>in int</B> id );

      /** insert a ticket and issue a unique ID */
      <B>int</B> insert( <B>in</B> Ticket t );

      /** remove a ready ticket from the TicketBook
       *  returns 0 (and null) on an empty TicketBook
       */
      <B>int</B> removeReady( <B>out</B> Ticket t );

      /**
       * immediate, returns the number of Tickets in the book.
       */
      <B>bool</B> isEmpty();

    }

    /**
     * This singleton class is implemented by Babel's runtime for RMI
     * libraries to invoke methods on server objects.  It maps
     * objectID strings to sidl_BaseClass objects and vice-versa.
     *
     * The InstanceRegistry creates and returns a unique string when a
     * new object is added to the registry.  When an object's refcount
     * reaches 0 and it is collected, it is removed from the Instance
     * Registry.
     *
     * Objects are added to the registry in 3 ways:
     * 1) Added to the server's registry when an object is
     *    create[Remote]'d.
     * 2) Implicity added to the local registry when an object is
     *    passed as an argument in a remote call.
     * 3) A user may manually add a reference to the local registry
     *    for publishing purposes.  The user hsould keep a reference
     *    to the object.  Currently, the user cannot provide their own
     *    objectID, this capability should probably be added.
     */
    <B>class</B> InstanceRegistry {

      /**
       * Register an instance of a class.
       *
       * the registry will return an objectID string guaranteed to be
       * unique for the lifetime of the process
       */
      <B>static string</B> registerInstance( <B>in</B> sidl.BaseClass instance );

      /**
       * Register an instance of a class with the given instanceID
       *
       * If a different object already exists in registry under
       * the supplied name, a false is returned, if the object was
       * successfully registered, true is returned.
       */
      <B>static string</B> registerInstance[ByString]( <B>in</B> sidl.BaseClass instance,
                                              <B>in string</B> instanceID);

      /**
       * returns a handle to the class based on the unique objectID
       * string, (null if the handle isn't in the table)
       */
      <B>static</B> sidl.BaseClass getInstance[ByString]( <B>in string</B> instanceID );

      /**
       * takes a class and returns the objectID string associated
       * with it.  (null if the handle isn't in the table)
       */
      <B>static string</B> getInstance[ByClass]( <B>in</B> sidl.BaseClass instance );

      /**
       * removes an instance from the table based on its objectID
       * string..  returns a pointer to the object, which must be
       * destroyed.
       */
      <B>static</B> sidl.BaseClass removeInstance[ByString]( <B>in string</B> instanceID );

      /**
       * removes an instance from the table based on its BaseClass
       * pointer.  returns the objectID string, which much be freed.
       */
      <B>static string</B> removeInstance[ByClass]( <B>in</B> sidl.BaseClass instance );
    }

    /**
     * This singleton class is implemented by Babel's runtime for to
     * allow RMI downcasting of objects.  When we downcast an RMI
     * object, we may be required to create a new derived class object
     * with a connect function.  We store all the connect functions in
     * this table for easy access.
     *
     * This Class is for Babel internal use only.
     */
    <B>class</B> ConnectRegistry {

      /**
       * The key is the SIDL classname the registered connect belongs
       * to.  Multiple registrations under the same key are possible,
       * this must be protected against in the user code.  Babel does
       * this internally with a static boolean.
       */
      <B>static void</B> registerConnect( <B>in string</B> key, <B>in opaque</B> func);

      /**
       * Returns the connect method for the class named in the key
       */
      <B>static opaque</B> getConnect( <B>in string</B> key );

      /**
       * Returns the connect method for the class named in the key,
       * and removes it from the table.
       */
      <B>static opaque</B> removeConnect( <B>in string</B> key );
    }

    /**
     * ServerInfo is an interface (possibly implemented by the ORB
     * itself) that provides functions to deal with the problems
     * associated with passing local object remotely.  It should be
     * registered with the ServerRegistry for general use.
     */
    <B>interface</B> ServerInfo {
      <B>string</B> getServerURL(<B>in string</B> objID);

      /**
       * For internal Babel use ONLY. Needed by Babel to determine if
       * a url points to a local or remote object.  Returns the
       * objectID if is local, Null otherwise.
       */
      <B>string</B> isLocalObject(<B>in string</B> url);

      /**
       * This gets an array of logged exceptions.  If an exception
       * can not be thrown back to the caller, we log it with the
       * Server.  This gets the array of all those exceptions.  THIS
       * IS SOMETHING OF A TEST! THIS MAY CHANGE!
       */
      <B>array</B>&lt;sidl.io.Serializable,1&gt; getExceptions();
    }

    /**
     * This singleton class is simply a place to register a
     * ServerInfo interface for general access.  This ServerInfo
     * should give info about the ORB being used to export RMI objects
     * for the current Babel process.
     *
     * This Registry provides two important functions, a way to get
     * the URL for local object we wish to expose over RMI, and a way
     * to tell if an object passed to this process via RMI is actually
     * a local object.  This abilities are protocol specific, the
     * ServerInfo interface must by implemented by the protocol
     * writer.
     *
     * THIS CLASS IS NOT DESIGNED FOR CONCURRENT WRITE ACCESS.  (Only
     * one server is assumed per Babel process)
     */
    <B>class</B> ServerRegistry {
      /**
       * Register the server with the ServerRegistry.
       */
      <B>static void</B> registerServer(<B>in</B> sidl.rmi.ServerInfo si);

      /**
       * Get the registered server from the Server Registery.
       */
      <B>static</B> sidl.rmi.ServerInfo getServer();

      /**
       * Perhaps this should take BaseClass and look the objectID up in
       * the Instance Registry
       */
      <B>static string</B> getServerURL(<B>in string</B> objID);

      /**
       * For internal Babel use ONLY. Needed by Babel to determine if a
       * url points to a local or remote object.  Returns the objectID
       * if is local, Null otherwise.
       */
      <B>static string</B> isLocalObject(<B>in string</B> url);

      /**
       * This gets an array of logged exceptions.  If an exception
       * can not be thrown back to the caller, we log it with the
       * Server.  This gets the array of all those exceptions.  THIS
       * IS SOMETHING OF A TEST! THIS MAY CHANGE!
       */
      <B>static array</B>&lt;sidl.io.Serializable,1&gt; getExceptions();

    }

  } //end package rmi
}</I></FONT></TD></TR>
</TABLE><!--TOC section Objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">6.7</A>  Objects</H2><!--SEC END --><P><A NAME="sec:basics:objects"></A>
<A NAME="@default329"></A><A NAME="@default330"></A><A NAME="@default331"></A>
<A NAME="@default332"></A><A NAME="@default333"></A></P><P>One of the strategies that SIDL uses to enforce 
language interoperability is to define an
object model that it supports across all 
language bindings. This enables real 
object-oriented programming in non-OO languages
such as C and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. This also means that
the inheritance mechanisms inside real OO languages
may be circumvented.</P><P>Contrary to newer scripting languages such as Python and
Ruby, not everything in SIDL is an object. Only
classes (abstract or not) and interfaces are objects. 
Everything else (e. g. arrays, enums, strings, ints) 
is something other than an object and therefore outside 
the scope of this section.</P><!--TOC subsection Babel’s Object Model-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Babel’s Object Model</H3><!--SEC END --><P><A NAME="sec:basics:objects:babelom"></A></P><P>SIDL defines three types of objects: interfaces, classes, 
and abstract classes. A SIDL
<FONT COLOR=maroon><I><TT>interface</TT></I></FONT><A NAME="@default334"></A><A NAME="@default335"></A> 
is akin to 
a Java interface or a C++ pure abstract base class.
It is an object that defines methods (aka member functions), 
but carries no implementation of those methods. 
A <FONT COLOR=maroon><I><TT>class</TT></I></FONT><A NAME="@default336"></A><A NAME="@default337"></A> 
by comparison is always concrete; meaning 
that there is an implementation for each of its methods
and it can be instantiated. An 
<FONT COLOR=maroon><I><TT>abstract class</TT></I></FONT><A NAME="@default338"></A><A NAME="@default339"></A> 
falls somewhere
between an <FONT COLOR=maroon><I><TT>interface</TT></I></FONT> and a <FONT COLOR=maroon><I><TT>class</TT></I></FONT>. It has at least
one method unimplemented, so it cannot be instantiated, but it
also may have several methods that are implemented and these
implementations can be inherited.</P><P>SIDL supports multiple inheritance<A NAME="@default340"></A> of interfaces and single 
inheritance of implementation.<A NAME="@default341"></A> This is a strategy found in 
other OO languages such as Java and ObjectiveC. The
words to distinguish these two forms of inheritance are
<FONT COLOR=maroon><I><TT>extends</TT></I></FONT> and <FONT COLOR=maroon><I><TT>implements</TT></I></FONT>. Interfaces can
extend multiple interfaces, but they cannot implement anything.
Classes can extend at most one other class (abstract or not), 
but can implement multiple interfaces.</P><P>Furthermore, any inherited abstract methods (inherited from either and
abstract parent class or and implemented interface) will default to
abstract unless they are re-declared in the current class. If a
concrete class
implements many large interfaces, this can result in a fairly large
list of redeclared functions in the class definition. As a shortcut,
we included the <TT>implements-all</TT> directive, a short hand
that states explicitly that we intend to implement every
method in the named interface concretely. That’s why, in the
following example, class B must be declared abstract, but class D is
concrete. Class B does not redeclare the <TT>printMe</TT> function,
but class D <TT>implements-all</TT>. There is no similar directive for
inheritance from abstract classes.</P><P>We display a small SIDL file below and finish this
subsection with a discussion of its details.
<A NAME="@default342"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> object <B>version</B> 1.0 {

  <B>interface</B> A {
    <B>void</B> display();
    <B>void</B> printMe();
  }

  <B>abstract class</B> B <B>implements</B> A {
    <B>void</B> display();
  }

  <B>class</B> C <B>extends</B> B {
    <B>void</B> printMe();
  }

  <B>class</B> D <B>implements</B>-all A {
  }
}</I></FONT></TD></TR>
</TABLE><P><FONT COLOR=maroon><I><TT>object.A</TT></I></FONT> is
an interface that has two methods <FONT COLOR=maroon><I><TT>display()</TT></I></FONT> and <FONT COLOR=maroon><I><TT>print()</TT></I></FONT>.
Both of these methods take no arguments and return no value.
(We will discuss arguments and return values in the next section.)
Since <FONT COLOR=maroon><I><TT>object.A</TT></I></FONT> is an interface, there is no implementation
associated with it, and Babel will not generate any implementation
code associated with it. </P><P><FONT COLOR=maroon><I><TT>object.B</TT></I></FONT> is an abstract class that <A NAME="@default343"></A><A NAME="@default344"></A>
inherits from <FONT COLOR=maroon><I><TT>object.A</TT></I></FONT>. Since it redeclares the
<FONT COLOR=maroon><I><TT>display()</TT></I></FONT> method, Babel will generate the appropriate
code for an implementation of this method only. It will not
generate code for the other inherited method <FONT COLOR=maroon><I><TT>print()</TT></I></FONT>
(since it wasn’t declared in the SIDL file) and it will not
generate constructors/destructors since the class is abstract.</P><P><FONT COLOR=maroon><I><TT>object.C</TT></I></FONT> is a concrete class that extends 
the abstract class <A NAME="@default345"></A><A NAME="@default346"></A>
<FONT COLOR=maroon><I><TT>object.B</TT></I></FONT> it then lists only the unimplemented method
<FONT COLOR=maroon><I><TT>print()</TT></I></FONT>, implying that it will use the implementation
of <FONT COLOR=maroon><I><TT>display()</TT></I></FONT> it inherited from its parent.</P><P><FONT COLOR=maroon><I><TT>object.D</TT></I></FONT> is also a concrete class that uses the
<FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT><A NAME="@default347"></A><A NAME="@default348"></A></P><P>directive. This is identical to using <FONT COLOR=maroon><I><TT>implements</TT></I></FONT> and then
listing all the methods declared in the interface. 
The <FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT> directive was added to SIDL 
as a convenience construct and to save excessive typing
in the SIDL file. By virtue of the <FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT>
directive, <FONT COLOR=maroon><I><TT>object.D</TT></I></FONT> will provide its own implementation of 
all of <FONT COLOR=maroon><I><TT>object.A</TT></I></FONT>’s methods, namely 
<FONT COLOR=maroon><I><TT>display()</TT></I></FONT> and <FONT COLOR=maroon><I><TT>print()</TT></I></FONT>.</P><!--TOC subsection Methods on Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Methods on Objects</H3><!--SEC END --><P><A NAME="sec:basics:objects:methods"></A></P><P>Methods in SIDL are virtual<A NAME="@default349"></A> by default. 
This means that the actual binding of a method
invocation to an actual implementation is determined
at runtime, based on the concrete type of the object.</P><P>SIDL currently defines three modifiers to methods
that change their default behavior.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=maroon><I><TT>final</TT></I></FONT>   :   
	<A NAME="@default350"></A><A NAME="@default351"></A>
	Final methods are the opposite of virtual.
	While they may still be inherited by child classes, 
	they cannot be overridden.
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>static</TT></I></FONT>   :   
	<A NAME="@default352"></A><A NAME="@default353"></A>	
	Static methods are sometimes called “class methods” because
	they are part of a class, but do not depend on an object instance.
	In non-OO languages, this means that the typical
	first argument of an instance is removed.
	In OO languages, these are mapped directly
	to an Java or C++ static method.
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>local</TT></I></FONT>   :   local is a keyword that relates to RMI. A
	local method cannot be called on a remote
	object. Any call on a local method must be an in-process call, or a
	PreViolation will be thrown.
	<A NAME="@default354"></A><A NAME="@default355"></A><A NAME="@default356"></A>	
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>oneway</TT></I></FONT>   :   oneway is a keyword that relates to RMI. A
	oneway method can only take in arguments, no out arguments. This
	allows the oneway method to be called with a oneway network message,
	so the user doesn’t need to wait for a response. 
	<A NAME="@default357"></A><A NAME="@default358"></A><A NAME="@default359"></A>	
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>nonblocking</TT></I></FONT>   :   nonblocking is a keyword that relates
	to RMI. A nonblocking method is split into two methods, method_send()
	and method_recv(). method_send() takes the in arguments and
	immediately returns a sidl.rmi.Ticket. This Ticket can be used to
	determine when the remote method returns, and get the out arguments.
	<A NAME="@default360"></A><A NAME="@default361"></A><A NAME="@default362"></A>	
</LI></UL><P>Starting with Babel <TT>0.11.0</TT>, all SIDL methods implicitly throw
<FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT>. A <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT> can be
generated by the Babel generated glue code. For example, if the code
is making a call across the network using remote method invocation and
the network goes down, Babel’s glue code would generate a
<FONT COLOR=maroon><I><TT>RuntimeException</TT></I></FONT>. In cases where the implementation throws an
unexpected exception (i. e., not one that is declared in the method’s
SIDL declaration), the glue code can generate a
<FONT COLOR=maroon><I><TT>RuntimeException</TT></I></FONT>.
<A NAME="@default363"></A></P><!--TOC subsection Parameter Passing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Parameter Passing</H3><!--SEC END --><P>Each parameter in a method call obeys the following syntax
</P><BLOCKQUOTE CLASS="quotation"><TT>
[ (modifier) ] (mode) (type) (name)
</TT></BLOCKQUOTE><P>
<A NAME="@default364"></A><A NAME="@default365"></A><A NAME="@default366"></A><A NAME="@default367"></A><A NAME="@default368"></A>
Where <TT>(mode)</TT> is one of <FONT COLOR=maroon><I><TT>in</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>out</TT></I></FONT>, or <FONT COLOR=maroon><I><TT>inout</TT></I></FONT>; <TT>(type)</TT> is
any SIDL recognized type; and <TT>(name)</TT> is
any non-reserved word<SUP><A NAME="text12" HREF="#note12">4</A></SUP>.
The <TT>(modifier)</TT> is optional, and currently
unimplemented. SIDL currently reserves the word
<FONT COLOR=maroon><I><TT>copy</TT></I></FONT> for future use as an parameter modifier, 
and may add others in the future<SUP><A NAME="text13" HREF="#note13">5</A></SUP>.</P><P>For new users, the parameter’s mode (e. g. <FONT COLOR=maroon><I><TT>in</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>out</TT></I></FONT>, or <FONT COLOR=maroon><I><TT>inout</TT></I></FONT>) is perhaps the most troublesome.
On the surface, it’s easy to explain that <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameters
are passed into the code, <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters come out, 
and <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> parameters do both. More specifically the rules are:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<FONT COLOR=maroon><I><TT>in</TT></I></FONT> does not mean <TT>const</TT>.
</LI><LI CLASS="li-enumerate"><FONT COLOR=maroon><I><TT>in</TT></I></FONT> arguments are passed by value, therefore what happens
	 inside the function has no effect on the value passed in (from the
	 perspective of the caller).
</LI><LI CLASS="li-enumerate"><FONT COLOR=maroon><I><TT>inout</TT></I></FONT> arguments are passed by reference. The callee is
	 allowed to do whatever it wants with the data passed in,
	 and changes made by the callee are sent back to the caller.
	 For interfaces, classes, and normal arrays, the callee
	 can even destroy the reference, create a new object or
	 array, and return a reference to it.
</LI><LI CLASS="li-enumerate">Objects, interfaces and arrays should be allocated using the
create methods provided. Types created on the stack should never be
passed as an <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> argument, since the implementation
may want to destroy it.
</LI><LI CLASS="li-enumerate"><FONT COLOR=maroon><I><TT>out</TT></I></FONT> arguments are also passed by reference, but the 
incoming value is ignore and typically overwritten.
	 <EM>Do Not</EM> attempt to
	 pass in a value to a function through an out argument. There is no
	 guarantee that the data will make it to the Implementation, and if the
	 data is lost, there is no guarantee the reference will be correctly destroyed.
</LI></OL><P>When an exception is thrown, the value of <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters is
undefined. Thus, the client code should not attempt to free <FONT COLOR=maroon><I><TT>out</TT></I></FONT>
string values or decrement reference counts for objects or arrays when
an exception has been thrown. Some bindings may initialize point types
to a NULL value, but the client should not depend on this behavior.</P><P>For strings and reference counted objects (i. e., objects, interfaces,
and arrays) called a resource here, these rules can be confusing. It
is useful to think about who retains ownership of the resource and the
phases of method call.
</P><DL CLASS="description"><DT CLASS="dt-description">
<FONT COLOR=maroon><I><TT><B>in</B></TT></I></FONT></DT><DD CLASS="dd-description"> The client owns the resource before the call, and the
callee borrows the reference. In the case of a string, the client
owns the string data, and the implementation would have to copy the
string if it wanted to retain a reference. Similarly, the
implementation would have to increment the reference count of an
object or smart copy an array. In the case of an exception being
thrown, the <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameters are unmodified.
</DD><DT CLASS="dt-description"><FONT COLOR=maroon><I><TT><B>inout</B></TT></I></FONT></DT><DD CLASS="dd-description"> The client initially owns the resource before the
call, and it transfers its ownership to the callee. Thus, the callee
is allowed to decrement the reference count of the object or <TT>free</TT> a
string. When the callee is finished, it transfers ownership back to
the caller (or potentially returns a NULL object/string). In the
event of an exception, the caller should ignore the outgoing
parameter values, and the implementation must insure that the
object’s reference counts are decremented and incoming string values are
<TT>free</TT>’ed.
</DD><DT CLASS="dt-description"><FONT COLOR=maroon><I><TT><B>out</B></TT></I></FONT></DT><DD CLASS="dd-description"> The incoming values of <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters are
ignored, and the callee creates any strings or objects that are to
be returned. When the callee returns, it transfers ownership of the
parameters to the caller. In the event of an exception, the caller
must ignore the value of <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters because they may be
uninitialized.
</DD></DL><!--TOC subsection Method Overloading-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Method Overloading</H3><!--SEC END --><P><A NAME="@default369"></A><A NAME="@default370"></A>
<A NAME="sec:overloading"></A>
Method overloading is the object-oriented practice of defining more than one 
method with the same name in a class. Doing so allows the convenient reuse of 
a method name when, for example, the underlying implementations differ based
on the types of the arguments. Actually, support for overloaded methods 
typically relies on the signature<A NAME="@default371"></A>
<A NAME="@default372"></A><A NAME="@default373"></A> of each method to ensure uniqueness. In 
this case, the signature consists of the method name along with the number, 
types, and ordering of its arguments. </P><P>Since Babel supports languages that do not support method overloading, a 
mechanism for generating unique names was needed. These are typically generated 
by compilers based on hashing the argument types into the method name. However, 
developers often manually address this with far fewer characters than would be 
used by a compiler. Consequently, it was determined it would be more efficient 
to leave the task of identifying the unique name to the developer. Therefore, 
Babel allows the specification of the base, or short,
<A NAME="@default374"></A> <A NAME="@default375"></A> method name along with an 
optional method name extension as illustrated in the SIDL file below for the 
<TT>getValue</TT> method. </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> Overload <B>version</B> 1.0 {

  <B>class</B> Sample {
    <B>int</B>      getValue ( );
    <B>int</B>      getValue[Int]( <B>in int</B> v );
    <B>double</B>   getValue[Double]( <B>in double</B> v );
  }
}</I></FONT></TD></TR>
</TABLE><P>Thus, the full method name<A NAME="@default376"></A> <A NAME="@default377"></A>
is the concatenation of the short name followed 
by the name extension. When generating code for supported languages, Babel 
makes use of either the short or full method name as appropriate for the 
language(s) involved. For those that support method overloading, such 
as C++ and Java, Babel relies only on the short method name, thus ignoring 
the extension. For the rest, like C, Fortran, and Python, Babel must make 
use of the full name to ensure methods are uniquely identified. </P><P>In the example above, the first method specification takes no arguments so has 
no name extension. This is acceptable because there are no potentially 
conflicting methods at this point for any programming language supported by 
Babel. The second method, with the user-defined name extension of <TT>Int</TT>, 
takes a single int argument, resulting in the unique method name 
<TT>getValueInt</TT>. The last method, with a user-defined name extension of 
<TT>Double</TT>, takes a single double argument, resulting in the unique method 
name of <TT>getValueDouble</TT>. Examples of calling overloaded methods from 
Babel-supported languages can be found in the respective language binding 
chapters.

			 
</P><!--TOC section XML Repositories-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">6.8</A>  XML Repositories</H2><!--SEC END --><P><A NAME="s:xml_repo"></A>
<A NAME="@default378"></A>
Even though SIDL is currently the primary input format for Babel, 
it is not the only format Babel understands. For type
repositories<A NAME="@default379"></A> (similar in function to include directories
for C/C++ headers) the preferred language to articulate
types is XML.</P><P>Babel has the capabilities to convert SIDL files into
XML files adhering to the <TT>sidl.dtd</TT>. This capability is
explained further in Chapter <A HREF="#c:xml_backend">16</A>. The XML
files in these repositories can be included in subsequent 
runs quickly since all the external references were resolved 
by Babel during their creation. A SIDL file may refer to 
unresolved types.

</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note9" HREF="#text9">1</A></DT><DD CLASS="dd-thefootnotes">meaning non-strided
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">2</A></DT><DD CLASS="dd-thefootnotes">Contract clauses should <EM>never</EM> replace defensive 
programming data checks since clause enforcement may be disabled during
deployment. The data checks of defensive programming, on the other hand,
should be executed on <EM>every</EM> run since they are needed to protect
against serious, undesirable side-effects that include abrupt, unexplained
termination.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note11" HREF="#text11">3</A></DT><DD CLASS="dd-thefootnotes">The <TT>is pure</TT> assertion is a non-executable
annotation since Babel is not equiped to statically analyze source code for
any of the supported programming languages.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note12" HREF="#text12">4</A></DT><DD CLASS="dd-thefootnotes">Refer to Section <A HREF="#s:sidl_reserved">A.2</A> for 
the list of reserved words
</DD><DT CLASS="dt-thefootnotes"><A NAME="note13" HREF="#text13">5</A></DT><DD CLASS="dd-thefootnotes">Babel is 
still pre-1.0 after all!
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Upgrade Notes-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc30">Chapter 7</A>  Upgrade Notes</H1><!--SEC END --><P><A NAME="c:upgrade"></A></P><P><BR>
</P><!--TOC section Upgrading from Babel 1.0 to 1.4-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">7.1</A>  Upgrading from Babel 1.0 to 1.4</H2><!--SEC END --><P>This section covers some of the important changes for users upgrading
from Babel 1.0 to Babel 1.4. Users who are new to Babel 1.4 should
skip this chapter because it gets into details that only experienced
Babel users will understand.</P><P>There are two major changes for users upgrading. The first involves
renaming certain splicer blocks in the C and C++ bindings, and the
second involves the extra comments needed for the CCA’s Bocca
IDE. Both these changes require new command line options.</P><P>Some splicer blocks have been renamed from what they were in Babel
1.0. The <TT>_misc</TT> and <TT>_includes</TT> in a C or C++ implementation
header file have been renamed to <TT>_hmisc</TT> and
<TT>_hincludes</TT>. The goal of this change has to give each splicer
block a unique name across the implementation header and
implementation source files. In Babel 1.0, the header and source both
have a splicer blocks named <TT>_misc</TT> and <TT>_includes</TT>. This
made things confusing for Bocca users.</P><P>To help users upgrading from Babel 1.0 to 1.4, Babel 1.4 has a
<TT>--rename-splicers</TT> command line option that will
automatically rename the header splicer blocks whose names have
changed. Once you’ve generated new implementation header files, you
do not need to keep using <TT>--rename-splicers</TT>.</P><P>To support CCA’s Bocca, Babel 1.0 introduced extra comments to guide
the Bocca IDE to blocks of text that need to be edited. In Babel 1.4,
you need to specifically request these extra comments with
<TT>--cca-mode</TT>.
</P><!--TOC part Supported Language Bindings-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc32">Part II</A><BR>
Supported Language Bindings</H1></TD></TR>
</TABLE><!--SEC END --><P><A NAME="p:supported_langs"></A></P><!--TOC chapter C Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc33">Chapter 8</A>  C Bindings</H1><!--SEC END --><P><A NAME="c:c"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc34">8.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:c:intro"></A></P><P>This chapter gives an overview of the C bindings for SIDL. Common aspects
of the bindings, such as the mapping of SIDL data types to their C 
representatives, are presented in Section <A HREF="#s:c:basics">8.2</A>.
Issues of concern to callers written in C are addressed in the client-side
bindings discussion in Section <A HREF="#s:c:client">8.3</A>, while callees written in
C would benefit from a review of implementation-side issues in
Section <A HREF="#s:c:implementation">8.4</A>.
Although it would defeat the multilingual interoperability goals of Babel, 
programs can be written solely with a C compiler since Babel’s Intermediate 
Object Representation (IOR) and all objects in the <FONT COLOR=maroon><I><TT>sidl</TT></I></FONT> name space
(e. g. <FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT>, etc.) are implemented in C. </P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">8.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:c:basics"></A></P><P>As with any programming language-neutral technology, translations must 
be made between abstract constructs supported by the technology and the
corresponding concrete constructs in the native programming language. 
Due to the need to identify types in a global context, 
Subsection <A HREF="#ss:c:namespace">8.2.1</A> describes the convention used to establish 
name spaces.
Conventions for generating language-specific method signatures are given 
in Subsection <A HREF="#ss:c:signatures">8.2.2</A>.
The mapping of SIDL fundamental types is given in Subsection <A HREF="#ss:c:types">8.2.3</A>. 
Finally, the process of casting between different types is described
in Subsection <A HREF="#ss:c:casting">8.2.4</A>.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.2.1  Name space</H3><!--SEC END --><P><A NAME="ss:c:namespace"></A>
<A NAME="@default380"></A>
<A NAME="@default381"></A></P><P>Since C does not have built-in mechanisms for protecting the global name space,
generated bindings avoid name space collisions by using struct
and method names that incorporate all relevant naming information.
Without this approach, there would be
multiple structures or routines with the same name.
For a type <TT>Z</TT> in package <TT>X.Y</TT>, for example,
the name of the type that C clients use for an object reference is
<TT>X_Y_Z</TT>. The name is defined as follows in the <TT>X_Y_Z.h</TT> 
header file:
<A NAME="@default382"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>struct</B> X_Y_Z__object;
<B>struct</B> X_Y_Z__array;
<B>typedef struct</B> X_Y_Z__object* X_Y_Z;</TD></TR>
</TABLE><P>Method names, as discussed in Subsection <A HREF="#ss:c:signatures">8.2.2</A>, are 
built in a similar manner.</P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.2.2  Method signatures</H3><!--SEC END --><P><A NAME="ss:c:signatures"></A>
<A NAME="@default383"></A>
<A NAME="@default384"></A></P><P>The name of a C routine used to call a SIDL method is a
concatenation of the package, class (or interface), and method 
name, with period characters replaced with underscores. If the
method is specified as overloaded (i. e., has a name extension), the
extension is appended. 
The object (or interface) pointer is automatically inserted as the first 
parameter in the signature of non-static methods. This parameter
operates like an <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameter. With the addition of remote 
method invocation (RMI) support, all methods now implicitly throw exceptions.
<A NAME="@default385"></A>
Hence, an extra <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter for the exception is added as the 
last parameter of the signature.</P><P>The following SIDL method — taken from the Babel regression tests — is an
example of a method that can throw multiple exception types:
<A NAME="@default386"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>int</B> getFib(<B>in int</B> n, <B>in int</B> max_depth, <B>in int</B> max_value, <B>in int</B> depth)
  <B>throws</B> NegativeValueException, FibException;</I></FONT></TD></TR>
</TABLE><P>The corresponding C API is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">int32_t
ExceptionTest_Fib_getFib(
  ExceptionTest_Fib self,
  int32_t n,
  int32_t max_depth,
  int32_t max_value,
  int32_t depth,
  sidl_BaseInterface *_ex);</TD></TR>
</TABLE><P>Note the addition of the object pointer (i. e., <TT>self</TT>) and
exception (i. e., <TT>_ex</TT>) parameters.</P><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.2.3  Data types</H3><!--SEC END --><P><A NAME="ss:c:types"></A>
<A NAME="@default387"></A>
<A NAME="@default388"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 8.1: SIDL to C Type Mappings</TD></TR>
</TABLE></DIV><A NAME="tbl:c:types"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B>C TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>int32_t</TT> <A NAME="@default389"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>int64_t</TT> <A NAME="@default390"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>float</TT> <A NAME="@default391"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>double</TT> <A NAME="@default392"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>typedef sidl_bool</TT> <A NAME="@default393"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>char</TT> <A NAME="@default394"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>char *</TT> <A NAME="@default395"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>struct sidl_fcomplex</TT> <A NAME="@default396"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>struct sidl_dcomplex</TT> <A NAME="@default397"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>enum</TT> <A NAME="@default398"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>void *</TT> <A NAME="@default399"></A><A NAME="@default400"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>typedef</TT> <A NAME="@default401"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>typedef</TT> <A NAME="@default402"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>array</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>struct *</TT> <A NAME="@default403"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Basic SIDL types are mapped into C according to Table <A HREF="#tbl:c:types">8.1</A>.
The remainder of this subsection illustrates use of enumerations and arrays.</P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:c:enum"></A>
<A NAME="@default404"></A><A NAME="@default405"></A>
<A NAME="@default406"></A><A NAME="@default407"></A></P><P>Since SIDL enumerations map to C enumerations, their use is fairly
straight-forward. The appropriate header file must be included. 
The naming convention for enumerations is <TT>enums</TT> followed by
the specified enumeration type and enumeration value name, where an 
underscore is used to separate each part. For example,
a variable can be assigned the <TT>blue</TT> constant for the <TT>color</TT> 
enumeration of the sample in Subsection <A HREF="#ssec:basics:fundamental:enums">6.3</A> 
as follows:
<A NAME="@default408"></A><A NAME="@default409"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "enums_color.h"

<FONT COLOR="blue"><I>/* ...deleted lines... */</I></FONT>
<B>enum</B> enums_color__enum myColor = enums_color_blue;</TD></TR>
</TABLE><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:c:arrays"></A>
<A NAME="@default410"></A><A NAME="@default411"></A>
<A NAME="@default412"></A><A NAME="@default413"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Normal SIDL arrays can be used by any supported
language; whereas, r-arrays are restricted to numeric types and use in
languages such as C, C++, and Fortran. This subsection discusses both
within the context of C bindings. More information on the C version of
the SIDL array API can be found in Subsection <A HREF="#ss:basics:array:api">6.4</A>.</P><P>In addition to defining the object structure and associated type for
user-defined interfaces and classes, Babel also defines a corresponding
array structure for normal SIDL arrays. The C mappings for the SIDL base 
interface and class are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/**
 * Symbol "sidl.BaseInterface" (version 0.9.12)
 *
 * Every interface in &lt;code&gt;SIDL&lt;/code&gt; implicitly inherits
 * from &lt;code&gt;BaseInterface&lt;/code&gt;, which is implemented
 * by &lt;code&gt;BaseClass&lt;/code&gt; below.
 */</I></FONT>
<B>struct</B> sidl_BaseInterface__object;
<B>struct</B> sidl_BaseInterface__array;
<B>typedef struct</B> sidl_BaseInterface__object* sidl_BaseInterface;

<FONT COLOR="blue"><I>/**
 * Symbol "sidl.BaseClass" (version 0.9.12)
 *
 * Every class implicitly inherits from &lt;code&gt;BaseClass&lt;/code&gt;.  This
 * class implements the methods in &lt;code&gt;BaseInterface&lt;/code&gt;.
 */</I></FONT>
<B>struct</B> sidl_BaseClass__object;
<B>struct</B> sidl_BaseClass__array;
<B>typedef struct</B> sidl_BaseClass__object* sidl_BaseClass;</TD></TR>
</TABLE><P>Given the package <TT>num</TT> and class <TT>Linsol</TT> with the <TT>solve</TT> 
method specified in Subsection <A HREF="#ss:r-arrays">6.4</A>, the corresponding generated 
C API is:
<A NAME="@default414"></A>
<A NAME="@default415"></A><A NAME="@default416"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/** C client-side API for solve method */</I></FONT>
<B>void</B> num_Linsol_solve(<FONT COLOR="blue"><I>/* in */</I></FONT> num_Linsol self,
                      <FONT COLOR="blue"><I>/* in rarray[m,n] */</I></FONT> <B>double</B>* A,
                      <FONT COLOR="blue"><I>/* inout rarray[n] */</I></FONT> <B>double</B>* x,
                      <FONT COLOR="blue"><I>/* in */</I></FONT> int32_t m,
                      <FONT COLOR="blue"><I>/* in */</I></FONT> int32_t n,
                      <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);</TD></TR>
</TABLE><P>In this example, data for each array is passed as a <TT>double</TT> pointer 
with the index parameters being normal <FONT COLOR=maroon><I><TT>in</TT></I></FONT> integers. 
The one catch for C programmers is that
<TT>A</TT> is in column-major order — not the typical row-major
ordering used in C. </P><P>Access to the element in row <TT>i</TT> and column <TT>j</TT> can be facilitated 
using <TT>RarrayElem2(A,i,j,m)</TT>. <A NAME="@default417"></A>
<TT>RarrayElem2</TT>, defined in <TT>sidlArray.h</TT>, is a convenience macro — 
for C and C++ programmers — supplied to facilitate accessing r-arrays in 
column-major order. Access to memory by stride one involves making the first
index argument to <TT>RarrayElem2</TT>, <TT>i</TT>, the inner loop.
Since valid pointers are always required for raw arrays, passing <TT>NULL</TT> 
for <TT>A</TT>, <TT>x</TT>, or <TT>b</TT> is not allowed. </P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.2.4  Type casting</H3><!--SEC END --><P><A NAME="ss:c:casting"></A>
<A NAME="@default418"></A><A NAME="@default419"></A>
<A NAME="@default420"></A></P><P>C bindings for interfaces and classes include two implicitly defined 
methods for performing type casts. The methods are: <TT>_cast</TT> and
<TT>_cast2</TT>. 
The <TT>_cast</TT> method casts a SIDL interface or object pointer to a 
<TT>sidl.BaseClass</TT> pointer. The <TT>_cast2</TT> method casts a SIDL 
interface or object pointer to a named <TT>type</TT> pointer.
In the latter case, the client is responsible
for casting the return value into the proper pointer type. 
Using <TT>sidl.BaseClass</TT> as an example, signatures of the 
two methods are:
<A NAME="@default421"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidl_BaseClass
sidl_BaseClass__cast(<B>void</B>* obj, <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);

<B>void</B>*
sidl_BaseClass__cast2(<B>void</B>* obj, <B>const char</B>* type,
                      <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);</TD></TR>
</TABLE><P>Using either method results in the reference count<A NAME="@default422"></A> 
of the underlying object being increased if the cast succeeded. Success can
be determined by checking the return value for a non-<TT>NULL</TT> result. That
is, if a <TT>NULL</TT> value is returned from either method, then the cast 
failed or <TT>obj</TT> was <TT>NULL</TT>.</P><P><EM><B>NOTE</B>:
These methods did not increment the reference count in Babel releases prior 
to 0.11.0.
</EM></P><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc36">8.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:c:client"></A>
<A NAME="@default423"></A></P><P>This section summarizes aspects of generating and using the C bindings
associated with software wrapped with Babel’s language interoperability 
middleware. The bindings generation process is presented before the
conventions used to name C header files are described. 
Object management and invocation of static and overloaded methods are 
also summarized. The process of catching exceptions is then discussed.
Finally, the processes for enabling and disabling implementation-specific
pre- and post-method instrumentation — referred to as “hooks” —
are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.1  Bindings generation</H3><!--SEC END --><P>
<A NAME="@default424"></A>
<A NAME="@default425"></A><A NAME="@default426"></A></P><P>C stubs (i. e. code to support C clients for a set of SIDL-specified
classes or interfaces), are created by invoking Babel as follows<SUP><A NAME="text14" HREF="#note14">1</A></SUP>:
<A NAME="@default427"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=C file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or more cryptically
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -cC file.sidl</B><BR>
</TT></BLOCKQUOTE><P>Using the <B><TT><CODE>--</CODE>exclude-external</TT></B> flag avoids generation
of files for symbols referenced (but not specified) in <TT>file.sidl</TT>; 
thereby, 
reducing the total number of generated files. Of the files generated, those 
ending in <TT>_IOR.h</TT> and <TT>_IOR.c</TT> contain the Intermediate Object
Representation (IOR). Files ending with <TT>_Stub.c</TT> are the C stubs
— the interface between C clients and the IOR. The remaining header
files contain the C client API.</P><P>To use the bindings, you must compile and link the stub files against the 
SIDL runtime library and an implementation of the API.</P><!--TOC subsection Header files-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.2  Header files</H3><!--SEC END --><P>
<A NAME="@default428"></A>
<A NAME="@default429"></A></P><P>The hierarchical nature of SIDL packages lends itself to multiple
options for including enumerations, 
interfaces, and classes. The naming convention for associated
header files uses underscore-separated parts corresponding to the
package hierarchy. That is, type <TT>X.Y.Z</TT> — where X is the name
of the package, Y the subpackage, and Z the class — is included with
<TT>#include "X_Y_Z.h"</TT><A NAME="@default430"></A><A NAME="@default431"></A>.
The header files for the whole subpackage, <TT>X.Y</TT>, are included with
<TT>#include "X_Y.h"</TT>. For instance, all 
types in the <TT>sidl</TT> name space are included in <TT>#include "sidl.h"</TT>.
<A NAME="@default432"></A></P><P>Babel ensures each generated client-side header file automatically includes
<TT>sidl_header.h</TT><A NAME="@default433"></A>, which defines:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>struct sidl_dcomplex</TT> for the SIDL dcomplex type with
parts named <TT>real</TT> and <TT>imaginary</TT>;
</LI><LI CLASS="li-enumerate"><TT>struct sidl_fcomplex</TT> for the SIDL fcomplex type with
parts named <TT>real</TT> and <TT>imaginary</TT>;
</LI><LI CLASS="li-enumerate"><TT>int32_t</TT> and <TT>int64_t</TT> for the SIDL int and long
types;
</LI><LI CLASS="li-enumerate">a typedef for <TT>sidl_bool</TT> for the SIDL bool type;
</LI><LI CLASS="li-enumerate">preprocessor symbols <TT>TRUE</TT> and <TT>FALSE</TT>; and 
</LI><LI CLASS="li-enumerate">function prototypes for the multi-dimensional array APIs for
the basic SIDL types.
</LI></OL><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.3  Object management</H3><!--SEC END --><P>
<A NAME="@default434"></A>
<A NAME="@default435"></A></P><P>SIDL-specified objects are managed through explicit creation and 
reference counting. An additional implicit method, called
<TT>_create</TT>, must be invoked to create new instances of a concrete class. 
The <TT>_create</TT> method returns a new reference
that must be managed by the client. 
The following is an example of its signature:
<A NAME="@default436"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/**
 * Constructor function for the class.
 */</I></FONT>
sidl_BaseClass
sidl_BaseClass__create(<FONT COLOR="blue"><I>/* out */</I></FONT>sidl_BaseInterface *_ex);</TD></TR>
</TABLE><P>References are then managed through methods inherited from
<TT>sidl.BaseInterface</TT>. The methods are <TT>addRef</TT> and
<TT>deleteRef</TT>, where <TT>addRef</TT><A NAME="@default437"></A> is used to increment the
reference counter<A NAME="@default438"></A> while 
<TT>deleteRef</TT><A NAME="@default439"></A> decrements it and, if 
the count reaches zero, frees any associated memory — assuming
the developer properly implemented the destructor.
Their C APIs for <TT>sidl.BaseInterface</TT> are:
<A NAME="@default440"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
sidl_BaseInterface_addRef(<FONT COLOR="blue"><I>/* in */</I></FONT> sidl_BaseInterface self,
                          <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);

<B>void</B>
sidl_BaseInterface_deleteRef(<FONT COLOR="blue"><I>/* in */</I></FONT> sidl_BaseInterface self,
                             <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);</TD></TR>
</TABLE><P>These same methods can be called from the <TT>sidl.BaseClass</TT>
bindings. In fact, since all SIDL-specified interfaces inherit from 
<TT>sidl.BaseInterface</TT> and all classes from <TT>sidl.BaseClass</TT>,
every C binding for an interface or class will inherit <TT>addRef</TT> 
and <TT>deleteRef</TT> methods. Their C APIs for <TT>sidl.BaseClass</TT>
are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
sidl_BaseClass_addRef(<FONT COLOR="blue"><I>/* in */</I></FONT>  sidl_BaseClass self,
                      <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);

<B>void</B>
sidl_BaseClass_deleteRef(<FONT COLOR="blue"><I>/* in */</I></FONT>  sidl_BaseClass self,
                         <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex);</TD></TR>
</TABLE><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.4  Static methods</H3><!--SEC END --><P>
<A NAME="@default441"></A>
<A NAME="@default442"></A></P><P>Static methods are class-wide so not associated with an object. As a 
result, <TT>self</TT> is <EM>not</EM> automatically added as the first argument 
to the method signature in the bindings.</P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.5  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default443"></A>
<A NAME="@default444"></A></P><P>Using the <TT>overload_sample.sidl</TT> file from Section <A HREF="#sec:overloading">6.7</A>
as an example, recall that three versions of the <TT>getValue</TT> method are
specified. The first signature takes no arguments, the second takes an 
integer, and the third a boolean. The code snippet below illustrates 
object creation, method invocation for each of the overloaded methods, 
and exception handling.
<A NAME="@default445"></A>
<A NAME="@default446"></A><A NAME="@default447"></A>
<A NAME="@default448"></A><A NAME="@default449"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
  int32_t b1, i1, iresult, nresult;
  sidl_BaseInterface ex;

  Overload_Sample t  = Overload_Sample__create (&amp;ex); SIDL_CHECK(ex);

  nresult = Overload_Sample_getValue(t, &amp;ex); SIDL_CHECK(ex);
  iresult = Overload_Sample_getValueInt(t, i1, &amp;ex); SIDL_CHECK(ex);
  bresult = Overload_Sample_getValueBool(t, b1, &amp;ex); SIDL_CHECK(ex);</TD></TR>
</TABLE><P><TT>SIDL_CHECK</TT><A NAME="@default450"></A> is used to check if an exception has 
been thrown. If so, control jumps to the code after the <TT>EXIT</TT> label, 
which is not illustrated here but is in the example presented in 
Subsection <A HREF="#ss:c:exceptions">8.3.6</A>.
<A NAME="@default451"></A><A NAME="@default452"></A></P><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.6  Exception catching</H3><!--SEC END --><P><A NAME="ss:c:exceptions"></A>
<A NAME="@default453"></A><A NAME="@default454"></A>
<A NAME="@default455"></A></P><P>Since all methods can now throw <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT>
<A NAME="@default456"></A>, Babel ensures there is an 
<FONT COLOR=maroon><I><TT>out</TT></I></FONT> argument to hold an exception. If not explicitly specified,
Babel will automatically add the argument. For maximum
backward compatibility and consistency, the argument is of type
<TT>sidl.BaseInterface</TT>. When the exception parameter value is not
<TT>NULL</TT>, an exception has been thrown. In that case, the caller should 
ignore the value of the other <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters as well as any 
return value. </P><P>To facilitate exception management, <TT>sidl_Exception.h</TT> provides several
helper utilities. Chief among them are: 
<TT>SIDL_CHECK</TT><A NAME="@default457"></A>, 
<TT>SIDL_CATCH</TT><A NAME="@default458"></A>, 
and <TT>SIDL_CLEAR</TT><A NAME="@default459"></A>.
Their use follows from their names. Their signatures are:
<A NAME="@default460"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* Macros to facilitate managing exceptions */</I></FONT>
SIDL_CHECK(EX_VAR)
SIDL_CLEAR(EX_VAR)

<FONT COLOR="blue"><I>/* Helper function to facilitate catching exceptions of a specific type */</I></FONT>
<B>int</B>
SIDL_CATCH(<B>struct</B> sidl_BaseInterface__object *ex_var,
           <B>const char</B> *sidl_Name);</TD></TR>
</TABLE><P><TT>EX_VAR</TT> (or <TT>ex_var</TT>) is the exception object itself and 
<TT>sidl_NAME</TT> is the string name of the exception type expected to 
be caught. </P><P>The following example, based on the <TT>getFib</TT> method from 
Subsection <A HREF="#ss:c:signatures">8.2.2</A>, illustrates not only catching an 
exception but determining whether it is one of the types identified 
in the specification:
<A NAME="@default461"></A>
<A NAME="@default462"></A><A NAME="@default463"></A>
<A NAME="@default464"></A>
<A NAME="@default465"></A><A NAME="@default466"></A>
<A NAME="@default467"></A><A NAME="@default468"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "sidl_Exception.h"
<FONT COLOR="blue"><I>/* ...numerous lines deleted... */</I></FONT>
  <B>int</B> x;
  sidl_BaseInterface _ex = NULL;

  x = ExceptionTest_Fib_getFib(f, 10, 1, 100, 0, &amp;_ex);
  <B>if</B> (SIDL_CATCH(_ex, "ExceptionTest.TooDeepException")) {
    traceback(_ex);
    SIDL_CLEAR(_ex);
  }
  <B>else if</B> (SIDL_CATCH(_ex, "ExceptionTest.TooBigException")) {
    traceback(_ex);
    SIDL_CLEAR(_ex);
  }
  <B>else if</B> (_ex == NULL) {
    <B>return</B> FALSE;
  }
  SIDL_CHECK(_ex);
  <B>return</B> TRUE;

  EXIT:;
    traceback(_ex);
    SIDL_CLEAR(_ex);
    <B>return</B> FALSE;</TD></TR>
</TABLE><P>As an alternative to using <TT>SIDL_CHECK</TT><A NAME="@default469"></A>,
<TT>_ex</TT> can be compared to <TT>NULL</TT> directly. Similarly, instead of
using <TT>SIDL_CATCH</TT><A NAME="@default470"></A>, type casting can be used to determine 
which of the potential exception types was actually thrown.</P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.7  Hooks execution</H3><!--SEC END --><P><A NAME="ss:c:sethooks"></A>
<A NAME="@default471"></A><A NAME="@default472"></A>
<A NAME="@default473"></A><A NAME="@default474"></A>
<A NAME="@default475"></A><A NAME="@default476"></A></P><P>If a given component supports pre- and post-method invocation instrumentation,
also known as “hooks”, their execution can be enabled or disabled at
runtime through the built-in <TT>_set_hooks</TT> method. For example,
given the following SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class, the processes for enabling and disabling
execution of the implementation-specific hooks are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  hooks_Basics obj;
  sidl_BaseInterface _ex = NULL;

  obj = hooks_Basics__create(&amp;exception); SIDL_CHECK(exception);

  <FONT COLOR="blue"><I>/* Enable hooks execution (enabled by default if hooks generated) */
  /* ... for static methods */</I></FONT>
  hooks_Basics__set_hooks_static(TRUE, &amp;_ex); SIDL_CHECK(exception);

  <FONT COLOR="blue"><I>/* ... for non-static methods */</I></FONT>
  hooks_Basics__set_hooks(obj, TRUE, &amp;_ex); SIDL_CHECK(exception);


  <FONT COLOR="blue"><I>/* ...do something meaningful... */


  /* Disable hooks execution */
  /* ... for static methods */</I></FONT>
  hooks_Basics__set_hooks_static(FALSE, &amp;_ex); SIDL_CHECK(exception);

  <FONT COLOR="blue"><I>/* ... for non-static methods */</I></FONT>
  hooks_Basics__set_hooks(obj, FALSE, &amp;_ex); SIDL_CHECK(exception);


  <FONT COLOR="blue"><I>/* ...do something meaningful... */</I></FONT></TD></TR>
</TABLE><P>It is important to keep in mind that the <TT>_set_hooks_static</TT>
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>_set_hooks</TT> method must be used for those of
non-static methods. Also, Babel does not provide client access to the
<TT>_pre</TT> and <TT>_post</TT> methods; therefore, they cannot be invoked
directly. More information on the instrumentation process is provided
in Subsection <A HREF="#ss:c:hooksimpl">8.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.3.8  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:c:contract_enforcement"></A>
<A NAME="@default477"></A>
<A NAME="@default478"></A>
<A NAME="@default479"></A></P><P>Interface contracts specify the expected behaviors of callers (or clients) 
and callees (or servers) of methods defined for interfaces and classes.
Once specified, contracts are optionally enforced at runtime, through checks
automatically integrated into the middleware generated by the Babel compiler.
This section provides an example of a specification and code snippets for
performing basic, traditional contract enforcement — introduced in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — in a C client.</P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below. 
(Refer to Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.) 
According to the preconditions,
<A NAME="@default480"></A><A NAME="@default481"></A>
<A NAME="@default482"></A>
all callers are expected to provide two one-dimensional, SIDL arrays of the 
same size as arguments. 
The postconditions
<A NAME="@default483"></A><A NAME="@default484"></A>
<A NAME="@default485"></A>
specify that all implementations are expected to return a non-null, 
one-dimensional array of the same size (as the first SIDL array), 
assuming the preconditions are satisfied.</P><P><A NAME="@default486"></A>
<A NAME="@default487"></A>
<A NAME="@default488"></A>
<A NAME="@default489"></A><A NAME="@default490"></A>
<A NAME="@default491"></A>
<A NAME="@default492"></A>
<A NAME="@default493"></A>
<A NAME="@default494"></A>
<A NAME="@default495"></A>
<A NAME="@default496"></A>
<A NAME="@default497"></A>
<A NAME="@default498"></A>
<A NAME="@default499"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a C client using the method is given below. The code snippet 
illustrates declaring and creating the arrays; enabling full contract 
enforcement (i. e., checking all contract clauses); executing <TT>vuSum</TT>; 
handling contract violation exceptions; and cleaning up references is given 
below.</P><P><A NAME="@default500"></A>
<A NAME="@default501"></A>
<A NAME="@default502"></A>
<A NAME="@default503"></A>
<A NAME="@default504"></A>
<A NAME="@default505"></A>
<A NAME="@default506"></A>
<A NAME="@default507"></A>
<A NAME="@default508"></A>
<A NAME="@default509"></A>
<A NAME="@default510"></A>
<A NAME="@default511"></A>
<A NAME="@default512"></A>
<A NAME="@default513"></A>
<A NAME="@default514"></A>
<A NAME="@default515"></A>
<A NAME="@default516"></A>
<A NAME="@default517"></A>
<A NAME="@default518"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "sidl_EnfPolicy.h"
<B>#include</B> "sidl_Exception.h"

<FONT COLOR="blue"><I>/* ... */</I></FONT>
{
  sidl_BaseInterface         exception = NULL;
  <B>struct</B> sidl_double__array* x         = NULL;
  <B>struct</B> sidl_double__array *u         = NULL;
  <B>struct</B> sidl_double__array *v         = NULL;
  sidl_BaseInterface         _ex       = NULL;

  u = sidl_double__array_create1d(max_size);
  v = sidl_double__array_create1d(max_size);

  <FONT COLOR="blue"><I>/* Initialize u and v IF they are non-NULL. */

  /* Enable FULL contract enforcement. */</I></FONT>
  sidl_EnfPolicy_setEnforceAll(sidl_ContractClass_ALLCLASSES, TRUE,
                               &amp;exception); SIDL_CHECK(exception);

  <FONT COLOR="blue"><I>/* Do something meaningful before execute method. */</I></FONT>

  x = vect_Utils_vuSum(u, v, (sidl_BaseInterface*)(&amp;_ex));
  <B>if</B> (_ex != NULL) {
    <B>if</B> (SIDL_CATCH(_ex, "sidl.PreViolation")) {
      <FONT COLOR="blue"><I>/* Precondition violated.  Do something meaningful. */</I></FONT>
    } <B>else if</B> (SIDL_CATCH(_ex, "sidl.PostViolation")) {
      <FONT COLOR="blue"><I>/* Postcondition violated.  Do something meaningful. */</I></FONT>
    } <B>else</B> {
      <FONT COLOR="blue"><I>/* Unrecognized or unhandled exception. Do something meaningful. */</I></FONT>
      <B>goto</B> EXIT;
    }

  }

  <FONT COLOR="blue"><I>/* Do something meaningful with the result, x. */
  /* ... */</I></FONT>

  <B>if</B> (x != NULL) sidl_double__array_deleteRef(x);
  sidl__array_deleteRef((<B>struct</B> sidl__array*)u);
  sidl__array_deleteRef((<B>struct</B> sidl__array*)v);
  <B>return</B> 0;

  EXIT:;
    <B>if</B> (x != NULL) sidl_double__array_deleteRef(x);
    <B>if</B> (_ex !=NULL) {
      sidl_BaseInterface _tae = NULL;
      sidl_SIDLException _cue = sidl_SIDLException__cast(_ex, &amp;_tae);
      <B>if</B> (_cue != NULL) {
        printExceptionNote(_cue);
        sidl_SIDLException_deleteRef(_cue, &amp;_tae);
      }
      sidl_BaseInterface_deleteRef((sidl_BaseInterface)_ex, &amp;_tae);
      _ex = NULL;
    }
    <B>return</B> -1;
}</TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the C calls associated with the traditional
options of enabling only precondition enforcement, enabling postcondition
enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default519"></A>
<A NAME="@default520"></A>
<A NAME="@default521"></A>
<A NAME="@default522"></A>
<A NAME="@default523"></A>
<A NAME="@default524"></A>
<A NAME="@default525"></A>
<A NAME="@default526"></A>
<A NAME="@default527"></A>
<A NAME="@default528"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "sidl_EnfPolicy.h"
<B>#include</B> "sidl_Exception.h"

{
   <FONT COLOR="blue"><I>/* ... */

  /*
   * Enable only precondition contract enforcement.
   * (Useful when only need to ensure callers comply with contract.)
   */</I></FONT>
  sidl_EnfPolicy_setEnforceAll(sidl_ContractClass_PRECONDS, FALSE,
                               &amp;exception); SIDL_CHECK(exception);

  <FONT COLOR="blue"><I>/*
   * Enable only postcondition contract enforcement.
   * (Useful when only need to ensure implementation(s) comply with contract.)
   */</I></FONT>
  sidl_EnfPolicy_setEnforceAll(sidl_ContractClass_POSTCONDS, FALSE,
                               &amp;exception); SIDL_CHECK(exception);

  <FONT COLOR="blue"><I>/*
   * Disable contract enforcement.
   * (Should only be used when have confidence in caller AND implementation.)
   */</I></FONT>
  sidl_EnfPolicy_setEnforceNone(FALSE, &amp;exception); SIDL_CHECK(exception);

  EXIT:
    <FONT COLOR="blue"><I>/* Do something with exception */</I></FONT>
}</TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a C client. 
Additional enforcement policy options and methods as well as more
information regarding the specification and enforcement of contracts
can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">8.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:c:implementation"></A>
<A NAME="@default529"></A></P><P>This section summarizes aspects of generating and wrapping software 
written in C. The bindings generation and basic implementation processes 
are presented first.
Since access to private data requires special steps in C, the process
for defining and managing that data is discussed. Throwing
exceptions in the implementation is then illustrated.
Finally, the results of generating implementations with pre- and post-method
“hooks” are shown.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:c:implgen"></A>
<A NAME="@default530"></A>
<A NAME="@default531"></A><A NAME="@default532"></A></P><P>To create the C implementation bindings for a set of SIDL classes,
Babel should be invoked as follows:
<A NAME="@default533"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=C file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or use the short form
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -sC file.sidl</B><BR>
</TT></BLOCKQUOTE><P>The command creates a number of files. Specifically, a Makefile fragment, 
called <TT>babel.make</TT>, headers, and source files are generated. 
The only files needing hand-editing are the C “Impl” files — which 
are header and source files whose names end in <TT>_Impl.h</TT> or
<TT>_Impl.c</TT>, respectively. More on this in Subsection <A HREF="#ss:c:implfill">8.4.2</A>.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:c:implfill"></A>
<A NAME="@default534"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:c:implgen">8.4.1</A>. Changes to these files must be made between 
code splicer pairs to ensure their retention in subsequent invocations of
Babel.
The following is an example of a code splicer pair in C:
<A NAME="@default535"></A><A NAME="@default536"></A>
<A NAME="@default537"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(num.Linsol._includes) */
/* Insert-Code-Here {num.Linsol._includes} (includes and arbitrary code) */
/* DO-NOT-DELETE splicer.end(num.Linsol._includes) */</I></FONT></TD></TR>
</TABLE><P>A snippet from the Babel-generated implementation file for the 
<TT>solve</TT> example from Subsection <A HREF="#ss:r-arrays">6.4</A> is given below, 
wherein r-array data are presented as <TT>double</TT> pointers, and 
index variables are normal integers.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
impl_num_Linsol_solve(<FONT COLOR="blue"><I>/* in */</I></FONT> num_Linsol self,
                      <FONT COLOR="blue"><I>/* in rarray[m,n] */</I></FONT> <B>double</B>* A,
                      <FONT COLOR="blue"><I>/* inout rarray[n] */</I></FONT> <B>double</B>* x,
                      <FONT COLOR="blue"><I>/* in */</I></FONT> int32_t m,
                      <FONT COLOR="blue"><I>/* in */</I></FONT> int32_t n,
                      <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex)
{
  *_ex = 0;
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(num.Linsol.solve) */
  /* Insert-Code-Here {num.Linsol.solve} (solve method) */
  /* DO-NOT-DELETE splicer.end(num.Linsol.solve) */</I></FONT>
}</TD></TR>
</TABLE><P>Data for the 2-D array, <TT>A</TT>, is in column-major order. The
<TT>RarrayElem2</TT><A NAME="@default538"></A> helper macro, described in 
Subsection <A HREF="#sss:c:arrays">8.2.3</A>, can be used to access <TT>A</TT>.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.4.3  Private data</H3><!--SEC END --><P>
<A NAME="@default539"></A>
<A NAME="@default540"></A></P><P>Any variables declared in the implementation source file will, by
virtue of Babel’s encapsulation, be private. The data can be global
to the class — as in static variables declared within the <TT>_includes</TT>
splicer block at the top of the class’s <TT>_Impl.c</TT> file — or 
local to an instance — as in variables declared through the private data 
structure automatically generated in the class’s <TT>_Impl.h</TT> file. 
In the former case, special initialization procedures can be added to
the built-in <TT>_load()</TT> method that is guaranteed to be called
exactly once per class — <EM>before</EM> any user-defined methods
can even be invoked. The latter case relies on the class-specific
data structure automatically generated in the implementation’s header
file. As illustrated in the <TT>foo.bar</TT> example below, the implementer 
is free to define suitable contents.
<A NAME="@default541"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/*
 * Private data for class foo.bar
 */</I></FONT>

<B>struct</B> foo_bar__data {
<FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(foo.bar._data) */</I></FONT>
  <B>int</B>    d_my_int_array[MY_MAX_ARRAY_SIZE];
  <B>double</B> d_my_double;
<FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(foo.bar._data) */</I></FONT>
}</TD></TR>
</TABLE><P>Upon instantiation, the object’s data structure is automatically 
initialized to <TT>NULL</TT> before the built-in <TT>_ctor()</TT> method
is invoked. Initialization of private data first requires sufficient
memory be allocated, as follows:
<A NAME="@default542"></A>
<A NAME="@default543"></A>
<A NAME="@default544"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
impl_foo_bar__ctor(
   <FONT COLOR="blue"><I>/* in */</I></FONT> foo_bar self)
{
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(foo.bar._ctor) */</I></FONT>
  <B>int</B> i;
  <B>struct</B> foo_bar__data *dataPtr = malloc(<B>sizeof</B>(<B>struct</B> foo_bar__data));
  TSTT_Triangle_Mesh__set_data(self, dataPtr);
  <B>if</B> (dataPtr) {
    <B>for</B> (i=0; i&lt;MY_MAX_ARRAY_SIZE; i++) {
      dataPtr-&gt;d_my_int_array[i] = i;
    }
    dataPtr-&gt;d_my_double = 0.0;
  }
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(foo.bar._ctor) */</I></FONT>
}</TD></TR>
</TABLE><P>To avoid leaking memory, allocated private data must be released during
instance destruction. This is accomplished through the built-in
<TT>_dtor()</TT> method. Continuing with the <TT>foo.bar</TT> example, the 
memory is freed as follows:
<A NAME="@default545"></A>
<A NAME="@default546"></A>
<A NAME="@default547"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
impl_foo_bar__dtor(
   <FONT COLOR="blue"><I>/* in */</I></FONT> foo_bar self)
{
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(foo.bar._dtor) */</I></FONT>
  <B>struct</B> foo_bar__data *dataPtr = foo_bar__get_data(self);
  <B>if</B> (dataPtr) {
    memset(dataPtr, 0, <B>sizeof</B>(<B>struct</B> foo_bar__data));
    free((<B>void</B>*)dataPtr);
  }
  foo_bar__set_data(self, NULL);
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(foo.bar._dtor) */</I></FONT>
}</TD></TR>
</TABLE><P>Notice all memory locations are initialized to zero before being
freed and the internal data pointer set to <TT>NULL</TT>. These
practices are recommended.</P><P>Hence, Babel supports the declaration and maintenance of private
data on class and instance basis.</P><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.4.4  Exception throwing</H3><!--SEC END --><P>
<A NAME="@default548"></A><A NAME="@default549"></A>
<A NAME="@default550"></A></P><P>In addition to the helpers discussed in Subsection <A HREF="#ss:c:exceptions">8.3.6</A>,
<TT>sidl_Exception.h</TT> provides the following 
<TT>SIDL_THROW</TT><A NAME="@default551"></A> macro for throwing exceptions:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">SIDL_THROW(EX_VAR,EX_CLS,MSG)</TD></TR>
</TABLE><P>The first argument to the macro is the exception output parameter; the
second is the type of exception being thrown; and the third provides 
a textual description of the exception.
The following code snippet, which is an extension of the 
Subsection <A HREF="#ss:c:exceptions">8.3.6</A> example, 
illustrates the process of using the macro to throw an exception:
<A NAME="@default552"></A>
<A NAME="@default553"></A><A NAME="@default554"></A>
<A NAME="@default555"></A><A NAME="@default556"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "sidl_Exception.h"
<FONT COLOR="blue"><I>/* ...numerous lines deleted... */</I></FONT>
int32_t
impl_ExceptionTest_Fib_getFib(
  ExceptionTest_Fib self, int32_t n, int32_t max_depth, int32_t max_value,
    int32_t depth, sidl_BaseInterface* _ex)
{
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFib) */</I></FONT>
  <B>if</B> (n &lt; 0) {
    SIDL_THROW(*_ex,
               ExceptionTest_NegativeValueException,
               "called with negative n");
  }
  <FONT COLOR="blue"><I>/* ...lines deleted... */</I></FONT>
  EXIT:;
    <FONT COLOR="blue"><I>/* SIDL_THROW macro will jump here. */
    /* Clean up code should be here. */</I></FONT>
    <B>return</B> theValue;
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFib) */</I></FONT>
}</TD></TR>
</TABLE><P><TT>EX_VAR</TT> is the exception object itself; <TT>EX_CLS</TT> is the 
string containing the name of the desired SIDL exception type; and 
<TT>MSG</TT> is the string containing the message to be included with 
the exception. 
As with the other helpers, the presence of the <TT>EXIT</TT> label is 
assumed in the macro. Statements following <TT>EXIT</TT> should be used
to conduct clean up operations, such as deleting any references that 
were to be returned to the caller. </P><P>A good practice we recommend is
to set all <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> and <FONT COLOR=maroon><I><TT>out</TT></I></FONT> array, interface or class pointers to
<TT>NULL</TT>. This makes things work out better for clients who forget
to check if an exception occurred or willfully choose to ignore it.</P><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->8.4.5  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:c:hooksimpl"></A>
<A NAME="@default557"></A><A NAME="@default558"></A>
<A NAME="@default559"></A>
<A NAME="@default560"></A><A NAME="@default561"></A>
<A NAME="@default562"></A><A NAME="@default563"></A></P><P>As discussed in Subsection <A HREF="#ss:c:sethooks">8.3.7</A>, when hooks execution
is enabled, implementation-specific instrumentation is executed. Using 
the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results
in the automatic generation of a <TT>_pre</TT> and <TT>_post</TT>
method for every static and non-static method associated with each class
in the specification. For the <TT>aStaticMethod</TT> specified in
Subsection <A HREF="#ss:c:sethooks">8.3.7</A>, the generated <TT>_pre</TT> method
implementation is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
impl_hooks_Basics_aStaticMeth_pre(int32_t i, int32_t io,
                                  sidl_BaseInterface *_ex)
{
  *_ex = 0;
  {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre) */
  /*
   * Add instrumentation here to be executed immediately prior
   * to dispatch to aStaticMeth().
   */
  /* DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre) */</I></FONT>
  }
}</TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B>
impl_hooks_Basics_aStaticMeth_post(int32_t i, int32_t o, int32_t io,
                                   int32_t _retval, sidl_BaseInterface *_ex)
{
  *_ex = 0;
  {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post) */
  /*
   * Add instrumentation here to be executed immediately after
   * return from dispatch to aStaticMeth().
   */
  /* DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post) */</I></FONT>
  }
}</TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation 
should be added within the splicer blocks of 
<TT>aStaticMethod_pre</TT> and 
<TT>aStaticMethod_post</TT>. As stated in the comments 
within those blocks, <TT>aStaticMethod_pre</TT> will be 
executed immediately prior to dispatch to <TT>aStaticMethod</TT> when the 
latter is invoked by a client. Assuming no exceptions are encountered, 
<TT>aStaticMethod_post</TT> is executed immediately upon 
return from <TT>aStaticMethod</TT>.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note14" HREF="#text14">1</A></DT><DD CLASS="dd-thefootnotes">For 
information on additional command line options, refer to 
Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter C++ Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc38">Chapter 9</A>  C++ Bindings</H1><!--SEC END --><P><A NAME="c:cxx"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">9.1</A>  Introduction</H2><!--SEC END --><P>This chapter gives an overview of the C++ bindings for SIDL as of Babel 1.0.
The original C++ bindings, available in the first public release 
(0.5.0 in July 2001), underwent a significant redesign thanks to Steve
Parker at the University of Utah. The result became known as the Utah C++ 
(i. e., initially tagged UCxx) alternative to the 
original bindings (0.10.0 January 2005). As of 1.0.0, the Utah 
version is the only binding released for C++.</P><P>Common aspects of those bindings, such as the mapping of SIDL data types to 
their C++ counterparts, are presented in Section <A HREF="#s:cxx:basics">9.2</A>.
Issues of concern to callers written in C++ are addressed in the 
client-side discussion in Section <A HREF="#s:cxx:client">9.3</A>, while issues for callees 
appear in the implementation-side discussion in 
Section <A HREF="#s:cxx:implementation">9.4</A>.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc40">9.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:cxx:basics"></A></P><P>This section summarizes basic features that are common to both client and
implementation bindings.
Subsection <A HREF="#ss:cxx:namespace">9.2.1</A> describes conventions used to establish
name spaces, while those associated with the generation
of subroutines from methods are given in Subsection <A HREF="#ss:cxx:signatures">9.2.2</A>.
The mapping of fundamental and key SIDL types is given in 
Subsection <A HREF="#ss:cxx:types">9.2.3</A>. 
Finally, casting between different types is discussed in 
Subsection <A HREF="#ss:cxx:casting">9.2.4</A>.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.2.1  Name space</H3><!--SEC END --><P><A NAME="ss:cxx:namespace"></A>
<A NAME="@default564"></A>
<A NAME="@default565"></A></P><P>The C++ bindings take advantage of language features to protect the global
name space. In particular, SIDL packages are mapped to C++ name spaces.
Interfaces and classes are mapped to 
proxy classes, called “stubs”, which serve as the firewall 
between the application in C++ and Babel’s internal workings. 
Static SIDL methods are translated into static C++ member functions,
while non-static methods are mapped to non-static C++ member functions.</P><P><EM><B>NOTE</B>:
For backward compatibility, as of the 1.0 release, the
<TT>SIDL_USE_UCXX</TT>, <TT>UCXX</TT>, and <TT>UCXX_LOCAL</TT> 
preprocessor macros are undefined. <TT>SIDL_USE_UCXX</TT> is used in
<TT>#ifdef SIDL_USE_CXX</TT>/<TT>#endif</TT> blocks to specify 
the <TT>ucxx</TT> name space. Hence, <TT>UCXX</TT> was to be used where 
<TT>::ucxx</TT> would normally appear and <TT>UCXX_LOCAL</TT> where 
<TT>ucxx::</TT> would appear.
</EM></P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.2.2  Method signatures</H3><!--SEC END --><P><A NAME="ss:cxx:signatures"></A>
<A NAME="@default566"></A></P><P>Since the bindings are able to map well into C++ language constructs,
C++ method signatures correspond very closely to those in the specification.
Adapted from the Babel regression tests, the following is an example of a 
package called <TT>ExceptionTest</TT> that has a class named <TT>Fib</TT> with 
a method, <TT>getFib</TT>, declared in SIDL as follows:
<A NAME="@default567"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>int</B> getFib(<B>in int</B> n, <B>in int</B> max_depth, <B>in int</B> max_value, <B>in int</B> depth)
  <B>throws</B> NegativeValueException, FibException;</I></FONT></TD></TR>
</TABLE><P>The corresponding C++ method signature is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">int32_t
getFib (/* in */int32_t n, /* in */int32_t max_depth,
        /* in */int32_t max_value, /* in */int32_t depth
)
// throws:
//     ::ExceptionTest::FibException
//     ::ExceptionTest::NegativeValueException
//     ::sidl::RuntimeException
;</TD></TR>
</TABLE><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.2.3  Data types</H3><!--SEC END --><P><A NAME="ss:cxx:types"></A>
<A NAME="@default568"></A>
<A NAME="@default569"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 9.1: SIDL to C++ Type Mappings</TD></TR>
</TABLE></DIV><A NAME="tbl:cxx:types"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B>C++ TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>int32_t</TT> <A NAME="@default570"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>int64_t</TT> <A NAME="@default571"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>float</TT> <A NAME="@default572"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>double</TT> <A NAME="@default573"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>bool</TT> <A NAME="@default574"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>char</TT> <A NAME="@default575"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>std::string</TT> <A NAME="@default576"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl::fcomplex</TT> <A NAME="@default577"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl::dcomplex</TT> <A NAME="@default578"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>enum</TT> <A NAME="@default579"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl::opaque</TT> <A NAME="@default580"></A><A NAME="@default581"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>class</TT> <A NAME="@default582"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>class</TT> <A NAME="@default583"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>array</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl::array</TT> (template specialization) <A NAME="@default584"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Basic SIDL types are mapped into C++ according to 
Table <A HREF="#tbl:cxx:types">9.1</A>. The remainder of this subsection 
illustrates the use of enumerations and arrays.</P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:cxx:enums"></A>
<A NAME="@default585"></A><A NAME="@default586"></A>
<A NAME="@default587"></A><A NAME="@default588"></A></P><P>Since SIDL enumerations map to C++ enumerations, their use is fairly
straight-forward. The appropriate header file must be included.
The naming convention for enumerations is for <TT>enums</TT> to be the
name space followed by the specified enumeration type as the name of 
the enumeration. A given enumeration value name starts with
the enumeration type and the name of the constant, with an underscore as
the separator.
For example, a variable can be assigned the <TT>blue</TT> constant for 
the <TT>color</TT> enumeration of the sample in 
Subsection <A HREF="#ssec:basics:fundamental:enums">6.3</A> as follows:
<A NAME="@default589"></A><A NAME="@default590"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#include "enums_color.hxx"

/* ...deleted lines... */
enums::color myColor = enums::color_blue;</TD></TR>
</TABLE><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:cxx:arrays"></A>
<A NAME="@default591"></A>
<A NAME="@default592"></A><A NAME="@default593"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Normal SIDL arrays can be used by any supported
language; whereas, r-arrays are restricted to numeric types. This subsection 
discusses both within the context of C++ bindings. </P><P><A NAME="@default594"></A><A NAME="@default595"></A>
Although it is feasible to expose the underlying C array API to create, 
destroy and access normal array elements and meta-data, the C++ bindings
provide a <TT>sidl::array&lt;T&gt;</TT> template mechanism that is more in keeping 
with C++ idioms. 
For SIDL built-in types, template specializations of <TT>sidl::array&lt;T&gt;</TT>
are defined in <TT>sidl_ucxx.hxx</TT><A NAME="@default596"></A>. 
The array template is specialized in the corresponding stub header for
SIDL interfaces and classes.
The extensive use of template specialization is used in an effort 
to hide details that the array implementation shifts between
the C++ type externally, and the C-based types stored in the IOR.
(See <TT>basearray</TT> in <TT>sidl_ucxx.hxx</TT> for the traits classes 
and grungy implementation details.) 
For example, the process to create a one-dimensional SIDL array of prime 
numbers is:
<A NAME="@default597"></A>
<A NAME="@default598"></A><A NAME="@default599"></A>
<A NAME="@default600"></A><A NAME="@default601"></A>
<A NAME="@default602"></A><A NAME="@default603"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">int32_t len = 10; // array length=10
int32_t dim = 1;  // one dimensional
int32_t lower[1] = {0}; // zero offset
int32_t upper[1] = {len-1};
int32_t prime = nextPrime(0);

// create a SIDL array of primes.
sidl::array&lt;int32_t&gt; a = sidl::array&lt;int32_t&gt;::createRow(dim, lower, upper);
for( int i=0; i&lt;len; ++i ) {
   prime = nextPrime( prime );
   a.set(i, v);
}</TD></TR>
</TABLE><P>Of course, the example above is only one way to create an array. 
The list of member functions for all C++ array classes is: </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">// constructors
array ( ior_array_t * src ); // internal
array ( const array &amp; src ); // copy constructor

// destructor
~array() ;

// create row-size of 1 to 7 dimensions
static array&lt;T&gt;
createRow( int32_t dimen, const int32_t lower[],
           const int32_t upper[]);

// create column-wise of 1 to 7 dimensions
static array&lt;T&gt;
createCol( int32_t dimen, const int32_t lower[],
           const int32_t upper[]);

// create 1-D array of specified length
static array&lt;T&gt; create1d( int32_t len );

// create 1-D array of specified length and init
static array&lt;T&gt; create1d(int32_t len, ior_item_internal_t data)

// create 2-D array of specified extents
static array&lt;T&gt; create2dCol( int32_t m, int32_t n);

// create 2-D array of specified extents
static array&lt;T&gt; create2dRow( int32_t m, int32_t n);

// get a slice of the array
array&lt;T&gt;
slice( int32_t dimen, const int32_t numElem[],
       const int32_t *srcStart = 0,
       const int32_t *srcStride = 0,
       const int32_t *newStart = 0);

void borrow( item_ior_t * first_element, int32_t dimen,
        const int32_t lower[], const int32_t upper[],
        const int32_t stride[]);

void ensure( int32_t dimen, array_ordering ordering );

void addRef();

void deleteRef();

// get/set
cxx_item_t get(int32_t i);
cxx_item_t get(int32_t i1, int32_t i2);
cxx_item_t get(int32_t i1, int32_t i2, int32_t i3);
cxx_item_t get(int32_t i1, int32_t i2, int32_t i3,
                       int32_t i4);
cxx_item_t get(int32_t i1, int32_t i2, int32_t i3,
                       int32_t i4, int32_t i5);
cxx_item_t get(int32_t i1, int32_t i2, int32_t i3,
                       int32_t i4, int32_t i5, int32_t i6);
cxx_item_t get(int32_t i1, int32_t i2, int32_t i3,
                       int32_t i4, int32_t i5, int32_t i6, int32_t i7);
cxx_item_t get(const int32_t *indices);

void set(int32_t i, cxx_item_t elem);
void set(int32_t i1, int32_t i2, cxx_item_t elem);
void set(int32_t i1, int32_t i2, int32_t i3,
         cxx_item_t elem);
void set(int32_t i1, int32_t i2, int32_t i3, int32_t i4,
         cxx_item_t elem);
void set(int32_t i1, int32_t i2, int32_t i3, int32_t i4,
         int32_t i5, cxx_item_t elem);
void set(int32_t i1, int32_t i2, int32_t i3, int32_t i4,
         int32_t i5, int32_t i6, cxx_item_t elem);
void set(int32_t i1, int32_t i2, int32_t i3, int32_t i4,
         int32_t i5, int32_t i6, int32_t i7, cxx_item_t elem);
void set(const int32_t *indices, cxx_item_t elem);

// [] overloaded to be same as get(i)
cxx_item_t operator[](int32_t i) const ;

bool is1dPacked() const;

// returns STL forward iterator iff 1DPacked, else null
iterator begin();

// returns STL forward iterator iff 1DPacked, else null
const_iterator begin();

// returns STL forward iterator iff 1DPacked, else null
iterator end();

// returns STL forward iterator iff 1DPacked, else null
const_iterator end();

const int32_t* first() const;

int32_t* first();

void copy( const array&lt; T &gt;&amp; src );


// other accessors
int32_t dimen() const;

int32_t lower( int32_t dim ) const;

int32_t upper( int32_t dim ) const;

int32_t stride( int32_t dim ) const;

bool _is_nil() const;

bool _not_nil() const;

// get a const pointer to the actual array ior
const array_ior_t* _get_ior() const;

// get a non-const pointer to the actual array ior
array_ior_t* _get_ior();

void _set_ior( ior_array_t * s);

array&amp; operator =(const array &amp;rhs);

array&amp; operator =(const basearray &amp;rhs);</TD></TR>
</TABLE><P>where 
<TT>cxx_array_t</TT>, 
<TT>cxx_item_t</TT>,
<TT>ior_array_t</TT>,
<TT>ior_item_t</TT>,
<TT>ior_item_internal_t</TT>,
<TT>iterator</TT>,<BR>
<TT>const_iterator</TT>,
<TT>pointer</TT>, and 
<TT>value_type</TT> are all public typedefs in the array class.
Table <A HREF="#tbl:basics:arrayfuncs">6.3</A> provides a brief description of each 
function in the array API.</P><P>The values of these typedefs are determined by traits classes,
which are a fairly standard, albeit advanced, C++ templating
idiom. Refer to any advanced C++ text for a detailed explanation.
Both the <TT>array_traits&lt;&gt;</TT> and <TT>array&lt;&gt;</TT>
template specializations for <TT>int32_t</TT> are reproduced below.
More built-in types and the UCxx stubs for user-defined types can be 
found in <TT>sidl_ucxx.hxx</TT><A NAME="@default604"></A>.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"> // template specialization for array_traits&lt;int32_t&gt;
  template&lt;&gt;
  struct array_traits&lt;int32_t&gt; {
    typedef array&lt;int32_t&gt;                            cxx_array_t;
    typedef int32_t                               cxx_item_t;
    typedef struct sidl_int__array                       ior_array_t;
    typedef int32_t                               ior_item_t;
    typedef const int32_t*      ior_item_internal_t;
    typedef cxx_item_t                               value_type;
    typedef value_type*                              pointer;
    typedef const value_type*                        const_pointer;
  };
 template&lt;&gt;
  class array&lt; int32_t &gt;
    : public basearray
  {
  public:
    typedef basearray                                  Base;
    typedef array_traits&lt;int32_t&gt;::cxx_array_t          cxx_array_t;
    typedef array_traits&lt;int32_t&gt;::cxx_item_t           cxx_item_t;
    typedef array_traits&lt;int32_t&gt;::ior_array_t          ior_array_t;
    typedef array_traits&lt;int32_t&gt;::ior_item_t           ior_item_t;
    typedef array_traits&lt;int32_t&gt;::ior_item_internal_t  ior_item_internal_t;
    typedef array_iter&lt; array_traits&lt;int32_t&gt; &gt;         iterator;
    typedef const_array_iter&lt; array_traits&lt;int32_t&gt; &gt;   const_iterator;
    typedef array_traits&lt; int32_t &gt; ::pointer         pointer;
    typedef array_traits&lt; int32_t &gt; ::value_type      value_type;

    // lots of methods to follow
  }</TD></TR>
</TABLE><P>The C++ mapping for r-arrays is essentially identical to the mapping
for C (see Section <A HREF="#sss:c:arrays">8.2.3</A>). The only difference is that the
C++ client header provides an overloaded version of each method
containing an r-array taking normal SIDL arrays instead of raw
data. 
<A NAME="@default605"></A>
For example, the <TT>solve</TT> method from
Section <A HREF="#ss:r-arrays">6.4</A> produces the following code in the
header file.
<A NAME="@default606"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    void solve (/*in*/    double* A,
                /*inout*/ double* x,
                /*in*/    double* b,
                /*in*/    int32_t m,
                /*in*/    int32_t n) throw ();

    void solve (/*in*/    ::sidl::array&lt;double&gt; A,
                /*inout*/ ::sidl::array&lt;double&gt;&amp; x,
                /*in*/    ::sidl::array&lt;double&gt; b) throw();</TD></TR>
</TABLE><P>Multi-dimensional arrays, such as <TT>A</TT> in the above example,
are stored in column-major order. Babel provides macros to
access r-array data correctly. In this case, for example, 
<TT>RarrayElem2(A, i, j, m)</TT> can be used to access the element in row <TT>i</TT>
and column <TT>j</TT>. In addition, memory can be accessed by stride one 
by making the row index the inner loop and the column index the outer.
Similar macros are available in <TT>sidlArray.h</TT> for arrays of dimension 
1 through 7.</P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.2.4  Type casting</H3><!--SEC END --><P><A NAME="ss:cxx:casting"></A>
<A NAME="@default607"></A><A NAME="@default608"></A>
<A NAME="@default609"></A></P><P>There are two forms of type casting: upcasting and downcasting. 
Upcasting involves casting from a derived, or subclass, to a more general
base class. As a result, it is safely handled with simple assignment.
Downcasting works in the other direction; that is, it involves casting 
an instance of a base class to a more specific subclass.
It should be done with <TT>sidl::babel_cast&lt;&gt;()</TT>. 
Downcasts are successful if the resulting pointer is non-<TT>NULL</TT>.
This can be checked by a call using either <TT>_is_nil()</TT> — for
determining cast failure — or <TT>_not_nil()</TT> — for success.</P><P><EM><B>NOTE</B>:</EM>
Never<EM> 
use <TT>dynamic_cast&lt;&gt;()</TT> on a SIDL object since Babel’s runtime 
system needs to be involved in verifying the legality of the downcast.
</EM></P><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">9.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:cxx:client"></A>
<A NAME="@default610"></A></P><P>This section summarizes aspects of generating and using the C++ bindings
associated with software wrapped with Babel’s language interoperability
middleware. The bindings generation process is presented before the 
convention used to name C++ header files is described. Object management
and invocation of static and overloaded methods are also summarized. 
The process of catching exceptions is then discussed.
Finally, the processes for enabling and disabling implementation-specific
pre- and post-method instrumentation — referred to as “hooks” —
are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.1  Bindings generation</H3><!--SEC END --><P>
<A NAME="@default611"></A>
<A NAME="@default612"></A><A NAME="@default613"></A></P><P>To create the C++ stubs from a SIDL file, invoke Babel as follows<SUP><A NAME="text15" HREF="#note15">1</A></SUP>:
<A NAME="@default614"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=C++ file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply 
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -cC++ file.sidl</B><BR>
</TT></BLOCKQUOTE><P>This will create a <TT>babel.make</TT> file, some C headers and sources, 
and many C++ headers and sources. Files ending in “.c” or “.h” are in C, 
files ending in “.cxx” or “.hxx” are the C++ binding. 
The files will need to be compiled and linked together to use the C++ stubs. </P><P>There is one command line option particular to this language binding.
Using the option <TT>--cxx-ior-exception</TT> (or it’s short form <TT>-x</TT>)
will generate C++ Babel stubs that check for a null IOR whenever a
method is called on them. If a method is called on a stub holding a
null IOR, it will throw a <TT>NullIORException</TT>. If this option is not
passed to Babel, the program will simply crash, as C++ would do
normally with a null pointer.</P><!--TOC subsection Header files-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.2  Header files</H3><!--SEC END --><P>
<A NAME="@default615"></A>
<A NAME="@default616"></A></P><P>All C++ code generated by Babel <TT>#include</TT>’s a file called
"<TT>sidl_ucxx.hh</TT>".<A NAME="@default617"></A><A NAME="@default618"></A> 
<A NAME="@default619"></A><A NAME="@default620"></A>
This file includes <TT>babel_config.h</TT>, the C header file that defines 
configuration information. Finally, <TT>sidl_ucxx.hh</TT> defines some 
C++ classes in the SIDL name space, such as:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>UCXX ::sidl::StubBase</TT> [implementation detail] Common base class for all 
	C++ stubs (proxy classes)<A NAME="@default621"></A>.
</LI><LI CLASS="li-itemize">template&lt;T,U,V&gt; UCXX ::sidl::basearray [implementation detail] 
	Common base class for all C++ array 
	classes.<A NAME="@default622"></A>
</LI><LI CLASS="li-itemize">typedefs for <TT>UCXX ::sidl::fcomplex</TT>, <TT>UCXX ::sidl::dcomplex</TT>, and <TT>UCXX ::sidl::opaque</TT><A NAME="@default623"></A>
	 (usually <TT>std::complex</TT>, <TT>std::complex</TT> and <TT>void*</TT>, respectively).
</LI><LI CLASS="li-itemize"><TT>template&lt;T&gt; UCXX ::sidl::array</TT> Template array type for SIDL arrays. 
</LI><LI CLASS="li-itemize">template specializations [implementation detail] 
	specialization of arrays of all SIDL types are defined in this file. 
</LI></UL><P><EM><B>NOTE</B>:
C++ headers 
have a ".hh"<A NAME="@default624"></A> or a “.hxx”<A NAME="@default625"></A>
suffix to distinguish them from C header files.
In pre-Babel 0.11, all C++ bindings used the “.hh” suffix.
Since Babel 0.11, the “.hh” suffix was exclusively for the original, 
deprecated
binding, while “.hxx” was introduced for the current, UCxx binding.
</EM></P><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.3  Object management</H3><!--SEC END --><P>
<A NAME="@default626"></A>
<A NAME="@default627"></A></P><P>SIDL-specified objects are managed through explicit creation with explicit
reference counting<A NAME="@default628"></A> basically unnecessary.
Babel automatically generates a static method called <TT>_create</TT>
that must be invoked to instantiate a concrete class. 
The default constructor creates the equivalent of a <TT>NULL</TT> pointer. 
Below is an example, using standard Babel classes, that creates an object
of the base class then upcasts it to its parent interface.
<A NAME="@default629"></A>
<A NAME="@default630"></A><A NAME="@default631"></A><A NAME="@default632"></A>
<A NAME="@default633"></A><A NAME="@default634"></A>
<A NAME="@default635"></A><A NAME="@default636"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#ifdef SIDL_USE_UCXX
using namespace ucxx;
#endif

sidl::BaseClass object = sidl::BaseClass::_create();
sidl::BaseInterface interface = object;</TD></TR>
</TABLE><P>SIDL C++ stubs can be treated as smart-pointers.
Constructors, destructors, and operators are overloaded making explicit
calls to <TT>addRef()</TT> or <TT>deleteRef()</TT> rarely needed.</P><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.4  Static methods</H3><!--SEC END --><P>
<A NAME="@default637"></A>
<A NAME="@default638"></A></P><P>As one would expect, proxy (or “stub”) classes maintain minimal state so that,
unlike C or <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, there is no special context argument added to 
non-static member functions. 
An example call to the static <TT>addSearchPath</TT> method of the 
<TT>sidl.Loader</TT> class is:
<A NAME="@default639"></A>
<A NAME="@default640"></A>
<A NAME="@default641"></A><A NAME="@default642"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#ifdef SIDL_USE_UCXX
using namespace ucxx;
#endif

std::string s("/try/looking/here");
sidl::Loader::addSearchPath( s );</TD></TR>
</TABLE><P>Note the function is invoked directly, through the use of its class name,
rather than through an instance.</P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.5  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default643"></A>
<A NAME="@default644"></A></P><P>Since C++ is an object-oriented language, the language is much
more amenable to the SIDL programming model and less demanding
of the programmer than bindings to non-OO languages, such as C 
and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. </P><P>The basic process of invoking overloaded methods is illustrated below based on 
the <TT>overload_sample.sidl</TT> file shown in Section <A HREF="#sec:overloading">6.7</A>.
Recall that the file describes three versions of the <TT>getValue</TT> method. 
The first takes no arguments, the second an integer, and the 
third a boolean. 
<A NAME="@default645"></A>
<A NAME="@default646"></A><A NAME="@default647"></A>
<A NAME="@default648"></A><A NAME="@default649"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#ifdef SIDL_USE_UCXX
using namespace ucxx;
#endif

bool b1, bresult;
int  i1, iresult, nresult;

Overload::Sample t  = Overload::Sample::_create();

nresult = t.getValue();
bresult = t.getValue(b1);
iresult = t.getValue(i1);</TD></TR>
</TABLE><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.6  Exception catching</H3><!--SEC END --><P>
<A NAME="@default650"></A><A NAME="@default651"></A>
<A NAME="@default652"></A></P><P>Since all methods can now throw <TT>sidl.RuntimeException</TT>, Babel 
ensures there is an <TT>out</TT> argument to hold an exception. If not
explicitly specified, Babel will automatically add the argument.
Using the example shown in Subsection <A HREF="#ss:cxx:signatures">9.2.2</A>,
a C++ code fragment (from the regression tests) that utilizes the
<TT>getFib</TT> method is:
<A NAME="@default653"></A>
<A NAME="@default654"></A><A NAME="@default655"></A>
<A NAME="@default656"></A>
<A NAME="@default657"></A><A NAME="@default658"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#ifdef SIDL_USE_UCXX
using namespace ucxx;
#endif

/* ...lines deleted... */
ExceptionTest::Fib fib = ExceptionTest::Fib::_create();
try {
  int result = fib.getFib( 4, 100, 32000, 0 );
  cout &lt;&lt; "Result of fib.getFib() = " &lt;&lt; result &lt;&lt; endl;
} catch ( ExceptionTest::NegativeValueException  e ) {
  // ...
} catch ( ExceptionTest::FibException e ) {
  // ...
}
/* ...lines deleted... */</TD></TR>
</TABLE><P>Note that SIDL exceptions map well into C++ exceptions allowing native 
exception mechanisms to be employed.</P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.7  Hooks execution</H3><!--SEC END --><P><A NAME="ss:cxx:sethooks"></A>
<A NAME="@default659"></A><A NAME="@default660"></A>
<A NAME="@default661"></A><A NAME="@default662"></A>
<A NAME="@default663"></A><A NAME="@default664"></A></P><P>If a given component supports pre- and post-method invocation instrumentation,
also known as “hooks”, their execution can be enabled or disabled at
runtime through the built-in <TT>_set_hooks</TT> method. For example,
given the following SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class, the processes for enabling and disabling 
execution of the implementation-specific hooks are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#ifdef SIDL_USE_UCXX
using namespace ucxx;
#endif

    try {
      hooks::Basics obj = hooks::Basics::_create();

      /* Enable hooks execution (enabled by default) */
      /* ... for static methods */
      hooks::Basics::_set_hooks_static(TRUE);

      /* ... for non-static methods */
      obj._set_hooks(TRUE);


      /* ...do something meaningful... */


      /* Disable hooks execution (on by default) */
      /* ... for static methods */
      hooks::Basics::_set_hooks_static(FALSE);

      /* ... for non-static methods */
      obj._set_hooks(FALSE);


      /* ...do something meaningful... */

    } catch (::sidl::RuntimeException e) {
      cout &lt;&lt; e.getNote() &lt;&lt; endl;
    }</TD></TR>
</TABLE><P>It is important to keep in mind that the 
<TT>_set_hooks_static</TT> 
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>_set_hooks</TT> method must be used for 
those of non-static methods. Also, Babel does not provide client 
access to the <TT>_pre</TT> and <TT>_post</TT> methods; therefore, 
they cannot be invoked directly. More information on the instrumentation 
process is provided in Subsection <A HREF="#ss:cxx:hooksimpl">9.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.3.8  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:cxx:contract_enforcement"></A>
<A NAME="@default665"></A>
<A NAME="@default666"></A>
<A NAME="@default667"></A></P><P>Interface contracts specify the expected behaviors of clients and servers
of interface and class methods.
Once specified, contracts can automatically be enforced at runtime.
This section provides an example of a specification and associated code 
snippets for performing basic, traditional contract enforcement — 
introduced in Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — within a 
C++ client.</P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below.
(Refer to Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.)
According to the preconditions,
<A NAME="@default668"></A><A NAME="@default669"></A>
<A NAME="@default670"></A>
all callers are expected to provide two one-dimensional, SIDL arrays of the
same size as arguments.
The postconditions 
<A NAME="@default671"></A><A NAME="@default672"></A>
<A NAME="@default673"></A>
specify that all implementations are expected to return a non-null, 
one-dimensional array of the same size (as the first SIDL array), 
assuming the preconditions are satisfied.</P><P><A NAME="@default674"></A>
<A NAME="@default675"></A>
<A NAME="@default676"></A>
<A NAME="@default677"></A><A NAME="@default678"></A>
<A NAME="@default679"></A>
<A NAME="@default680"></A>
<A NAME="@default681"></A>
<A NAME="@default682"></A>
<A NAME="@default683"></A>
<A NAME="@default684"></A>
<A NAME="@default685"></A>
<A NAME="@default686"></A>
<A NAME="@default687"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a C++ client calling the method is given below. 
The code snippet illustrates declaring and creating the arrays; 
enabling full contract enforcement (i. e., checking all contract 
clauses); executing <TT>vuSum</TT>; handling contract violation 
exceptions; and cleaning up references is given below.</P><P><A NAME="@default688"></A>
<A NAME="@default689"></A>
<A NAME="@default690"></A>
<A NAME="@default691"></A>
<A NAME="@default692"></A>
<A NAME="@default693"></A>
<A NAME="@default694"></A>
<A NAME="@default695"></A>
<A NAME="@default696"></A>
<A NAME="@default697"></A>
<A NAME="@default698"></A>
<A NAME="@default699"></A>
<A NAME="@default700"></A>
<A NAME="@default701"></A>
<A NAME="@default702"></A>
<A NAME="@default703"></A>
<A NAME="@default704"></A>
<A NAME="@default705"></A>
<A NAME="@default706"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#include "sidl_EnfPolicy.hxx"

/* ... */
{
  ::sidl::array&lt;double&gt; u  = ::sidl::array&lt;double&gt;::create1d(max_size);
  ::sidl::array&lt;double&gt; v  = ::sidl::array&lt;double&gt;::create1d(max_size);
  ::sidl::array&lt;double&gt; x;

  /* Initialize u and v. */

  /* Enable FULL contract enforcement. */
  ::sidl::EnfPolicy::setEnforceAll(::sidl::ContractClass_ALLCLASSES, true);

  /* Do something meaningful before execute method. */

  try {
    x = vect::Utils::vuSum(u, v);
    if (x) {
      /* Do something useful with the result, x. */
    }
  } catch ( ::sidl::PreViolation preExc ) {
    std::cerr&lt;preExc.getNote()&lt;&lt;std::endl;
  } catch ( ::sidl::PostViolation postExc ) {
    std::cerr&lt;postExc.getNote()&lt;&lt;std::endl;
  } catch (...) {
    std::cerr&lt;"Caught unexpected exception."&lt;&lt;std::endl;
    /* Do something meaningful. */
  }

  if (x) { x.deleteRef(); }
  u.deleteRef();
  v.deleteRef();
  return 0;
}</TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the C++ calls associated with the traditional
options of enabling only precondition enforcement, enabling postcondition
enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default707"></A>
<A NAME="@default708"></A>
<A NAME="@default709"></A>
<A NAME="@default710"></A>
<A NAME="@default711"></A>
<A NAME="@default712"></A>
<A NAME="@default713"></A>
<A NAME="@default714"></A>
<A NAME="@default715"></A>
<A NAME="@default716"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#include "sidl_EnfPolicy.hxx"

  /* ... */

  /*
   * Enable only precondition contract enforcement.
   * (Useful when only need to ensure callers comply with contract.)
   */
  ::sidl::EnfPolicy::setEnforceAll(::sidl::ContractClass_PRECONDS, false);

  /*
   * Enable only postcondition contract enforcement.
   * (Useful when only need to ensure implementation(s) comply with contract.)
   */
  ::sidl::EnfPolicy::setEnforceAll(::sidl::ContractClass_POSTCONDS, false);

  /*
   * Disable contract enforcement.
   * (Should only be used when have confidence in caller AND implementation.)
   */
  ::sidl::EnfPolicy::setEnforceNone(false);</TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a C++ client.
Additional enforcement policy options and methods as well as more
information regarding the specification and enforcement of contracts
can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">9.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:cxx:implementation"></A>
<A NAME="@default717"></A></P><P>This section summarizes aspects of generating and wrapping software written
in C++. The bindings generation and basic implementation processes are 
presented first. Accessing private data is then discussed before illustrating 
the process of throwing exceptions.
Finally, the results of generating implementations with pre- and post-method
“hooks” are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:cxx:implgen"></A>
<A NAME="@default718"></A>
<A NAME="@default719"></A><A NAME="@default720"></A></P><P>Much of the information for generating client-side bindings is pertinent to 
implementing a SIDL class in C++. 
SIDL type mappings are listed in Table <A HREF="#tbl:cxx:types">9.1</A>.
An implementation can call other SIDL methods, in which case 
the rules for client calls must be followed. </P><P>To create the implementation, a valid SIDL file must be generated by invoking
Babel as follows: 
<A NAME="@default721"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=C++ file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -sC++ file.sidl</B><BR>
</TT></BLOCKQUOTE><P>As a result, a makefile fragment called <TT>babel.make</TT>, several C header 
and source files, and numerous C++ header and source files are created.
The only files that need to be hand-edited are the C++ “Impl” files 
(i. e., header and source files that end in <TT>_Impl.hxx</TT> or 
<TT>_Impl.cxx</TT>). 
More on this in Subsection <A HREF="#ss:cxx:implfill">9.4.2</A>.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:cxx:implfill"></A>
<A NAME="@default722"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:cxx:implgen">9.4.1</A>. Changes to these files must be made between
code splicer pairs to ensure their retention in subsequent invocations of
Babel. Below is an example of a code splicer pair in C++. 
The actual implementation needs to replace the “// Insert code here...” line.
<A NAME="@default723"></A><A NAME="@default724"></A>
<A NAME="@default725"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">void MyPackage::MyClass_impl::myMethod_impl() {
    // DO-NOT-DELETE splicer.begin(MyPackage.MyClass.myMethod)
    // Insert code here...
    // DO-NOT-DELETE splicer.end(MyPackage.MyClass.myMethod)
}</TD></TR>
</TABLE><P>It is important to understand where and why splicer blocks occur. 
Splicer blocks appear at the beginning and end of each “Impl” header and 
source file to allow
developers to add <TT>#include</TT>’s and other miscellaneous items,
respectively.
In the headers, there is a splicer block that allows a user to make the “Impl”
class inherit from some other class. From SIDL’s point of view this is
private inheritance — meaning that it is useful for inheriting implementation
details — since they cannot be automatically exposed to the SIDL method 
dispatch mechanism. There is a splicer block inside the class definition for 
developers to add any desired data members. 
In the source files, splicer blocks appear in each method implementation. 
Examples of filling in these splicer blocks are provided in the subsections
to follow.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.4.3  Private data</H3><!--SEC END --><P><A NAME="ss:cxx:privatedata"></A>
<A NAME="@default726"></A>
<A NAME="@default727"></A></P><P>Any variables declared in the implementation source file will, by virtue
of Babel’s encapsulation, be private. The data can be global to the class —
as in static variables declared within the <TT>_includes</TT> splicer block
at the top of the class’s <TT>_Impl.cxx</TT> file — or “local” to an 
instance.
In the former case, special initialization procedures can be added to
the built-in <TT>_load()</TT> method that is guaranteed to be called
exactly once per class — <EM>before</EM> any user-defined methods
can even be invoked. The latter case relies on the class-specific
name space automatically generated in the implementation’s header
file. As illustrated in the <TT>foo.bar</TT> example below, the implementor 
is free to define suitable contents.
<A NAME="@default728"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">namespace foo {

  /**
   * Symbol "foo.bar" (version 0.1)
   */
  class bar_impl : public virtual ::foo::bar
  // DO-NOT-DELETE splicer.begin(foo.bar._inherits)
  // Put additional inheritance here...
  // DO-NOT-DELETE splicer.end(foo.bar._inherits)
  {

  // All data marked protected will be accessable by
  // descendant Impl classes
  protected:
    bool _wrapped;

    // DO-NOT-DELETE splicer.begin(foo.bar._implementation)
    char*  d_timestamp;
    // DO-NOT-DELETE splicer.end(foo.bar._implementation)

  public:
    /* ...lines deleted... */
  }
}</TD></TR>
</TABLE><P>If the object has no state, these functions are typically empty. 
The built-in <TT>_ctor()</TT> method is invoked upon instantiation. 
Hence, private data should be initialized in the method. For example:
<A NAME="@default729"></A>
<A NAME="@default730"></A><A NAME="@default731"></A>
<A NAME="@default732"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">void foo::bar_impl::_ctor() {
  // DO-NOT-DELETE splicer.begin(foo.bar._ctor)
  time_t currTime = time(NULL);
  sidl_String_strdup(d_timestamp, ctime(&amp;currTime));
  // DO-NOT-DELETE splicer.end(foo.bar._ctor)
}</TD></TR>
</TABLE><P>To avoid leaking memory, private data must be released during
instance destruction. This is accomplished through the built-in
<TT>_dtor()</TT> method. The memory is then freed as follows:
<A NAME="@default733"></A>
<A NAME="@default734"></A><A NAME="@default735"></A>
<A NAME="@default736"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">void foo::bar_impl::_dtor() {
  // DO-NOT-DELETE splicer.begin(foo.bar._dtor)
  sidl_String_free(d_timestamp);
  // DO-NOT-DELETE splicer.end(foo.bar._dtor)
}</TD></TR>
</TABLE><P>Hence, Babel supports the declaration and maintenance of private
data on class and instance basis.</P><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.4.4  Exception throwing</H3><!--SEC END --><P>
<A NAME="@default737"></A>
<A NAME="@default738"></A></P><P>The example below shows the standard way to throw an exception in C++. Use
of <TT>setNote</TT> and <TT>add</TT> methods
is not strictly required; however, they do provide information that may be
helpful in debugging or error reporting.
<A NAME="@default739"></A>
<A NAME="@default740"></A><A NAME="@default741"></A>
<A NAME="@default742"></A><A NAME="@default743"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">int32_t
ExceptionTest::Fib_impl::getFib_impl (
  /*in*/ int32_t n,
  /*in*/ int32_t max_depth,
  /*in*/ int32_t max_value,
  /*in*/ int32_t depth )
// throws:
//     ::ExceptionTest::FibException
//     ::ExceptionTest::NegativeValueException
//     ::sidl::RuntimeException
{
  // DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFib)
  if (n &lt; 0) {
    UCXX ::ExceptionTest::NegativeValueException ex =
      UCXX ::ExceptionTest::NegativeValueException::_create();
    ex.setNote("n negative");
    ex.add(__FILE__, __LINE__, "ExceptionTest::Fib_impl::getFib");
    throw ex;

  } else if (depth &gt; max_depth) {
    UCXX ::ExceptionTest::TooDeepException ex =
      UCXX ::ExceptionTest::TooDeepException::_create();
    ex.setNote("too deep");
    ex.add(__FILE__, __LINE__, "ExceptionTest::Fib_impl::getFib");
    throw ex;

  } else if (n == 0) {
    return 1;

  } else if (n == 1) {
    return 1;

  } else {
    int32_t a = getFib(n-1, max_depth, max_value, depth+1);
    int32_t b = getFib(n-2, max_depth, max_value, depth+1);
    if (a + b &gt; max_value) {
      UCXX ::ExceptionTest::TooBigException ex =
        UCXX ::ExceptionTest::TooBigException::_create();
      ex.setNote("too big");
      ex.add(__FILE__, __LINE__, "ExceptionTest::Fib_impl::getFib");
      throw ex;
    }
    return a + b;
  }
  // DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFib)
}</TD></TR>
</TABLE><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->9.4.5  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:cxx:hooksimpl"></A>
<A NAME="@default744"></A><A NAME="@default745"></A>
<A NAME="@default746"></A>
<A NAME="@default747"></A><A NAME="@default748"></A>
<A NAME="@default749"></A><A NAME="@default750"></A></P><P>As discussed in Subsection <A HREF="#ss:cxx:sethooks">9.3.7</A>, when hooks execution 
is enabled, implementation-specific instrumentation is executed. Using 
the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results
in the automatic generation of a <TT>_pre</TT> and <TT>_post</TT>
method for every static and non-static method associated with each class
in the specification. For the <TT>aStaticMethod</TT> specified in 
Subsection <A HREF="#ss:cxx:sethooks">9.3.7</A>, the generated <TT>_pre</TT> method 
implementation is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">void
hooks::Basics_impl::aStaticMeth_pre_impl(int32_t i, int32_t io )
{
  // DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre)
  /*
   * Add instrumentation here to be executed immediately prior
   * to dispatch to aStaticMeth().
   */
  // DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre)
}</TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">void
hooks::Basics_impl::aStaticMeth_post_impl(int32_t i, int32_t o, int32_t io,
                                          int32_t _retval)
{
  // DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post)
  /*
   * Add instrumentation here to be executed immediately after
   * return from dispatch to aStaticMeth().
   */
  // DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post)
}</TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation
should be added within the splicer blocks of
<TT>aStaticMethod_pre</TT> and
<TT>aStaticMethod_post</TT>. As stated in the comments
within those blocks, <TT>aStaticMethod_pre</TT> will be
executed immediately prior to dispatch to <TT>aStaticMethod</TT> when the
latter is invoked by a client. Assuming no exceptions are encountered,
<TT>aStaticMethod_post</TT> is executed immediately upon
return from <TT>aStaticMethod</TT>.</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note15" HREF="#text15">1</A></DT><DD CLASS="dd-thefootnotes">For 
information on additional command line options, refer to 
Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter FORTRAN 77 Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc43">Chapter 10</A>  FORTRAN 77 Bindings</H1><!--SEC END --><P><A NAME="c:f77"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">10.1</A>  Introduction</H2><!--SEC END --><P>
This chapter provides an overview of the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> bindings for SIDL. 
Common aspects of the bindings, such as the mapping of SIDL data types 
to their native <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> representatives, are presented in 
Section <A HREF="#s:f77:basics">10.2</A>.
Issues of concern to <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> callers are addressed in the client-side
bindings discussion in Section <A HREF="#s:f77:client">10.3</A>, while <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> 
callees would benefit from a review of implementation-side issues in
Section <A HREF="#s:f77:implementation">10.4</A>.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">10.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:f77:basics"></A></P><P>This section summarizes basic features that are common to both client and
implementation bindings. 
Conventions used to protect the global name space are described in 
Subsection <A HREF="#ss:f77:namespace">10.2.1</A>, while those associated with the generation
of subroutines from methods are given in Subsection <A HREF="#ss:f77:signatures">10.2.2</A>.
Translations between SIDL and native <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> constructs are 
described in Subsection <A HREF="#ss:f77:types">10.2.3</A>. 
Finally, the process of casting between different types is illustrated
in Subsection <A HREF="#ss:f77:casting">10.2.4</A>.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.2.1  Name space</H3><!--SEC END --><P><A NAME="ss:f77:namespace"></A>
<A NAME="@default751"></A>
<A NAME="@default752"></A></P><P>As with C bindings, the language does not have built-in mechanisms for 
protecting the global name space. As a result, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> bindings
also attempt to avoid collisions by incorporating relevant naming 
information from the package and class. Since interfaces and classes map
to <TT>INTEGER*8</TT>, there are no naming issues associated with these
SIDL types. However, as discussed in Subsection <A HREF="#ss:f77:signatures">10.2.2</A>, 
name space issues do arise for methods.</P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.2.2  Method signatures</H3><!--SEC END --><P><A NAME="ss:f77:signatures"></A>
<A NAME="@default753"></A>
<A NAME="@default754"></A></P><P>All SIDL methods are implemented as <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>
subroutines<A NAME="@default755"></A> regardless 
of whether they have return values.
The name of a subroutine used to call a SIDL method is a
concatenation of the package, class (or interface), and method
name, where each part is separated by an underscore. If the
method is specified as overloaded (i. e., has a name extension), the
extension is appended to the name part. An additional string is appended 
to further
distinguish between client-side methods (to be invoked) and the
implementation-side, where the former end in “_f” while the latter
end in “_fi”.</P><P>As for arguments,
the object (or interface) pointer is automatically inserted as the first
parameter in the signature of non-static methods. This parameter
operates like an <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameter. 
When a method has a return value, a variable to hold the return value should 
be passed as an argument following the formally declared arguments.
This extra argument behaves like an <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter.
With the addition of remote method invocation (RMI) support, all methods 
now implicitly throw exceptions.<A NAME="@default756"></A>
Hence, an extra <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter for the exception is automatically added 
at the end of the signature.
<A NAME="@default757"></A><A NAME="@default758"></A></P><P>The following SIDL method — taken from regression tests — is an
example of a method that can throw multiple exception types:
<A NAME="@default759"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>int</B> getFib(<B>in int</B> n, <B>in int</B> max_depth, <B>in int</B> max_value, <B>in int</B> depth)
    <B>throws</B> NegativeValueException, FibException;</I></FONT></TD></TR>
</TABLE><P>The corresponding <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> API is:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine ExceptionTest_Fib_getFib_f(self, n, max_depth,
     &amp;     max_value, depth, retval, exception)
        implicit none
C        in ExceptionTest.Fib self
        integer*8 self
C        in int n
        integer*4 n
C        in int max_depth
        integer*4 max_depth
C        in int max_value
        integer*4 max_value
C        in int depth
        integer*4 depth
C        out int retval
        integer*4 retval
C        out sidl.BaseInterface exception
        integer*8 exception
        end</TD></TR>
</TABLE><P>Note the addition of the object (i. e., <TT>self</TT>), 
return (i. e., <TT>retval</TT>), and exception (i. e., <TT>exception</TT>) 
parameters.</P><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.2.3  Data types</H3><!--SEC END --><P><A NAME="ss:f77:types"></A>
<A NAME="@default760"></A><A NAME="@default761"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 10.1: SIDL to <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> Type Mappings</TD></TR>
</TABLE></DIV><A NAME="tbl:f77:types"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B><SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER*4</TT>		<A NAME="@default762"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER*8</TT>		<A NAME="@default763"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>REAL</TT>			<A NAME="@default764"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>DOUBLE PRECISION</TT>	<A NAME="@default765"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>LOGICAL</TT>		<A NAME="@default766"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>CHARACTER*1</TT>		<A NAME="@default767"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>CHARACTER*(*)</TT>		<A NAME="@default768"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>COMPLEX</TT>		<A NAME="@default769"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>DOUBLE COMPLEX</TT>	<A NAME="@default770"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER</TT>		<A NAME="@default771"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER*8</TT>		<A NAME="@default772"></A><A NAME="@default773"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER*8</TT>		<A NAME="@default774"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER*8</TT>		<A NAME="@default775"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>array</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER*8</TT>		<A NAME="@default776"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Basic SIDL types are mapped into <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> according to 
Table <A HREF="#tbl:f77:types">10.1</A><A NAME="@default777"></A>. 
The remainder of this subsection elaborates on mappings of strings, 
pointers, enumerations, and arrays.</P><!--TOC subsubsection Strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Strings</H4><!--SEC END --><P><A NAME="sss:f77:strings"></A>
<A NAME="@default778"></A><A NAME="@default779"></A>
<A NAME="@default780"></A><A NAME="@default781"></A></P><P>When mapping the SIDL string type into <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, some capability was 
sacrificed to make it possible to use normal looking <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> string handling.
<A NAME="@default782"></A> One difference is that all
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> strings have a limited fixed size. Specifically, <FONT COLOR=maroon><I><TT>out</TT></I></FONT> string
parameters are automatically limited to 512 characters each. </P><P><EM><B>NOTE</B>:
Modification of the value of <TT>SIDL_F77_STR_MINSIZE</TT> in 
<TT>runtime/sidl/babel_config.h</TT> prior to configuring Babel 
can be used to change the string size limitation.
</EM></P><!--TOC subsubsection Pointers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Pointers</H4><!--SEC END --><P><A NAME="sss:f77:pointers"></A>
<A NAME="@default783"></A><A NAME="@default784"></A>
<A NAME="@default785"></A><A NAME="@default786"></A></P><P><A NAME="@default787"></A><A NAME="@default788"></A><A NAME="@default789"></A><A NAME="@default790"></A>
<A NAME="@default791"></A>
<A NAME="@default792"></A>
<A NAME="@default793"></A>
<A NAME="@default794"></A>
Pointer types, such as opaque, interface, class, and array, translate into
64-bit integers to enable <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> code portability between systems 
with 32-bit and 64-bit address spaces. 
On a 32-bit system, the upper 32 bits of these quantities are ignored. 
Systems with more than 64-bit pointers aren’t currently supported.
<A NAME="@default795"></A></P><P>Generally, clients should treat opaque, interface, class, and array values 
as black boxes. 
However, there is one value that is special. 
A value of zero for any of these quantities indicates the pointer does 
not refer to an object, thus making zero the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> equivalent of 
<TT>NULL</TT>. Any nonzero value is or should be a valid object reference.
Developers should initialize values to be passed as 
<FONT COLOR=maroon><I><TT>in</TT></I></FONT> or <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> parameters to zero or a valid object reference.</P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:f77:enum"></A>
<A NAME="@default796"></A><A NAME="@default797"></A>
<A NAME="@default798"></A><A NAME="@default799"></A></P><P>SIDL enumerations map to integer values. For compilers that support some
form of inclusion, constants are defined in an inclusion file. 
Specifically, Babel will
generate <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> include files in the style of DEC FORTRAN (Compaq
FORTRAN? (now HP FORTRAN???)) <TT>%INCLUDE</TT>. These files are named
by taking the fully qualified name<A NAME="@default800"></A> of the <FONT COLOR=maroon><I><TT>enum</TT></I></FONT>, 
changing the periods to underscores, and appending <TT>.inc</TT>. </P><P>Given the specification of a <FONT COLOR=maroon><I><TT>car</TT></I></FONT> enumeration type from 
Section <A HREF="#ssec:basics:fundamental:enums">6.3</A>, the corresponding 
include file is:
<A NAME="@default801"></A><A NAME="@default802"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
C       File:          enums_car.inc
C       Symbol:        enums.car-v1.0
C       Symbol Type:   enumeration
C       Babel Version: 0.5.0
C       Description:   Automatically generated; changes will be lost
C
C       babel-version = 0.5.0
C       source-line   = 25
C
        integer porsche
        parameter (porsche = 911)
        integer ford
        parameter (ford = 150)
        integer mercedes
        parameter (mercedes = 550)</TD></TR>
</TABLE><P>The following snippet illustrates the inclusion of the file and an assignment of
the <TT>mercedes</TT> constant:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        integer*4 myCar

C       include the enumeration constants file
        include 'enums_car.inc'

        myCar = mercedes</TD></TR>
</TABLE><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:f77:arrays"></A>
<A NAME="@default803"></A><A NAME="@default804"></A>
<A NAME="@default805"></A><A NAME="@default806"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Normal SIDL arrays can be used by any supported
language; whereas, r-arrays are restricted to numeric types and use in
languages such as C, C++, and Fortran. This subsection discusses both
within the context of <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> bindings. More information on the FORTRAN
77 version of the SIDL array API can be found in 
Subsection <A HREF="#ss:basics:array:api">6.4</A>.</P><P>The difference in how normal SIDL arrays and r-arrays are accessed is profound. 
A normal SIDL array is passed as an
<TT>integer*8</TT>, and accessed using an API or
by converting the array data to an index into a known array. 
R-arrays<A NAME="@default807"></A><A NAME="@default808"></A>
appear like normal <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> arrays, so there is a big incentive to
use r-arrays for performance purposes, when appropriate.</P><P>The client-side interface for the <TT>solve</TT> example introduced in
Section <A HREF="#ss:r-arrays">6.4</A> behaves as if it is a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> function
with the following declarations:
<A NAME="@default809"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine num_Linsol_solve_f(self, A, x, m, n, exception)
        implicit none
C       in num.Linsol self
        integer*8 self
C       in int m, n
        integer*4 m, n
C       out sidl.BaseInterface exception
        integer*8 exception
C       in rarray&lt;double,2&gt; A(m,n)
        double precision A(0:m-1, 0:n-1)
C       inout rarray&lt;double&gt; x(n)
        double precision x(0:n-1)
        end</TD></TR>
</TABLE><P><EM><B>NOTE</B>:
Array indices go from
<B>0</B> to <TT>m</TT>−1 instead of the normal 1 to <TT>m</TT>. This
was a concession to the C/C++ programmers who have to deal with the
fact that <TT>A</TT> is stored in column-major order.
</EM></P><P>The remainder of this section is dedicated to describing how normal
SIDL arrays are accessed. The normal SIDL C function API is available 
to create, destroy, and access array elements and meta-data — with 
<TT>_f</TT> appended to subroutine names but no extra exception arguments.</P><P>For <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>,
<FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, and <FONT COLOR=maroon><I><TT>long</TT></I></FONT> SIDL types, 
a method is provided to get direct access to array elements. 
For other types, you must use the array API to access elements.
For SIDL type <TT>X</TT>, a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> function called
<TT>sidl_X__array_access_f</TT> provides direct access, as illustrated
below. This will
<B>not</B> work if your <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> compiler does array bounds checking,
however.
<A NAME="@default810"></A>
<A NAME="@default811"></A><A NAME="@default812"></A>
<A NAME="@default813"></A><A NAME="@default814"></A>
<A NAME="@default815"></A><A NAME="@default816"></A>
<A NAME="@default817"></A><A NAME="@default818"></A>
<A NAME="@default819"></A><A NAME="@default820"></A>
<A NAME="@default821"></A><A NAME="@default822"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        integer*4 lower(1), upper(1), stride(1), i, index(1)
        integer*4 value, refarray(1), modval
        integer*8 nextprime, refindex, tmp
        lower(1) = 0
        value = 0
        upper(1) = len - 1
        call sidl_int__array_create_f(1, lower, upper, retval)
        call sidl_int__array_access_f(retval, refarray, lower,
     $       upper, stride, refindex)
        do i = 0, len - 1
           tmp = value
           value = nextprime(tmp)
           modval = mod(i, 3)
           if (modval .eq. 0) then
              call sidl_int__array_set1_f(retval, i, value)
           else
              if (modval .eq. 1) then
                 index(1) = i
                 call sidl_int__array_set_f(retval, index, value)
              else
C this is equivalent to the sidl_int__array_set_f(retval, index, value)
                 refarray(refindex + stride(1)*(i - lower(1))) =
     $                value
              endif
           endif
        enddo</TD></TR>
</TABLE><P>To access a two-dimensional array, the expression referring to element
<TT>i</TT>, <TT>j</TT> is: </P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       refarray(refindex + stride(1) * (i - lower(1)) + stride(2) *
    $   (j - lower(2))</TD></TR>
</TABLE><P>The expression referring to element <TT>i</TT>, <TT>j</TT>, <TT>k</TT> 
of a three-dimensional array is: </P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       refarray(refindex + stride(1) * (i - lower(1)) + stride(2) *
    $   (j - lower(2)) + stride(3) * (k - lower(3))</TD></TR>
</TABLE><P>Software packages such as LINPACK or BLAS can be called, but 
the stride should be checked to make sure the array is suitably packed.
<TT>stride(i)</TT><A NAME="@default823"></A> indicates the distance between elements in 
dimension
<TT>i</TT>, where a value of 1 means elements are packed densely in dimension
<TT>i</TT>. Negative stride values are possible and, when an array is
a slice of another array, there may be no dimension with a stride of 1. </P><P><EM><B>NOTE</B>:
For a <FONT COLOR=maroon><TT><I>dcomplex</I></TT></FONT><A NAME="@default824"></A> array, the reference array should be a 
Fortran array of <TT>REAL*8</TT> instead of a Fortran array of double complex 
to avoid potential alignment problems. For a <FONT COLOR=maroon><TT><I>fcomplex</I></TT></FONT><A NAME="@default825"></A>
array, the reference array is a <TT>COMPLEX*8</TT> because we don’t anticipate 
an alignment problem in this case.
</EM></P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.2.4  Type casting</H3><!--SEC END --><P><A NAME="ss:f77:casting"></A>
<A NAME="@default826"></A><A NAME="@default827"></A>
<A NAME="@default828"></A><A NAME="@default829"></A></P><P>Babel automatically generates two methods for casting between
interfaces and classes: <TT>_cast()</TT> and <TT>_cast2()</TT>.
The <TT>_cast()</TT> method, which tries to convert its opaque argument to 
the type of the class indicated by the method name, is static. 
Similarly, the non-static <TT>_cast2()</TT> method attempts to convert an 
object pointer to the named type — specified as a string.
For example, the following code snippet creates an instance of 
<TT>sidl.BaseClass</TT> then casts it to <TT>sidl.BaseInterface</TT> using
each of the two methods:
<A NAME="@default830"></A><A NAME="@default831"></A>
<A NAME="@default832"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      integer*8 object, interface, except
      call sidl_BaseClass__create_f(object, except)
      call sidl_BaseInterface__cast_f(object, interface, except)
c     the following call to _cast2 is equivalent to the previous _cast call
      call sidl_BaseClass__cast2_f(object, 'sidl.BaseInterface',
     $     interface, except)</TD></TR>
</TABLE><P>In either case, a zero <TT>except</TT> means the cast was successful
and the returned reference (i. e., <TT>interface</TT>)
should be non-zero. Since Babel 0.11.0, both methods increment the 
reference count when they are able to successfully
cast the object. The caller then owns the returned reference.</P><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">10.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:f77:client"></A>
<A NAME="@default833"></A></P><P>This section summarizes aspects of generating and using the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> bindings
associated with software wrapped with Babel’s language interoperability
middleware. The bindings generation process is presented before summarizing
object management and invocation of static and overloaded methods. 
The process of catching exceptions is then discussed.
Finally, the processes for enabling and disabling implementation-specific
pre- and post-method instrumentation — referred to as “hooks” —
are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.1  Bindings generation</H3><!--SEC END --><P>
<A NAME="@default834"></A>
<A NAME="@default835"></A><A NAME="@default836"></A></P><P>The basic command line for creating the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> stubs for a SIDL 
file (called “file.sidl”) is <SUP><A NAME="text16" HREF="#note16">1</A></SUP>:
<A NAME="@default837"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=f77 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -c=f77 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>The command results in the creation of a makefile fragment, called 
<TT>babel.make</TT>, numerous C header and source files, and some FORTRAN 
77 files. Files ending in <TT>_fStub.c</TT> are the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> stubs 
that allow <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> to call a SIDL method. 
These files (i. e. those listed in <TT>STUBSRCS</TT> in <TT>babel.make</TT>),
need to be compiled and linked into the application.</P><P>Normally, IOR files (i. e., those ending in <TT>_IOR.c</TT>) are linked 
together with the
implementation file, so do not need to be compiled.
Files with the <TT>.fif</TT> extension are documentation
for <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> programmers showing how the class and
interface would have been defined if they were implemented in FORTRAN
77. Consequently, <TT>.fif</TT> files are only for reference, so should 
<B>not</B> be compiled.</P><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.2  Object management</H3><!--SEC END --><P>
<A NAME="@default838"></A>
<A NAME="@default839"></A></P><P>SIDL-specified objects are managed through explicit creation and
reference counting<A NAME="@default840"></A>. Babel automatically generates 
an <TT>_create</TT> method for concrete classes. The method is used to 
instantiate the class and return the
associated reference. The owner of the instance is responsible for 
its proper disposal.
In other words, when processing with the object is done, the owner must 
invoke <TT>deleteRef</TT> on it. Similarly, any object references returned 
by a subroutine call must be deleted or given to another part of the code 
that will take ownership of and, therefore, responsibility 
for <TT>deleteRef</TT>’ing it. </P><P>For example, the following calls <TT>deleteRef()</TT> using the 
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> version of the method:
<A NAME="@default841"></A>
<A NAME="@default842"></A><A NAME="@default843"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       integer*8 interface1, except
C      code to initialize interface1 here
       call sidl_BaseInterface_deleteRef_f(interface1, except)</TD></TR>
</TABLE><P>When it is necessary to determine if two references point to the same object,
the built-in <TT>isSame</TT> method can be used. For example, the following
attempts to determine if <TT>interface1</TT> and <TT>interface2</TT> point to
the same object:
<A NAME="@default844"></A><A NAME="@default845"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       integer*8 interface1, interface2, except
       logical areSame
C      code to initialize interface1 and interface2 here
       call sidl_BaseInterface_isSame_f(interface1,
     $     interface2, areSame, except)
C      now areSame holds the return value</TD></TR>
</TABLE><P>Similarly, it is sometimes necessary to find out if a given method is of a
specific type. One case in point is when trying to determine if an exception
is of a given type. The built-in <TT>isType</TT> method is provided for that
purpose. For example, the following tries to determin if <TT>interface1</TT>
is of type <TT>x.y.z</TT>:
<A NAME="@default846"></A><A NAME="@default847"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       integer*8 interface1, except
       logical typeMatch
C      code to initialize interface1 here
       call sidl_BaseInterface_isType_f(interface1, 'x.y.z',
     $   typeMatch, except)</TD></TR>
</TABLE><P>Along those same lines, it is possible to find the name of a SIDL class that
implements a particular interface. Using a sequence of calls with
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> interface, this can be accomplished as follows:
<A NAME="@default848"></A>
<A NAME="@default849"></A>
<A NAME="@default850"></A><A NAME="@default851"></A>
<A NAME="@default852"></A><A NAME="@default853"></A>
<A NAME="@default854"></A><A NAME="@default855"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       integer*8 interface1, classinfo, except
       character*256 className
C      code to initialize interface1 here
       call sidl_BaseInterface_getClassInfo_f(interface1,
     $   classinfo, except)
       call sidl_ClassInfo_getName_f(classinfo, className, except)
       call sidl_BaseInterface_deleteRef_f(classinfo, except)</TD></TR>
</TABLE><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.3  Static methods</H3><!--SEC END --><P>
<A NAME="@default856"></A>
<A NAME="@default857"></A></P><P>Below is an example illustrating a call to <TT>addSearchPath()</TT>, which
is a static method in the <FONT COLOR=maroon><I><TT>sidl.Loader</TT></I></FONT> class. 
<A NAME="@default858"></A>
<A NAME="@default859"></A>
<A NAME="@default860"></A><A NAME="@default861"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      integer*8 except
      call sidl_Loader_addSearchPath_f('/try/looking/here', except)</TD></TR>
</TABLE><P>Note the function is invoked directly, without an object reference
argument.</P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.4  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default862"></A>
<A NAME="@default863"></A></P><P>Examples of calls to SIDL overloaded methods are based on the 
<TT>overload_sample.sidl</TT> file shown in Section <A HREF="#sec:overloading">6.7</A>. 
Recall that the file describes three versions of the <TT>getValue</TT> method. 
The first takes no arguments, the second takes an integer, and the 
third a boolean. Each is called in the code snippet below:
<A NAME="@default864"></A>
<A NAME="@default865"></A><A NAME="@default866"></A>
<A NAME="@default867"></A><A NAME="@default868"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      integer*8 t, except
      logical b1, bretval
      integer*4 i1, iretval

      call Overload_Sample__create_f (t, except)

      call Overload_Sample_getValue_f (t, iretval, except)
      call Overload_Sample_getValueInt_f (t, i1, iretval, except)
      call Overload_Sample_getValueBool_f (t, b1, bretval, except)</TD></TR>
</TABLE><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.5  Exception catching</H3><!--SEC END --><P><A NAME="ss:f77:exceptioncatching"></A>
<A NAME="@default869"></A><A NAME="@default870"></A>
<A NAME="@default871"></A></P><P>Since all methods can now throw <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT>
<A NAME="@default872"></A>, Babel ensures there is an
<FONT COLOR=maroon><I><TT>out</TT></I></FONT> argument to hold an exception. If not explicitly specified,
Babel will automatically add the argument.
For maximum backward compatibility, the base exception argument type
is <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>, while the base exception class is
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>. The exception argument appears after the
return value when both occur in a method. </P><P>After the call, the client
should test this argument. If a function does not test the exception
argument, thrown exceptions will be utterly ignored — not propagated
to higher level functions. If the exception parameter is non-zero, an
exception was thrown by the method, and the caller should respond
appropriately. When an exception is thrown, the value of all other
arguments is undefined (so should be ignored).</P><P>One approach to exception handling is to pass the exception on to the
caller. In this case, <FONT COLOR=maroon><I><TT>sidl.BaseException.add</TT></I></FONT> 
should be called to add another line in the stack trace for the exception.
<FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT> defines two methods that can be helpful when
reporting exceptions to end users: <TT>getNote</TT> and
<TT>getTrace</TT>. <TT>getNote</TT> often provides some indication of what
went wrong. Its contents are provided by the implementor of the
called function, so it can be empty. Similarly, <TT>getTrace</TT>
provides a summary of the call stack. Again, 
implementors are responsible for providing the information.</P><P>Alternatively, the caller could try to determine which exception was thrown
through casting the argument. A successful cast
indicates the type of exception that has occurred. 
An example of this process is illustrated below, though not all exceptions
associated with the method are checked. 
The SIDL specification and corresponding <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> API are given in
Section <A HREF="#ss:f77:signatures">10.2.2</A>.
<A NAME="@default873"></A>
<A NAME="@default874"></A><A NAME="@default875"></A>
<A NAME="@default876"></A><A NAME="@default877"></A>
<A NAME="@default878"></A><A NAME="@default879"></A>
<A NAME="@default880"></A>
<A NAME="@default881"></A><A NAME="@default882"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">       integer*8 fib, except, except2, except3
       integer*4 index, maxdepth, maxval, depth, result
       call ExceptionTest_Fib__create_f(fib, except)
       if (except .ne. 0) then
C         do something with a runtime exception
       endif
       index = 4
       maxdepth = 100
       maxvalue = 32000
       depth = 0
       call ExceptionTest_getFib_f(fib, index, maxdepth,
     $       maxvalue, depth, result, except)
       if (except .ne. 0) then
         call ExceptionTest_FibException__cast_f(except, except2, except3)
         if (except2 .ne. 0) then
c           do something here with the FibException
            call ExceptionTest_FibException_deleteRef_f(except2, except3)
         else
           call ExceptionTest_NegativeValueException__cast_f
     $           (exception, except2, except3)
c          do something here with the NegativeValueException
            call ExceptionTest_NegativeValueException_
     $           deleteRef_f(except2, except3)
         endif
         call sidl_BaseException_deleteRef_f(except, except3)
       else
         write (*,*) 'getFib for ', index, ' returned ', result
       endif
       call ExceptionTest_Fib_deleteRef_f(fib, except)</TD></TR>
</TABLE><P>If one of the
possible exception types is a subclass of another, casting to the subclass 
should be attempted before casting to the superclass — assuming
that the distinction between the two exception types results in
different exception recovery behavior. </P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.6  Hooks execution</H3><!--SEC END --><P><A NAME="ss:f77:sethooks"></A>
<A NAME="@default883"></A><A NAME="@default884"></A>
<A NAME="@default885"></A><A NAME="@default886"></A>
<A NAME="@default887"></A><A NAME="@default888"></A></P><P>If a given component supports pre- and post-method invocation instrumentation,
also known as “hooks”, their execution can be enabled or disabled at
runtime through the built-in <TT>_set_hooks</TT> method. For example,
given the following SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class, the processes for enabling and disabling
execution of the implementation-specific hooks are:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      integer*8 obj, except

      call hooks_Basics__create_f (obj, except)
c
c     Enable hooks execution (enabled by default)
c     ...for static methods
c
      call hooks_Basics__set_hooks_static_f (1, except)
c
c     ...for non-static methods
c
      call hooks_Basics__set_hooks_f (obj, 1, except)

c
c     ...do something meaningful...
c

c
c     Disable hooks execution
c     ...for static methods
c
      call hooks_Basics__set_hooks_static_f (0, except)
c
c     ...for non-static methods
c
      call hooks_Basics__set_hooks_f (obj, 0, except)

c
c     ...do something meaningful...
c</TD></TR>
</TABLE><P>It is important to keep in mind that the 
<TT>_set_hooks_static</TT>
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>_set_hooks</TT> method must be used for 
those of non-static methods. Also, Babel does not provide client access 
to the <TT>_pre</TT> and <TT>_post</TT> methods; therefore, they cannot 
be invoked directly. More information on the instrumentation process 
is provided in Subsection <A HREF="#ss:f77:hooksimpl">10.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.3.7  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:f77:contract_enforcement"></A>
<A NAME="@default889"></A>
<A NAME="@default890"></A>
<A NAME="@default891"></A></P><P>Interface contracts specify the expected behaviors of callers (or clients)
and callees (or servers) of methods defined for interfaces and classes.
Once specified, contracts are optionally enforced at runtime, through checks
automatically integrated into the middleware generated by the Babel compiler.
This section provides an example of a specification and code snippets for
performing basic, traditional contract enforcement — introduced in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — in a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> client.</P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below.
(Refer to Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.)
According to the preconditions,
<A NAME="@default892"></A><A NAME="@default893"></A>
<A NAME="@default894"></A>
all callers are expected to provide two one-dimensional, SIDL arrays of the
same size as arguments.
The postconditions
<A NAME="@default895"></A><A NAME="@default896"></A>
<A NAME="@default897"></A>
specify that all implementations are expected to return a non-null, 
one-dimensional array of the same size (as the first SIDL array), 
assuming the preconditions are satisfied.</P><P><A NAME="@default898"></A>
<A NAME="@default899"></A>
<A NAME="@default900"></A>
<A NAME="@default901"></A><A NAME="@default902"></A>
<A NAME="@default903"></A>
<A NAME="@default904"></A>
<A NAME="@default905"></A>
<A NAME="@default906"></A>
<A NAME="@default907"></A>
<A NAME="@default908"></A>
<A NAME="@default909"></A>
<A NAME="@default910"></A>
<A NAME="@default911"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> client invoking the method is given below. 
The code snippet illustrates declaring and creating the arrays; enabling 
full contract enforcement (i. e., checking all contract clauses); 
executing <TT>vuSum</TT>; handling contract violation exceptions; 
and cleaning up references is given below.</P><P><A NAME="@default912"></A>
<A NAME="@default913"></A>
<A NAME="@default914"></A>
<A NAME="@default915"></A>
<A NAME="@default916"></A>
<A NAME="@default917"></A>
<A NAME="@default918"></A>
<A NAME="@default919"></A>
<A NAME="@default920"></A>
<A NAME="@default921"></A>
<A NAME="@default922"></A>
<A NAME="@default923"></A>
<A NAME="@default924"></A>
<A NAME="@default925"></A>
<A NAME="@default926"></A>
<A NAME="@default927"></A>
<A NAME="@default928"></A>
<A NAME="@default929"></A>
<A NAME="@default930"></A>
</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      integer*8 exc, tae
      integer*8 u, v, x
      include 'sidl_ContractClass.inc'

      call createDouble(MAX_SIZE, u)
      call createDouble(MAX_SIZE, v)

C     Initialize u and v.

C     Enable FULL contract enforcement.
      call sidl_EnfPolicy_setEnforceAll_f(ALLCLASSES, .true.,
     $                                    exc)
      if (exc .ne. 0) then
C       Handle the exception
      endif

C     Do something meaningful before executing the method.

      call vect_Utils_vuSum_f(u, v, x, exc)
      if (exc .ne. 0) then
C       Handle the exception
      endif

C     Do something meaningful with the result, x.

      call sidl_double__array_deleteRef_f(u, tae)
      call sidl_double__array_deleteRef_f(v, tae)
      if (x .ne. 0) then
        call sidl_double__array_deleteRef_f(x, tae)
      endif
      end</TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> calls associated with the 
traditional options of enabling only precondition enforcement, enabling 
postcondition enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default931"></A>
<A NAME="@default932"></A>
<A NAME="@default933"></A>
<A NAME="@default934"></A>
<A NAME="@default935"></A>
<A NAME="@default936"></A>
<A NAME="@default937"></A>
<A NAME="@default938"></A>
<A NAME="@default939"></A>
<A NAME="@default940"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      include 'sidl_ContractClass.inc'

C
C     Enable only precondition contract enforcement.
C     (Useful when only need to ensure callers comply with contract.)
C
      call sidl_EnfPolicy_setEnforceAll_f(PRECONDS, .false., exception)
      if (exception .ne. 0)
C       Handle the exception
      endif


C
C     Enable only postcondition contract enforcement.
C     (Useful when only need to ensure implementation(s) comply with contract.)
C
      call sidl_EnfPolicy_setEnforceAll_f(POSTCONDS, .false., exception)
      if (exception .ne. 0)
C       Handle the exception
      endif

C
C     Disable contract enforcement.
C     (Should only be used when have confidence in caller AND implementation.)
C
      call sidl_EnfPolicy_setEnforceNone_f(.false., exception)
      if (exception .ne. 0)
C       Handle the exception
      endif</TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> client.
Additional enforcement policy options and methods as well as more
information regarding the specification and enforcement of contracts
can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc47">10.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:f77:implementation"></A>
<A NAME="@default941"></A></P><P>This section summarizes aspects of generating and wrapping software
written in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. The bindings generation and basic implementation 
processes are presented first.
Since access to object state requires special steps in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, the process
for defining and managing that data is discussed. Throwing
exceptions in the implementation is then illustrated.
Finally, the results of generating implementations with pre- and post-method
“hooks” are shown.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:f77:implgen"></A>
<A NAME="@default942"></A>
<A NAME="@default943"></A><A NAME="@default944"></A></P><P>Much of the information associated with generating client-side bindings 
is pertinent to implementing a SIDL class in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. (Recall
Table <A HREF="#tbl:f77:types">10.1</A> listed the type mappings.) If the implementation
calls other SIDL methods, client-side caller rules must be followed.</P><P>Implementation-side bindings are generated by the following call to Babel:
<A NAME="@default945"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=f77 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -s=f77 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>As a result, a makefile fragment called <TT>babel.make</TT>, numerous C 
header and source files, and some <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> source files are created. 
Implementation details must be added to the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> “Impl” files,
whose names end with <TT>_Impl.f</TT>. 
More on this matter is provided in Subsection <A HREF="#ss:f77:implfill">10.4.2</A>.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:f77:implfill"></A>
<A NAME="@default946"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:f77:implgen">10.4.1</A>. Changes to these files must be made between
code splicer pairs to ensure their retention in subsequent invocations of
Babel. Below is an example of a code splicer pair. 
<A NAME="@default947"></A><A NAME="@default948"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">C       DO-NOT-DELETE splicer.begin(_miscellaneous_code_start)
C       Insert-Code-Here {_miscellaneous_code_start} (extra code)
C       DO-NOT-DELETE splicer.end(_miscellaneous_code_start)</TD></TR>
</TABLE><P>where the “C Insert-Code-Here...” line should be replaced
with the implementation.
Examples of filling in these splicer blocks are provided in the subsections
to follow.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.4.3  Private data</H3><!--SEC END --><P>
<A NAME="@default949"></A>
<A NAME="@default950"></A></P><P>Any variables declared in the implementation source file will, by
virtue of Babel’s encapsulation, be private. 
Special initialization procedures can be added to
the built-in <TT>_load()</TT> method that is guaranteed to be called
exactly once per class to set global class data — <EM>before</EM> any 
user-defined methods can even be invoked. Alternatively,
if private data (sometimes referred to as state) needs to be added 
to a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> class, SIDL arrays 
can be used to store the data. This is certainly not the
only way to implement a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> class with state, but it’s one 
that will work wherever Babel works. </P><P>The SIDL IOR keeps a pointer (i. e., a C <TT>void *</TT>) for each object
in order to support private data. Like their C equivalents, each
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> skeleton provides two functions for accessing the private
pointer. Although the pointer arguments to the methods are
64-bit integers in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, the number of bits actually
stored by the IOR is determined by <TT>sizeof(void *)</TT>.
Babel/SIDL does not provide a low level mechanism for <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> to
allocate memory to use for the private data pointer.</P><P>The following example illustrates the process of managing private data
using the automatically generated constructor subroutine, <TT>_ctor</TT>:
<A NAME="@default951"></A>
<A NAME="@default952"></A>
<A NAME="@default953"></A><A NAME="@default954"></A>
<A NAME="@default955"></A><A NAME="@default956"></A>
<A NAME="@default957"></A><A NAME="@default958"></A>
<A NAME="@default959"></A><A NAME="@default960"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine example_withState__ctor_fi(self, exception)
        implicit none
        integer*8 self, exception
C       DO-NOT-DELETE splicer.begin(example.withState._ctor)
        integer*8 statearray, logarray, dblarray
        call sidl_opaque__array_create1d_f(2, statearray)
        call sidl_bool__array_create1d_f(3, logarray)
        call sidl_double__array_create1d_f(2, dblarray)
        if ((statearray .ne. 0) .and. (logarray .ne. 0) .and.
     $       (dblarray .ne. 0)) then
           call sidl_opaque__array_set1_f(statearray, 0, logarray)
           call sidl_opaque__array_set1_f(statearray, 1, dblarray)
        else
C          a real implementation would not leak memory like this one
           statearray = 0
        endif
        call example_withState__set_data_f(self, statearray)
C       DO-NOT-DELETE splicer.end(example.withState._ctor)
        end</TD></TR>
</TABLE><P>Of course, it is up to the implementation to associate 
elements of the arrays with particular state variables. For example,
element 0 of the double array could be the kinematic
viscosity and element 1 the airspeed velocity of an unladen
swallow.<A NAME="@default961"></A> Element 0 of the boolean array could specify 
African (true) or
European (false). The destructor implementation for this class could look 
something like:
<A NAME="@default962"></A>
<A NAME="@default963"></A><A NAME="@default964"></A>
<A NAME="@default965"></A><A NAME="@default966"></A>
<A NAME="@default967"></A><A NAME="@default968"></A>
<A NAME="@default969"></A><A NAME="@default970"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine example_withState__dtor_fi(self, exception)
        implicit none
        integer*8 self, exception
C       DO-NOT-DELETE splicer.begin(example.withState._dtor)
        integer*8 statearray, logarray, dblarray
        call example_withState__get_data_f(self, statearray)
        if (statearray .ne. 0) then
           call sidl_opaque__array_get1_f(statearray, 0, logarray)
           call sidl_opaque__array_get1_f(statearray, 1, dblarray)
           call sidl_bool__array_deleteRef_f(logarray)
           call sidl_double__array_deleteRef_f(dblarray)
           call sidl_opaque__array_deleteRef_f(statearray)
C       the following two lines are not strictly necessary
           statearray = 0
           call example_withState__set_data_f(self, statearray)
        endif
C       DO-NOT-DELETE splicer.end(example.withState._dtor)
        end</TD></TR>
</TABLE><P>Continuing with this example, an accessor function for the airspeed velocity 
of an unladen swallow could be implemented as follows:
<A NAME="@default971"></A>
<A NAME="@default972"></A><A NAME="@default973"></A>
<A NAME="@default974"></A><A NAME="@default975"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine example_withState_getAirspeedVelocity_fi(
     $     self, velocity, exception)
        implicit none
        integer*8 self, exception
        real*8 velocity
C       DO-NOT-DELETE splicer.begin(example.withState.getAirspeedVelocity)
        integer*8 statearray, dblarray
        call example_withState__get_data_f(self, statearray)
        if (statearray .ne. 0) then
           call sidl_opaque__array_get1_f(statearray, 1, dblarray)
           call sidl_double__array_get1_f(dblarray, 1, velocity)
        endif
C       DO-NOT-DELETE splicer.end(example.withState.getAirspeedVelocity)
        end</TD></TR>
</TABLE><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.4.4  Exception throwing</H3><!--SEC END --><P><A NAME="ss:f77:exceptionthrowing"></A>
<A NAME="@default976"></A><A NAME="@default977"></A></P><P>Continuing with the Fibonocci example used in 
Subsections <A HREF="#ss:f77:signatures">10.2.2</A> and <A HREF="#ss:f77:exceptioncatching">10.3.5</A>, 
the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> code that throws the exceptions is:
<A NAME="@default978"></A>
<A NAME="@default979"></A><A NAME="@default980"></A></P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine ExceptionTest_Fib_getFib_fi(self, n, max_depth,
     &amp;     max_value, depth, retval, exception)
        implicit none
        integer*8 self, exception, ignored
        integer*4 n, max_depth, max_value, depth, retval
C       DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFib)
        character*(*) myfilename
        parameter(myfilename='ExceptionTest_Fib_Impl.f')
C ...lines of code deleted...
        if (n .lt. 0) then
          call ExceptionTest_NegativeValueException__create_f(exception
     $          ,ignored)
          if (exception .ne. 0) then
            call ExceptionTest_NegativeValueException_setNote_f(
     $             exception,
     $             'called with negative n', ignored)
            call ExceptionTest_NegativeValueException_add_f(
     $             exception,
     $             myfilename,
     $             57,
     $             'ExceptionTest_Fib_getFib_impl', ignored)
            return
          endif
C ...lines of code deleted...
C       DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFib)
        end</TD></TR>
</TABLE><P>Not all exceptions are thrown in this example in order to
keep its length down. The interested reader is encouraged to refer
to the corresponding regression tests for the complete routine.</P><P>When an exception is thrown, the implementation should 
<TT>deleteRef</TT> any references it was planning to return to the
caller because the caller is instructed to ignore any returned values
under those circumstances. In general, when throwing an exception, 
it is good practice to set all <FONT COLOR=maroon><I><TT>out</TT></I></FONT>
and <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> array, class, and interface arguments to zero before
returning. This makes things work out
better for clients who forget to check if an exception occurred or
willfully choose to ignore it.</P><P><EM><B>NOTE</B>:
It is typically 
safe to assume that calling <TT>deleteRef</TT>, <TT>_cast</TT> or
<TT>_cast2</TT> on an exception will never cause an exception to be
thrown because returned exceptions are always local.
</EM></P><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->10.4.5  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:f77:hooksimpl"></A>
<A NAME="@default981"></A><A NAME="@default982"></A>
<A NAME="@default983"></A>
<A NAME="@default984"></A><A NAME="@default985"></A>
<A NAME="@default986"></A><A NAME="@default987"></A></P><P>As discussed in Subsection <A HREF="#ss:f77:sethooks">10.3.6</A>, when hooks execution
is enabled, implementation-specific instrumentation is executed. Using
the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results
in the automatic generation of a <TT>_pre</TT> and <TT>_post</TT>
method for every static and non-static method associated with each class
in the specification. For the <TT>aStaticMethod</TT> specified in
Subsection <A HREF="#ss:f77:sethooks">10.3.6</A>, the generated <TT>_pre</TT> method
implementation is:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine hooks_Basics_aStaticMeth_pre_fi(i, io, exception)
        implicit none
C        in int i
        integer*4 i
C        in int io
        integer*4 io
C        out sidl.BaseInterface exception
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre)
C
C       Add instrumentation here to be executed immediately prior
C       to dispatch to aStaticMeth().
C
C       DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre)
        end</TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine hooks_Basics_aStaticMeth_post_fi(i, o, io, retval,
     &amp;     exception)
        implicit none
C        in int i
        integer*4 i
C        in int o
        integer*4 o
C        in int io
        integer*4 io
C        in int retval
        integer*4 retval
C        out sidl.BaseInterface exception
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post)
C
C       Add instrumentation here to be executed immediately after
C       return from dispatch to aStaticMeth().
C
        return
C       DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post)
        end</TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation
should be added within the splicer blocks of
<TT>aStaticMethod_pre</TT> and
<TT>aStaticMethod_post</TT>. As stated in the comments
within those blocks, <TT>aStaticMethod_pre</TT> will be
executed immediately prior to dispatch to <TT>aStaticMethod</TT> when the
latter is invoked by a client. Assuming no exceptions are encountered,
<TT>aStaticMethod_post</TT> is executed immediately upon
return from <TT>aStaticMethod</TT>.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note16" HREF="#text16">1</A></DT><DD CLASS="dd-thefootnotes">For information on additional 
command line options, refer to Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Fortran 90/95 Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc48">Chapter 11</A>  Fortran 90/95 Bindings</H1><!--SEC END --><P><A NAME="c:f90"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">11.1</A>  Introduction</H2><!--SEC END --><P>
This chapter provides an overview of the Fortran 90/95 bindings for SIDL.
Common aspects of the bindings, such as the mapping of SIDL data types
to their native Fortran 90/95 representatives, are presented in
Section <A HREF="#s:f90:basics">11.2</A>.
Issues of concern to Fortran 90/95 callers are addressed in the client-side 
bindings discussion in Section <A HREF="#s:f90:client">11.3</A>, while issues of interest
to callees of Fortran 90/95 appear in the implementation-side discussion in
Section <A HREF="#s:f90:implementation">11.4</A>.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">11.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:f90:basics"></A></P><P>This section summarizes basic features that are common to both client and
implementation bindings.
Conventions used to protect the global name space are described in
Subsection <A HREF="#ss:f90:namespace">11.2.1</A>, while those associated with the generation
of subroutines from methods are given in Subsection <A HREF="#ss:f90:signatures">11.2.2</A>.
Translations between SIDL and native Fortran 90/95 constructs are
described in Subsection <A HREF="#ss:f90:types">11.2.3</A>.
Finally, the process of casting between different types is illustrated
in Subsection <A HREF="#ss:f90:casting">11.2.4</A>.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.2.1  Name space</H3><!--SEC END --><P><A NAME="ss:f90:namespace"></A>
<A NAME="@default988"></A>
<A NAME="@default989"></A></P><P>The name of the module that holds method definitions is derived
from the fully qualified name of the class or interface. Module names
are essentially formed by replacing all periods in the fully qualified
name with underscores. The name of the module holding the derived type 
of the class or interface is the same as the one holding the methods 
with the exception of having <TT>_type</TT> appended. For example, the 
methods for <FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT><A NAME="@default990"></A> are 
defined in a module named <TT>sidl_SIDLException</TT> in the file 
<TT>sidl_SIDLException.F90</TT>. Defined in the file 
<TT>sidl_SIDLException_type.F90</TT>, the types for 
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT> are called 
<TT>sidl_SIDLException_t</TT>
and, for the array, <TT>sidl_SIDLException_a</TT>.</P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.2.2  Method signatures</H3><!--SEC END --><P><A NAME="ss:f90:signatures"></A>
<A NAME="@default991"></A>
<A NAME="@default992"></A></P><P>All SIDL methods are implemented as Fortran 90/95 
subroutines<A NAME="@default993"></A> regardless 
of whether they have a return value. 
The name of a subroutine that clients invoke is the method’s
full name from the SIDL description. Hence, in cases where 
the method has a name extension (so is overloaded), the full 
name is the concatenation of the specified short name and extension.
On the implementation-side, the name is formed as the 
concatenation of the package, class (or interface), full 
method name<A NAME="@default994"></A>, and “mi”, with each part separated by an 
underscore and name mangling used to ensure uniqueness if 
the resulting name exceeds the character limit.</P><P>The same process used for <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, described in 
Subsection <A HREF="#ss:f77:signatures">10.2.2</A>, is used to build up the parameters 
for generated methods. That is, object (or interface) pointers, return
values, and exception pointers are added, as needed. More specifically,
the object (or interface) pointer is automatically inserted as the first
parameter in the signature of non-static methods. This parameter
operates like an <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameter. 
When a method has a return value, a parameter to hold the return value is
also added after all of the formally declared arguments.
This extra argument behaves like an <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter.
With the addition of remote method invocation (RMI) support, all methods
now implicitly throw exceptions<A NAME="@default995"></A>.
Hence, an extra <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter for the exception is automatically added
as the last parameter of the signature.
<A NAME="@default996"></A><A NAME="@default997"></A>
An example that illustrates the SIDL specification and corresponding 
routines can be found in Subsections <A HREF="#ss:f90:exceptioncatching">11.3.5</A>
and <A HREF="#ss:f90:exceptionthrowing">11.4.4</A>.</P><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.2.3  Data types</H3><!--SEC END --><P><A NAME="ss:f90:types"></A>
<A NAME="@default998"></A>
<A NAME="@default999"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 11.1: SIDL to Fortran 90/95 Type Mappings</TD></TR>
</TABLE></DIV><A NAME="tbl:f90:types"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B>Fortran 90/95 TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER (kind=sidl_int)</TT>	<A NAME="@default1000"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER (kind=sidl_long)</TT>	<A NAME="@default1001"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>REAL (kind=sidl_float)</TT>	<A NAME="@default1002"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>REAL (kind=sidl_double)</TT>	<A NAME="@default1003"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>LOGICAL</TT>			<A NAME="@default1004"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>CHARACTER (LEN=1)</TT>		<A NAME="@default1005"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>CHARACTER (LEN=*)</TT>		<A NAME="@default1006"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>COMPLEX (kind=sidl_fcomplex)</TT> <A NAME="@default1007"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>COMPLEX (kind=sidl_dcomplex)</TT> <A NAME="@default1008"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER (kind=sidl_enum)</TT>	<A NAME="@default1009"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>INTEGER (kind=sidl_opaque)</TT> 	<A NAME="@default1010"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=left NOWRAP><EM><TT>derived type</TT></EM>		<A NAME="@default1011"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>class</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><EM><TT>derived type</TT></EM>		<A NAME="@default1012"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>array</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><EM><TT>derived type</TT></EM>		<A NAME="@default1013"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The mapping for simple SIDL types to Fortran 90/95 is given in
Table <A HREF="#tbl:f90:types">11.1</A>. The kind parameters, given in
the <TT>sidl</TT> F90 module, define integer
parameters for <TT>sidl_int</TT>, <TT>sidl_long</TT>,
<TT>sidl_float</TT>, <TT>sidl_double</TT>, 
<TT>sidl_fcomplex</TT>, <TT>sidl_dcomplex</TT>, 
<TT>sidl_enum</TT> and <TT>sidl_opaque</TT> to
give sizes that match the corresponding SIDL types.
The remainder of this subsection elaborates on mappings of strings, 
pointers, enumerations, and arrays.</P><!--TOC subsubsection Strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Strings</H4><!--SEC END --><P><A NAME="sss:f90:strings"></A>
<A NAME="@default1014"></A><A NAME="@default1015"></A>
<A NAME="@default1016"></A><A NAME="@default1017"></A></P><P>The SIDL string type mapping is currently identical to that of the
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> mapping. That is, all Fortran 90/95 strings have a limited 
fixed size<A NAME="@default1018"></A>. When implementing a
subroutine with an <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter, the size of the string is 
restricted to 512 characters. </P><P><EM><B>NOTE</B>:
Modification of the value of 
<TT>SIDL_F90_STR_MINSIZE</TT> in
<TT>runtime/sidl/babel_config.h</TT> prior to configuring Babel
can be used to change the string size limitation.
</EM></P><!--TOC subsubsection Pointers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Pointers</H4><!--SEC END --><P><A NAME="sss:f90:pointers"></A>
<A NAME="@default1019"></A><A NAME="@default1020"></A>
<A NAME="@default1021"></A><A NAME="@default1022"></A></P><P>Pointer types are: opaque, interface, class, and array. This subsection
elaborates on each within the context of the Fortran 90/95 language bindings.
Opaque<A NAME="@default1023"></A><A NAME="@default1024"></A>
pointers<A NAME="@default1025"></A><A NAME="@default1026"></A> are 
mapped to the equivalent of SIDL double. That is, the
intermediate object reference (IOR) assumes a 64-bit integer is used to
enable portability between systems with 32-bit and 64-bit address spaces. 
On a 32-bit system, the upper 32
bits of these quantities are ignored. Systems with more than 64-bit
pointers aren’t currently supported.
A derived type is used to hold opaque pointers for 
interfaces<A NAME="@default1027"></A><A NAME="@default1028"></A>, 
classes<A NAME="@default1029"></A><A NAME="@default1030"></A>, and 
arrays<A NAME="@default1031"></A><A NAME="@default1032"></A>. 
The derived type for arrays of numeric types also
has a pointer to an array to provide native access without
function calls. For each interface and class, there are two modules
created. In the first module, the derived type for the object and
array are defined. In the second, methods for the object (or interface)
and arrays of the object (or interface) are defined. Clients of a class (or
interface), typically <TT>use</TT> the module containing the methods. 
It, in turn, <TT>use</TT>s the module containing the types.</P><P>Generally, clients should treat 
opaque<A NAME="@default1033"></A><A NAME="@default1034"></A>, 
interface<A NAME="@default1035"></A><A NAME="@default1036"></A>, 
class<A NAME="@default1037"></A><A NAME="@default1038"></A>, and 
array<A NAME="@default1039"></A><A NAME="@default1040"></A>
values as black boxes. However, the value zero is special
since it is the equivalent of <TT>NULL</TT><A NAME="@default1041"></A>.
Hence, any non-zero value is or should be a valid object
reference. The method module provides built-in functions to test whether an
interface, class, or array value <TT>is_null</TT> or is
<TT>not_null</TT>. There is also a subroutine to initialize the value
to <TT>set_null</TT><A NAME="@default1042"></A>. Clients should
generally initialize new class (or interface) pointers to <TT>NULL</TT>.</P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:f90:enum"></A>
<A NAME="@default1043"></A><A NAME="@default1044"></A>
<A NAME="@default1045"></A><A NAME="@default1046"></A></P><P>SIDL enumerations map to integer values, which are defined in a module.
Given the specification from Section <A HREF="#ssec:basics:fundamental:enums">6.3</A> 
for an enumeration type called <FONT COLOR=maroon><I><TT>car</TT></I></FONT>, Babel will produce the following 
enumerated type:
<A NAME="@default1047"></A><A NAME="@default1048"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>! File:          enums_car.F90
! Symbol:        enums.car-v1.0
! Symbol Type:   enumeration
! Babel Version: 0.8.2
! Description:   Client-side module for enums.car</I></FONT>

<B>module</B> enums_car
<FONT COLOR="blue"><I>! Symbol "enums.car" (version 1.0)</I></FONT>
  <B>use</B> sidl

  integer (<B>kind</B>=sidl_enum), parameter :: porsche = 911
  integer (<B>kind</B>=sidl_enum), parameter :: ford = 150
  integer (<B>kind</B>=sidl_enum), parameter :: mercedes = 550
end <B>module</B> enums_car</TD></TR>
</TABLE><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:f90:arrays"></A>
<A NAME="@default1049"></A><A NAME="@default1050"></A>
<A NAME="@default1051"></A><A NAME="@default1052"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Normal SIDL arrays can be used by any supported
language; whereas, r-arrays are restricted to numeric types and use in
languages such as C, C++, and Fortran. This subsection starts with a 
discussion normal and generic arrays before proceeding with an example
of the interfaces for r-arrays. </P><P>The normal SIDL array API is available in a module for creating, 
destroying, and accessing array elements and meta-data for normal arrays. 
More information on the API can be found in 
Subsection <A HREF="#ss:basics:array:api">6.4</A>.
For <FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>, the array module — called
<TT>sidl_SIDLException_array</TT> — is defined in
<TT>sidl_SIDLException_array.F90</TT>.
The derived type for a SIDL array is named after the class,
interface, or basic type that it holds and the dimension of the
array. For <FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>, the array derived types are
named <TT>sidl_SIDLException_1d</TT>, 
<TT>sidl_SIDLException_2d</TT>,
<TT>sidl_SIDLException_3d</TT>, … up to
<TT>sidl_SIDLException_7d</TT>. For basic types, they 
are treated as <FONT COLOR=maroon><I><TT>sidl.dcomplex</TT></I></FONT>, <FONT COLOR=maroon><I><TT>sidl.double</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>sidl.fcomplex</TT></I></FONT>, etc. Each of these derived types has a 
64-bit integer to hold an opaque pointer.</P><P><EM><B>NOTE</B>:
Normal Fortran 90/95 arrays or normal SIDL arrays can be used when
calling a Fortran 90/95 method, but they cannot be mixed.
</EM></P><P>Derived types for SIDL types <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, and <FONT COLOR=maroon><I><TT>long</TT></I></FONT> have pointers to arrays of the 
appropriate type and dimension that facilitate direct access to array elements. 
For example, the derived type for 2d and 3d arrays of <FONT COLOR=maroon><I><TT>double</TT></I></FONT>s is:
<A NAME="@default1053"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  type sidl_double_2d
    <B>sequence</B>
    integer (<B>kind</B>=sidl_arrayptr) :: d_array
    real (<B>kind</B>=sidl_double), <B>pointer</B>, &amp;
      dimension(:,:) :: d_data
  end type sidl_double_2d

  type sidl_double_3d
    <B>sequence</B>
    integer (<B>kind</B>=sidl_arrayptr) :: d_array
    real (<B>kind</B>=sidl_double), <B>pointer</B>, &amp;
      dimension(:,:,:) :: d_data
  end type sidl_double_3d</TD></TR>
</TABLE><P>For the other types, the array API must be used to access elements.
In this case, the array can be accessed with the F90 array pointer 
<TT>d_data</TT> just like any other F90 array. However, 
the F90 built-in methods <TT>allocate</TT><A NAME="@default1054"></A> or 
<TT>deallocate</TT><A NAME="@default1055"></A> on <TT>d_data</TT> <EM>must not</EM> 
be used. Instead, SIDL functions, <TT>createCol</TT><A NAME="@default1056"></A>, 
<TT>createRow</TT><A NAME="@default1057"></A>, <TT>create1d</TT><A NAME="@default1058"></A>, 
<TT>create2dRow</TT><A NAME="@default1059"></A>, or 
<TT>create2dCol</TT><A NAME="@default1060"></A>, must be used to create a
new array. These SIDL routines initialize <TT>d_data</TT> to refer to
the data allocated in <TT>d_array</TT>. </P><P><EM><B>NOTE</B>:
<TT>create1d</TT>,
<TT>create2dRow</TT>, and <TT>create2dCol</TT> create arrays whose lower
index is </EM>0<EM> not 1. To create arrays with a lower index of 1, 
<TT>createCol</TT> or <TT>createRow</TT> must be used.
</EM></P><P>Software packages like LINPACK or BLAS can be called, but the stride 
should be checked to make sure the array is suitably packed. Using
<TT>stride(i)</TT><A NAME="@default1061"></A> will provide the distance between elements in 
dimension <TT>i</TT>. 
A value of 1 means elements are packed densely.
Negative stride values are possible and, when an array is sliced, the
resulting array might not even have one densely packed dimension.</P><P>As discussed in Section <A HREF="#sss:basics:genericarrays">6.4</A>, the type of a generic 
array<A NAME="@default1062"></A><A NAME="@default1063"></A> is not specified.
As a result, Fortran 90/95 represents generic arrays as the derived type
<TT>sidl__array</TT> as defined in the 
<TT>sidl_array_type</TT> module.
(Note the use of a two underscore separator.) The following subroutines,
defined in the <TT>sidl_array_array</TT> module, apply to 
generic arrays:
<TT>addRef</TT><A NAME="@default1064"></A>, 
<TT>deleteRef</TT><A NAME="@default1065"></A>, 
<TT>dimen</TT>, <TT>type</TT>,
<TT>isColumnOrder</TT><A NAME="@default1066"></A>, 
<TT>isRowOrder</TT><A NAME="@default1067"></A>,
<TT>is_null</TT><A NAME="@default1068"></A>, 
<TT>no_null</TT><A NAME="@default1069"></A>, 
<TT>set_null</TT><A NAME="@default1070"></A>, 
<TT>lower</TT><A NAME="@default1071"></A>, 
<TT>upper</TT><A NAME="@default1072"></A>, 
<TT>length</TT><A NAME="@default1073"></A>, 
<TT>stride</TT><A NAME="@default1074"></A>, and 
<TT>smartCopy</TT><A NAME="@default1075"></A>. </P><P>Finally, SIDL r-arrays<A NAME="@default1076"></A><A NAME="@default1077"></A> are passed 
to and from methods as normal Fortran 90/95 arrays. 
Index variables do not need to be included because the
values are determined from the Fortran 90/95 array extents in each
dimension. For example,
the client-side interface for <TT>solve</TT> — introduced in
Section <A HREF="#ss:r-arrays">6.4</A> — behaves as if it is a Fortran 90/95 function
with the following overloaded interface:
<A NAME="@default1078"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>private</B> :: solve_1s, solve_2s
  <B>interface</B> solve
    <B>module</B> procedure solve_1s, solve_2s
  end <B>interface

  recursive</B> subroutine solve_1s(self, A, x, exception)
    implicit <B>none</B>
    <FONT COLOR="blue"><I>! in num.Linsol self</I></FONT>
    type(num_Linsol_t) , <B>intent</B>(<B>in</B>) :: self
    <FONT COLOR="blue"><I>! in array&lt;double,2,column-major&gt; A</I></FONT>
    type(sidl_double_2d) , <B>intent</B>(<B>in</B>) :: A
    <FONT COLOR="blue"><I>! inout array&lt;double,column-major&gt; x</I></FONT>
    type(sidl_double_1d) , <B>intent</B>(<B>inout</B>) :: x
    <FONT COLOR="blue"><I>! out sidl.BaseInterface exception</I></FONT>
    type(sidl_BaseInterface_t) , <B>intent</B>(<B>out</B>) :: exception
  end subroutine solve_1s

  <B>recursive</B> subroutine solve_2s(self, A, x, exception)
    implicit <B>none</B>
    <FONT COLOR="blue"><I>! in num.Linsol self</I></FONT>
    type(num_Linsol_t) , <B>intent</B>(<B>in</B>) :: self
    <FONT COLOR="blue"><I>! in rarray&lt;double,2&gt; A(m,n)</I></FONT>
    real (<B>kind</B>=sidl_double) , <B>intent</B>(<B>in</B>), dimension(:, :) :: A
    <FONT COLOR="blue"><I>! inout rarray&lt;double&gt; x(n)</I></FONT>
    real (<B>kind</B>=sidl_double) , <B>intent</B>(<B>inout</B>), dimension(:) :: x
    <FONT COLOR="blue"><I>! out sidl.BaseInterface exception</I></FONT>
    type(sidl_BaseInterface_t) , <B>intent</B>(<B>out</B>) :: exception
    <FONT COLOR="blue"><I>! in int m</I></FONT>
    integer (<B>kind</B>=sidl_int) :: m
    <FONT COLOR="blue"><I>! in int n</I></FONT>
    integer (<B>kind</B>=sidl_int) :: n
  end subroutine solve_2s</TD></TR>
</TABLE><P>The server-side interface, shown below, is similar. 
<A NAME="@default1079"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine num_Linsol_solve_mi(self, A, x, m, n, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> num_Linsol
  <B>use</B> sidl_double_array
  <B>use</B> num_Linsol_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(num.Linsol.solve.use)
  ! Insert-Code-Here {num.Linsol.solve.use} (use statements)
  ! DO-NOT-DELETE splicer.end(num.Linsol.solve.use)</I></FONT>
  implicit <B>none</B>
  type(num_Linsol_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: m <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: n <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out</I></FONT>
  real (<B>kind</B>=sidl_double), dimension(0:m-1, 0:n-1) :: A <FONT COLOR="blue"><I>! in</I></FONT>
  real (<B>kind</B>=sidl_double), dimension(0:n-1) :: x <FONT COLOR="blue"><I>! inout

! DO-NOT-DELETE splicer.begin(num.Linsol.solve)
! Insert-Code-Here {num.Linsol.solve} (solve method)
! DO-NOT-DELETE splicer.end(num.Linsol.solve)</I></FONT>
end subroutine num_Linsol_solve_mi</TD></TR>
</TABLE><P><EM><B>NOTE</B>:
The lower
index of each dimension of every incoming array is <B>always</B> zero.
</EM></P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.2.4  Type casting</H3><!--SEC END --><P><A NAME="ss:f90:casting"></A>
<A NAME="@default1080"></A><A NAME="@default1081"></A>
<A NAME="@default1082"></A></P><P>Babel automatically generates the <TT>cast()</TT><A NAME="@default1083"></A>
method for casting between different interface and class types.
Actually, a set of overloaded methods support every allowable cast 
between a type and all its parent types
(both objects and interfaces). The first argument is the object (or interface)
to be cast, and the second is a variable of the desired
type. The cast is successful if, after the call to <TT>cast()</TT>, the value 
of the second argument is <TT>not_null</TT><A NAME="@default1084"></A>. The 
caller then owns (and is responsible for) the returned reference. 
Examples of type casting can be found in 
Subsections <A HREF="#ss:f90:exceptioncatching">11.3.5</A> and <A HREF="#ss:f90:exceptionthrowing">11.4.4</A>.</P><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">11.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:f90:client"></A>
<A NAME="@default1085"></A></P><P>This section summarizes aspects of generating and using the Fortran 90/95 bindings
associated with software wrapped with Babel’s language interoperability
middleware. The bindings generation process is presented first.
Object management and invocation of static and overloaded methods are
also summarized. The process of catching exceptions is then discussed.
Finally, the processes for enabling and disabling implementation-specific
pre- and post-method instrumentation — referred to as “hooks” —
are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.1  Bindings generation</H3><!--SEC END --><P>
<A NAME="@default1086"></A>
<A NAME="@default1087"></A><A NAME="@default1088"></A></P><P>The following is an example of invoking Babel to create the Fortran 90/95 
stubs for a SIDL file<SUP><A NAME="text17" HREF="#note17">1</A></SUP>:
<A NAME="@default1089"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=f90 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -c=f90 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>As a result, a makefile fragment called <TT>babel.make</TT>, numerous C header 
and source files, and some Fortran 90/95 files will be created. Files ending in
<TT>_fStub.c</TT> (i. e., <TT>STUBSRCS</TT> in <TT>babel.make</TT>) are called 
by the Fortran 90/95 module which in turn allow Fortran 90/95 to call SIDL 
methods. Files ending in <TT>_type.F90</TT> (i. e., <TT>STUBMODULESRCS</TT> 
in <TT>babel.make</TT>) contain derived type definitions for classes and 
interfaces. The remaining files ending in <TT>.F90</TT> (i. e., 
<TT>TYPEMODULESRCS</TT> in <TT>babel.make</TT>) are Fortran 90/95 modules 
containing methods. All of these files need to be compiled and 
linked into the application. </P><P>Normally, IOR files (i. e., those ending in <TT>_IOR.c</TT>) are linked 
together with the implementation file, so probably don’t need to be compiled.</P><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.2  Object management</H3><!--SEC END --><P>
<A NAME="@default1090"></A>
<A NAME="@default1091"></A></P><P>SIDL-specified objects are managed through explicit creation and
reference counting<A NAME="@default1092"></A>. Babel automatically generates
a <TT>new()</TT><A NAME="@default1093"></A> method for concrete classes.
The method is used to instantiate the class and return the associated reference.
The following example illustrates the instantiation and casting of an object
to an interface:
<A NAME="@default1094"></A><A NAME="@default1095"></A>
<A NAME="@default1096"></A><A NAME="@default1097"></A>
<A NAME="@default1098"></A><A NAME="@default1099"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_BaseClass
  <B>use</B> sidl_BaseInterface
  type(sidl_BaseClass_t)     :: object
  type(sidl_BaseInterface_t) :: <B>interface</B>
  type(sidl_BaseInterface_t) :: exception
  <FONT COLOR="blue"><I>! perhaps other code here</I></FONT>
  call new(object, exception)
  call cast(object, <B>interface</B>, exception)</TD></TR>
</TABLE><P>The owner of the instance is responsible for its proper disposal. In other
words, when processing with the object is done, the owner must
invoke <TT>deleteRef()</TT><A NAME="@default1100"></A> on it. Similarly, any object 
references returned
by a subroutine call must be deleted or given to another part of the code
that will take ownership of and, therefore, responsibility
for <TT>deleteRef</TT>’ing it.
The following example illustrates calling <TT>deleteRef()</TT> using the
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> method:
<A NAME="@default1101"></A>
<A NAME="@default1102"></A><A NAME="@default1103"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_BaseInterface
  type(sidl_BaseInterface_t) :: interface1, interface2
  type(sidl_BaseInterface_t) :: exception
  logical                    :: areSame
  <FONT COLOR="blue"><I>!
  ! code to initialize interface1 &amp; interface 2 here
  !</I></FONT>
  call deleteRef(interface1, exception)</TD></TR>
</TABLE><P>When it is necessary to determine if two references point to the same object,
the built-in <TT>isSame</TT> method can be used. For example, the following
attempts to determine if <TT>interface1</TT> and <TT>interface2</TT> point to
the same object:
<A NAME="@default1104"></A><A NAME="@default1105"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_BaseInterface
  <FONT COLOR="blue"><I>! later in the code</I></FONT>
  call isSame(interface1, interface2, areSame, exception)
  <FONT COLOR="blue"><I>! areSame holds the return value</I></FONT></TD></TR>
</TABLE><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.3  Static methods</H3><!--SEC END --><P>
<A NAME="@default1106"></A></P><P>Below is an example illustrating a call to <TT>addSearchPath()</TT>, which
is a static method in the <FONT COLOR=maroon><I><TT>sidl.Loader</TT></I></FONT> class.
<A NAME="@default1107"></A>
<A NAME="@default1108"></A>
<A NAME="@default1109"></A><A NAME="@default1110"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_Loader
  <B>use</B> sidl_BaseInterface
  type(sidl_BaseInterface_t) :: exception
  <FONT COLOR="blue"><I>! later</I></FONT>
  call addSearchPath('/try/looking/here', exception)</TD></TR>
</TABLE><P>Note the function is invoked directly, without an object reference
argument.</P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.4  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default1111"></A>
<A NAME="@default1112"></A></P><P>Examples of calls to SIDL overloaded methods are based on the 
<TT>overload_sample.sidl</TT> file shown in Section <A HREF="#sec:overloading">6.7</A>. 
Recall that the file describes three versions of the <TT>getValue</TT> method. 
The first takes no arguments, the second takes an integer argument, and the 
third takes a boolean. Each is called in the following code snippet:
<A NAME="@default1113"></A>
<A NAME="@default1114"></A><A NAME="@default1115"></A>
<A NAME="@default1116"></A><A NAME="@default1117"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> Overload_Sample
  type(Overload_Sample_t)         :: t
  type(sidl_BaseInterface_t)      :: exception
  logical                         :: b1, bretval
  integer (<B>kind</B>=sidl_int)  :: i1, iretval

  call new(t, exception)

  call getValue (t, iretval, exception)
  call getValueInt (t, i1, iretval, exception)
  call getValueBool (t, b1, bretval, exception)</TD></TR>
</TABLE><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.5  Exception catching</H3><!--SEC END --><P><A NAME="ss:f90:exceptioncatching"></A>
<A NAME="@default1118"></A><A NAME="@default1119"></A>
<A NAME="@default1120"></A></P><P>Since all methods can now throw <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT>
<A NAME="@default1121"></A>, Babel ensures there is an
<FONT COLOR=maroon><I><TT>out</TT></I></FONT> argument to hold an exception. If not explicitly specified,
Babel will automatically add the argument.
For maximum backward compatibility, the exception argument type is 
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>, while the base exception class is
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>. The exception argument, which behaves like 
an <TT>out</TT> parameter, will appear after the return value when both 
occur in a method. After the call, the client should test this argument 
using <TT>is_null</TT><A NAME="@default1122"></A> or <TT>not_null</TT>. 
If it is <TT>not_null</TT><A NAME="@default1123"></A><TT>_null</TT>, an exception was 
thrown by the method
so the caller should respond appropriately. When an exception is thrown,
the values of all other arguments are undefined. So the best course of
action is to ignore them. If the code does not check the
exception argument after each call (that can throw one), any
exceptions that are thrown will be utterly ignored as a result of not being
automatically propagated to higher level routines.</P><P>It is possible to determine which exception was thrown through
casting the argument. A successful cast indicates the type of exception
that occurred. An example of this process is illustrated below.
Package <TT>ExceptionTest</TT> has a class named <TT>Fib</TT> with a 
<TT>getFib</TT> method declared in SIDL as follows: 
<A NAME="@default1124"></A>
<A NAME="@default1125"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>int</B> getFib(<B>in int</B> n, <B>in int</B> max_depth, <B>in int</B> max_value, <B>in int</B> depth)
    <B>throws</B> NegativeValueException, FibException;</I></FONT></TD></TR>
</TABLE><P>The code to catch specified exception types is:
<A NAME="@default1126"></A><A NAME="@default1127"></A>
<A NAME="@default1128"></A><A NAME="@default1129"></A>
<A NAME="@default1130"></A><A NAME="@default1131"></A>
<A NAME="@default1132"></A><A NAME="@default1133"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> ExceptionTest_Fib
  <B>use</B> ExceptionTest_FibException
  <B>use</B> ExceptionTest_NegativeValueException
  <B>use</B> sidl_BaseInterface
  type(ExceptionTest_Fib_t)                    :: fib
  type(sidl_BaseInterface_t)                   :: except, except2
  type(ExceptionTest_FibException_t)           :: fibexcept
  type(ExceptionTest_NegativeValueException_t) :: nvexcept
  integer (<B>kind</B>=sidl_int)  :: index, maxdepth, maxval, depth, <B>result</B>
  call new(fib, except)

  index    = 4
  maxdepth = 100
  maxvalue = 32000
  depth    = 0
  call getFib(fib, index, maxdepth, maxvalue, depth, <B>result</B>, except)
  if (not_null(except)) then
    call cast(except, fibexcept, except2)
    if (not_null(fibexcept)) then
<FONT COLOR="blue"><I>!      do something here with the FibException</I></FONT>
       call deleteRef(fibexcept, except2)
    else
      call cast(except, nvexcept, except2)
<FONT COLOR="blue"><I>!     do something here with the NegativeValueException</I></FONT>
      call deleteRef(nvexcept, except2)
    <B>endif</B>
    call deleteRef(except, except2)
  else
    write (*,*) 'getFib for ', index, ' returned ', <B>result
  endif</B>
  call deleteRef(fib, except2)</TD></TR>
</TABLE><P><EM><B>NOTE</B>:
Any caller of a method that returns an exception should ignore
the values of <TT>out</TT> and <TT>inout</TT> parameters. Anything not
freed becomes a reference and memory leak. 
</EM></P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.6  Hooks execution</H3><!--SEC END --><P><A NAME="ss:f90:sethooks"></A>
<A NAME="@default1134"></A><A NAME="@default1135"></A>
<A NAME="@default1136"></A><A NAME="@default1137"></A>
<A NAME="@default1138"></A><A NAME="@default1139"></A></P><P>If a given component supports pre- and post-method invocation instrumentation,
also known as “hooks”, their execution can be enabled or disabled at
runtime through the built-in <TT>set_hooks</TT> method. For example,
given the following SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class. Due to unresolved method overloading problems, 
the processes for enabling and disabling execution of the 
implementation-specific hooks are currently dependent on use of 
fully-qualified functions, as illustrated below.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> hooks_Basics
  type(hooks_Basics_t)         :: obj
  type(sidl_BaseInterface_t)   :: exception

  call new(obj, exception)

  <FONT COLOR="blue"><I>!
  ! Enable hooks execution (enabled by default)
  ! ...for static methods
  !    (until method overloading issue can be resolved)...
  !</I></FONT>
  call hooks_Basics__set_hooks_static_m(1, exception)
  <FONT COLOR="blue"><I>!
  ! ...for non-static methods
  !    (until method overloading issue can be resolved)...
  !</I></FONT>
  call hooks_Basics__set_hooks_m(obj, 1, exception)

  <FONT COLOR="blue"><I>!
  ! ...do something important...
  !

  !
  ! Disable hooks execution
  ! ...for static methods
  !</I></FONT>
  call hooks_Basics__set_hooks_static_m(0, exception)
  <FONT COLOR="blue"><I>!
  ! ...for non-static methods
  !</I></FONT>
  call hooks_Basics__set_hooks_m(obj, 0, exception)

  <FONT COLOR="blue"><I>!
  ! ...do something important...
  !</I></FONT></TD></TR>
</TABLE><P>It is important to keep in mind that the 
<TT>set_hooks_static</TT>
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>set_hooks</TT> method must be used for 
those of non-static methods. Also, Babel does not provide client 
access to the <TT>_pre</TT> and <TT>_post</TT> methods; therefore, they 
cannot be invoked directly. More information on the instrumentation 
process is provided in Subsection <A HREF="#ss:f90:hooksimpl">11.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.3.7  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:f90:contract_enforcement"></A>
<A NAME="@default1140"></A>
<A NAME="@default1141"></A>
<A NAME="@default1142"></A></P><P>Interface contracts specify the expected behaviors of clients and servers
of interface and class methods.
Once specified, contracts can automatically be enforced at runtime.
This section provides an example of a specification and associated code
snippets for performing basic, traditional contract enforcement —
introduced in Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — within a
Fortran 90/95 client.</P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below.
(Refer to Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.)
According to the preconditions,
<A NAME="@default1143"></A><A NAME="@default1144"></A>
<A NAME="@default1145"></A>
all callers are expected to provide two one-dimensional, SIDL arrays of the
same size as arguments.
The postconditions
<A NAME="@default1146"></A><A NAME="@default1147"></A>
<A NAME="@default1148"></A>
specify that all implementations are expected to return a non-null, 
one-dimensional array of the same size (as the first SIDL array), 
assuming the preconditions are satisfied.</P><P><A NAME="@default1149"></A>
<A NAME="@default1150"></A>
<A NAME="@default1151"></A>
<A NAME="@default1152"></A><A NAME="@default1153"></A>
<A NAME="@default1154"></A>
<A NAME="@default1155"></A>
<A NAME="@default1156"></A>
<A NAME="@default1157"></A>
<A NAME="@default1158"></A>
<A NAME="@default1159"></A>
<A NAME="@default1160"></A>
<A NAME="@default1161"></A>
<A NAME="@default1162"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a Fortran 90/95 client calling the method is given below. 
The code snippet illustrates declaring and creating the arrays; enabling 
full contract enforcement (i. e., checking all contract clauses); 
executing <TT>vuSum</TT>; handling contract violation exceptions; 
and cleaning up references is given below.</P><P><A NAME="@default1163"></A>
<A NAME="@default1164"></A>
<A NAME="@default1165"></A>
<A NAME="@default1166"></A>
<A NAME="@default1167"></A>
<A NAME="@default1168"></A>
<A NAME="@default1169"></A>
<A NAME="@default1170"></A>
<A NAME="@default1171"></A>
<A NAME="@default1172"></A>
<A NAME="@default1173"></A>
<A NAME="@default1174"></A>
<A NAME="@default1175"></A>
<A NAME="@default1176"></A>
<A NAME="@default1177"></A>
<A NAME="@default1178"></A>
<A NAME="@default1179"></A>
<A NAME="@default1180"></A>
<A NAME="@default1181"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> sidl_ContractClass
  <B>use</B> sidl_double_array
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_EnfPolicy
  <B>use</B> vect_Utils
  implicit <B>none</B>

<FONT COLOR="blue"><I>!     ...</I></FONT>

  type (sidl_BaseInterface_t) :: exc, tae
  type (sidl_double_1d) :: u, v, x

  call createDouble(MAX_SIZE, u)
  call createDouble(MAX_SIZE, v)

<FONT COLOR="blue"><I>!     Initialize u and v.

!     Enable FULL contract enforcement.</I></FONT>
  call sidl_EnfPolicy_setEnforceAll_m(ALLCLASSES, .true., exc)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!    Handle the exception</I></FONT>
  <B>endif</B>

<FONT COLOR="blue"><I>!     Do something meaningful before executing the method.</I></FONT>

  call vect_Utils_vuSum_m(u, v, x, exc)
  if (is_null(exc)) then
<FONT COLOR="blue"><I>!    Do something meaningful with the result, x.</I></FONT>
  else
<FONT COLOR="blue"><I>!    Handle the exception</I></FONT>
  <B>endif</B>

<FONT COLOR="blue"><I>!     ...</I></FONT>

  call deleteRef(u)
  call deleteRef(v)
  if (.not. is_null(x)) then
     call deleteRef(x)
  <B>endif</B></TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the Fortran 90/95 calls associated with the 
traditional options of enabling only precondition enforcement, enabling 
postcondition enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default1182"></A>
<A NAME="@default1183"></A>
<A NAME="@default1184"></A>
<A NAME="@default1185"></A>
<A NAME="@default1186"></A>
<A NAME="@default1187"></A>
<A NAME="@default1188"></A>
<A NAME="@default1189"></A>
<A NAME="@default1190"></A>
<A NAME="@default1191"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> sidl_ContractClass
  <B>use</B> sidl_double_array
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_EnfPolicy
  <B>use</B> vect_Utils
  implicit <B>none</B>

<FONT COLOR="blue"><I>!     ...

!
!     Enable only precondition contract enforcement.
!     (Useful when only need to ensure callers comply with contract.)
!</I></FONT>
  call sidl_EnfPolicy_setEnforceAll_m(PRECONDS, .false., exception)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!       Handle the exception</I></FONT>
  <B>endif</B>


<FONT COLOR="blue"><I>!
!     Enable only postcondition contract enforcement.
!     (Useful when only need to ensure implementation(s) comply with contract.)
!</I></FONT>
  call sidl_EnfPolicy_setEnforceAll_m(POSTCONDS, .false., exception)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!       Handle the exception</I></FONT>
  <B>endif</B>

<FONT COLOR="blue"><I>!
!     Disable contract enforcement.
!     (Should only be used when have confidence in caller AND implementation.)
!</I></FONT>
  call sidl_EnfPolicy_setEnforceNone_m(.false., exception)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!       Handle the exception</I></FONT>
  <B>endif</B></TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a Fortran 90/95 client.
Additional enforcement policy options and methods as well as more
information regarding the specification and enforcement of contracts
can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">11.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:f90:implementation"></A>
<A NAME="@default1192"></A></P><P>This section summarizes aspects of generating and wrapping software
written in Fortran 90/95. The bindings generation and basic implementation 
processes are presented first.
Since access to object state requires special steps in Fortran 90/95, the process
for defining and managing that data is discussed. Throwing
exceptions in the implementation is then illustrated.
Finally, the results of generating implementations with pre- and post-method
“hooks” are shown.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:f90:implgen"></A>
<A NAME="@default1193"></A>
<A NAME="@default1194"></A><A NAME="@default1195"></A></P><P>Much of the information associated with generating client-side bindings is 
pertinent to implementing a SIDL class in Fortran 90/95. The mapping of SIDL 
types to language constructs was given in Table <A HREF="#tbl:f90:types">11.1</A>.
If the implementation calls other SIDL methods, client-side caller rules 
must be followed.</P><P>To create the implementation bindings for a set of SIDL classes in Fortran 90/95,
Babel is invoked as follows:
<A NAME="@default1196"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=f90 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -s=f90 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>As a result, a makefile fragment called <TT>babel.make</TT>, numerous C 
header and source files, and some Fortran 90/95 source files will be created. 
The <TT>SUBROUTINE</TT> and <TT>END SUBROUTINE</TT>
statements are automatically generated and the types of arguments declared. 
Implementation details must be added to the Fortran 90/95 “Impl” files,
whose names end with <TT>_Impl.F90</TT> and <TT>_Mod.F90</TT>.
More on this matter is provided in Subsection <A HREF="#ss:f90:implfill">11.4.2</A>.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:f90:implfill"></A>
<A NAME="@default1197"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:f90:implgen">11.4.1</A>. Changes to these files must be made between
code splicer pairs to ensure their retention in subsequent invocations of
Babel. Below is an example of the 
standard, automatically generated code splicer pairs.
<A NAME="@default1198"></A><A NAME="@default1199"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(_miscellaneous_code_start)
! Insert-Code-Here {_miscellaneous_code_start} (extra code)
! DO-NOT-DELETE splicer.end(_miscellaneous_code_start)</I></FONT>

.
.
.

<B>recursive</B> subroutine Pkg_Class_name_mi(self, arg, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> Pkg_Class
  <B>use</B> Pkg_Class_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Pkg.Class.name.use)
  ! Insert-Code-Here {Pkg.Class.name.use} (use statements)
  ! DO-NOT-DELETE splicer.end(Pkg.Class.name.use)</I></FONT>
  implicit <B>none</B>
  type(Pkg_Class_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: arg <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(Pkg.Class.name)
! Insert-Code-Here {Pkg.Class.name} (name method)
! DO-NOT-DELETE splicer.end(Pkg.Class.name)</I></FONT>
end subroutine Pkg_Class_name_mi</TD></TR>
</TABLE><P>The comment 
“Insert-Code-Here” associated with the “miscellaneous code start” 
splicer pair will need to be replaced with details such as 
additional abbreviation file(s) and any local, or 
private, subroutines. For the subroutine’s “use” splicer pair, the 
“Insert-Code-Here {Pkg.Class.name.use} (use statements)” comment must
be replaced with any <TT>use</TT> statements needed by the subroutine. 
Finally, the implementation between the subroutine body’s splicer pairs 
must be added in place of the 
“Insert-Code-Here {Pkg.Class.name} (name method)” comment.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.4.3  Private data</H3><!--SEC END --><P>
<A NAME="@default1200"></A>
<A NAME="@default1201"></A></P><P>Any variables declared in the implementation source file will, by
virtue of Babel’s encapsulation, be private.
Special initialization procedures can be added to
the built-in <TT>_load()</TT> method, which is guaranteed to be called
exactly once per class to set global class data — <EM>before</EM> 
any user-defined methods can even be invoked.</P><P>The SIDL IOR keeps a pointer for each object that is intended to hold 
a pointer to the object’s internal data. Below is an
excerpt from a <TT>_Mod.F90</TT> file for an object whose state requires a
single integer value.
<A NAME="@default1202"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#<B>include</B> "sort_SimpleCounter_fAbbrev.h"
<B>module</B> sort_SimpleCounter_impl

<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter.use)</I></FONT>
<B>use</B> sidl
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(sort.SimpleCounter.use)</I></FONT>

type sort_SimpleCounter_priv
  <B>sequence</B>
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter.private_data)</I></FONT>
   integer(<B>kind</B>=sidl_int) :: count
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(sort.SimpleCounter.private_data)</I></FONT>
end type sort_SimpleCounter_priv

type sort_SimpleCounter_wrap
  <B>sequence</B>
  type(sort_SimpleCounter_priv), <B>pointer</B> :: d_private_data
end type sort_SimpleCounter_wrap

end <B>module</B> sort_SimpleCounter_impl</TD></TR>
</TABLE><P>The derived type <TT>sort_SimpleCounter_priv</TT> is the type in which
the developer adds data to store the object’s state. The
<TT>sort_SimpleCounter_wrap</TT> type exists simply to 
facilitate transferring the <TT>sort_SimpleCounter_priv</TT> 
pointer to and from the IOR.</P><P>Access to this data is provided by two built-in functions — referred to
as <TT>set_data</TT> and <TT>get_data</TT> — whose full names are derived 
from the fully qualified type name<A NAME="@default1203"></A>. In both cases, the 
first argument is the object pointer (i. e., <TT>self</TT>), and the second is a
derived type defined in the <TT>_Mod.F90</TT> file. The developer is 
responsible for managing the memory associated with the private data.</P><P>As illustrated in the constructor below, the basic process to initialize
private data involves allocating memory then setting the data pointer.
<A NAME="@default1204"></A>
<A NAME="@default1205"></A><A NAME="@default1206"></A>
<A NAME="@default1207"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine sort_SimpleCounter__ctor_mi(self, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> sort_SimpleCounter
  <B>use</B> sort_SimpleCounter_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter._ctor.use)
  ! Insert-Code-Here {sort.SimpleCounter._ctor.use} (use statements)
  ! DO-NOT-DELETE splicer.end(sort.SimpleCounter._ctor.use)</I></FONT>
  implicit <B>none</B>
  type(sort_SimpleCounter_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(sort.SimpleCounter._ctor)</I></FONT>
  type(sort_SimpleCounter_wrap) :: dp
  <B>allocate</B>(dp%d_private_data)
  dp%d_private_data%count = 0
  call sort_SimpleCounter__set_data_m(self, dp)
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(sort.SimpleCounter._ctor)</I></FONT>
end subroutine sort_SimpleCounter__ctor_mi</TD></TR>
</TABLE><P>Note the use of <TT>allocate(pd%d_private_data)</TT> 
in the constructor, <TT>_ctor</TT>, to allocate the memory for the
<TT>sort_SimpleCounter_priv</TT> derived type and the fully qualified
name for <TT>get_data</TT>.</P><P>Similarly, the destructor is responsible for freeing the data’s memory
as follows:
<A NAME="@default1208"></A>
<A NAME="@default1209"></A><A NAME="@default1210"></A>
<A NAME="@default1211"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine sort_SimpleCounter__dtor_mi(self, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> sort_SimpleCounter
  <B>use</B> sort_SimpleCounter_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter._dtor.use)
  ! Insert-Code-Here {sort.SimpleCounter._dtor.use} (use statements)
  ! DO-NOT-DELETE splicer.end(sort.SimpleCounter._dtor.use)</I></FONT>
  implicit <B>none</B>
  type(sort_SimpleCounter_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(sort.SimpleCounter._dtor)</I></FONT>
  type(sort_SimpleCounter_wrap) :: dp
  call sort_SimpleCounter__get_data_m(self, dp)
  <B>deallocate</B>(dp%d_private_data)
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(sort.SimpleCounter._dtor)</I></FONT>
end subroutine sort_SimpleCounter__dtor_mi</TD></TR>
</TABLE><P>In this case, <TT>deallocate(pd%d_private_data)</TT> is used to 
free the memory allocated in the constructor for the 
<TT>sort_SimpleCounter_priv</TT> derived type. </P><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.4.4  Exception throwing</H3><!--SEC END --><P><A NAME="ss:f90:exceptionthrowing"></A>
<A NAME="@default1212"></A>
<A NAME="@default1213"></A></P><P>Below is an example of an implementation subroutine that throws an
exception. The returned exception object pointer must be <TT>cast</TT>
into the exception <TT>out</TT> parameter. This example also utilizes
two methods, inherited from <FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT> and implemented 
in 
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>, that aid client-side debugging. The first,
<TT>setNote</TT>, allows the developer to provide a useful error message.
The second, <TT>add</TT>, provides a multi-language traceback capability —
assuming each layer of the call stack invokes <TT>add</TT> before it propagates
the exception.
<A NAME="@default1214"></A>
<A NAME="@default1215"></A><A NAME="@default1216"></A>
<A NAME="@default1217"></A><A NAME="@default1218"></A>
<A NAME="@default1219"></A><A NAME="@default1220"></A>
<A NAME="@default1221"></A><A NAME="@default1222"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine ExceptionTest_Fib_getFib_mi(self, n, max_depth, &amp;
  max_value, depth, retval, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> ExceptionTest_Fib
  <B>use</B> ExceptionTest_NegativeValueException
  <B>use</B> ExceptionTest_FibException
  <B>use</B> ExceptionTest_Fib_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFib.use)</I></FONT>
  <B>use</B> ExceptionTest_TooBigException
  <B>use</B> ExceptionTest_TooDeepException
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFib.use)</I></FONT>
  implicit <B>none</B>
  type(ExceptionTest_Fib_t) :: self
  integer (<B>kind</B>=sidl_int) :: n, max_depth, max_value
  integer (<B>kind</B>=sidl_int) :: retval, depth
  type(sidl_BaseInterface_t) :: exception
  type(sidl_BaseInterface_t) :: except2
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFib)</I></FONT>
  type(ExceptionTest_NegativeValueException_t) :: negexc
<FONT COLOR="blue"><I>! ...lines deleted...</I></FONT>
  character (<B>len</B>=*) myfilename
  parameter(myfilename='ExceptionTest_Fib_Impl.f')
  retval = 0
  if (n .lt. 0) then
     call new(negexc, except2)
     if (not_null(negexc)) then
        call setNote(negexc, &amp;
             'called with negative n', except2)
        call add(negexc, myfilename, 57, &amp;
                 'ExceptionTest_Fib_getFib_impl', except2)
        call cast(negexc, exception, except2)
        call deleteRef(negexc, except2)
        return
     <B>endif</B>
  else
<FONT COLOR="blue"><I>! ...numerous lines deleted....
! DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFib)</I></FONT>
end subroutine ExceptionTest_Fib_getFib_mi</TD></TR>
</TABLE><P>When an exception is thrown, the implementation should
<TT>deleteRef</TT> any references it was planning to return to its
caller. In general, when throwing an exception, it is
good practice to call <TT>set_null</TT> on all <TT>out</TT> and
<TT>inout</TT> array, class, and interface arguments before returning.
This makes things work out better for
clients who forget to check if an exception occurred or willfully
choose to ignore it.</P><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.4.5  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:f90:hooksimpl"></A>
<A NAME="@default1223"></A><A NAME="@default1224"></A>
<A NAME="@default1225"></A>
<A NAME="@default1226"></A><A NAME="@default1227"></A>
<A NAME="@default1228"></A><A NAME="@default1229"></A></P><P>As discussed in Subsection <A HREF="#ss:f90:sethooks">11.3.6</A>, when hooks execution
is enabled, implementation-specific instrumentation is executed. Using
the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results
in the automatic generation of a <TT>_pre</TT> and <TT>_post</TT>
method for every static and non-static method associated with each class
in the specification. For the <TT>aStaticMethod</TT> specified in
Subsection <A HREF="#ss:f90:sethooks">11.3.6</A>, the generated <TT>_pre</TT> method
implementation is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine hooks_Basics_aStaticMeth_pre_mi(i, io, exception)
  <B>use</B> sidl
  <B>use</B> sidl_NotImplementedException
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> hooks_Basics
  <B>use</B> hooks_Basics_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre.use)
  !   Insert implementation use details
  ! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre.use)</I></FONT>
  implicit <B>none</B>
  integer (<B>kind</B>=sidl_int) :: i <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: io <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre)
!
!   Add instrumentation here to be executed immediately prior
!   to dispatch to aStaticMeth().
!
! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre)</I></FONT>
end subroutine hooks_Basics_aStaticMeth_pre_mi</TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine B_aStaticMeth_postywgp49zzy2_mi(i, o, io, retval,         &amp;
  exception)
  <B>use</B> sidl
  <B>use</B> sidl_NotImplementedException
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> hooks_Basics
  <B>use</B> hooks_Basics_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post.use)
  !   Insert implementation use details
  ! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post.use)</I></FONT>
  implicit <B>none</B>
  integer (<B>kind</B>=sidl_int) :: i <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: o <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: io <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: retval <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post)
!
!    Add instrumentation here to be executed immediately after
!    return from dispatch to aStaticMeth().
!</I></FONT>
  return
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post)</I></FONT>
end subroutine B_aStaticMeth_postywgp49zzy2_mi</TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation
should be added within the splicer blocks of
<TT>aStaticMethod_pre</TT> and
<TT>aStaticMethod_post</TT>. As stated in the comments
within those blocks, <TT>aStaticMethod_pre</TT> will be
executed immediately prior to dispatch to <TT>aStaticMethod</TT> when the
latter is invoked by a client. Assuming no exceptions are encountered,
<TT>aStaticMethod_post</TT> is executed immediately upon
return from <TT>aStaticMethod</TT>.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note17" HREF="#text17">1</A></DT><DD CLASS="dd-thefootnotes">For information on additional command line 
options, refer to Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Fortran 2003/2008 Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc53">Chapter 12</A>  Fortran 2003/2008 Bindings</H1><!--SEC END --><P><A NAME="c:f03"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc54">12.1</A>  Introduction</H2><!--SEC END --><P>
This chapter provides an overview of the Fortran 2003/2008 bindings for SIDL.
Common aspects of the bindings, such as the mapping of SIDL data types
to their native Fortran 2003/2008 representatives, are presented in
Section <A HREF="#s:f03:basics">12.2</A>.
Issues of concern to Fortran 2003/2008 callers are addressed in the client-side 
bindings discussion in Section <A HREF="#s:f03:client">12.3</A>, while issues of interest
to callees of Fortran 2003/2008 appear in the implementation-side discussion in
Section <A HREF="#s:f03:implementation">12.4</A>.</P><!--TOC subsection Compatibility with Fortran compilers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.1.1  Compatibility with Fortran compilers</H3><!--SEC END --><P>
Fortran 2003/2008 is a relatively new standard and at the time of
writing no compiler supports the full feature set. Babel’s
<TT>configure</TT> script therefore tests for several features
(including type extensions and C-compatible function pointers) before
it enables the <TT>f03</TT> backend. The <TT>configure</TT> script will
output an explanation, if one of the tests should fail. As of
October 2011, only GNU <TT>gfortran</TT> 4.6.1 and Intel
<TT>ifort</TT> 12.1.233 and IBM XL Fortran for Blue Gene 11.1 were up to
the task.<SUP><A NAME="text18" HREF="#note18">1</A></SUP> It is advisable to run the regression tests (<TT>make
check</TT>) in the build tree to confirm whether the <TT>f03</TT> backend
is working.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc55">12.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:f03:basics"></A></P><P>This section summarizes basic features that are common to both client
and implementation bindings. Conventions used to protect the global
name space are described in Subsection <A HREF="#ss:f03:namespace">12.2.2</A>, while
those associated with the generation of subroutines from methods are
given in Subsection <A HREF="#ss:f03:signatures">12.2.3</A>. Translations between
SIDL and native Fortran 2003/2008 constructs are described in
Subsection <A HREF="#ss:f03:types">12.2.4</A>. Finally, the process of casting
between different types is illustrated in
Subsection <A HREF="#ss:f03:casting">12.2.5</A>.</P><!--TOC subsection File extension-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.1  File extension</H3><!--SEC END --><P><A NAME="ss:f03:extension"></A>
<A NAME="@default1230"></A> <A NAME="@default1231"></A> The
default file extension for preprocessed Fortran 2003/2008 sources is
<TT>.f03</TT>. Some compilers (e. g., Intel’s) do not recognize this
extension; in these cases the <TT>configure</TT> process detects this
and switches to <TT>.f90</TT> instead. The capital version
<TT>.F03</TT> is used for files that are meant to be run through the C
preprocessor <TT>cpp</TT>. If your compiler’s <TT>cpp</TT> has
troubles with the extensions, it may help to pass
<TT>CPP=’gcc -E’</TT> to <TT>configure</TT> to enforce the use of
GCC’s preprocessor instead.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.2  Name space</H3><!--SEC END --><P><A NAME="ss:f03:namespace"></A>
<A NAME="@default1232"></A>
<A NAME="@default1233"></A></P><P>The name of the module that holds method definitions is derived
from the fully qualified name of the class or interface. Module names
are essentially formed by replacing all periods in the fully qualified
name with underscores. The name of the module holding the derived type 
of the class or interface is the same as the one holding the methods 
with the exception of having <TT>_type</TT> appended. For example, the 
methods for <FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT><A NAME="@default1234"></A> are 
defined in a module named <TT>sidl_SIDLException</TT> in the file 
<TT>sidl_SIDLException.F03</TT>. Defined in the file 
<TT>sidl_SIDLException_type.F03</TT>, the types for 
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT> are called 
<TT>sidl_SIDLException_t</TT>
and, for the array, <TT>sidl_SIDLException_a</TT>.</P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.3  Method signatures</H3><!--SEC END --><P><A NAME="ss:f03:signatures"></A>
<A NAME="@default1235"></A>
<A NAME="@default1236"></A></P><P>To maintain compatibility with the Fortran 90/95 implementation
(cf. Section <A HREF="#ss:f90:signatures">11.2.2</A>), all SIDL methods are
implemented as Fortran 2003/2008
subroutines<A NAME="@default1237"></A> regardless of whether
they have a return value. However, in most cases, Babel will also
generate an alternative stub using a <EM>function</EM> signature. The
name of a subroutine that clients invoke is the method’s full name
from the SIDL description. Hence, in cases where the method has a
name extension (so is overloaded), the full name is the concatenation
of the specified short name and extension. On the
implementation-side, the name is formed as the concatenation of the
package, class (or interface), full method name<A NAME="@default1238"></A>, and
“mi”, with each part separated by an underscore and name mangling
used to ensure uniqueness if the resulting name exceeds the character
limit.</P><P>The same process used for <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, described in 
Subsection <A HREF="#ss:f77:signatures">10.2.2</A>, is used to build up the parameters 
for generated methods. That is, object (or interface) pointers, return
values, and exception pointers are added, as needed. More specifically,
the object (or interface) pointer is automatically inserted as the first
parameter in the signature of non-static methods. This parameter
operates like an <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameter. 
When a method has a return value, a parameter to hold the return value is
also added after all of the formally declared arguments.
This extra argument behaves like an <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter.
With the addition of remote method invocation (RMI) support, all methods
now implicitly throw exceptions<A NAME="@default1239"></A>.
Hence, an extra <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter for the exception is automatically added
as the last parameter of the signature.
<A NAME="@default1240"></A><A NAME="@default1241"></A>
An example that illustrates the SIDL specification and corresponding 
routines can be found in Subsections <A HREF="#ss:f03:exceptioncatching">12.3.5</A>
and <A HREF="#ss:f03:exceptionthrowing">12.4.4</A>.</P><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.4  Data types</H3><!--SEC END --><P><A NAME="ss:f03:types"></A>
<A NAME="@default1242"></A>
<A NAME="@default1243"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 12.1: SIDL to Fortran 2003/2008 Type Mappings</TD></TR>
</TABLE></DIV><A NAME="tbl:f03:types"></A>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP> SIDL type</TD><TD ALIGN=left NOWRAP>Real Fortran 2003/2008 type</TD><TD ALIGN=left NOWRAP>Alternative name</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>integer(c_int32_t)</TT></TD><TD ALIGN=left NOWRAP><TT>integer(kind=sidl_int)</TT> <A NAME="@default1244"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>integer(c_int64_t)</TT></TD><TD ALIGN=left NOWRAP><TT>integer(kind=sidl_long)</TT> <A NAME="@default1245"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>real(c_float)</TT></TD><TD ALIGN=left NOWRAP><TT>real (kind=sidl_float)</TT> <A NAME="@default1246"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>real(c_double)</TT></TD><TD ALIGN=left NOWRAP><TT>real (kind=sidl_double)</TT> <A NAME="@default1247"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>integer(c_int)</TT></TD><TD ALIGN=left NOWRAP><TT>logical</TT>		 <A NAME="@default1248"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>integer(c_signed_char)</TT></TD><TD ALIGN=left NOWRAP><TT>character (len=1)</TT>	 <A NAME="@default1249"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>type(c_ptr)</TT> 	</TD><TD ALIGN=left NOWRAP><TT>character (len=*)</TT> <A NAME="@default1250"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>complex(c_float_complex)</TT></TD><TD ALIGN=left NOWRAP> <TT>COMPLEX (kind=sidl_fcomplex)</TT> <A NAME="@default1251"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>complex(c_double_complex)</TT></TD><TD ALIGN=left NOWRAP> <TT>COMPLEX (kind=sidl_dcomplex)</TT> <A NAME="@default1252"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>enum</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>integer(c_int64_t)</TT>	</TD><TD ALIGN=left NOWRAP><TT>integer (kind=sidl_enum)</TT> <A NAME="@default1253"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>type(c_ptr)</TT></TD><TD ALIGN=left NOWRAP><TT>integer (kind=sidl_opaque)</TT> <A NAME="@default1254"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>type(c_ptr)</TT>		</TD><TD ALIGN=left NOWRAP><EM><TT>derived type</TT></EM>	<A NAME="@default1255"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>class</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>type(c_ptr)</TT>		</TD><TD ALIGN=left NOWRAP><EM><TT>derived type</TT></EM>	<A NAME="@default1256"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>array</TT></I></FONT>	</TD><TD ALIGN=left NOWRAP><TT>type(c_ptr)</TT>	</TD><TD ALIGN=left NOWRAP><EM><TT>derived type</TT></EM>	<A NAME="@default1257"></A></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The mapping for simple SIDL types to Fortran 2003/2008 is given in
Table <A HREF="#tbl:f03:types">12.1</A>. The kind parameters, given in
the <TT>sidl</TT> F03 module, define integer
parameters for <TT>sidl_int</TT>, <TT>sidl_long</TT>,
<TT>sidl_float</TT>, <TT>sidl_double</TT>, 
<TT>sidl_fcomplex</TT>, <TT>sidl_dcomplex</TT>, 
<TT>sidl_enum</TT> and <TT>sidl_opaque</TT> to
give sizes that match the corresponding SIDL types.
The remainder of this subsection elaborates on mappings of strings, 
pointers, enumerations, and arrays.</P><!--TOC subsubsection Strings-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Strings</H4><!--SEC END --><P><A NAME="sss:f03:strings"></A>
<A NAME="@default1258"></A><A NAME="@default1259"></A>
<A NAME="@default1260"></A><A NAME="@default1261"></A></P><P>The SIDL string type mapping is currently identical to that of the
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> mapping. That is, all Fortran 2003/2008 strings have
a limited fixed size<A NAME="@default1262"></A>.
When implementing a subroutine with an <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameter, the size
of the string is restricted to 512 characters.</P><P><EM><B>NOTE</B>:
Modification of the value of 
<TT>SIDL_F03_STR_MINSIZE</TT> in
<TT>runtime/sidl/babel_config.h</TT> prior to configuring Babel
can be used to change the string size limitation.
</EM></P><!--TOC subsubsection Pointers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Pointers</H4><!--SEC END --><P><A NAME="sss:f03:pointers"></A>
<A NAME="@default1263"></A><A NAME="@default1264"></A>
<A NAME="@default1265"></A><A NAME="@default1266"></A></P><P>Pointer types are: opaque, interface, class, and array. All pointer
types are mapped to <TT>type(c_ptr)</TT>. The convenience functions
<TT>set_null</TT> and <TT>is_null</TT> are generated to perform
assignments and checks for unassociated pointers.</P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:f03:enum"></A>
<A NAME="@default1267"></A><A NAME="@default1268"></A>
<A NAME="@default1269"></A><A NAME="@default1270"></A></P><P>SIDL enumerations map to integer values, which are defined in a module.
Given the specification from Section <A HREF="#ssec:basics:fundamental:enums">6.3</A> 
for an enumeration type called <FONT COLOR=maroon><I><TT>car</TT></I></FONT>, Babel will produce the following 
enumerated type:
<A NAME="@default1271"></A><A NAME="@default1272"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>! File:          enums_car_type.F03
! Symbol:        enums.car-v1.0
! Symbol Type:   enumeration
! Babel Version: 2.0.0 (Revision: 7140  trunk)
! Description:   Client-side module for enums.car
! 
! WARNING: Automatically generated; changes will be lost
! </I></FONT>

#<B>include</B> "enums_car_fAbbrev.h"

<FONT COLOR="blue"><I>! 
! This file contains a FORTRAN 2003 derived type for the
! sidl type enums.car.
! </I></FONT>

<B>module</B> enums_car
  <B>use</B> sidl
  <B>use</B>, intrinsic :: iso_c_binding

  integer (<B>kind</B>=sidl_enum), parameter :: porsche = 911
  integer (<B>kind</B>=sidl_enum), parameter :: ford = 150
  integer (<B>kind</B>=sidl_enum), parameter :: mercedes = 550

end <B>module</B> enums_car</TD></TR>
</TABLE><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:f03:arrays"></A>
<A NAME="@default1273"></A><A NAME="@default1274"></A>
<A NAME="@default1275"></A><A NAME="@default1276"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Normal SIDL arrays can be used by any supported
language; whereas, r-arrays are restricted to numeric types and use in
languages such as C, C++, and Fortran. This subsection starts with a 
discussion normal and generic arrays before proceeding with an example
of the interfaces for r-arrays. </P><P>The normal SIDL array API is available in a module for creating,
destroying, and accessing array elements and meta-data for normal
arrays. More information on the API can be found in
Subsection <A HREF="#ss:basics:array:api">6.4</A>. For
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>, the array module — called
<TT>sidl_SIDLException_array</TT> — is defined in
<TT>sidl_SIDLException_array.F03</TT>. The
derived type for a SIDL array is named after the class, interface, or
basic type that it holds and the dimension of the array. For
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>, the array derived types are named
<TT>sidl_SIDLException_1d</TT>,
<TT>sidl_SIDLException_2d</TT>,
<TT>sidl_SIDLException_3d</TT>, … up to
<TT>sidl_SIDLException_7d</TT>. For basic types,
they are treated as <FONT COLOR=maroon><I><TT>sidl.dcomplex</TT></I></FONT>,
<FONT COLOR=maroon><I><TT>sidl.double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>sidl.fcomplex</TT></I></FONT>, etc. Each
of these derived types has a 64-bit integer to hold an opaque pointer.</P><P><EM><B>NOTE</B>: Normal Fortran 2003/2008 arrays or normal SIDL
arrays can be used when calling a Fortran 2003/2008 method, but they
cannot be mixed. 
</EM></P><P>Derived types for SIDL types <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, and <FONT COLOR=maroon><I><TT>long</TT></I></FONT> have pointers to arrays of the 
appropriate type and dimension that facilitate direct access to array elements. 
For example, the derived type for 2d and 3d arrays of <FONT COLOR=maroon><I><TT>double</TT></I></FONT>s is:
<A NAME="@default1277"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>module</B> sidl_double_array
  <B>use</B> sidl
  <B>use</B> sidl_array_type
  <B>use</B>, intrinsic :: iso_c_binding

  type sidl_double_1d
    type(c_ptr) :: d_array = c_null_ptr
    real (<B>kind</B>=sidl_double), <B>pointer</B>, &amp;
      dimension(:) :: d_data
  end type sidl_double_1d

  type sidl_double_2d
    type(c_ptr) :: d_array = c_null_ptr
    real (<B>kind</B>=sidl_double), <B>pointer</B>, &amp;
      dimension(:,:) :: d_data
  end type sidl_double_2d</TD></TR>
</TABLE><P>For the other types, the array API must be used to access elements.
In this case, the array can be accessed with the <TT>bind(C)</TT> array pointer 
<TT>d_data</TT> just like any other Fortran array. However, 
the Fortran 2003/2008 built-in methods <TT>allocate</TT><A NAME="@default1278"></A> or 
<TT>deallocate</TT><A NAME="@default1279"></A> on <TT>d_data</TT> <EM>must not</EM> 
be used. Instead, SIDL functions, <TT>createCol</TT><A NAME="@default1280"></A>, 
<TT>createRow</TT><A NAME="@default1281"></A>, <TT>create1d</TT><A NAME="@default1282"></A>, 
<TT>create2dRow</TT><A NAME="@default1283"></A>, or 
<TT>create2dCol</TT><A NAME="@default1284"></A>, must be used to create a
new array. These SIDL routines initialize <TT>d_data</TT> to refer to
the data allocated in <TT>d_array</TT>. </P><P><EM><B>NOTE</B>:
<TT>create1d</TT>,
<TT>create2dRow</TT>, and <TT>create2dCol</TT> create arrays whose lower
index is </EM>0<EM> not 1. To create arrays with a lower index of 1, 
<TT>createCol</TT> or <TT>createRow</TT> must be used.
</EM></P><P>Software packages like LINPACK or BLAS can be called, but the stride 
should be checked to make sure the array is suitably packed. Using
<TT>stride(i)</TT><A NAME="@default1285"></A> will provide the distance between elements in 
dimension <TT>i</TT>. 
A value of 1 means elements are packed densely.
Negative stride values are possible and, when an array is sliced, the
resulting array might not even have one densely packed dimension.</P><P>As discussed in Section <A HREF="#sss:basics:genericarrays">6.4</A>, the type of a generic 
array<A NAME="@default1286"></A><A NAME="@default1287"></A> is not specified.
As a result, Fortran 2003/2008 represents generic arrays as the derived type
<TT>sidl__array</TT> as defined in the 
<TT>sidl_array_type</TT> module.
(Note the use of a two underscore separator.) The following subroutines,
defined in the <TT>sidl_array_array</TT> module, apply to 
generic arrays:
<TT>addRef</TT><A NAME="@default1288"></A>, 
<TT>deleteRef</TT><A NAME="@default1289"></A>, 
<TT>dimen</TT>, <TT>type</TT>,
<TT>isColumnOrder</TT><A NAME="@default1290"></A>, 
<TT>isRowOrder</TT><A NAME="@default1291"></A>,
<TT>is_null</TT><A NAME="@default1292"></A>, 
<TT>no_null</TT><A NAME="@default1293"></A>, 
<TT>set_null</TT><A NAME="@default1294"></A>, 
<TT>lower</TT><A NAME="@default1295"></A>, 
<TT>upper</TT><A NAME="@default1296"></A>, 
<TT>length</TT><A NAME="@default1297"></A>, 
<TT>stride</TT><A NAME="@default1298"></A>, and 
<TT>smartCopy</TT><A NAME="@default1299"></A>. </P><P>Finally, SIDL r-arrays<A NAME="@default1300"></A><A NAME="@default1301"></A> are
passed to and from methods as normal Fortran 2003/2008 <TT>bind(C)</TT>
arrays. Index variables do not need to be included because the values
are determined from the Fortran 2003/2008 array extents in each
dimension. For example, the client-side interface for <TT>solve</TT>
— introduced in Section <A HREF="#ss:r-arrays">6.4</A> — behaves as if it is a
Fortran 2003/2008 function with the following overloaded interface:
<A NAME="@default1302"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>private</B> :: solve_1s, solve_2s
  <B>interface</B> solve
    <B>module</B> procedure solve_1s, solve_2s
  end <B>interface

  recursive</B> subroutine solve_1s(self, A, x, exception)
    implicit <B>none</B>
    <FONT COLOR="blue"><I>! in num.Linsol self</I></FONT>
    type(num_Linsol_t) , <B>intent</B>(<B>in</B>) :: self
    <FONT COLOR="blue"><I>! in array&lt;double,2,column-major&gt; A</I></FONT>
    type(sidl_double_2d) , <B>intent</B>(<B>in</B>) :: A
    <FONT COLOR="blue"><I>! inout array&lt;double,column-major&gt; x</I></FONT>
    type(sidl_double_1d) , <B>intent</B>(<B>inout</B>) :: x
    <FONT COLOR="blue"><I>! out sidl.BaseInterface exception</I></FONT>
    type(sidl_BaseInterface_t) , <B>intent</B>(<B>out</B>) :: exception
  end subroutine solve_1s

  <B>recursive</B> subroutine solve_2s(self, A, x, exception)
    implicit <B>none</B>
    <FONT COLOR="blue"><I>! in num.Linsol self</I></FONT>
    type(num_Linsol_t) , <B>intent</B>(<B>in</B>) :: self
    <FONT COLOR="blue"><I>! in rarray&lt;double,2&gt; A(m,n)</I></FONT>
    real (<B>kind</B>=sidl_double) , <B>intent</B>(<B>in</B>), dimension(:, :) :: A
    <FONT COLOR="blue"><I>! inout rarray&lt;double&gt; x(n)</I></FONT>
    real (<B>kind</B>=sidl_double) , <B>intent</B>(<B>inout</B>), dimension(:) :: x
    <FONT COLOR="blue"><I>! out sidl.BaseInterface exception</I></FONT>
    type(sidl_BaseInterface_t) , <B>intent</B>(<B>out</B>) :: exception
    <FONT COLOR="blue"><I>! in int m</I></FONT>
    integer (<B>kind</B>=sidl_int) :: m
    <FONT COLOR="blue"><I>! in int n</I></FONT>
    integer (<B>kind</B>=sidl_int) :: n
  end subroutine solve_2s</TD></TR>
</TABLE><P>The server-side interface, shown below, is similar. 
<A NAME="@default1303"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine num_Linsol_solve_mi(self, A, x, m, n, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> num_Linsol
  <B>use</B> sidl_double_array
  <B>use</B> num_Linsol_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(num.Linsol.solve.use)
  ! Insert-Code-Here {num.Linsol.solve.use} (use statements)
  ! DO-NOT-DELETE splicer.end(num.Linsol.solve.use)</I></FONT>
  implicit <B>none</B>
  type(num_Linsol_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: m <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: n <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out</I></FONT>
  real (<B>kind</B>=sidl_double), dimension(0:m-1, 0:n-1) :: A <FONT COLOR="blue"><I>! in</I></FONT>
  real (<B>kind</B>=sidl_double), dimension(0:n-1) :: x <FONT COLOR="blue"><I>! inout

! DO-NOT-DELETE splicer.begin(num.Linsol.solve)
! Insert-Code-Here {num.Linsol.solve} (solve method)
! DO-NOT-DELETE splicer.end(num.Linsol.solve)</I></FONT>
end subroutine num_Linsol_solve_mi</TD></TR>
</TABLE><P><EM><B>NOTE</B>:
The lower
index of each dimension of every incoming array is <B>always</B> zero.
</EM></P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.2.5  Type casting</H3><!--SEC END --><P><A NAME="ss:f03:casting"></A>
<A NAME="@default1304"></A><A NAME="@default1305"></A>
<A NAME="@default1306"></A></P><P>Babel automatically generates the
<TT>cast()</TT><A NAME="@default1307"></A> method for casting between
different interface and class types. Actually, a set of overloaded
methods support every allowable cast between a type and all its parent
types (both objects and interfaces). The first argument is the object
(or interface) to be cast, and the second is a variable of the desired
type. The cast is successful if, after the call to <TT>cast()</TT>, the
value of the second argument is
<TT>not_null</TT><A NAME="@default1308"></A>. The caller then owns (and
is responsible for) the returned reference. Examples of type casting
can be found in Subsections <A HREF="#ss:f03:exceptioncatching">12.3.5</A>
and <A HREF="#ss:f03:exceptionthrowing">12.4.4</A>.</P><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc56">12.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:f03:client"></A>
<A NAME="@default1309"></A></P><P>This section summarizes aspects of generating and using the
Fortran 2003/2008 bindings associated with software wrapped with
Babel’s language interoperability middleware. The bindings generation
process is presented first. Object management and invocation of
static and overloaded methods are also summarized. The process of
catching exceptions is then discussed. Finally, the processes for
enabling and disabling implementation-specific pre- and post-method
instrumentation — referred to as “hooks” — are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.1  Bindings generation</H3><!--SEC END --><P>
<A NAME="@default1310"></A>
<A NAME="@default1311"></A><A NAME="@default1312"></A></P><P>The following is an example of invoking Babel to create the
Fortran 2003/2008 stubs for a SIDL file<SUP><A NAME="text19" HREF="#note19">2</A></SUP>: <A NAME="@default1313"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=f03 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -c=f03 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>As a result, a <TT>Makefile</TT> fragment called <TT>babel.make</TT>,
numerous C header and source files, and some Fortran 2003/2008 files
will be created. Files ending in <TT>_fStub.c</TT> (i. e.,
<TT>STUBSRCS</TT> in <TT>babel.make</TT>) are called by the
Fortran 2003/2008 module which in turn allow Fortran 2003/2008 to call
SIDL methods. Files ending in <TT>[_type].F03</TT> (i. e.,
<TT>STUBMODULESRCS</TT> in <TT>babel.make</TT>) contain derived type
definitions for classes and interfaces. The remaining files ending in
<TT>.F03</TT> (i. e., <TT>TYPEMODULESRCS</TT> in <TT>babel.make</TT>) are
Fortran 2003/2008 modules containing methods. All of these files need
to be compiled and linked into the application.</P><P>Normally, IOR files (i. e., those ending in <TT>_IOR.c</TT>) are
linked together with the implementation file, so they probably don’t
need to be compiled.</P><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.2  Object management</H3><!--SEC END --><P>
<A NAME="@default1314"></A>
<A NAME="@default1315"></A></P><P>SIDL-specified objects are managed through explicit creation and
reference counting<A NAME="@default1316"></A>. Babel automatically generates
a <TT>new()</TT><A NAME="@default1317"></A> method for concrete classes.
The method is used to instantiate the class and return the associated reference.
The following example illustrates the instantiation and casting of an object
to an interface:
<A NAME="@default1318"></A><A NAME="@default1319"></A>
<A NAME="@default1320"></A><A NAME="@default1321"></A>
<A NAME="@default1322"></A><A NAME="@default1323"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_BaseClass
  <B>use</B> sidl_BaseInterface
  type(sidl_BaseClass_t)     :: object
  type(sidl_BaseInterface_t) :: <B>interface</B>
  type(sidl_BaseInterface_t) :: exception
  <FONT COLOR="blue"><I>! perhaps other code here</I></FONT>
  call new(object, exception)
  call cast(object, <B>interface</B>, exception)</TD></TR>
</TABLE><P>The owner of the instance is responsible for its proper disposal. In
other words, when processing with the object is done, the owner must
invoke <TT>deleteRef()</TT><A NAME="@default1324"></A> on it. Similarly, any
object references returned by a subroutine call must be deleted or
given to another part of the code that will take ownership of and,
therefore, responsibility for <TT>deleteRef</TT>’ing it. The following
example illustrates calling <TT>deleteRef()</TT> using the
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> method: <A NAME="@default1325"></A>
<A NAME="@default1326"></A><A NAME="@default1327"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_BaseInterface
  type(sidl_BaseInterface_t) :: interface1, interface2
  type(sidl_BaseInterface_t) :: exception
  logical                    :: areSame
  <FONT COLOR="blue"><I>!
  ! code to initialize interface1 &amp; interface 2 here
  !</I></FONT>
  call deleteRef(interface1, exception)</TD></TR>
</TABLE><P>When it is necessary to determine if two references point to the same object,
the built-in <TT>isSame</TT> method can be used. For example, the following
attempts to determine if <TT>interface1</TT> and <TT>interface2</TT> point to
the same object:
<A NAME="@default1328"></A><A NAME="@default1329"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_BaseInterface
  <FONT COLOR="blue"><I>! later in the code</I></FONT>
  call isSame(interface1, interface2, areSame, exception)
  <FONT COLOR="blue"><I>! areSame holds the return value</I></FONT></TD></TR>
</TABLE><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.3  Static methods</H3><!--SEC END --><P>
<A NAME="@default1330"></A></P><P>Below is an example illustrating a call to <TT>addSearchPath()</TT>, which
is a static method in the <FONT COLOR=maroon><I><TT>sidl.Loader</TT></I></FONT> class.
<A NAME="@default1331"></A>
<A NAME="@default1332"></A>
<A NAME="@default1333"></A><A NAME="@default1334"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl_Loader
  <B>use</B> sidl_BaseInterface
  type(sidl_BaseInterface_t) :: exception
  <FONT COLOR="blue"><I>! later</I></FONT>
  call addSearchPath('/try/looking/here', exception)</TD></TR>
</TABLE><P>Note the function is invoked directly, without an object reference
argument.</P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.4  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default1335"></A>
<A NAME="@default1336"></A></P><P>Examples of calls to SIDL overloaded methods are based on the 
<TT>overload_sample.sidl</TT> file shown in Section <A HREF="#sec:overloading">6.7</A>. 
Recall that the file describes three versions of the <TT>getValue</TT> method. 
The first takes no arguments, the second takes an integer argument, and the 
third takes a boolean. Each is called in the following code snippet:
<A NAME="@default1337"></A>
<A NAME="@default1338"></A><A NAME="@default1339"></A>
<A NAME="@default1340"></A><A NAME="@default1341"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> Overload_Sample
  type(Overload_Sample_t)         :: t
  type(sidl_BaseInterface_t)      :: exception
  logical                         :: b1, bretval
  integer (<B>kind</B>=sidl_int)  :: i1, iretval

  call new(t, exception)

  call getValue (t, iretval, exception)
  call getValueInt (t, i1, iretval, exception)
  call getValueBool (t, b1, bretval, exception)</TD></TR>
</TABLE><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.5  Exception catching</H3><!--SEC END --><P><A NAME="ss:f03:exceptioncatching"></A>
<A NAME="@default1342"></A><A NAME="@default1343"></A>
<A NAME="@default1344"></A></P><P>Since all methods can now throw <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT>
<A NAME="@default1345"></A>, Babel ensures there is
an <FONT COLOR=maroon><I><TT>out</TT></I></FONT> argument to hold an exception. If not explicitly
specified, Babel will automatically add the argument. For maximum
backward compatibility, the exception argument type is
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>, while the base exception class is
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>. The exception argument, which
behaves like an <TT>out</TT> parameter, will appear after the return
value (if both occur in a method). After the call, the client should
test this argument using <TT>is_null</TT><A NAME="@default1346"></A> or
<TT>not_null</TT>. If it is
<TT>not_null</TT><A NAME="@default1347"></A><TT>_null</TT>, an exception was
thrown by the method so the caller should respond appropriately. When
an exception is thrown, the values of all other arguments are
undefined. So the best course of action is to ignore them. If the
code does not check the exception argument after each call (that can
throw one), any exceptions that are thrown will be utterly ignored as
a result of not being automatically propagated to higher level
routines.</P><P>It is possible to determine which exception was thrown through
casting the argument. A successful cast indicates the type of exception
that occurred. An example of this process is illustrated below.
Package <TT>ExceptionTest</TT> has a class named <TT>Fib</TT> with a 
<TT>getFib</TT> method declared in SIDL as follows: 
<A NAME="@default1348"></A>
<A NAME="@default1349"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>int</B> getFib(<B>in int</B> n, <B>in int</B> max_depth, <B>in int</B> max_value, <B>in int</B> depth)
    <B>throws</B> NegativeValueException, FibException;</I></FONT></TD></TR>
</TABLE><P>The code to catch specified exception types is:
<A NAME="@default1350"></A><A NAME="@default1351"></A>
<A NAME="@default1352"></A><A NAME="@default1353"></A>
<A NAME="@default1354"></A><A NAME="@default1355"></A>
<A NAME="@default1356"></A><A NAME="@default1357"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> ExceptionTest_Fib
  <B>use</B> ExceptionTest_FibException
  <B>use</B> ExceptionTest_NegativeValueException
  <B>use</B> sidl_BaseInterface
  type(ExceptionTest_Fib_t)                    :: fib
  type(sidl_BaseInterface_t)                   :: except, except2
  type(ExceptionTest_FibException_t)           :: fibexcept
  type(ExceptionTest_NegativeValueException_t) :: nvexcept
  integer (<B>kind</B>=sidl_int)  :: index, maxdepth, maxval, depth, <B>result</B>
  call new(fib, except)

  index    = 4
  maxdepth = 100
  maxvalue = 32000
  depth    = 0
  <B>result</B> = getFib(fib, index, maxdepth, maxvalue, depth, except)
  if (not_null(except)) then
    call cast(except, fibexcept, except2)
    if (not_null(fibexcept)) then
<FONT COLOR="blue"><I>!      do something here with the FibException</I></FONT>
       call deleteRef(fibexcept, except2)
    else
      call cast(except, nvexcept, except2)
<FONT COLOR="blue"><I>!     do something here with the NegativeValueException</I></FONT>
      call deleteRef(nvexcept, except2)
    <B>endif</B>
    call deleteRef(except, except2)
  else
    write (*,*) 'getFib for ', index, ' returned ', <B>result
  endif</B>
  call deleteRef(fib, except2)</TD></TR>
</TABLE><P><EM><B>NOTE</B>:
Any caller of a method that returns an exception should ignore
the values of <TT>out</TT> and <TT>inout</TT> parameters. Anything not
freed becomes a reference and memory leak. 
</EM></P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.6  Hooks execution</H3><!--SEC END --><P><A NAME="ss:f03:sethooks"></A>
<A NAME="@default1358"></A><A NAME="@default1359"></A>
<A NAME="@default1360"></A><A NAME="@default1361"></A>
<A NAME="@default1362"></A><A NAME="@default1363"></A></P><P>If a given component supports pre- and post-method invocation
instrumentation, also known as “hooks”, their execution can be
enabled or disabled at runtime through the built-in
<TT>set_hooks</TT> method. For example, given the following
SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class. Due to unresolved method overloading problems,
the processes for enabling and disabling execution of the
implementation-specific hooks are currently dependent on use of
fully-qualified functions, as illustrated below.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> hooks_Basics
  type(hooks_Basics_t)         :: obj
  type(sidl_BaseInterface_t)   :: exception

  call new(obj, exception)

  <FONT COLOR="blue"><I>!
  ! Enable hooks execution (enabled by default)
  ! ...for static methods
  !    (until method overloading issue can be resolved)...
  !</I></FONT>
  call hooks_Basics__set_hooks_static_m(1, exception)
  <FONT COLOR="blue"><I>!
  ! ...for non-static methods
  !    (until method overloading issue can be resolved)...
  !</I></FONT>
  call hooks_Basics__set_hooks_m(obj, 1, exception)

  <FONT COLOR="blue"><I>!
  ! ...do something important...
  !

  !
  ! Disable hooks execution
  ! ...for static methods
  !</I></FONT>
  call hooks_Basics__set_hooks_static_m(0, exception)
  <FONT COLOR="blue"><I>!
  ! ...for non-static methods
  !</I></FONT>
  call hooks_Basics__set_hooks_m(obj, 0, exception)

  <FONT COLOR="blue"><I>!
  ! ...do something important...
  !</I></FONT></TD></TR>
</TABLE><P>It is important to keep in mind that the 
<TT>set_hooks_static</TT>
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>set_hooks</TT> method must be used for 
those of non-static methods. Also, Babel does not provide client 
access to the <TT>_pre</TT> and <TT>_post</TT> methods; therefore, they 
cannot be invoked directly. More information on the instrumentation 
process is provided in Subsection <A HREF="#ss:f03:hooksimpl">12.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.3.7  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:f03:contract_enforcement"></A>
<A NAME="@default1364"></A>
<A NAME="@default1365"></A>
<A NAME="@default1366"></A></P><P>Interface contracts specify the expected behaviors of clients and
servers of interface and class methods. Once specified, contracts can
automatically be enforced at runtime. This section provides an
example of a specification and associated code snippets for performing
basic, traditional contract enforcement — introduced in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — within a
Fortran 2003/2008 client.</P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below. (Refer to
Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.) According to the preconditions, <A NAME="@default1367"></A> <A NAME="@default1368"></A> <A NAME="@default1369"></A> all callers are expected to provide two one-dimensional, SIDL arrays
of the same size as arguments. The postconditions <A NAME="@default1370"></A> <A NAME="@default1371"></A> <A NAME="@default1372"></A> specify that all implementations are expected to return a non-null,
one-dimensional array of the same size (as the first SIDL array),
assuming the preconditions are satisfied.</P><P><A NAME="@default1373"></A>
<A NAME="@default1374"></A>
<A NAME="@default1375"></A>
<A NAME="@default1376"></A>
<A NAME="@default1377"></A>
<A NAME="@default1378"></A>
<A NAME="@default1379"></A>
<A NAME="@default1380"></A>
<A NAME="@default1381"></A>
<A NAME="@default1382"></A>
<A NAME="@default1383"></A>
<A NAME="@default1384"></A>
<A NAME="@default1385"></A>
<A NAME="@default1386"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a Fortran 2003/2008 client calling the method is given below. 
The code snippet illustrates declaring and creating the arrays; enabling 
full contract enforcement (i. e., checking all contract clauses); 
executing <TT>vuSum</TT>; handling contract violation exceptions; 
and cleaning up references is given below.</P><P><A NAME="@default1387"></A>
<A NAME="@default1388"></A>
<A NAME="@default1389"></A>
<A NAME="@default1390"></A>
<A NAME="@default1391"></A>
<A NAME="@default1392"></A>
<A NAME="@default1393"></A>
<A NAME="@default1394"></A>
<A NAME="@default1395"></A>
<A NAME="@default1396"></A>
<A NAME="@default1397"></A>
<A NAME="@default1398"></A>
<A NAME="@default1399"></A>
<A NAME="@default1400"></A>
<A NAME="@default1401"></A>
<A NAME="@default1402"></A>
<A NAME="@default1403"></A>
<A NAME="@default1404"></A>
<A NAME="@default1405"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> sidl_ContractClass
  <B>use</B> sidl_double_array
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_EnfPolicy
  <B>use</B> vect_Utils
  implicit <B>none</B>

<FONT COLOR="blue"><I>!     ...</I></FONT>

  type (sidl_BaseInterface_t) :: exc, tae
  type (sidl_double_1d) :: u, v, x

  u = createDouble(MAX_SIZE)
  v = createDouble(MAX_SIZE)

<FONT COLOR="blue"><I>!     Initialize u and v.

!     Enable FULL contract enforcement.</I></FONT>
  call sidl_EnfPolicy_setEnforceAll_m(ALLCLASSES, .true., exc)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!    Handle the exception</I></FONT>
  <B>endif</B>

<FONT COLOR="blue"><I>!     Do something meaningful before executing the method.</I></FONT>

  x = vect_Utils_vuSum_m(u, v, exc)
  if (is_null(exc)) then
<FONT COLOR="blue"><I>!    Do something meaningful with the result, x.</I></FONT>
  else
<FONT COLOR="blue"><I>!    Handle the exception</I></FONT>
  <B>endif</B>

<FONT COLOR="blue"><I>!     ...</I></FONT>

  call deleteRef(u)
  call deleteRef(v)
  if (.not. is_null(x)) then
     call deleteRef(x)
  <B>endif</B></TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the Fortran 2003/2008 calls associated with the 
traditional options of enabling only precondition enforcement, enabling 
postcondition enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default1406"></A>
<A NAME="@default1407"></A>
<A NAME="@default1408"></A>
<A NAME="@default1409"></A>
<A NAME="@default1410"></A>
<A NAME="@default1411"></A>
<A NAME="@default1412"></A>
<A NAME="@default1413"></A>
<A NAME="@default1414"></A>
<A NAME="@default1415"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>use</B> sidl
  <B>use</B> sidl_ContractClass
  <B>use</B> sidl_double_array
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_EnfPolicy
  <B>use</B> vect_Utils
  implicit <B>none</B>

<FONT COLOR="blue"><I>!     ...

!
!     Enable only precondition contract enforcement.
!     (Useful when only need to ensure callers comply with contract.)
!</I></FONT>
  call sidl_EnfPolicy_setEnforceAll_m(PRECONDS, .false., exception)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!       Handle the exception</I></FONT>
  <B>endif</B>


<FONT COLOR="blue"><I>!
!     Enable only postcondition contract enforcement.
!     (Useful when only need to ensure implementation(s) comply with contract.)
!</I></FONT>
  call sidl_EnfPolicy_setEnforceAll_m(POSTCONDS, .false., exception)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!       Handle the exception</I></FONT>
  <B>endif</B>

<FONT COLOR="blue"><I>!
!     Disable contract enforcement.
!     (Should only be used when have confidence in caller AND implementation.)
!</I></FONT>
  call sidl_EnfPolicy_setEnforceNone_m(.false., exception)
  if (.not. is_null(exc)) then
<FONT COLOR="blue"><I>!       Handle the exception</I></FONT>
  <B>endif</B></TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a Fortran 2003/2008
client. Additional enforcement policy options and methods as well as
more information regarding the specification and enforcement of
contracts can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc57">12.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:f03:implementation"></A>
<A NAME="@default1416"></A></P><P>This section summarizes aspects of generating and wrapping software
written in Fortran 2003/2008. The bindings generation and basic
implementation processes are presented first. Since access to object
state requires special steps in Fortran 2003/2008, the process for
defining and managing that data is discussed. Throwing exceptions in
the implementation is then illustrated. Finally, the results of
generating implementations with pre- and post-method “hooks” are
shown.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:f03:implgen"></A>
<A NAME="@default1417"></A>
<A NAME="@default1418"></A><A NAME="@default1419"></A></P><P>Much of the information associated with generating client-side bindings is 
pertinent to implementing a SIDL class in Fortran 2003/2008. The mapping of SIDL 
types to language constructs was given in Table <A HREF="#tbl:f03:types">12.1</A>.
If the implementation calls other SIDL methods, client-side caller rules 
must be followed.</P><P>To create the implementation bindings for a set of SIDL classes in Fortran 2003/2008,
Babel is invoked as follows:
<A NAME="@default1420"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=f90 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -s=f90 file.sidl</B><BR>
</TT></BLOCKQUOTE><P>As a result, a makefile fragment called <TT>babel.make</TT>, numerous C
header and source files, and some Fortran 2003/2008 source files will
be created. The <TT>SUBROUTINE</TT> and <TT>END SUBROUTINE</TT>
statements are automatically generated and the types of arguments
declared. Implementation details must be added to the
Fortran 2003/2008 “Impl” files, whose names end with
<TT>_Impl.F90</TT> and <TT>_Mod.F90</TT>. More on this matter is
provided in Subsection <A HREF="#ss:f03:implfill">12.4.2</A>.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:f03:implfill"></A>
<A NAME="@default1421"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:f03:implgen">12.4.1</A>. Changes to these files must be made between
code splicer pairs to ensure their retention in subsequent invocations of
Babel. Below is an example of the 
standard, automatically generated code splicer pairs.
<A NAME="@default1422"></A><A NAME="@default1423"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(_miscellaneous_code_start)
! Insert-Code-Here {_miscellaneous_code_start} (extra code)
! DO-NOT-DELETE splicer.end(_miscellaneous_code_start)</I></FONT>

.
.
.

<B>recursive</B> subroutine Pkg_Class_name_mi(self, arg, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> Pkg_Class
  <B>use</B> Pkg_Class_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Pkg.Class.name.use)
  ! Insert-Code-Here {Pkg.Class.name.use} (use statements)
  ! DO-NOT-DELETE splicer.end(Pkg.Class.name.use)</I></FONT>
  implicit <B>none</B>
  type(Pkg_Class_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: arg <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(Pkg.Class.name)
! Insert-Code-Here {Pkg.Class.name} (name method)
! DO-NOT-DELETE splicer.end(Pkg.Class.name)</I></FONT>
end subroutine Pkg_Class_name_mi</TD></TR>
</TABLE><P>The comment “Insert-Code-Here” associated with the “miscellaneous
code start”’ splicer pair will need to be replaced with details such
as additional abbreviation file(s) and any local, or private,
subroutines. For the subroutine’s “use” splicer pair, the
“Insert-Code-Here {Pkg.Class.name.use} (use statements)” comment
must be replaced with any <TT>use</TT> statements needed by the
subroutine. Finally, the implementation between the subroutine body’s
splicer pairs must be added in place of the “Insert-Code-Here
{Pkg.Class.name} (name method)” comment.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.4.3  Private data</H3><!--SEC END --><P>
<A NAME="@default1424"></A>
<A NAME="@default1425"></A></P><P>Any variables declared in the implementation source file will, by
virtue of Babel’s encapsulation, be private. Special initialization
procedures can be added to the built-in <TT>_load()</TT> method, which
is guaranteed to be called exactly once per class to set global class
data — <EM>before</EM> any user-defined methods can even be invoked.</P><P>The SIDL IOR keeps a pointer for each object that is intended to hold
a pointer to the object’s internal data. Below is an excerpt from a
<TT>_Impl.F03</TT> file for an object whose state requires a single
integer value. <A NAME="@default1426"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  type, extends(sort_SimpleCounter_t) :: sort_SimpleCounter_impl_t
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter.private_data)
    ! insert code here (private data members)</I></FONT>
    integer(<B>kind</B>=sidl_int) :: count
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(sort.SimpleCounter.private_data)</I></FONT>
  end type sort_SimpleCounter_impl_t</TD></TR>
</TABLE><P>As illustrated in the constructor below, the basic process to initialize
private data involves allocating memory then setting the data pointer.
<A NAME="@default1427"></A>
<A NAME="@default1428"></A><A NAME="@default1429"></A>
<A NAME="@default1430"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  subroutine ctor_impl(self, exception)
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter._ctor.use)
    ! Insert use statements here...
    ! DO-NOT-DELETE splicer.end(sort.SimpleCounter._ctor.use)</I></FONT>
    implicit <B>none</B>
    type(sort_SimpleCounter_impl_t) :: self
    type(sidl_BaseInterface_t), <B>intent</B>(<B>out</B>) :: exception

    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(sort.SimpleCounter._ctor)</I></FONT>
    self%count = 0
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(sort.SimpleCounter._ctor)</I></FONT>
  end subroutine ctor_impl</TD></TR>
</TABLE><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.4.4  Exception throwing</H3><!--SEC END --><P><A NAME="ss:f03:exceptionthrowing"></A>
<A NAME="@default1431"></A>
<A NAME="@default1432"></A></P><P>Below is an example of an implementation subroutine that throws an
exception. The returned exception object pointer must be <TT>cast</TT>
into the exception <TT>out</TT> parameter. This example also utilizes
two methods, inherited from <FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT> and implemented 
in 
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT>, that aid client-side debugging. The first,
<TT>setNote</TT>, allows the developer to provide a useful error message.
The second, <TT>add</TT>, provides a multi-language traceback capability —
assuming each layer of the call stack invokes <TT>add</TT> before it propagates
the exception.
<A NAME="@default1433"></A>
<A NAME="@default1434"></A><A NAME="@default1435"></A>
<A NAME="@default1436"></A><A NAME="@default1437"></A>
<A NAME="@default1438"></A><A NAME="@default1439"></A>
<A NAME="@default1440"></A><A NAME="@default1441"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  function getFib_impl(self, n, max_depth, max_value, depth, exception)        &amp;
       <B>result</B>(retval)
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Exceptions.Fib.getFib.use)</I></FONT>
    <B>use</B> Exceptions_TooBigException
    <B>use</B> Exceptions_TooDeepException
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Exceptions.Fib.getFib.use)</I></FONT>
    implicit <B>none</B>
    type(Exceptions_Fib_impl_t) :: self
    integer (<B>kind</B>=sidl_int), <B>intent</B>(<B>in</B>) :: n
    integer (<B>kind</B>=sidl_int), <B>intent</B>(<B>in</B>) :: max_depth
    integer (<B>kind</B>=sidl_int), <B>intent</B>(<B>in</B>) :: max_value
    integer (<B>kind</B>=sidl_int), <B>intent</B>(<B>in</B>) :: depth
    type(sidl_BaseInterface_t), <B>intent</B>(<B>out</B>) :: exception
    <FONT COLOR="blue"><I>!  function result</I></FONT>
    integer (<B>kind</B>=sidl_int) :: retval

    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Exceptions.Fib.getFib)</I></FONT>
    type(Exceptions_NegativeValueException_t) :: negexc
    type(Exceptions_TooDeepException_t) :: deepexc
    type(Exceptions_TooBigException_t) :: toobigexc
    type(Exceptions_FibException_t) :: fibexc
    type(sidl_BaseInterface_t) :: throwaway
    character (<B>len</B>=*) myfilename
    parameter(myfilename='Exceptions_Fib_Impl.f')
    integer(<B>kind</B>=sidl_int) a, b
    retval = 0_sidl_int
    if (n .lt. 0_sidl_int) then
       call new(negexc, throwaway)
       if (not_null(negexc)) then
          call setNote(negexc, &amp;
               'called with negative n', throwaway)
          call add( &amp;
               negexc, myfilename, 57_sidl_int, 'Exceptions_Fib_getFib_impl',&amp;
               throwaway)
          call cast(negexc, exception,throwaway)
          call deleteRef(negexc,throwaway)
          return
       <B>endif</B>
    else if (depth .gt. max_depth) then
    <FONT COLOR="blue"><I>! ...numerous lines deleted....
    ! DO-NOT-DELETE splicer.end(Exceptions.Fib.getFib)</I></FONT>
  end function getFib_impl</TD></TR>
</TABLE><P>When an exception is thrown, the implementation should
<TT>deleteRef</TT> any references it was planning to return to its
caller. In general, when throwing an exception, it is
good practice to call <TT>set_null</TT> on all <TT>out</TT> and
<TT>inout</TT> array, class, and interface arguments before returning.
This makes things work out better for
clients who forget to check if an exception occurred or willfully
choose to ignore it.</P><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->12.4.5  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:f03:hooksimpl"></A>
<A NAME="@default1442"></A><A NAME="@default1443"></A>
<A NAME="@default1444"></A>
<A NAME="@default1445"></A><A NAME="@default1446"></A>
<A NAME="@default1447"></A><A NAME="@default1448"></A></P><P>As discussed in Subsection <A HREF="#ss:f03:sethooks">12.3.6</A>, when hooks execution
is enabled, implementation-specific instrumentation is executed.
Using the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results in
the automatic generation of a <TT>_pre</TT> and <TT>_post</TT> method
for every static and non-static method associated with each class in
the specification. For the <TT>aStaticMethod</TT> specified in
Subsection <A HREF="#ss:f03:sethooks">12.3.6</A>, the generated <TT>_pre</TT> method
implementation is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine hooks_Basics_aStaticMeth_pre_mi(i, io, exception)
  <B>use</B> sidl
  <B>use</B> sidl_NotImplementedException
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> hooks_Basics
  <B>use</B> hooks_Basics_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre.use)
  !   Insert implementation use details
  ! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre.use)</I></FONT>
  implicit <B>none</B>
  integer (<B>kind</B>=sidl_int) :: i <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: io <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre)
!
!   Add instrumentation here to be executed immediately prior
!   to dispatch to aStaticMeth().
!
! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre)</I></FONT>
end subroutine hooks_Basics_aStaticMeth_pre_mi</TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 2003/2008</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine B_aStaticMeth_postywgp49zzy2_mi(i, o, io, retval,         &amp;
  exception)
  <B>use</B> sidl
  <B>use</B> sidl_NotImplementedException
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> hooks_Basics
  <B>use</B> hooks_Basics_impl
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post.use)
  !   Insert implementation use details
  ! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post.use)</I></FONT>
  implicit <B>none</B>
  integer (<B>kind</B>=sidl_int) :: i <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: o <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: io <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: retval <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post)
!
!    Add instrumentation here to be executed immediately after
!    return from dispatch to aStaticMeth().
!</I></FONT>
  return
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post)</I></FONT>
end subroutine B_aStaticMeth_postywgp49zzy2_mi</TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation
should be added within the splicer blocks of
<TT>aStaticMethod_pre</TT> and
<TT>aStaticMethod_post</TT>. As stated in the comments within those blocks,
<TT>aStaticMethod_pre</TT> will be executed
immediately prior to dispatch to <TT>aStaticMethod</TT> when the latter
is invoked by a client. Assuming no exceptions are encountered,
<TT>aStaticMethod_post</TT> is executed immediately
upon return from <TT>aStaticMethod</TT>.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note18" HREF="#text18">1</A></DT><DD CLASS="dd-thefootnotes"><TT>configure</TT> tests for the features and not for
the version numbers, so future versions of other compilers may also
work.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note19" HREF="#text19">2</A></DT><DD CLASS="dd-thefootnotes">For information on
additional command line options, refer to
Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Java Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc58">Chapter 13</A>  Java Bindings</H1><!--SEC END --><P><A NAME="c:java"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc59">13.1</A>  Introduction</H2><!--SEC END --><P>This chapter provides an overview of the Java bindings for SIDL.
Common aspects of the bindings, such as the mapping of SIDL data types to
their Java counterparts, are presented in Section <A HREF="#s:java:basics">13.2</A>.
Issues of concern to callers written in Java are addressed in the
client-side discussion in Section <A HREF="#s:java:client">13.3</A>, while issues for callees
appear in the implementation-side discussion in
Section <A HREF="#s:java:implementation">13.4</A>.</P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc60">13.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:java:basics"></A></P><P>This section summarizes basic features that are common to both client and
implementation bindings.
Subsection <A HREF="#ss:java:namespace">13.2.1</A> describes conventions used to establish
name spaces, while those associated with the generation
of subroutines from methods are given in Subsection <A HREF="#ss:java:signatures">13.2.2</A>.
The mapping of fundamental and key SIDL types is given in
Subsection <A HREF="#ss:java:types">13.2.3</A>.
Finally, casting between different types is discussed in
Subsection <A HREF="#ss:java:casting">13.2.4</A>.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.2.1  Name space</H3><!--SEC END --><P><A NAME="ss:java:namespace"></A>
<A NAME="@default1449"></A>
<A NAME="@default1450"></A></P><P>SIDL’s object model is very similar to Java’s, and therefore maps
easily into it. A SIDL object is treated almost exactly the
same in Java as any other Java object, the only differences being that all data
held by the object is private and all methods are public. </P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.2.2  Method signatures</H3><!--SEC END --><P><A NAME="ss:java:signatures"></A>
<A NAME="@default1451"></A></P><P>Since the bindings map well into Java language constructs,
Java method signatures correspond very closely to those in the specification.
Adapted from the Babel regression tests, the following is an example 
specification of a package called <TT>ExceptionTest</TT> that has a class 
named <TT>Fib</TT> with a <TT>getFib</TT> method declared as:
<A NAME="@default1452"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>int</B> getFib(<B>in int</B> n, <B>in int</B> max_depth, <B>in int</B> max_value, <B>in int</B> depth)
  <B>throws</B> NegativeValueException, FibException;</I></FONT></TD></TR>
</TABLE><P>The corresponding client-side, or stub, signature is:
<A NAME="@default1453"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"> <B>public native int</B> getFib(
    <B>int</B> n,
    <B>int</B> max_depth,
    <B>int</B> max_value,
    <B>int</B> depth) <B>throws</B>
    ExceptionTest.FibException,
    ExceptionTest.NegativeValueException;</TD></TR>
</TABLE><P>Note the one-to-one mapping in arguments and native exception types.</P><P>The corresponding implementation-side signature is:
<A NAME="@default1454"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>public int</B> getFib_Impl (
    <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> n,
    <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> max_depth,
    <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> max_value,
    <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> depth )
    <B>throws</B> ExceptionTest.FibException,
    ExceptionTest.NegativeValueException,
    sidl.RuntimeException.Wrapper</TD></TR>
</TABLE><P>Once again, there is a one-to-one mapping of arguments and the two
specified exceptions. However, the implementation side includes
the (implicit) <TT>sidl.RuntimeException</TT>’s <TT>Wrapper</TT>
class (since <TT>RuntimeException</TT> is an interface. For more
on the reasoning behind this, refer to Subsection <A HREF="#sss:Java:ifcs">13.2.3</A>.</P><!--TOC subsubsection <TT><I><FONT COLOR=maroon>Out</FONT></I></TT> and <TT><I><FONT COLOR=maroon>inout</FONT></I></TT> arguments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><FONT COLOR=maroon><I><TT>Out</TT></I></FONT> and <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> arguments</H4><!--SEC END --><P>
<A NAME="@default1455"></A><A NAME="@default1456"></A><A NAME="@default1457"></A></P><P>Unlike languages such as C/C++, Java does not support pointers. As a 
result, <FONT COLOR=maroon><I><TT>out</TT></I></FONT> and <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> arguments are handled — for each
SIDL type and class — through a static inner <TT>Holder</TT> class. 
The class can hold a single variable or object of the correct type. 
Built-in functions <TT>get()</TT> and <TT>set()</TT> are provided for accessing
the data.</P><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.2.3  Data types</H3><!--SEC END --><P><A NAME="ss:java:types"></A>
<A NAME="@default1458"></A><A NAME="@default1459"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 13.1: SIDL to Java Type Mappings</TD></TR>
</TABLE></DIV><A NAME="tbl:java:types"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B>JAVA TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>int</TT> 		<A NAME="@default1460"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>long</TT>		<A NAME="@default1461"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>float</TT>	<A NAME="@default1462"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>double</TT>	<A NAME="@default1463"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>boolean</TT>	<A NAME="@default1464"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>char</TT>		<A NAME="@default1465"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>String</TT>	<A NAME="@default1466"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>FloatComplex</TT>	<A NAME="@default1467"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>DoubleComplex</TT><A NAME="@default1468"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>Enum</TT>		<A NAME="@default1469"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>long</TT>		<A NAME="@default1470"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>interface</TT>	<A NAME="@default1471"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>class</TT>	<A NAME="@default1472"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>array</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>type.Array</TT>	<A NAME="@default1473"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Most SIDL types map directly into Java as shown in
Table <A HREF="#tbl:java:types">13.1</A><A NAME="@default1474"></A>.
The remainder of this subsection focuses specifically on interfaces,
abstract classes, exceptions (in general), enumerations, and arrays.</P><!--TOC subsubsection interfaces and Abstract Classes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->interfaces and Abstract Classes</H4><!--SEC END --><P><A NAME="sss:Java:ifcs"></A>
<A NAME="@default1475"></A><A NAME="@default1476"></A>
<A NAME="@default1477"></A><A NAME="@default1478"></A>
<A NAME="@default1479"></A><A NAME="@default1480"></A>
<A NAME="@default1481"></A><A NAME="@default1482"></A></P><P>As a result of the fact that Java interfaces cannot hold data, 
an additional layer was added to the Java bindings for internal 
processing needs within the implementation of the SIDL object 
model — such as throwing an (interface) exception.
For this reason, wrappers were created for interfaces and 
abstract classes. Called <TT>Wrapper</TT>, these classes hold the 
interface IOR pointer, inherit from <TT>gov.llnl.babel.BaseClass</TT>,
and implement the outer interface. Therefore, all interface 
and <TT>gov.llnl.babel.BaseClass</TT> methods — such as <TT>_cast2</TT> 
and <TT>isType</TT> — can be called on the wrapper object. In addition,
the wrapper object is returned when an interface is retrieved from
an array. The client is not usually affected in this case. The wrapper 
class is also used for methods that take or return interface arguments 
and when an exception implemented as an interface is caught. 
In the latter case, the developer must be sure to catch the wrapper class.
Examples appear later in this chapter.</P><!--TOC subsubsection Exceptions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exceptions</H4><!--SEC END --><P><A NAME="sss:java:exceptions"></A>
<A NAME="@default1483"></A><A NAME="@default1484"></A>
<A NAME="@default1485"></A><A NAME="@default1486"></A></P><P>Although SIDL exceptions may be specified as interfaces while Java
exceptions are always classes, SIDL exceptions are basically caught 
and thrown in the native Java manner. A critical difference,
as mentioned in the discussion on interface data types, is that 
a SIDL exception interface’s wrapper object must be thrown.
While similar from a developer standpoint in that SIDL exceptions 
are mapped to Java exceptions, the converse is not true. That is, 
there is no mapping of all Java exceptions to SIDL exceptions.</P><P>If an exception is defined in SIDL, Babel will generate
code for it. The only difference between native Java and SIDL
exceptions is that the SIDL exception constructor cannot take a <TT>String</TT>
argument. Instead, the message must be set with the inherited <TT>setNote</TT> 
method and retrieved with <TT>getNote</TT>. This
is important because SIDL exceptions inherit from the Java <TT>Exception</TT>
class. The Java compiler <EM>will not</EM> give an error if 
<TT>getMessage</TT><A NAME="@default1487"></A> is called; however, the 
message returned will not be from SIDL. </P><P><A NAME="@default1488"></A><A NAME="@default1489"></A>
Another problem is that regular Java exceptions cannot be passed through
the SIDL middleware. Since it is not possible to throw normal, non-SIDL
exceptions from a SIDL function implemented in Java, the Java compiler will 
throw an error if an attempt to do so is made. There are some exceptions.
For example, Java runtime exceptions such as
<TT>ArrayIndexOutOfBoundsException</TT> 
can be thrown. In this case, an
error message and stack trace are printed to <TT>stderr</TT>. In addition, 
the method returns <TT>0</TT>; values of any <FONT COLOR=maroon><I><TT>out</TT></I></FONT> or <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> arguments 
are set to <TT>NULL</TT>; and the program proceeds. </P><P>For more information on catching and throwing exceptions, including 
examples, refer to Subsections <A HREF="#ss:Java:exceptioncatching">13.3.7</A> 
and <A HREF="#ss:Java:exceptionthrowing">13.4.4</A>.</P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:java:enums"></A>
<A NAME="@default1490"></A><A NAME="@default1491"></A>
<A NAME="@default1492"></A><A NAME="@default1493"></A></P><P>Enumerations are implemented as <TT>final static int</TT>s in their own
Java class and, as such, are accessed just like variables in that
class. Recall the specification of a <FONT COLOR=maroon><I><TT>car</TT></I></FONT> enumeration 
type, from Section <A HREF="#ssec:basics:fundamental:enums">6.3</A> and repeated
below, defines three constants: <TT>porsche</TT>, <TT>ford</TT>, and
<TT>mercedes</TT>.
<A NAME="@default1494"></A><A NAME="@default1495"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  enum car {
    porsche = 911,
    ford = 150,
    mercedes = 550
  };</TD></TR>
</TABLE><P>The value of the <TT>porsche</TT> constant, for example, can be accessed through
<TT>enums.car.porsche</TT>.</P><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:java:arrays"></A>
<A NAME="@default1496"></A><A NAME="@default1497"></A>
<A NAME="@default1498"></A><A NAME="@default1499"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Normal SIDL arrays can be used by any supported
language; whereas, r-arrays are restricted to numeric types. This subsection
discusses both within the context of Java bindings.
<A NAME="@default1500"></A><A NAME="@default1501"></A></P><P>Every object and type defined in SIDL has a corresponding array to
hold elements of that type.
<A NAME="@default1502"></A>
In the case of Java bindings, this means the entire SIDL array API is available 
with a few exceptions that have no real use in the language. More specifically,
<TT>ensure()</TT><A NAME="@default1503"></A>, <TT>borrow()</TT><A NAME="@default1504"></A>, and 
<TT>first()</TT><A NAME="@default1505"></A> are not supported in the bindings.
Unlike with most of the other language bindings, explicit
array deletion should be done using the <TT>destroy()</TT> array function.
Refer to Subsection <A HREF="#ss:basics:array:api">6.4</A> for more information on the API.</P><P>More to the point are the specifics of the Java implementation — which
provides a wider variety of options for constructing arrays than other 
bindings. Each
SIDL type and class includes a static inner class named <TT>Array</TT>.
This is the main Array class and, in order to support up to 7
dimensional arrays, every method takes either 7 array indices or an
array of indices. For example, in order to get the element (2,3) from a 2
dimensional array, <TT>arry._get(2,3,0,0,0,0,0)</TT> would be used.
<A NAME="@default1506"></A>
Since typing all those zeros can get a little tedious, a set of 
array subclasses have also been implemented with one subclass per
supported dimension. So, given an <TT>Array2</TT> instead of an <TT>Array</TT>,
<TT>arry2._get(2,3)</TT> could be used to get the element (2,3) instead.</P><P>These numbered array subclasses improve on the array API usability
somewhat, but they do have a side effect. In order to avoid conflicts
between the array superclass and the numbered array subclass
functions, all other basic array methods found in the <TT>Array</TT> superclass
are preceded by an underscore ’_’<A NAME="@default1507"></A>. For example, 
<TT>arry._dim()</TT> returns an array’s dimensionality. Since numbered
arrays all inherit these methods, they can be used as well. In the 
dimensionality example, <TT>arry2._dim()</TT> could also be used — though
the answer should be obvious.</P><P>Furthermore, there is another underscore rule for arrays in Java. All
numbered arrays have two <TT>get</TT> and two <TT>set</TT> functions. The
<TT>_get</TT> and <TT>_set</TT> functions are the same in <TT>Array</TT> and all
the <TT>Array#</TT> subclasses in that they simply pass the arguments of the
<TT>_get</TT> call down to the underlying implementation. However, the 
underscore-less <TT>get</TT> and <TT>set</TT> methods do bounds checking in Java
before calling the underlying implementation. If a problem is detected, they
throw <TT>ArrayIndexOutOfBoundsException</TT>. </P><P>Because numbered arrays are subclasses of <TT>Array</TT>, an <TT>Array#</TT> 
can be Java cast to an <TT>Array</TT>, if necessary. However, some
functions return an <TT>Array</TT>. <A NAME="@default1508"></A>
In order to convert an <TT>Array</TT> to the correctly numbered array, a 
function in <TT>Array</TT>, called <TT>_dcast()</TT>, can be used by simply
invoking <TT>_dcast()</TT> on the object.
For example, given a one-dimensional array of type <TT>foo.bar</TT> called 
<TT>arry</TT> that is represented by the Java class <TT>Array</TT>, the
correctly numbered array type can be retrieved as follows:
<A NAME="@default1509"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo.bar.Array1 arry1 = arry._dcast();</TD></TR>
</TABLE><P>After this cast, two references are now available to the same array;
namely, <TT>arry</TT> and <TT>arry1</TT>.</P><P>Finally, the Java array constructors are slightly different than
in other languages. The constructor definition for <TT>Array</TT> is:
<A NAME="@default1510"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public</B> Array(<B>int</B> dim, <B>int</B>[] lower, <B>int</B>[] upper, <B>boolean</B> isRow)</TD></TR>
</TABLE><P>This constructor creates an array of dimension <TT>dim</TT>. It takes
two arrays of integers to define the lower and upper bounds of each
dimension in the array. If lower or upper has fewer elements than
there are dimensions in the array, or any element in lower is larger
than the corresponding element in upper, the constructor will throw
an exception. Finally, the constructor takes a boolean <TT>isRow</TT>.
If <TT>isRow</TT> is true, a SIDL array will be created in
row-major order; if false, a column-major order array will be created.</P><P>Constructors for numbered arrays are simpler. The constructor for a 
two-dimensional array is:
<A NAME="@default1511"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public</B> Array2( <B>int</B> l0, <B>int</B> l1, <B>int</B> u0, <B>int</B> u1, <B>boolean</B> isRow)</TD></TR>
</TABLE><P>Since the dimensionality is known, the dimension argument was dropped.
In addition, it is no longer necessary to create arrays of bounds to 
pass into the constructor; instead,
<TT>l0</TT> and <TT>l1</TT> are the lower bounds and <TT>u0</TT> and
<TT>u1</TT> the upper. The choice between column- and row-major orders
is obviously still necessary.</P><P>For arrays with all lower bounds of zero, an even simpler constructor
is available. Its signature is:
<A NAME="@default1512"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public</B> Array2( <B>int</B> s0, <B>int</B> s1, <B>boolean</B> isRow)</TD></TR>
</TABLE><P>Another alternate construction method for SIDL arrays is present in numbered
arrays. The following constructor takes a two-dimensional Java array,
and copies it into a 2-dimensional SIDL array:
<A NAME="@default1513"></A>
<A NAME="@default1514"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public</B> Array2(foo.bar[][] array, <B>boolean</B> isRow)</TD></TR>
</TABLE><P>Alternatively, arrays can be constructed as copies of existing arrays through
two additional built-in methods.
An existing numbered SIDL array of the correct dimension can be set to
the same contents of a Java array with the <TT>fromArray</TT> method.
The same arguments as the constructor above are used but nothing is returned.
Conversely, a SIDL array can be copied into a Java array through the
<TT>toArray</TT> numbered array function. The function takes no arguments 
but returns a new Java array containing copies of the SIDL array’s elements.</P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.2.4  Type casting</H3><!--SEC END --><P><A NAME="ss:java:casting"></A>
<A NAME="@default1515"></A><A NAME="@default1516"></A>
<A NAME="@default1517"></A></P><P>There are two issues associated with casting of types in the Java bindings.
The simplest is the casting of SIDL objects implemented in Java. The second
involves the casting of SIDL interfaces which, as discussed in 
Subsection <A HREF="#sss:Java:ifcs">13.2.3</A>, is a little more involved. This subsection 
describes the normal, object casting process before that of the Java 
equivalents of SIDL interfaces.</P><P>In some cases it is necessary to cast the internal representation of
an object as well as the Java object. (For example, getting an object
from a SIDL array of superclass objects.) In these cases a Java cast is
insufficient. Therefore two built-in casting functions have
been provided: <TT>_cast()</TT> and <TT>_cast2()</TT>. 
The static <TT>_cast(object)</TT><A NAME="@default1518"></A> function returns a new 
Java object based on the <TT>object</TT> argument. For example, 
<TT>foo.bar newobj = (foo.bar) foo.bar._cast(oldobj)</TT> will cast 
<TT>oldobj</TT>, an object of type <TT>sidl.BaseClass</TT>, to 
<TT>foo.bar</TT>. If this is an invalid cast, <TT>_cast</TT> will 
return <TT>null</TT>. 
<A NAME="@default1519"></A>
<A NAME="@default1520"></A></P><P>The <TT>_cast2(‘‘ClassName’’)</TT> method, on the other hand, casts an
object to a named type (i. e., <TT>ClassName</TT>). It performs
basically the same function as <TT>_cast</TT>, but the form is
<TT>object._cast2(‘‘ClassName’’)</TT>, where <TT>ClassName</TT> must be a 
fully qualified name<A NAME="@default1521"></A>. If the cast is invalid, or a class of 
that name cannot be found, <TT>null</TT> is returned.</P><P>Both functions
return a <TT>sidl.BaseClass</TT> which must then be Java casted to the
correct Java class type. They both also create a new Java object that 
owns a new reference to the IOR object. Although you never have to 
worry about reference counting in Java<A NAME="@default1522"></A>,
it is important to remember that casting leaves two valid objects.</P><P>As mentioned in Subsection <A HREF="#sss:Java:ifcs">13.2.3</A>, SIDL interfaces are mapped
to wrapper classes that inherit from an interface. As a result, they
can be Java cast to their ancestor interfaces but must be Babel cast to
any classes. In the following example, <TT>Subclass</TT> implements 
<TT>SuperInterface</TT>:
<A NAME="@default1523"></A>
<A NAME="@default1524"></A>
<A NAME="@default1525"></A><A NAME="@default1526"></A>
<A NAME="@default1527"></A><A NAME="@default1528"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">SuperInterface.Array1 arry = <B>new</B> SuperInterface.Array1(5, <B>true</B>);
SubClass obj = <B>new</B> SubClass();
arry.set(0, (SuperInterface)obj);
obj = <B>null</B>;
SuperInterface temp = arry.get(0);
obj = (SubClass) temp;   <FONT COLOR="blue"><I>//INCORRECT Will throw ClassCastException</I></FONT>

obj = (SubClass) SubClass._cast((SuperInterface.Wrapper)temp); <FONT COLOR="blue"><I>//CORRECT</I></FONT></TD></TR>
</TABLE><P>Finally, in some cases, as when the interface is retrieved from an array, Java 
casting the interface is not necessary before Babel casting it; however, 
that is not true in general.
The following is an example of casting an interface in a Java implementation:
<A NAME="@default1529"></A>
<A NAME="@default1530"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
<B>public</B> objarg.SubClass toClass_Impl (<FONT COLOR="blue"><I>/*in*/</I></FONT> objarg.Iface ifcy ) {
  <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(objarg.SubClass.toClass)</I></FONT>
  objarg.SubClass ret =  (objarg.SubClass)
    ((objarg.Iface.Wrapper)ifcy)._cast2("objarg.SubClass");
  <B>return</B> ret;
  <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(objarg.SubClass.toClass)</I></FONT>
}</TD></TR>
</TABLE><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc61">13.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:java:client"></A>
<A NAME="@default1531"></A></P><P>This section summarizes aspects of generating and using the Java bindings
associated with software wrapped with Babel’s language interoperability
middleware. The bindings generation process is presented before discussing
required environment variables. The manner in which SIDL-specified types
are imported into Java is then given.
Object management and invocation of static and 
overloaded methods are also summarized.
The process of catching exceptions is then discussed. 
Finally, the processes for enabling and disabling implementation-specific
pre- and post-method instrumentation — referred to as “hooks” —
are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:java:clientgen"></A>
<A NAME="@default1532"></A>
<A NAME="@default1533"></A><A NAME="@default1534"></A></P><P>Java stubs (i. e., code to support Java clients for a set of SIDL
classes or interfaces) are created by invoking Babel as follows<SUP><A NAME="text20" HREF="#note20">1</A></SUP>:
<A NAME="@default1535"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=Java file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -cJava file.sidl</B><BR>
</TT></BLOCKQUOTE><P>This will create a plethora of files, including a directory
named <TT>file</TT>, which contains the Java client classes. Files
ending in <TT>_IOR.h</TT> and <TT>_IOR.c</TT> implement the Intermediate Object
Representation (IOR). Files ending with <TT>_jniStub.c</TT> are the Java
Native Interface (JNI) stubs. The use of “jni” in the filename reflects 
the fact that the JNI is used to communicate between Java and the IOR.
The remaining header files include the external Java API used by Java clients.</P><P>The stub files — whose names end with <TT>_jniStub.c</TT> — must be
compiled and linked against the SIDL runtime library and an
implementation. The resulting library needs to
be referenced in a <TT>.scl</TT> file listed in the SIDL_DLL_PATH
environment variable so the Babel runtime library loader can find it. 
Also, the current directory needs to be in the CLASSPATH environment 
variable so Java can find the <TT>file</TT> and <TT>sidl</TT> directories 
containing the client-side Java components. More information on 
environmental settings is given in Subsection <A HREF="#ss:Java:env">13.3.2</A>.</P><!--TOC subsection Environment variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.2  Environment variables</H3><!--SEC END --><P><A NAME="ss:Java:env"></A>
<A NAME="@default1536"></A><A NAME="@default1537"></A>
<A NAME="@default1538"></A><A NAME="@default1539"></A></P><P>Four environment variables are associated with running Java bindings.
The first three, described below, identify path-related directories that
must be set properly for various tools. It is assumed Babel was already
installed in directories rooted at <TT>$PREFIX</TT>. The last variable is
used to pass options to the implementation-side.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>CLASSPATH</TT>.</B></DT><DD CLASS="dd-description"> 
Java uses the <TT>CLASSPATH</TT><A NAME="@default1540"></A> environment variable to 
find <TT>.class</TT> files. While not specific to Babel, this colon-separated 
list of directories must include at least three directories. The first
is the one containing the implementation-side <TT>.class</TT> files. The second
is the directory containing <TT>sidl_$VERSION.jar</TT>, where <TT>$VERSION</TT> 
is the version of your installed Babel, which is likely to be 
the SIDL jar file. The latter directory should be <TT>$PREFIX/lib</TT>.
Finally, <TT>CLASSPATH</TT> must include <TT>$PREFIX/runtime/java</TT>.</DD><DT CLASS="dt-description"><B><TT>LD_LIBRARY_PATH</TT> (or <TT>LIBPATH</TT> on AIX).</B></DT><DD CLASS="dd-description">
Many systems require <TT>LD_LIBRARY_PATH</TT><A NAME="@default1541"></A>
environment variable contain <TT>$PREFIX/lib</TT>. However, the
system-specific environment variable should be used. AIX, for example,
uses <TT>LIBPATH</TT>. The goal is to
include <TT>$PREFIX/lib</TT> in the search path used to locate shared/dynamic
link libraries.</DD><DT CLASS="dt-description"><B><TT>SIDL_DLL_PATH</TT>.</B></DT><DD CLASS="dd-description">
The <TT>SIDL_DLL_PATH</TT><A NAME="@default1542"></A> environment variable
is typically required to contain the path to the directory holding
the shared/dynamic link library containing the implementation of SIDL
objects. This is a semicolon-separated path variable.</DD><DT CLASS="dt-description"><B><TT>BABEL_JVM_FLAGS</TT>.</B></DT><DD CLASS="dd-description">
Consisting of a semicolon-separated list of command line options, 
<TT>BABEL_JVM_FLAGS</TT> passes them on to the implementation.
For instance, <TT>-Xcheck:jni</TT> can be useful since it results in the 
JVM validating parameters and environment data prior to JNI requests.
The following command illustrates additional useful options:<DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>shell</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">BABEL_JVM_FLAGS="-verbose:gc;-Xmx500m"</TD></TR>
</TABLE></DD></DL><P><EM><B>WARNING</B>:
Not including all the necessary files in the <TT>SIDL_DLL_PATH</TT> and 
<TT>LD_LIBRARY_PATH</TT></EM> can<EM> crash the JVM in unexpected ways. 
Babel tries to generate helpful error messages, but sometimes the JVM 
crashes due to missing files with the resulting output not being very helpful.
If the JVM crashes, <TT>SIDL_DLL_PATH</TT> and <TT>LD_LIBRARY_PATH</TT> 
should be checked to ensure they point to the necessary files.
</EM></P><!--TOC subsection Imports-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.3  Imports</H3><!--SEC END --><P>
<A NAME="@default1543"></A>
<A NAME="@default1544"></A></P><P>Importing SIDL packages and classes is also similar to the native Java
approach.
Babel generates Java code in subdirectories to organize packages and classes
in the same manner as done in Java. For example, assume the presence of a 
specification of a package called <TT>test</TT> that contains two classes: 
<TT>HelloWorld</TT> 
and <TT>GoodbyeWorld</TT>. Running <TT>babel -cJava test.sidl</TT> in the 
directory named <TT>babelcode</TT> will result in the generation of a new
subdirectory called <TT>test</TT> containing the following two files: 
<TT>HelloWorld.java</TT> and <TT>GoodbyeWorld.java</TT>. The resulting classes 
will be accessible from any Java program that imports them when 
<TT>babelcode</TT> is in the <TT>CLASSPATH</TT>. In this example, the 
import statement for the first class is:
<A NAME="@default1545"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> test.HelloWorld;</TD></TR>
</TABLE><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.4  Object management</H3><!--SEC END --><P>
<A NAME="@default1546"></A>
<A NAME="@default1547"></A></P><P>SIDL-specified objects are managed through explicit creation but explicit
reference counting<A NAME="@default1548"></A> is basically unnecessary.
Thanks to the straightforward mapping between SIDL and Java types, 
SIDL-specified concrete classes can be instantiated through Java’s
<TT>new</TT>.
For example, given a package <TT>test</TT> that includes
the class <TT>HelloWorld</TT>, the following code snippet illustrates
the creation of an object as well as its use:
<A NAME="@default1549"></A>
<A NAME="@default1550"></A><A NAME="@default1551"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> test.HelloWorld;

<B>public static</B> main(String args[]) {

  HelloWorld hi = <B>new</B> HelloWorld();
  hi.printMsg();
}</TD></TR>
</TABLE><P>Writing the fully qualified class name would also have sufficed as in:
<A NAME="@default1552"></A><A NAME="@default1553"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public static</B> main(String args[]) {

  test.HelloWorld hi = <B>new</B> test.HelloWorld();
  hi.printMsg();
}</TD></TR>
</TABLE><P><EM><B>WARNING</B>:
Although <TT>addRef</TT> and <TT>deleteRef</TT> exist in Java,
they should <B>not</B> be used because Java decrements the reference count
itself when it garbage collects a SIDL object.
</EM></P><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.5  Static methods</H3><!--SEC END --><P>
<A NAME="@default1554"></A>
<A NAME="@default1555"></A></P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.6  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default1556"></A>
<A NAME="@default1557"></A></P><P>Using the <TT>overload_sample.sidl</TT> file from Section <A HREF="#sec:overloading">6.7</A>
as an example, recall that three versions of the <TT>getValue</TT> method are
specified. The first signature takes no arguments, the second takes an
integer, and the third a boolean. The code snippet below illustrates
object creation, and method invocation for each of the overloaded methods.
<A NAME="@default1558"></A>
<A NAME="@default1559"></A><A NAME="@default1560"></A>
<A NAME="@default1561"></A><A NAME="@default1562"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>boolean</B> b1, bresult;
<B>int</B>     i1, iresult, nresult;

Overload.Sample t  = <B>new</B> Overload.Sample();

nresult = t.getValue();
bresult = t.getValue(b1);
iresult = t.getValue(i1);</TD></TR>
</TABLE><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.7  Exception catching</H3><!--SEC END --><P><A NAME="ss:Java:exceptioncatching"></A>
<A NAME="@default1563"></A>
<A NAME="@default1564"></A></P><P>Recall Subsection <A HREF="#sss:java:exceptions">13.2.3</A> discussed issues associated
with the fact that SIDL supports exception interfaces while Java does not.
In the following example, derived from regression tests, a <TT>getFibi</TT> 
method takes an integer argument and can throw one of two exceptions 
specified as SIDL exception interfaces: <TT>NegativeValueException</TT> 
and <TT>TooDeepException</TT>. 
<A NAME="@default1565"></A>
<A NAME="@default1566"></A><A NAME="@default1567"></A>
<A NAME="@default1568"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
<B>try</B> {
  fib.getFibi(-1);
} <B>catch</B> (NegativeValueException.Wrapper ex) {
  System.err.println(ex.getNote());
} <B>catch</B> (TooDeepException.Wrapper ex) {
  System.err.println(ex.getNote());
} <B>catch</B> (java.lang.Exception ex) {
  <B>if</B> (((sidl.BaseInterface)ex).isType("sidl.SIDLException")) {
    System.err.println("Unexpected SIDL Exception thrown");
  } <B>else</B> {
    System.err.println("Unexpected and unknown exception thrown");
  }
}</TD></TR>
</TABLE><P>Since the two exception types are specified as interfaces, the code to trap
each must reference their <TT>Wrapper</TT> classes. Hence, the use of each
class’s fully qualified name<A NAME="@default1569"></A> in the <TT>catch</TT> clauses.</P><P>The example also illustrates another option that is generally available for
distinguishing between exception types. That is, the body of the final 
<TT>catch</TT> includes a call to the <TT>isType()</TT> method, which is used
to check the exception against a named type. In this example, however,
SIDL can cast between the two interfaces, so <TT>isType()</TT> would return 
true regardless of the the type of the exception instance.</P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.8  Hooks execution</H3><!--SEC END --><P><A NAME="ss:java:sethooks"></A>
<A NAME="@default1570"></A><A NAME="@default1571"></A>
<A NAME="@default1572"></A><A NAME="@default1573"></A>
<A NAME="@default1574"></A><A NAME="@default1575"></A></P><P>If a given component supports pre- and post-method invocation instrumentation,
also known as “hooks”, their execution can be enabled or disabled at
runtime through the built-in <TT>_set_hooks</TT> method. For example,
given the following SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class, the processes for enabling and disabling
execution of the implementation-specific hooks are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>try</B> {
    hooks.Basics obj  = <B>new</B> hooks.Basics();

    <FONT COLOR="blue"><I>/*
     * Enable hooks execution (enabled by default)
     * ...for static methods
     */</I></FONT>
    hooks.Basics._set_hooks_static(<B>true</B>);
    <FONT COLOR="blue"><I>/*
     * ...for non-static methods
     */</I></FONT>
    obj._set_hooks(<B>true</B>);

    <FONT COLOR="blue"><I>/*
     * ...do something important...
     */

    /*
     * Disable hooks execution
     * ...for static methods
     */</I></FONT>
    hooks.Basics._set_hooks_static(<B>false</B>);
    <FONT COLOR="blue"><I>/*
     * ...for non-static methods
     */</I></FONT>
    obj._set_hooks(<B>false</B>);

    <FONT COLOR="blue"><I>/*
     * ...do something important...
     */</I></FONT>
    } <B>catch</B> (Throwable ex) {
      ex.printStackTrace();
    }</TD></TR>
</TABLE><P>It is important to keep in mind that the <TT>_set_hooks_static</TT>
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>_set_hooks</TT> method must be used for those of
non-static methods. Also, Babel does not provide client access to the
<TT>_pre</TT> and <TT>_post</TT> methods; therefore, they cannot be invoked
directly. More information on the instrumentation process is provided
in Subsection <A HREF="#ss:java:hooksimpl">13.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.3.9  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:java:contract_enforcement"></A>
<A NAME="@default1576"></A>
<A NAME="@default1577"></A>
<A NAME="@default1578"></A></P><P>Interface contracts specify the expected behaviors of callers (or clients)
and callees (or servers) of methods defined for interfaces and classes.
Once specified, contracts are optionally enforced at runtime, through checks
automatically integrated into the middleware generated by the Babel compiler.
This section provides an example of a specification and code snippets for
performing basic, traditional contract enforcement — introduced in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — in a Java client.</P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below.
(Refer to Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.)
According to the preconditions,
<A NAME="@default1579"></A><A NAME="@default1580"></A>
<A NAME="@default1581"></A>
all callers are expected to provide two one-dimensional, SIDL arrays of the
same size as arguments.
The postconditions
<A NAME="@default1582"></A><A NAME="@default1583"></A>
<A NAME="@default1584"></A>
specify that all implementations are expected to return a non-null,
one-dimensional array of the same size (as the first SIDL array),
assuming the preconditions are satisfied.</P><P><A NAME="@default1585"></A>
<A NAME="@default1586"></A>
<A NAME="@default1587"></A>
<A NAME="@default1588"></A><A NAME="@default1589"></A>
<A NAME="@default1590"></A>
<A NAME="@default1591"></A>
<A NAME="@default1592"></A>
<A NAME="@default1593"></A>
<A NAME="@default1594"></A>
<A NAME="@default1595"></A>
<A NAME="@default1596"></A>
<A NAME="@default1597"></A>
<A NAME="@default1598"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a Java client invoking the method is given below. 
The code snippet illustrates declaring and creating the arrays; 
enabling full contract enforcement (i. e., checking all contract 
clauses); executing <TT>vuSum</TT>; and handling contract 
violation exceptions is given below.</P><P><A NAME="@default1599"></A>
<A NAME="@default1600"></A>
<A NAME="@default1601"></A>
<A NAME="@default1602"></A>
<A NAME="@default1603"></A>
<A NAME="@default1604"></A>
<A NAME="@default1605"></A>
<A NAME="@default1606"></A>
<A NAME="@default1607"></A>
<A NAME="@default1608"></A>
<A NAME="@default1609"></A>
<A NAME="@default1610"></A>
<A NAME="@default1611"></A>
<A NAME="@default1612"></A>
<A NAME="@default1613"></A>
<A NAME="@default1614"></A>
<A NAME="@default1615"></A>
<A NAME="@default1616"></A>
<A NAME="@default1617"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> sidl.ContractClass;
<B>import</B> sidl.Double.Array1;
<B>import</B> sidl.EnfPolicy;
<B>import</B> sidl.PostViolation;
<B>import</B> sidl.PreViolation;
<B>import</B> sidl.SIDLException;
<B>import</B> vect.Utils;

  <FONT COLOR="blue"><I>/* ... */</I></FONT>

  Array1 u  = <B>new</B> Array1(0, S_MAX_SIZE-1, <B>false</B>);
  Array1 v  = <B>new</B> Array1(0, S_MAX_SIZE-1, <B>false</B>);

  <FONT COLOR="blue"><I>/* Initialize u and v. */

  /* Enable FULL contract enforcement. */</I></FONT>
  <B>try</B> {
    d_policy.setEnforceAll(sidl.ContractClass.ALLCLASSES, <B>true</B>);
  } <B>catch</B> (SIDLException exc) {
    <FONT COLOR="blue"><I>/* Handle the exception */</I></FONT>
  }

  <FONT COLOR="blue"><I>/* Do something meaningful before execute method. */</I></FONT>

  <B>try</B> {
    Array1 x = vect.Utils.vuSum(u, v);
    <B>if</B> (x != <B>null</B>) {
      <FONT COLOR="blue"><I>/* Do something meaningful with the result, x. */</I></FONT>
    }
  } <B>catch</B> (PreViolation preExc) {
    <FONT COLOR="blue"><I>/* Handle the precondition violation, preExc. */</I></FONT>
  } <B>catch</B> (PostViolation postExc) {
    <FONT COLOR="blue"><I>/* Handle the postcondition violation, postExc. */</I></FONT>
  } <B>catch</B> (Exception exc) {
    <FONT COLOR="blue"><I>/* Handle the undifferentiated exception, exc. */</I></FONT>
  }</TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the Java calls associated with the traditional
options of enabling only precondition enforcement, enabling postcondition
enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default1618"></A>
<A NAME="@default1619"></A>
<A NAME="@default1620"></A>
<A NAME="@default1621"></A>
<A NAME="@default1622"></A>
<A NAME="@default1623"></A>
<A NAME="@default1624"></A>
<A NAME="@default1625"></A>
<A NAME="@default1626"></A>
<A NAME="@default1627"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> sidl.ContractClass;
<B>import</B> sidl.EnfPolicy;

  <FONT COLOR="blue"><I>/* ... */</I></FONT>

  policy = <B>new</B> sidl.EnfPolicy();

  <FONT COLOR="blue"><I>/*
   * Enable only precondition contract enforcement.
   * (Useful when only need to ensure callers comply with contract.)
   */</I></FONT>
  <B>try</B> {
    policy.setEnforceAll(sidl.ContractClass.PRECONDS, <B>false</B>);
  } <B>catch</B> (SIDLException exc) {
    <FONT COLOR="blue"><I>/* Handle the exception */</I></FONT>
  }

  <FONT COLOR="blue"><I>/*
   * Enable only postcondition contract enforcement.
   * (Useful when only need to ensure implementation(s) comply with contract.)
   */</I></FONT>
  <B>try</B> {
    policy.setEnforceAll(sidl.ContractClass.POSTCONDS, <B>false</B>);
  } <B>catch</B> (SIDLException exc) {
    <FONT COLOR="blue"><I>/* Handle the exception */</I></FONT>
  }

  <FONT COLOR="blue"><I>/*
   * Disable contract enforcement.
   * (Should only be used when have confidence in caller AND implementation.)
   */</I></FONT>
  <B>try</B> {
    policy.setEnforceNone(<B>false</B>);
  } <B>catch</B> (SIDLException exc) {
    <FONT COLOR="blue"><I>/* Handle the exception */</I></FONT>
  }</TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a Java client.
Additional enforcement policy options and methods as well as more
information regarding the specification and enforcement of contracts
can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc62">13.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:java:implementation"></A>
<A NAME="@default1628"></A></P><P>This section summarizes aspects of generating and wrapping software written
in Java. The bindings generation and basic implementation processes are
presented first. Accessing private data is then discussed before illustrating 
the process of throwing exceptions.
Finally, the results of generating implementations with pre- and post-method
“hooks” are shown.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:java:implgen"></A>
<A NAME="@default1629"></A>
<A NAME="@default1630"></A><A NAME="@default1631"></A></P><P>Babel supports calls to SIDL classes implemented in Java. These
classes obey the same rules described in Subsection <A HREF="#ss:java:clientgen">13.3.1</A> 
for client-side Java classes, except
that in this case the file, class, and method names all end in <TT>_Impl</TT>.
Implementation of a set of SIDL classes in Java first requires the 
generation of the necessary bindings. This is accomplished by invoking
Babel as follows:
<A NAME="@default1632"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=Java file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -sJava file.sidl</B><BR>
</TT></BLOCKQUOTE><P>The directory structure that results from this command is the same as
that produced on the client-side except there are many more files. Given 
the SIDL file is named “file.sidl”, as above, a <TT>file</TT> subdirectory is 
created and “Impl” files (i. e., those ending in <TT>_Impl.java</TT>) are 
automatically generated in that subdirectory.
These Java “Impl” files are supposed to contain implementation 
details. Refer to Subsection <A HREF="#ss:java:implfill">13.4.2</A> for details.</P><P>In the current directory there are also new files that end in
<TT>_jniSkel.c</TT>. These files are equivalent to the client-side 
<TT>_jniStub.c</TT>. In fact, all client-side files are generated 
from this call as well to allow for calling methods 
on the current object in the Java “Impl” file. Consequently, they 
can safely be ignored.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:java:implfill"></A>
<A NAME="@default1633"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:java:implgen">13.4.1</A>. Changes to these files must be made between
code splicer pairs to ensure their retention in subsequent invocations of
Babel. Code splicing is a technique for preserving hand-edited 
code between multiple invocations of Babel. This allows a developer to refine 
the implementation without losing previous implementation details. Hence,
code between splicer pairs will be retained by subsequent invocations of Babel;
whereas, code outside splicer pairs will not.</P><P><A NAME="@default1634"></A>
Another interesting fact of the implementation-side is that it inherits from
the client-side Java class. This allows calls to local methods
directly. Take this recursive Fibonacci function implementation, for example:
<A NAME="@default1635"></A>
<A NAME="@default1636"></A><A NAME="@default1637"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>class</B> Fib_Impl <B>extends</B> Fib {
  <B>public int</B> getFib_Impl(<B>int</B> x) {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFib) </I></FONT>
    <B>if</B>(x &gt;= 2) {
      <B>return</B> getFib(x-1) + getFib(x-2);
    } <B>else</B> {
      <B>return</B> 1;
    }
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFib)</I></FONT>
  }
}</TD></TR>
</TABLE><P>The client-side class name is <TT>Fib</TT> and, therefore, the
implementation-side class is <TT>Fib_Impl</TT>. The same relation holds for
the <TT>getFib</TT> method. Note that <TT>getFib</TT>, the client-side method, 
can be called directly. A call like this
goes through Babel glue code, as it should. That is, calls 
directly to <TT>_Impl</TT> methods should <EM>never</EM> be made since they
break the object model for the current class and will not work on different 
objects. The reason for this situation is that, by making local calls, within 
<TT>fib_Impl</TT> for example, any inheritance information stored in the
middleware is lost. It also means implementation-side object inheritance
from non-SIDL Java classes is impossible. In fact, since no splicer blocks are
available for inheritance, implementing interfaces on the 
implementation-side is also not supported since having the
implementation-side inherit from non-SIDL classes is probably not a good idea.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.4.3  Private data</H3><!--SEC END --><P>
<A NAME="@default1638"></A>
<A NAME="@default1639"></A></P><P>Any variables declared in the implementation source file will, by virtue
of Babel’s encapsulation, be private. The data can be global to the class —
as in static variables declared within the <TT>_includes</TT> splicer block
at the top of the class’s <TT>_Impl.java</TT> file — or “local” to an
instance.
In the former case, special initialization procedures can be added to
the built-in <TT>_load()</TT> method, which is guaranteed to be called
exactly once per class — <EM>before</EM> any user-defined methods
can even be invoked. The latter case relies on the class-specific
name space automatically generated in the implementation’s header
file.</P><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.4.4  Exception throwing</H3><!--SEC END --><P><A NAME="ss:Java:exceptionthrowing"></A>
<A NAME="@default1640"></A><A NAME="@default1641"></A></P><P>Recall Subsection <A HREF="#sss:java:exceptions">13.2.3</A> discussed issues associated
with SIDL support for exception interfaces versus Java’s requirement
that all exceptions be classes. Below is an extension of the example
in Subsection <A HREF="#ss:Java:exceptioncatching">13.3.7</A> 
involving <TT>getFibi</TT>, which could throw one of the following two
interface exceptions: <TT>NegativeValueException</TT> and 
<TT>TooDeepException</TT>.
<A NAME="@default1642"></A>
<A NAME="@default1643"></A><A NAME="@default1644"></A>
<A NAME="@default1645"></A><A NAME="@default1646"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public int</B> getFibi_Impl ( <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> n)
<B>throws</B> NegativeValueException.Wrapper, TooDeepException.Wrapper {
  <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(ExceptionTest.Fib.getFibi)</I></FONT>
  <B>if</B> (n &lt; 0) {
    FibException fex = <B>new</B> FibException();
    NegativeValueException.Wrapper neg = (NegativeValueException.Wrapper)
      NegativeValueException.Wrapper._cast(fex);
    neg.setNote("n negative");
    <B>throw</B> neg;
  }

  <FONT COLOR="blue"><I>//  .... Do Fibonacci stuff ....
  // DO-NOT-DELETE splicer.end(ExceptionTest.Fib.getFibi)</I></FONT>
}</TD></TR>
</TABLE><P>Notice that the interface exceptions and their <TT>Wrapper</TT>s cannot
be instantiated directly. Instead, a <TT>FibException</TT> object is 
created then cast to the appropriate exception interface type. As
in Subsection <A HREF="#ss:Java:exceptioncatching">13.3.7</A>, the wrapper class’s
full name<A NAME="@default1647"></A> is required during the cast operation.
Finally, the example illustrates the use of <TT>setNote</TT> to add
the message to the exception being thrown — which is necessary
since the note cannot be passed to the exception’s constructor.</P><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->13.4.5  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:java:hooksimpl"></A>
<A NAME="@default1648"></A><A NAME="@default1649"></A>
<A NAME="@default1650"></A>
<A NAME="@default1651"></A><A NAME="@default1652"></A>
<A NAME="@default1653"></A><A NAME="@default1654"></A></P><P>As discussed in Subsection <A HREF="#ss:java:sethooks">13.3.8</A>, when hooks execution
is enabled, implementation-specific instrumentation is executed. Using
the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results
in the automatic generation of a <TT>_pre</TT> and <TT>_post</TT>
method for every static and non-static method associated with each class
in the specification. For the <TT>aStaticMethod</TT> specified in
Subsection <A HREF="#ss:java:sethooks">13.3.8</A>, the generated <TT>_pre</TT> method
implementation is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>public static void</B> aStaticMeth_pre_Impl ( <B>int</B> i, <B>int</B> io )
    <B>throws</B> sidl.RuntimeException.Wrapper
  {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_pre)
    /*
     * Add instrumentation here to be executed immediately prior
     * to dispatch to aStaticMeth().
     */
    // DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_pre)</I></FONT>
  }</TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>public static void</B> aStaticMeth_post_Impl ( <B>int</B> i, <B>int</B> o, <B>int</B> io, <B>int</B> _retval )
    <B>throws</B> sidl.RuntimeException.Wrapper
  {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(hooks.Basics.aStaticMeth_post)
    /*
     * Add instrumentation here to be executed immediately after
     * return from dispatch to aStaticMeth().
     */
    // DO-NOT-DELETE splicer.end(hooks.Basics.aStaticMeth_post)</I></FONT>
  }</TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation
should be added within the splicer blocks of
<TT>aStaticMethod_pre</TT> and
<TT>aStaticMethod_post</TT>. As stated in the comments
within those blocks, <TT>aStaticMethod_pre</TT> will be
executed immediately prior to dispatch to <TT>aStaticMethod</TT> when the
latter is invoked by a client. Assuming no exceptions are encountered,
<TT>aStaticMethod_post</TT> is executed immediately upon
return from <TT>aStaticMethod</TT>.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note20" HREF="#text20">1</A></DT><DD CLASS="dd-thefootnotes">For 
information on additional command line options, refer to 
Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Python Bindings-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc63">Chapter 14</A>  Python Bindings</H1><!--SEC END --><P><A NAME="c:python"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc64">14.1</A>  Introduction</H2><!--SEC END --><P>This chapter gives an overview of the Python bindings for SIDL. Common aspects
of the bindings, such as the mapping of SIDL data types to their Python
representatives, are presented in Section <A HREF="#s:python:basics">14.2</A>.
Issues of concern to callers written in Python are addressed in the 
client-side bindings discussion in Section <A HREF="#s:python:client">14.3</A>, while 
issues for callees written in Python are in 
Section <A HREF="#s:python:implementation">14.4</A>, which describes the implementation-side
bindings.</P><P><EM><B>NOTE</B>:
Babel requires a Python shared library. Because Python 2.3 has a
configure/build system that builds shared libraries on many
architectures, use of Python 2.3 or beyond is recommended.
</EM></P><!--TOC section Basics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc65">14.2</A>  Basics</H2><!--SEC END --><P><A NAME="s:python:basics"></A></P><P>As with any programming language-neutral technology, translations must
be made between abstract constructs supported by the technology and the
corresponding concrete constructs in the native programming language.
Due to the need to identify types in a global context,
Subsection <A HREF="#ss:python:namespace">14.2.1</A> describes the convention used to establish
name spaces.
Conventions for generating language-specific method signatures are given
in Subsection <A HREF="#ss:python:signatures">14.2.2</A>.
The mapping of SIDL fundamental types is given in 
Subsection <A HREF="#ss:python:types">14.2.3</A>.
Finally, the process of casting between different types is described
in Subsection <A HREF="#ss:python:casting">14.2.4</A>.</P><!--TOC subsection Name space-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.2.1  Name space</H3><!--SEC END --><P><A NAME="ss:python:namespace"></A>
<A NAME="@default1655"></A>
<A NAME="@default1656"></A></P><P>As in the case of Java, the SIDL name space maps easily into Python packages
and modules. That is, the SIDL package and interface/class hierarchy maps to 
a corresponding Python hierarchy. For example, a class <TT>Z</TT> in 
a SIDL specification with the top-most package <TT>X</TT> and nested, parent 
package <TT>Y</TT> maps to a Python package <TT>X</TT> with module <TT>Y</TT> that 
contains method <TT>Z</TT>. The class is then identified as <TT>X.Y.Z</TT> in 
Python.
<A NAME="@default1657"></A></P><!--TOC subsection Method signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.2.2  Method signatures</H3><!--SEC END --><P><A NAME="ss:python:signatures"></A>
<A NAME="@default1658"></A>
<A NAME="@default1659"></A></P><P>Despite the natural name space mapping, the goal to make language bindings
as natural as possible led to some variation for Python method signatures.
While the method name is used directly — where the full name<A NAME="@default1660"></A>
(i. e., the short name with the extension appended) is used for overloaded 
methods — there are some differences for its 
arguments. Specifically, arguments to the method include only the specified
<FONT COLOR=maroon><I><TT>in</TT></I></FONT> and <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> arguments, while the return 
value<A NAME="@default1661"></A> of the Python method includes the SIDL 
return value in addition to the <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> and <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters. 
(This will, hopefully, seem natural to Python programmers.) 
For example, the following SIDL declaration for method <TT>passeverywhere</TT>
of class <TT>Cdouble</TT> within the <TT>Args</TT> package is:
<A NAME="@default1662"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>double</B> passeverywhere( <B>in double</B> d1, <B>out double</B> d2, <B>inout double</B> d3 );</I></FONT></TD></TR>
</TABLE><P>The corresponding calling signature — based on Python’s built-in 
documentation capability — is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">passeverywhere(<B>in</B> double d1,
               inout double d3)
RETURNS
   (double _return,
    out double d2,
    inout double d3)</TD></TR>
</TABLE><P>Whenever the SIDL specification includes a return type, the corresponding
Python signature will include an <TT>_return</TT> as the first value of
the Python’s <TT>RETURNS</TT> value<A NAME="@default1663"></A>.
Starting <TT>_return</TT> with an underbar is used to indicate the argument 
is not a parameter since Python parameter names cannot begin with an underbar. 
More information on Python’s built-in documentation capability is given in
Subsection <A HREF="#ss:python:objectmanagement">14.3.4</A>.</P><P><EM><B>NOTE</B>:
As discussed in Subsection <A HREF="#sss:python:arrays">14.2.3</A>, methods passing raw SIDL 
arrays (or r-arrays) do not have index arguments in Python.
</EM><A NAME="@default1664"></A><A NAME="@default1665"></A>
</P><!--TOC subsection Data types-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.2.3  Data types</H3><!--SEC END --><P><A NAME="ss:python:types"></A>
<A NAME="@default1666"></A><A NAME="@default1667"></A></P><P>Unlike the other bindings, a straightforward mapping of SIDL to Python types 
does not exist. Consequently, this subsection describes key data types. </P><!--TOC subsubsection Long-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Long</H4><!--SEC END --><P><A NAME="sss:python:long"></A>
<A NAME="@default1668"></A><A NAME="@default1669"></A>
<A NAME="@default1670"></A><A NAME="@default1671"></A></P><P>As stated in Section <A HREF="#ssec:basics:fundamental:numbers">6.3</A>, SIDL <FONT COLOR=maroon><I><TT>long</TT></I></FONT>s
are equivalent to those in C. Hence, they map to 64-bit integers in the
middleware. However, since Python’s unlimited precision integer data type
is used in the bindings, the behaviour is not exactly like 64-bit integers
(i. e., there is no overflow). </P><P><EM><B>NOTE</B>:
For Python versions before 2.2, the code needs to guarantee that a Python 
unlimited precision integer is used whenever a SIDL <FONT COLOR=maroon><TT><I>long</I></TT></FONT> is needed. 
For example, calling <TT>isPrime</TT><A NAME="@default1672"></A> — whose SIDL 
signature is <TT>bool isPrime(long num)</TT> — as <TT>isPrime(1)</TT> will 
fail. However, calling <TT>isPrime(1L)</TT> will succeed.
</EM></P><!--TOC subsubsection Integers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Integers</H4><!--SEC END --><P><A NAME="sss:python:int"></A>
<A NAME="@default1673"></A><A NAME="@default1674"></A>
<A NAME="@default1675"></A><A NAME="@default1676"></A></P><P>As stated in Section <A HREF="#ssec:basics:fundamental:numbers">6.3</A>, SIDL <FONT COLOR=maroon><I><TT>int</TT></I></FONT>s
for Python are equivalent to those in C. Hence, they map to a 32-bit 
integer.</P><!--TOC subsubsection Exceptions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Exceptions</H4><!--SEC END --><P><A NAME="sss:python:exceptions"></A>
<A NAME="@default1677"></A><A NAME="@default1678"></A></P><P>Python exceptions must be Python classes; they cannot be C extension
types — the mechanism used to wrap SIDL objects as Python
objects. Because of this, Babel defines an exception class for each
SIDL type that implements <TT>sidl.BaseException</TT>. For a type
called <TT>X.Y.Z</TT>, the Python exception class is named
<TT>X.Y.Z._Exception</TT>. 
<A NAME="@default1679"></A></P><P><EM><B>NOTE</B>:
In Babel 0.10.2 and previous releases, the Python exception class was 
named <TT>X.Y.Z.Exception</TT>, but this name can potentially collide with 
the class constructor or a static method named <TT>Exception</TT>. For 
backwards compatibility, Babel defines <TT>X.Y.Z.Exception</TT> if the 
name <TT>Exception</TT> is not used in the class.
</EM></P><!--TOC subsubsection Enumerations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Enumerations</H4><!--SEC END --><P><A NAME="sss:python:enum"></A>
<A NAME="@default1680"></A><A NAME="@default1681"></A>
<A NAME="@default1682"></A><A NAME="@default1683"></A></P><!--TOC subsubsection Arrays-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Arrays</H4><!--SEC END --><P><A NAME="sss:python:arrays"></A>
<A NAME="@default1684"></A><A NAME="@default1685"></A>
<A NAME="@default1686"></A><A NAME="@default1687"></A>
<A NAME="@default1688"></A><A NAME="@default1689"></A></P><P>As discussed in Section <A HREF="#s:arrays">6.4</A>, SIDL supports both normal and raw
arrays (i. e., r-arrays). Both types of arrays are treated the same in 
Python bindings. That is, they both map to their NumPy or Numeric
Python equivalents. In the case of SIDL <FONT COLOR=maroon><I><TT>long</TT></I></FONT>s, an array of
64-bit integers may be used if NumPy or Numeric Python supports 64-bit
integers; otherwise, an array of Python’s indefinite precision
integers (i. e., integers with unlimited bits) are used.</P><P><EM><B>NOTE</B>:
The SIDL array API is not supported in these bindings; instead, 
those in NumPy or Numeric Python must be used. With Babel 1.1.0 and
later, Babel supports either the new NumPy or the deprecated Numeric
Python. To determine which Babel is configured to use, you can use the
following:</EM></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> sidlPyArray
<B>if</B> sidlPyArray.type == "numpy":
  <B>import</B> numpy
<B>else</B>:
  <B>if</B> sidlPyArray.type == "numeric":
    <B>import</B> numeric</TD></TR>
</TABLE><!--TOC subsubsection Opaque-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Opaque</H4><!--SEC END --><P><A NAME="sss:python:opaque"></A>
<A NAME="@default1690"></A>
<A NAME="@default1691"></A></P><P>There is no way to access the value of a SIDL <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> in Python.
The Python value <TT>None</TT> can be passed as an incoming
<FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> parameter. You can also pass in an <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> value
that was returned by previous Babel method invocation. Babel maps SIDL
<FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> to the Python <TT>CObject</TT> type — a type that is
only accessible from Python C extension modules.</P><!--TOC subsection Type casting-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.2.4  Type casting</H3><!--SEC END --><P><A NAME="ss:python:casting"></A>
<A NAME="@default1692"></A><A NAME="@default1693"></A>
<A NAME="@default1694"></A><A NAME="@default1695"></A></P><P>Given an object, <TT>obj</TT>, it is possible to determine if it is an 
instance of a SIDL class or interface whose fully qualified name is 
<TT>X.Y.Z</TT> as follows:
<A NAME="@default1696"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
&gt;&gt;&gt; <B>import X.Y.Z</B><BR>
&gt;&gt;&gt; <B>zobj = X.Y.Z.Z(obj)</B><BR>
</TT></BLOCKQUOTE><P>Of course, the import is not needed if <TT>X.Y.Z</TT> has already been imported. 
If <TT>zobj</TT> is not equal to <TT>None</TT>, the cast was successful.</P><!--TOC section Client-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">14.3</A>  Client-side</H2><!--SEC END --><P><A NAME="s:python:client"></A>
<A NAME="@default1697"></A></P><P>This section summarizes aspects of generating and using the Python bindings
associated with software wrapped with Babel’s language interoperability
middleware. The bindings generation process and required environment variables
are presented before the process for importing SIDL-specified constructs 
is described.
Object management and invocation of static and overloaded methods are
also summarized. The process of catching exceptions is then discussed.
Finally, the processes for enabling and disabling implementation-specific
pre- and post-method instrumentation — referred to as “hooks” —
are illustrated.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:python:clientgen"></A>
<A NAME="@default1698"></A>
<A NAME="@default1699"></A><A NAME="@default1700"></A></P><P>Building Python bindings requires an installation with Python compiled
as a shared or dynamically linked library. The standard Python build only
creates the necessary shared library on a few platforms — none of
which are target platforms for Babel. Some Linux distributions include
a Python shared library, and it is possible to make a Python shared
library on Solaris. The Python shared library should contain the
objects from <TT>libpythonm.n.a</TT> where <TT>m.n</TT> is the version of
Python being used. Since making a shared library is different on each 
platform, the process is not covered here.</P><P>To generate client-side bindings, Babel must be run as follows<SUP><A NAME="text21" HREF="#note21">1</A></SUP>:
<A NAME="@default1701"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --client=python file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -c=python file.sidl</B><BR>
</TT></BLOCKQUOTE><P>This creates the Intermediate Object Representation (IOR) files in the current 
directory and a tree of
subdirectories based on the package hierarchy found in <TT>file.sidl</TT>. 
It also creates module (i. e., <TT>_Module.c</TT>) files in the appropriate
subdirectories.
In most cases, the IOR, <TT>_pSkel.c</TT>, and <TT>_pLaunch.c</TT> files must 
be compiled and place in a shared library.</P><!--TOC subsection Environment variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.2  Environment variables</H3><!--SEC END --><P>
<A NAME="@default1702"></A><A NAME="@default1703"></A>
<A NAME="@default1704"></A><A NAME="@default1705"></A></P><P>There are three environment variables associated with running
Python with Babel on many systems. Each, described below, 
identifies path-related directories that must be set properly 
for various tools. It is assumed Babel was already installed 
in directories rooted at <TT>$PREFIX</TT>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>PYTHONPATH</TT>.</B></DT><DD CLASS="dd-description">
The <TT>PYTHONPATH</TT><A NAME="@default1706"></A> environment variable 
needs to contain <TT>$PREFIX/python</TT> and the directory where
work is being done. </DD><DT CLASS="dt-description"><B><TT>LD_LIBRARY_PATH (or system-specific alternative)</TT>.</B></DT><DD CLASS="dd-description">
Many systems require the <TT>LD_LIBRARY_PATH</TT><A NAME="@default1707"></A> 
environment variable contain <TT>$PREFIX/lib</TT>. Others, however, use
different variables. AIX, for example, uses <TT>LIBPATH</TT> instead. The 
point is to include <TT>$PREFIX/lib</TT> in the search path used to locate 
shared/dynamic link libraries.</DD><DT CLASS="dt-description"><B><TT>SIDL_DLL_PATH</TT>.</B></DT><DD CLASS="dd-description">
The <TT>SIDL_DLL_PATH</TT><A NAME="@default1708"></A> environment variable
is typically required to contain the path to the directory holding
the shared/dynamic link library containing the implementation of SIDL
objects. This is a semicolon-separated path variable.</DD></DL><!--TOC subsection Imports-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.3  Imports</H3><!--SEC END --><P>
<A NAME="@default1709"></A><A NAME="@default1710"></A>
The following command is used to import a class named <TT>X.Y.Z</TT>:
<A NAME="@default1711"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
&gt;&gt;&gt; <B>import X.Y.Z</B><BR>
</TT></BLOCKQUOTE><P>Alternatively,</P><BLOCKQUOTE CLASS="quotation"><TT>
&gt;&gt;&gt; <B>from X.Y.Z import *</B><BR>
</TT></BLOCKQUOTE><P>can be used but there can be no name space collisions.</P><!--TOC subsubsection Common problems-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Common problems</H4><!--SEC END --><P>
<A NAME="@default1712"></A>
<A NAME="@default1713"></A></P><P>This subsection elaborates on a few of the common problems (and possible
solutions) that occur when importing SIDL-specified extensions.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>ImportError: undefined function.</B></DT><DD CLASS="dd-description">
The following illustrates an error that can arise that appears to be
associated with an undefined function:
<A NAME="@default1714"></A>
<A NAME="@default1715"></A><A NAME="@default1716"></A><BLOCKQUOTE CLASS="quotation"><TT>
&gt;&gt;&gt; <B>import X.Y.Zmodule</B><BR>
 Traceback (innermost last):<BR>
 File "&lt;stdin&gt;", line 1, in ?<BR>
 ImportError: dynamic module does not define init function (initZmodule)<BR>
</TT></BLOCKQUOTE><P>This could be a matter of an incorrect import or a problem with the 
environment. Consider the following:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Is the name of your SIDL interface (or class) <TT>X.Y.Z</TT> or <TT>X.Y.Zmodule</TT>?</B></DT><DD CLASS="dd-description">
In the former case, the command should be <B><TT>import X.Y.Z</TT></B> instead.
<A NAME="@default1717"></A></DD><DT CLASS="dt-description"><B>Is <TT>PYTHONPATH</TT> set properly?</B></DT><DD CLASS="dd-description">
Make sure this environment variable contains directories for all 
required Python shared libraries.</DD></DL><P>If the answers to these questions do not solve the problem, 
submit a bug report for Babel. </P></DD><DT CLASS="dt-description"><B>Fatal Python error: class load</B></DT><DD CLASS="dd-description">
If the class fails to load, for example, the following occurs:
<A NAME="@default1718"></A><BLOCKQUOTE CLASS="quotation"><TT>
&gt;&gt;&gt; <B>import X.Y.Z</B><BR>
Fatal Python error: Cannot load implementation for SIDL class X.Y.Z<BR>
Abort (core dumped)<BR>
</TT></BLOCKQUOTE><P>then the Python stub code — the code that links Python to SIDL’s 
independent object representation (IOR) — failed in its attempt to load 
the shared or dynamically linked library that contains the implementation 
of SIDL class <TT>X.Y.Z</TT>. 
This is likely to be a path problem so consider the following:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Is <TT>SIDL_DLL_PATH</TT> set properly?</B></DT><DD CLASS="dd-description">
Make sure it lists all directories where the shared (or dynamic) link 
libraries for the required SIDL objects and interfaces are stored. </DD><DT CLASS="dt-description"><B>Is <TT>LD_LIBRARY_PATH</TT> set properly?</B></DT><DD CLASS="dd-description">
Make sure this environment variable (or whatever your machine’s mechanism for
locating shared library files) also includes the directory in which the SIDL 
runtime resides.</DD></DL></DD><DT CLASS="dt-description"><B>Fatal Python error: interface load.</B></DT><DD CLASS="dd-description">
If the following error occurs:
<A NAME="@default1719"></A><BLOCKQUOTE CLASS="quotation"><TT>
&gt;&gt;&gt; <B>import X.Y.Z</B><BR>
Fatal Python error: Cannot load implementation for SIDL interface X.Y.Z<BR>
Abort (core dumped)<BR>
</TT></BLOCKQUOTE><P>it is the same problem described for the fatal error encountered when
attempting to load a SIDL class.</P></DD></DL><!--TOC subsection Object management-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.4  Object management</H3><!--SEC END --><P><A NAME="ss:python:objectmanagement"></A>
<A NAME="@default1720"></A>
<A NAME="@default1721"></A>
<A NAME="@default1722"></A><A NAME="@default1723"></A></P><P>Once the Python extension module is built and imported, an instance 
can be created. 
For example, given the <TT>Args.Cdouble</TT> example in 
Subsection <A HREF="#ss:python:signatures">14.2.2</A> with the method <TT>passeverywhere</TT>,
the process for instantiating the class and printing its calling signature
is:
<A NAME="@default1724"></A>
<A NAME="@default1725"></A><A NAME="@default1726"></A>
<A NAME="@default1727"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">$ python
&gt;&gt;&gt; <B>import</B> Args.Cdouble
&gt;&gt;&gt; obj = Args.Cdouble.Cdouble()
&gt;&gt;&gt; <B>print</B> obj.passeverywhere.__doc__
passeverywhere(<B>in</B> double d1,
               inout double d3)
RETURNS
   (double _return,
    out double d2,
    inout double d3)</TD></TR>
</TABLE><P>In this case the last part of the class name is repeated when assigning
the instance to <TT>obj</TT>.
Any SIDL document comments (i. e. comments enclosed in <TT>/** */</TT>) will
appear below the signature documentation.</P><P>In some cases, the Python extension module may be named
<TT>Cdoublemodule.so</TT> instead of simply <TT>Cdouble.so</TT>. 
This might result in the temptation to <B><TT>import Args.Cdoublemodule</TT></B>
instead of <B><TT>import Args.Cdouble</TT></B>; <EM>resist!</EM></P><!--TOC subsection Static methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.5  Static methods</H3><!--SEC END --><P>
<A NAME="@default1728"></A>
<A NAME="@default1729"></A></P><P>Static methods of a SIDL-specified class are available in Python. Since
they are associated with a class, they reside in its name space. </P><!--TOC subsection Overloaded methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.6  Overloaded methods</H3><!--SEC END --><P>
<A NAME="@default1730"></A>
<A NAME="@default1731"></A></P><P>Examples of calls to SIDL overloaded methods are based on the 
<TT>overload_sample.sidl</TT> file shown in Section <A HREF="#sec:overloading">6.7</A>. 
Recall that the file describes three versions of the <TT>getValue</TT> method. 
The first takes no arguments, the second takes an integer argument, and the 
third takes a boolean. Each is called in the code snippet below:
<A NAME="@default1732"></A>
<A NAME="@default1733"></A><A NAME="@default1734"></A>
<A NAME="@default1735"></A><A NAME="@default1736"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
  b1 = 1
  i1 = 1

  t = Overload.Sample.Sample()

  nresult = t.getValue()
  iresult = t.getValueInt(i1)
  bresult = t.getValueBool(b1)</TD></TR>
</TABLE><!--TOC subsection Exception catching-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.7  Exception catching</H3><!--SEC END --><P><A NAME="ss:python:exceptioncatching"></A>
<A NAME="@default1737"></A><A NAME="@default1738"></A>
<A NAME="@default1739"></A></P><P>SIDL exceptions are caught very much like normal Python exceptions 
except the Python exception class of the SIDL type must be used. 
The exception value holds the SIDL object as attribute <TT>exception</TT>. 
Below is an example of catching exceptions from a call to <TT>getFib</TT>. 
<A NAME="@default1740"></A>
<A NAME="@default1741"></A><A NAME="@default1742"></A>
<A NAME="@default1743"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>try</B>:
    fib.getFib(-1, 10, 10, 0)
  <B>except</B> ExceptionTest.NegativeValueException._Exception:
    (etype, eobj, etb) = sys.exc_info()
    <FONT COLOR="blue"><I># eobj is the SIDL exception object</I></FONT>
    <B>print</B> eobj.exception.getNote()  <FONT COLOR="blue"><I># show the exception comment</I></FONT>
    <B>print</B> eobj.exception.getTrace() <FONT COLOR="blue"><I># and traceback</I></FONT></TD></TR>
</TABLE><P>Note that <TT>eobj.exception</TT> is an instance of
<TT>ExceptionTest.NegativeValueException.NegativeValueException</TT>,
the Python type corresponding to the SIDL type
<TT>ExceptionTest.NegativeValueException</TT>.</P><!--TOC subsection Hooks execution-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.8  Hooks execution</H3><!--SEC END --><P><A NAME="ss:python:sethooks"></A>
<A NAME="@default1744"></A><A NAME="@default1745"></A>
<A NAME="@default1746"></A><A NAME="@default1747"></A>
<A NAME="@default1748"></A><A NAME="@default1749"></A></P><P>If a given component supports pre- and post-method invocation instrumentation,
also known as “hooks”, their execution can be enabled or disabled at
runtime through the built-in <TT>_set_hooks</TT> method. For example,
given the following SIDL specification:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> hooks <B>version</B> 1.0
{
  <B>class</B> Basics {
    /**
     * Basic illustration of hooks for static methods.
     */
    <B>static int</B> aStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);

    /**
     * Basic illustration of hooks for static methods.
     */
    <B>int</B> aNonStaticMeth(<B>in int</B> i, <B>out int</B> o, <B>inout int</B> io);
  }
}</I></FONT></TD></TR>
</TABLE><P>which has a single static function and a member function for the
<TT>Basics</TT> class, the processes for enabling and disabling
execution of the implementation-specific hooks are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
  obj = hooks.Basics.Basics()

<FONT COLOR="blue"><I>#
# Enable hooks execution (enabled by default)
# ...for non-static methods
#</I></FONT>
    hooks.Basics._set_hooks_static(1)
<FONT COLOR="blue"><I>#
# ...for static methods
#</I></FONT>
    obj._set_hooks(1)

<FONT COLOR="blue"><I>#
# ...do something important...
#

#
# Disable hooks execution
# ...for non-static methods
#</I></FONT>
    hooks.Basics._set_hooks_static(0)
<FONT COLOR="blue"><I>#
# ...for static methods
#</I></FONT>
    obj._set_hooks(0)

<FONT COLOR="blue"><I>#
# ...do something important...
#</I></FONT></TD></TR>
</TABLE><P>It is important to keep in mind that the <TT>_set_hooks_static</TT>
method must be used to enable/disable invocation of hooks for static 
methods and the <TT>_set_hooks</TT> method must be used for those of
non-static methods. Also, Babel does not provide client access to the
<TT>_pre</TT> and <TT>_post</TT> methods; therefore, they cannot be invoked
directly. More information on the instrumentation process is provided
in Subsection <A HREF="#ss:c:hooksimpl">8.4.5</A>.</P><!--TOC subsection Contract enforcement-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.3.9  Contract enforcement</H3><!--SEC END --><P><A NAME="ss:python:contract_enforcement"></A>
<A NAME="@default1750"></A> 
<A NAME="@default1751"></A>
<A NAME="@default1752"></A></P><P>Interface contracts specify the expected behaviors of clients and servers
of interface and class methods. 
Once specified, contracts can automatically be enforced at runtime.
This section provides an example of a specification and associated code
snippets for performing basic, traditional contract enforcement —
introduced in Section <A HREF="#ss:intro_contract_enforcement">6.5</A> — within a
Python client. </P><P>A SIDL specification, including preconditions and postconditions, for
calculating the sum of two vectors is given below.
(Refer to Section <A HREF="#s:ifc_contracts">6.5</A> for an introduction to the contract
syntax.)
According to the preconditions,
<A NAME="@default1753"></A><A NAME="@default1754"></A>
<A NAME="@default1755"></A>
all callers are expected to provide two one-dimensional, SIDL arrays of the
same size as arguments.
The postconditions
<A NAME="@default1756"></A><A NAME="@default1757"></A>
<A NAME="@default1758"></A>
specify that all implementations are expected to return a non-null,
one-dimensional array of the same size (as the first SIDL array),
assuming the preconditions are satisfied.</P><P><A NAME="@default1759"></A>
<A NAME="@default1760"></A>
<A NAME="@default1761"></A>
<A NAME="@default1762"></A><A NAME="@default1763"></A>
<A NAME="@default1764"></A>
<A NAME="@default1765"></A>
<A NAME="@default1766"></A>
<A NAME="@default1767"></A>
<A NAME="@default1768"></A>
<A NAME="@default1769"></A>
<A NAME="@default1770"></A>
<A NAME="@default1771"></A>
<A NAME="@default1772"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>An example of a Python client calling the method is given below.
The code snippet illustrates declaring and creating the arrays;
enabling full contract enforcement (i. e., checking all contract
clauses); executing <TT>vuSum</TT>; and handling contract violation
exceptions is given below.</P><P><A NAME="@default1773"></A>
<A NAME="@default1774"></A>
<A NAME="@default1775"></A>
<A NAME="@default1776"></A>
<A NAME="@default1777"></A>
<A NAME="@default1778"></A>
<A NAME="@default1779"></A>
<A NAME="@default1780"></A>
<A NAME="@default1781"></A>
<A NAME="@default1782"></A>
<A NAME="@default1783"></A>
<A NAME="@default1784"></A>
<A NAME="@default1785"></A>
<A NAME="@default1786"></A>
<A NAME="@default1787"></A>
<A NAME="@default1788"></A>
<A NAME="@default1789"></A>
<A NAME="@default1790"></A>
<A NAME="@default1791"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> sidl.EnfPolicy
<B>import</B> sidl.PostViolation
<B>import</B> sidl.PreViolation
<B>import</B> vect.Utils

<B>import</B> sidl.ContractClass
ALL_TYPES      = sidl.ContractClass.ALLCLASSES
PRECONDITIONS  = sidl.ContractClass.PRECONDS
POSTCONDITIONS = sidl.ContractClass.POSTCONDS

<B>import</B> sidlPyArrays
<B>if</B> sidlPyArrays.type == "numpy":
  <B>from</B> numpy <B>import</B> zeros, float64, ndarray
  ArrayType = ndarray
<B>elif</B> sidlPyArrays.type == "numeric":
  <B>import</B> Numeric
  zeros = Numeric.zeros
  float64 = Numeric.Float64
  ArrayType = Numeric.ArrayType

<B>def</B> savespace(o):
  <B>try</B>:
    o.savespace(1)
  <B>except</B> AttributeError:
    <B>pass

def</B> createDouble(len):
  result = None
  <B>if</B> (len &gt;= 0):
    result = zeros((len, ), float64)
    savespace(result)
  <B>return</B> result

<FONT COLOR="blue"><I># ...</I></FONT>

  u  = createDouble(MAX_SIZE)
  v  = createDouble(MAX_SIZE)

<FONT COLOR="blue"><I># Initialize u and v.

#
# Enable FULL contract enforcement. </I></FONT>
  <B>try</B>:
    sidl.EnfPolicy.setEnforceAll(ALL_TYPES, TRUE)
  <B>except</B>:
<FONT COLOR="blue"><I>#   Handle the exception

# Do something meaningful before execute method.</I></FONT>

  <B>try</B>:
    x  = vect.Utils.vuSum(u, v)
    <B>if</B> (x != None):
<FONT COLOR="blue"><I>#     Do something with the result, x.</I></FONT>
  <B>except</B>:
    (excType, excObj, ExcTb) = sys.exc_info()
    <B>if</B> (excObj):
      <B>try</B>:
        <B>if</B> (excObj.exception.isType("sidl.PreViolation")):
<FONT COLOR="blue"><I>#         Handle precondition violation</I></FONT>
        <B>elif</B> (excObj.exception.isType("sidl.PostViolation")):
<FONT COLOR="blue"><I>#         Handle postcondition violation</I></FONT>
        <B>else</B>:
<FONT COLOR="blue"><I>#         Handle unexpected exception</I></FONT>
      <B>except</B>:
<FONT COLOR="blue"><I>#       Handle exception 

# ...</I></FONT></TD></TR>
</TABLE><P>Alternative enforcement options can be set, as described in
Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, through the two
basic helper methods: <TT>setEnforceAll</TT> and <TT>setEnforceNone</TT>.
The code snippet below shows the Python calls associated with the traditional
options of enabling only precondition enforcement, enabling postcondition
enforcement, or completely disabling contract enforcement.</P><P><A NAME="@default1792"></A>
<A NAME="@default1793"></A>
<A NAME="@default1794"></A>
<A NAME="@default1795"></A>
<A NAME="@default1796"></A>
<A NAME="@default1797"></A>
<A NAME="@default1798"></A>
<A NAME="@default1799"></A>
<A NAME="@default1800"></A>
<A NAME="@default1801"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> sidl.EnfPolicy
<B>import</B> sidl.ContractClass

<FONT COLOR="blue"><I>#
# Enable only precondition contract enforcement. 
# (Useful when only need to ensure callers comply with contract.)</I></FONT>
  <B>try</B>:
    sidl.EnfPolicy.setEnforceAll(sidl.ContractClass.PRECONDS, FALSE)
  <B>except</B>:
<FONT COLOR="blue"><I>#   Handle the exception

#
# Enable only postcondition contract enforcement. 
# (Useful when only need to ensure implementation(s) comply with contract.)</I></FONT>
  <B>try</B>:
    sidl.EnfPolicy.setEnforceAll(sidl.ContractClass.POSTCONDS, FALSE)
  <B>except</B>:
<FONT COLOR="blue"><I>#   Handle the exception

#
# Disable contract enforcement. 
# (Should only be used when have confidence in caller AND implementation.)</I></FONT>
  <B>try</B>:
    sidl.EnfPolicy.setEnforceNone(FALSE)
  <B>except</B>:
<FONT COLOR="blue"><I>#   Handle the exception</I></FONT></TD></TR>
</TABLE><P>This section illustrates the basic interfaces and processes for
traditional interface contract enforcement for a Python client.
Additional enforcement policy options and methods as well as more
information regarding the specification and enforcement of contracts
can be found in Chapter <A HREF="#c:contracts">21</A>.</P><!--TOC section Implementation-side-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc67">14.4</A>  Implementation-side</H2><!--SEC END --><P><A NAME="s:python:implementation"></A>
<A NAME="@default1802"></A></P><P>This section summarizes aspects of generating and wrapping software
written in Python. The bindings generation process is presented first.
The process for defining and managing that data is then discussed. 
The process of throwing exceptions in the implementation is then
illustrated.
Finally, the results of generating implementations with pre- and post-method
“hooks” are shown.</P><!--TOC subsection Bindings generation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.4.1  Bindings generation</H3><!--SEC END --><P><A NAME="ss:python:implgen"></A>
<A NAME="@default1803"></A>
<A NAME="@default1804"></A><A NAME="@default1805"></A></P><P>As mentioned in Subsection <A HREF="#ss:python:clientgen">14.3.1</A>, Python must
have been compiled as a shared or dynamically linked library.
To implement an object in Python, Babel must first create
the Python implementation-side bindings<SUP><A NAME="text22" HREF="#note22">2</A></SUP> as
follows:
<A NAME="@default1806"></A></P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --server=python file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -s=python file.sidl</B><BR>
</TT></BLOCKQUOTE><P>This creates the IOR, Python skeletons (i. e., <TT>_pSkel.c</TT>), and Python 
launch (i. e., <TT>_pLaunch.c</TT>) files in the current directory. 
In most cases, the IOR, <TT>_pSkel.c</TT>, and <TT>_pLaunch.c</TT> files must 
be compiled and place in a shared library.
It also creates a tree of subdirectories based on the package hierarchy found 
in <TT>file.sidl</TT> in which it generates Python extension modules for the 
client-side binding (i. e., <TT>_Module.c</TT>) and implementation (i. e., 
<TT>_Impl.py</TT>) files. The implementation files need to be filled in, as
described in Subsection <A HREF="#ss:python:impldetails">14.4.2</A>, and extension modules 
compiled as discussed in Subsection <A HREF="#ss:python:extbuild">14.4.3</A>.</P><!--TOC subsection Bindings implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.4.2  Bindings implementation</H3><!--SEC END --><P><A NAME="ss:python:impldetails"></A>
<A NAME="@default1807"></A></P><P>Implementation details must be added to the “Impl” files generated in
Subsection <A HREF="#ss:python:implgen">14.4.1</A>. Changes to these files must be made between
code splicer pairs to ensure their retention in subsequent invocations of
Babel. In fact,
Babel generates everything except the code that appears between splicer
blocks (i. e., <TT>splicer.begin</TT> and <TT>splicer.end</TT> comments). 
That is, it creates a class definition and empty methods in files whose 
names end in <TT>_Impl.py</TT>. Code placed within matching splicer pairs
will be preserved in subsequent executions of Babel while changes outside 
them will be lost.</P><P>Using the example from Subsection <A HREF="#ss:python:signatures">14.2.2</A>, the 
splicer blocks and implementation details for <TT>passeverywhere</TT> 
are:
<A NAME="@default1808"></A>
<A NAME="@default1809"></A><A NAME="@default1810"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>def</B> passeverywhere(self, d1, d3):
    <FONT COLOR="blue"><I>#
    # SIDL EXPECTED INCOMING TYPES
    # ============================
    # double d1
    # double d3
    #

    #
    # SIDL EXPECTED RETURN VALUE(s)
    # =============================
    # (_return, d2, d3)
    # double _return
    # double d2
    # double d3
    #

    # DO-NOT-DELETE splicer.begin(passeverywhere)</I></FONT>
    <B>if</B> (d1 == 3.14):
      retval = 3.14
    <B>else</B>:
      retval = 0
    <B>return</B> (retval, 3.14, -d3)
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(passeverywhere)</I></FONT></TD></TR>
</TABLE><!--TOC subsection Python Extension Modules-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.4.3  Python Extension Modules</H3><!--SEC END --><P><A NAME="ss:python:extbuild"></A>
<A NAME="@default1811"></A></P><P>Babel creates a <TT>setup.py</TT> file that can be used to build the 
Python extension modules that you create. <TT>setup.py</TT> uses the
Python distutils package to build the Python extension modules. The
following are two extra command line arguments:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>--include-dirs=</TT> — 
Use this to specify extra directories for the preprocessor
include path. That is, use it like <TT>-I</TT> is used for 
most C compilers.
</LI><LI CLASS="li-itemize"><TT>--library-dirs=</TT> — 
Use this to specify extra directories for static or shared
libraries. That is, use it like <TT>-L</TT> is used for most 
C compilers/loaders.
</LI></UL><P>The directory containing the SIDL runtime and Python headers 
is normally specified with <TT>--include-dirs=</TT>. The 
directory where <TT>libsidl.so</TT> is stored must also be specified.
The following is a hypothetical example:</P><BLOCKQUOTE CLASS="quotation"><TT>
setup.py --include-dirs=/usr/local/include<BR>
 --include-dirs=/usr/local/include/python<BR>
 --library-dirs=/usr/local/lib build_ext --inplace
</TT></BLOCKQUOTE><P>although any real installation is unlikely to actually use those settings.</P><!--TOC subsection Private data-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.4.4  Private data</H3><!--SEC END --><P>
<A NAME="@default1812"></A>
<A NAME="@default1813"></A></P><P>Any variables declared in the implementation source file will, by virtue
of Babel’s encapsulation, be private. 
</P><P><EM><B>NOTE</B>:
Python does not support the built-in, class-wide <TT>_load()</TT> method 
used for one-time initialization in the other language bindings.
</EM></P><!--TOC subsection Exception throwing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.4.5  Exception throwing</H3><!--SEC END --><P>
<A NAME="@default1814"></A><A NAME="@default1815"></A></P><P>Recall Subsection <A HREF="#sss:python:exceptions">14.2.3</A> discussed issues associated
with support for SIDL exceptions. 
Below is an example snippet of code for throwing the exceptions that are
caught in the Subsection <A HREF="#ss:python:exceptioncatching">14.3.7</A> example.
The <TT>setNote</TT> method provides a useful error message,
and the <TT>add</TT> method helps provide a multi-language traceback
capability — provided each layer of the call stack calls <TT>add</TT>.
<A NAME="@default1816"></A>
<A NAME="@default1817"></A><A NAME="@default1818"></A>
<A NAME="@default1819"></A><A NAME="@default1820"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>def</B> getFib(self, n, max_depth, max_value, depth):
    <FONT COLOR="blue"><I># sidl EXPECTED INCOMING TYPES
    # ============================
    # int n, max_depth, max_value, depth
    #
    # sidl EXPECTED RETURN VALUE(s)
    # =============================
    # int _return
    # DO-NOT-DELETE splicer.begin(getFib)</I></FONT>
    <B>if</B> (n &lt; 0):
      ex = ExceptionTest.NegativeValueException.NegativeValueException()
      ex.setNote("n negative")
      ex.add(__name__, 0, "ExceptionTest.Fib.getFib")
      <B>raise</B> ExceptionTest.NegativeValueException._Exception, ex
    <FONT COLOR="blue"><I># numerous lines deleted
    # DO-NOT-DELETE splicer.end(getFib)</I></FONT></TD></TR>
</TABLE><!--TOC subsection Hooks implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->14.4.6  Hooks implementation</H3><!--SEC END --><P><A NAME="ss:python:hooksimpl"></A>
<A NAME="@default1821"></A><A NAME="@default1822"></A>
<A NAME="@default1823"></A>
<A NAME="@default1824"></A><A NAME="@default1825"></A>
<A NAME="@default1826"></A><A NAME="@default1827"></A></P><P>As discussed in Subsection <A HREF="#ss:python:sethooks">14.3.8</A>, when hooks execution
is enabled, implementation-specific instrumentation is executed. Using
the <B><TT><CODE>--</CODE>generate-hooks</TT></B> option on the Babel
command line when generating implementation-side bindings results
in the automatic generation of a <TT>_pre</TT> and <TT>_post</TT>
method for every static and non-static method associated with each class
in the specification. For the <TT>aStaticMethod</TT> specified in
Subsection <A HREF="#ss:python:sethooks">14.3.8</A>, the generated <TT>_pre</TT> method
implementation is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>def</B> aStaticMeth_pre(i, io):
  <FONT COLOR="blue"><I>#
  # sidl EXPECTED INCOMING TYPES
  # ============================
  # int i
  # int io
  #

  #
  # sidl EXPECTED RETURN VALUE(s)
  # =============================
  # # None
  #</I></FONT>

  """\
Basic illustration of hooks for static methods.
"""
  <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(aStaticMeth_pre)
  # 
  # Add instrumentation here to be executed immediately prior
  # to dispatch to aStaticMeth().
  # </I></FONT>
  <B>return</B>
  <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(aStaticMeth_pre)</I></FONT></TD></TR>
</TABLE><P>while that of the <TT>_post</TT> method is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>def</B> aStaticMeth_post(i, o, io, _retval):
  <FONT COLOR="blue"><I>#
  # sidl EXPECTED INCOMING TYPES
  # ============================
  # int i
  # int o
  # int io
  # int _retval
  #

  #
  # sidl EXPECTED RETURN VALUE(s)
  # =============================
  # # None
  #</I></FONT>

  """\
Basic illustration of hooks for static methods.
"""
  <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(aStaticMeth_post)
  #
  # Add instrumentation here to be executed immediately after
  # return from dispatch to aStaticMeth().
  # </I></FONT>
  <B>return</B>
  <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(aStaticMeth_post)</I></FONT></TD></TR>
</TABLE><P>Per the normal implementation process, the desired instrumentation
should be added within the splicer blocks of
<TT>aStaticMethod_pre</TT> and
<TT>aStaticMethod_post</TT>. As stated in the comments
within those blocks, <TT>aStaticMethod_pre</TT> will be
executed immediately prior to dispatch to <TT>aStaticMethod</TT> when the
latter is invoked by a client. Assuming no exceptions are encountered,
<TT>aStaticMethod_post</TT> is executed immediately upon
return from <TT>aStaticMethod</TT>.
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note21" HREF="#text21">1</A></DT><DD CLASS="dd-thefootnotes">For 
information on additional command line options, refer to 
Section <A HREF="#s:basics_commandline">4.2</A>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note22" HREF="#text22">2</A></DT><DD CLASS="dd-thefootnotes">For information on additional 
command line options, refer to Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter SIDL Backend-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc68">Chapter 15</A>  SIDL Backend</H1><!--SEC END --><P><A NAME="c:sidl_backend"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc69">15.1</A>  Introduction</H2><!--SEC END --><P>
This chapter introduces the SIDL backend associated with symbols that may 
originate from a SIDL file or the corresponding Extensible Markup Language 
(XML) representation. Unlike most of the other supported language bindings,
the output from this backend is textual in nature. That is, it is the textual, 
human-readable form of the interfaces description. An alternative text form,
XML that is, which is also supported is described in Chapter
 <A HREF="#c:xml_backend">16</A>.</P><!--TOC section Purpose-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc70">15.2</A>  Purpose</H2><!--SEC END --><P>
The primary reason for having a SIDL backend is to provide a mechanism for 
generating human-readable text for interfaces that are written in conformant 
XML. It is important to emphasize that Babel requires the XML to conform to 
the SIDL DTD in order to benefit from this feature. </P><P>Generating SIDL provides a feature to collaborators who are interested in 
experimenting with the XML form of the interfaces. Such groups should find 
the more human-readable descriptions of the interfaces to be helpful for 
distribution and discussion.</P><!--TOC section Generated versus Original SIDL files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc71">15.3</A>  Generated versus Original SIDL files</H2><!--SEC END --><P>
<A NAME="@default1828"></A>
Generated SIDL files may differ from their original SIDL files in several 
respects in terms of content as well as layout. These differences are 
summarized below.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Packages.</B></DT><DD CLASS="dd-description"> The code generation is limited to one high-level package
per generated file. In fact, the name of the generated file is currently 
defined to be the concatenation of the name of the highest-level package and 
<TT>.sidl</TT>. </DD><DT CLASS="dt-description"><B>Versioning.</B></DT><DD CLASS="dd-description"> The generation of requires statements is inferred from the 
symbols that actually appear in the associated interface descriptions. The 
intent is to provide a requires statement for only the highest level package 
needed of a given version. Consequently, requires and imports statements that 
were not necessary for resolving symbols will not appear. Also, fully 
qualified names will be shortened in the generated files due to the automatic 
generation of the associated requires statement(s). Finally, since an import 
and require statement can be used in a SIDL file and no distinction is made in 
the XML, only a require statement will appear in the generated file.</DD><DT CLASS="dt-description"><B>Implements.</B></DT><DD CLASS="dd-description"> Since there is no distinction between <FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT>
and <FONT COLOR=maroon><I><TT>implements</TT></I></FONT> in the XML version of the interfaces, the generated code 
outputs <FONT COLOR=maroon><I><TT>implements</TT></I></FONT> along with the inherited methods.</DD><DT CLASS="dt-description"><B>Comments.</B></DT><DD CLASS="dd-description"> Babel preserves only document, or doc, comments so any 
comments that do not conform will not appear in the generated file
<SUP><A NAME="text23" HREF="#note23">1</A></SUP>.</DD><DT CLASS="dt-description"><B>Whitespace.</B></DT><DD CLASS="dd-description"> Obviously there may be whitespace differences in the 
generated file. These include indentation, blank spaces and lines, and brace 
placement.</DD></DL><P>As an example, suppose we have a package in the file <TT>foo.sidl</TT>. The 
original file’s contents are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> foo <B>version</B> 1.0 {

  <B>class</B> A {}

  <B>package</B> bar <B>version</B> 2.0 {
    <B>class</B> B {}
  }

}</I></FONT></TD></TR>
</TABLE><P>The resulting contents of the generated SIDL file are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> foo <B>version</B> 1.0 {

  <B>class</B> A {
  }

  <B>package</B> bar <B>version</B> 2.0 {

    <B>class</B> B {
    }

  }


}</I></FONT></TD></TR>
</TABLE><P>Notice the differences in white space. To illustrate more features, further 
suppose we have a package in the file <TT>fooTest.sidl</TT>. The original file’s 
contents are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>// An ignored comment
<B>require</B> foo <B>version</B> 1.0;
<B>require</B> foo.bar <B>version</B> 2.0;

/**
 * Test of doc comment with XML special characters &lt; &amp; &gt;.
 */
<B>package</B> fooTest <B>version</B> 0.1 {

  /**
   * Another doc comment for an empty class.
   */
  <B>class</B> A <B>extends</B> foo.bar.B {}

  <B>class</B> B <B>extends</B> foo.A {}
}</I></FONT></TD></TR>
</TABLE><P>The resulting contents of the generated SIDL file are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>require</B> foo <B>version</B> 1.0;
<B>require</B> foo.bar <B>version</B> 2.0;

/**
 * Test of doc comment with XML special characters &lt; &amp; &gt;.
 */
<B>package</B> fooTest <B>version</B> 0.1 {

  /**
   * Another doc comment for an empty class.
   */
  <B>class</B> A <B>extends</B> foo.bar.B {
  }

  <B>class</B> B <B>extends</B> foo.A {
  }

}</I></FONT></TD></TR>
</TABLE><P>Here we see the exclusion of non-document comments and the retention of 
document comments. Refer to Section <A HREF="#s:basics_sidl">6.2</A> and 
Appendix <A HREF="#c:xml">C</A> for more information about document comments.</P><!--TOC section XML File Comparison-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc72">15.4</A>  XML File Comparison</H2><!--SEC END --><P>
Testing has revealed that XML generated from the original SIDL file compared 
to XML generated from generated SIDL files have only minor differences. In 
fact, the differences are limited to specific metadata fields. Specifically, 
the date, source-url, and source-line entries can differ. The dates, however, 
will be the same if the “<TT>--suppress-timestamp</TT>” option was used when 
both XML files were generated. Similarly, the source-line entries will be the 
same if the package started on the same line in both the original and generated 
SIDL files. The latter can happen if, for instance, there are no non-doc 
comments in the original file.</P><!--TOC section Babel Command Line Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc73">15.5</A>  Babel Command Line Options</H2><!--SEC END --><P>
<A NAME="@default1829"></A>
To generate SIDL from a file using the default repository to resolve symbols, 
you should invoke Babel as follows <SUP><A NAME="text24" HREF="#note24">2</A></SUP>:</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --text=SIDL file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or use the short form
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -tSIDL file.sidl</B><BR>
</TT></BLOCKQUOTE><P>Alternatively, you can generate SIDL from XML symbols, again assuming the 
default repository is used to resolve symbols, by typing the following at the 
command line:</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --text=SIDL packagename</B><BR>
</TT></BLOCKQUOTE><P>
or use the short form
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -tSIDL packagename</B><BR>
</TT></BLOCKQUOTE><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note23" HREF="#text23">1</A></DT><DD CLASS="dd-thefootnotes">For more information on comments and doc-comments, refer to 
<B>Comments and Doc-Comments</B> in Section <A HREF="#s:basics_sidl">6.2</A>.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note24" HREF="#text24">2</A></DT><DD CLASS="dd-thefootnotes">For information on additional 
command line options, refer to Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter XML Backend-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc74">Chapter 16</A>  XML Backend</H1><!--SEC END --><P><A NAME="c:xml_backend"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc75">16.1</A>  Introduction</H2><!--SEC END --><P>
This chapter introduces the XML representation supported by Babel. Here we
describe the motivation for having an XML backend and the basic structure of 
a conformant XML file. To illustrate, a few of the SIDL symbol XML files 
will be presented.</P><P>Details regarding the layout of XML files can be obtained by referring to the 
Document Type Definition (DTD) provided in Appendix <A HREF="#c:xml">C</A>. For more on 
the type repositories, refer to[XML Repositories in 
Section <A HREF="#s:basics_sidl">6.2</A>.</P><!--TOC section Purpose-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">16.2</A>  Purpose</H2><!--SEC END --><P>
<A NAME="@default1830"></A>
The XML backend is a key feature of Babel. It provides the basis upon which 
the symbol, or type, repository depends. SIDL files should be translated into 
their XML representations and stored in the type repository. This is the case
for the SIDL interfaces and classes that are provided as part of the Babel 
toolkit.</P><!--TOC section Basic Structure-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc77">16.3</A>  Basic Structure</H2><!--SEC END --><P>
<A NAME="@default1831"></A>
Each generated XML file specifies the interfaces for a given SIDL Symbol in an 
expanded textual representation. Although the structure of a given file 
depends upon the type of symbol it contains, the basic layout consists of a 
set of common elements followed by symbol-specific elements. </P><!--TOC subsection Common Elements-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Common Elements</H3><!--SEC END --><P>
The common elements are <EM>prolog</EM>, <EM>document type</EM>, <EM>name</EM>, 
<EM>metadata</EM>, and <EM>comment</EM>. These elements, which are described 
below, are followed by symbol-specific information.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Prolog.</B></DT><DD CLASS="dd-description"> The prolog simply identifies the XML version and 
encoding scheme associated with the file.</DD><DT CLASS="dt-description"><B>Document Type.</B></DT><DD CLASS="dd-description"> The document type declaration states the 
document contains a <EM>Symbol</EM> and it identifies the associated DTD (i. e., 
<EM>sidl.dtd</EM>).</DD><DT CLASS="dt-description"><B>Name.</B></DT><DD CLASS="dd-description"> The symbol name is the first element within the symbol 
tag pair and it identifies the name and version of the SIDL symbol that is 
described in the file.</DD><DT CLASS="dt-description"><B>Metadata.</B></DT><DD CLASS="dd-description"> The metadata element identifies the date the XML file 
was generated<SUP><A NAME="text25" HREF="#note25">1</A></SUP> along with a set of three key-value pair entries. The first, 
<EM>source-url</EM>, identifies the URL of the SIDL file that was used to 
generate the XML file. The second, <EM>source-line</EM>, identifies the line 
within the SIDL file at which the symbol was first detected. Finally, 
<EM>babel-version</EM> identifies the version of Babel that was used to generate 
the XML file.</DD><DT CLASS="dt-description"><B>Comment.</B></DT><DD CLASS="dd-description"> The comment tag is used to save off any comment that 
is associated with the symbol.</DD></DL><!--TOC subsection Packages-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Packages</H3><!--SEC END --><P>
<A NAME="@default1832"></A>
In addition to the common elements, packages retain elements and attributes
associated with SIDL packages. These include whether or not the package is 
<EM>final</EM> along with a list of the symbols contained within the package. 
The list of symbols consists of the tuple: name, type, and version.</P><P>For example, the XML representation of the toplevel SIDL package (i. e., 
<FONT COLOR=maroon><I><TT>sidl</TT></I></FONT>) is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>XML</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE Symbol PUBLIC "-//CCA//sidl Symbol DTD v1.1//EN"
  "/babel/share/repository/sidl.dtd"&gt;
&lt;Symbol&gt;
  &lt;SymbolName name="sidl" version="0.9.12" /&gt;
  &lt;Metadata date="20051208 10:47:28 PST"&gt;
    &lt;MetadataEntry key="source-url"
    value="file:/babel/runtime/sidl/sidl.sidl" /&gt;
    &lt;MetadataEntry key="babel-version" value="0.10.51" /&gt;
    &lt;MetadataEntry key="xml-url"
    value="/babel/share/repository/sidl-v0.9.12.xml" /&gt;
    &lt;MetadataEntry key="source-line" value="39" /&gt;
  &lt;/Metadata&gt;
  &lt;Comment&gt;The
  &lt;code&gt;sidl&lt;/code&gt;package contains the fundamental type and
  interface definitions for the
  &lt;code&gt;sidl&lt;/code&gt;interface definition language. It defines common
  run-time libraries and common base classes and interfaces. Every
  interface implicitly inherits from
  &lt;code&gt;sidl.BaseInterface&lt;/code&gt;and every class implicitly
  inherits from
  &lt;code&gt;sidl.BaseClass&lt;/code&gt;.&lt;/Comment&gt;
  &lt;Package final="false"&gt;
    &lt;PackageSymbol name="BaseInterface" type="interface"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="BaseClass" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="io" type="package" version="0.9.12" /&gt;
    &lt;PackageSymbol name="BaseException" type="interface"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="RuntimeException" type="interface"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="SIDLException" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="PreViolation" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="PostViolation" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="InvViolation" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="Scope" type="enum" version="0.9.12" /&gt;
    &lt;PackageSymbol name="Resolve" type="enum" version="0.9.12" /&gt;
    &lt;PackageSymbol name="DLL" type="class" version="0.9.12" /&gt;
    &lt;PackageSymbol name="Finder" type="interface"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="DFinder" type="class" version="0.9.12" /&gt;
    &lt;PackageSymbol name="Loader" type="class" version="0.9.12" /&gt;
    &lt;PackageSymbol name="ClassInfo" type="interface"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="ClassInfoI" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="MemoryAllocationException" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="CastException" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="LangSpecificException" type="class"
    version="0.9.12" /&gt;
    &lt;PackageSymbol name="rmi" type="package" version="0.9.12" /&gt;
  &lt;/Package&gt;
&lt;/Symbol&gt;</TD></TR>
</TABLE><!--TOC subsection Interfaces-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Interfaces</H3><!--SEC END --><P>
<A NAME="@default1833"></A>
Similarly, the XML for interface symbols contain the common elements. In 
addition, they retain elements and attributes associated with SIDL interfaces. 
These include any extensions, parent interfaces it implements, and its methods.
Method information includes its name, communication mode, short name, name 
extension (for languages that don’t support method overloading), comment, 
return type, argument list, and exception list.</P><P>For example, the XML representation of <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>XML</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE Symbol PUBLIC "-//CCA//sidl Symbol DTD v1.1//EN"
  "/babel/share/repository/sidl.dtd"&gt;
&lt;Symbol&gt;
  &lt;SymbolName name="sidl.BaseInterface" version="0.9.12" /&gt;
  &lt;Metadata date="20051208 10:47:28 PST"&gt;
    &lt;MetadataEntry key="source-url"
    value="file:/babel/runtime/sidl/sidl.sidl" /&gt;
    &lt;MetadataEntry key="babel-version" value="0.10.51" /&gt;
    &lt;MetadataEntry key="xml-url"
    value="/babel/share/repository/sidl.BaseInterface-v0.9.12.xml" /&gt;
    &lt;MetadataEntry key="source-line" value="46" /&gt;
  &lt;/Metadata&gt;
  &lt;Comment&gt;Every interface in
  &lt;code&gt;sidl&lt;/code&gt;implicitly inherits from
  &lt;code&gt;BaseInterface&lt;/code&gt;, and it is implemented by
  &lt;code&gt;BaseClass&lt;/code&gt;below.&lt;/Comment&gt;
  &lt;Interface&gt;
    &lt;ExtendsBlock /&gt;
    &lt;AllParentInterfaces /&gt;
    &lt;MethodsBlock&gt;
      &lt;Method communication="normal" copy="false"
      definition="abstract" extension="" shortname="addRef"&gt;
        &lt;Comment&gt;
          &lt;p&gt;Add one to the intrinsic reference count in the
          underlying object. Object in
          &lt;code&gt;sidl&lt;/code&gt;have an intrinsic reference count.
          Objects continue to exist as long as the reference count
          is positive. Clients should call this method whenever
          they create another ongoing reference to an object or
          interface.&lt;/p&gt;
          &lt;p&gt;This does not have a return value because there is no
          language independent type that can refer to an interface
          or a class.&lt;/p&gt;
        &lt;/Comment&gt;
        &lt;Type type="void" /&gt;
        &lt;ArgumentList /&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="abstract" extension="" shortname="deleteRef"&gt;
        &lt;Comment&gt;Decrease by one the intrinsic reference count in
        the underlying object, and delete the object if the
        reference is non-positive. Objects in
        &lt;code&gt;sidl&lt;/code&gt;have an intrinsic reference count. Clients
        should call this method whenever they remove a reference to
        an object or interface.&lt;/Comment&gt;
        &lt;Type type="void" /&gt;
        &lt;ArgumentList /&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="abstract" extension="" shortname="isSame"&gt;
        &lt;Comment&gt;Return true if and only if
        &lt;code&gt;obj&lt;/code&gt;refers to the same object as this
        object.&lt;/Comment&gt;
        &lt;Type type="boolean" /&gt;
        &lt;ArgumentList&gt;
          &lt;Argument copy="false" mode="in" name="iobj"&gt;
            &lt;Type type="symbol"&gt;
              &lt;SymbolName name="sidl.BaseInterface"
              version="0.9.12" /&gt;
            &lt;/Type&gt;
          &lt;/Argument&gt;
        &lt;/ArgumentList&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="abstract" extension="" shortname="isType"&gt;
        &lt;Comment&gt;Return whether this object is an instance of the
        specified type. The string name must be the
        &lt;code&gt;sidl&lt;/code&gt;type name. This routine will return
        &lt;code&gt;true&lt;/code&gt;if and only if a cast to the string type
        name would succeed.&lt;/Comment&gt;
        &lt;Type type="boolean" /&gt;
        &lt;ArgumentList&gt;
          &lt;Argument copy="false" mode="in" name="name"&gt;
            &lt;Type type="string" /&gt;
          &lt;/Argument&gt;
        &lt;/ArgumentList&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="abstract" extension="" shortname="getClassInfo"&gt;
        &lt;Comment&gt;Return the meta-data about the class implementing
        this interface.&lt;/Comment&gt;
        &lt;Type type="symbol"&gt;
          &lt;SymbolName name="sidl.ClassInfo" version="0.9.12" /&gt;
        &lt;/Type&gt;
        &lt;ArgumentList /&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
    &lt;/MethodsBlock&gt;
  &lt;/Interface&gt;
&lt;/Symbol&gt;</TD></TR>
</TABLE><!--TOC subsection Classes-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Classes</H3><!--SEC END --><P>
<A NAME="@default1834"></A>
Class definitions are almost identical to that of interfaces except for
additional attributes. The additional attribute, which include whether or 
not the class is <EM>final</EM>. Recall that Babel/SIDL supports only single
inheritance of classes; therefore, only a single class will appear in the
extends block. If one does not appear in the original SIDL file, by default
the class will extend <FONT COLOR=maroon><I><TT>sidl.Baseclase</TT></I></FONT>.</P><P>For example, the XML representation of <FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT> is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>XML</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE Symbol PUBLIC "-//CCA//sidl Symbol DTD v1.1//EN"
  "/babel/share/repository/sidl.dtd"&gt;
&lt;Symbol&gt;
  &lt;SymbolName name="sidl.BaseClass" version="0.9.12" /&gt;
  &lt;Metadata date="20051208 10:47:28 PST"&gt;
    &lt;MetadataEntry key="source-url"
    value="file:/babel/runtime/sidl/sidl.sidl" /&gt;
    &lt;MetadataEntry key="babel-version" value="0.10.51" /&gt;
    &lt;MetadataEntry key="xml-url"
    value="/babel/share/repository/sidl.BaseClass-v0.9.12.xml" /&gt;
    &lt;MetadataEntry key="source-line" value="97" /&gt;
  &lt;/Metadata&gt;
  &lt;Comment&gt;Every class implicitly inherits from
  &lt;code&gt;BaseClass&lt;/code&gt;. This class implements the methods in
  &lt;code&gt;BaseInterface&lt;/code&gt;.&lt;/Comment&gt;
  &lt;Class abstract="false"&gt;
    &lt;Extends /&gt;
    &lt;ImplementsBlock&gt;
      &lt;SymbolName name="sidl.BaseInterface" version="0.9.12" /&gt;
    &lt;/ImplementsBlock&gt;
    &lt;AllParentClasses /&gt;
    &lt;AllParentInterfaces&gt;
      &lt;SymbolName name="sidl.BaseInterface" version="0.9.12" /&gt;
    &lt;/AllParentInterfaces&gt;
    &lt;MethodsBlock&gt;
      &lt;Method communication="normal" copy="false"
      definition="final" extension="" shortname="addRef"&gt;
        &lt;Comment&gt;
          &lt;p&gt;Add one to the intrinsic reference count in the
          underlying object. Object in
          &lt;code&gt;sidl&lt;/code&gt;have an intrinsic reference count.
          Objects continue to exist as long as the reference count
          is positive. Clients should call this method whenever
          they create another ongoing reference to an object or
          interface.&lt;/p&gt;
          &lt;p&gt;This does not have a return value because there is no
          language independent type that can refer to an interface
          or a class.&lt;/p&gt;
        &lt;/Comment&gt;
        &lt;Type type="void" /&gt;
        &lt;ArgumentList /&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="final" extension="" shortname="deleteRef"&gt;
        &lt;Comment&gt;Decrease by one the intrinsic reference count in
        the underlying object, and delete the object if the
        reference is non-positive. Objects in
        &lt;code&gt;sidl&lt;/code&gt;have an intrinsic reference count. Clients
        should call this method whenever they remove a reference to
        an object or interface.&lt;/Comment&gt;
        &lt;Type type="void" /&gt;
        &lt;ArgumentList /&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="final" extension="" shortname="isSame"&gt;
        &lt;Comment&gt;Return true if and only if
        &lt;code&gt;obj&lt;/code&gt;refers to the same object as this
        object.&lt;/Comment&gt;
        &lt;Type type="boolean" /&gt;
        &lt;ArgumentList&gt;
          &lt;Argument copy="false" mode="in" name="iobj"&gt;
            &lt;Type type="symbol"&gt;
              &lt;SymbolName name="sidl.BaseInterface"
              version="0.9.12" /&gt;
            &lt;/Type&gt;
          &lt;/Argument&gt;
        &lt;/ArgumentList&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="normal" extension="" shortname="isType"&gt;
        &lt;Comment&gt;Return whether this object is an instance of the
        specified type. The string name must be the
        &lt;code&gt;sidl&lt;/code&gt;type name. This routine will return
        &lt;code&gt;true&lt;/code&gt;if and only if a cast to the string type
        name would succeed.&lt;/Comment&gt;
        &lt;Type type="boolean" /&gt;
        &lt;ArgumentList&gt;
          &lt;Argument copy="false" mode="in" name="name"&gt;
            &lt;Type type="string" /&gt;
          &lt;/Argument&gt;
        &lt;/ArgumentList&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
      &lt;Method communication="normal" copy="false"
      definition="final" extension="" shortname="getClassInfo"&gt;
        &lt;Comment&gt;Return the meta-data about the class implementing
        this interface.&lt;/Comment&gt;
        &lt;Type type="symbol"&gt;
          &lt;SymbolName name="sidl.ClassInfo" version="0.9.12" /&gt;
        &lt;/Type&gt;
        &lt;ArgumentList /&gt;
        &lt;ThrowsList /&gt;
        &lt;ImplicitThrowsList&gt;
          &lt;SymbolName name="sidl.RuntimeException"
          version="0.9.12" /&gt;
        &lt;/ImplicitThrowsList&gt;
      &lt;/Method&gt;
    &lt;/MethodsBlock&gt;
  &lt;/Class&gt;
&lt;/Symbol&gt;</TD></TR>
</TABLE><!--TOC section Command Line Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc78">16.4</A>  Command Line Options</H2><!--SEC END --><P>
<A NAME="@default1835"></A></P><P>XML must be generated from a SIDL file. The Babel command line is as follows
<SUP><A NAME="text26" HREF="#note26">2</A></SUP>:</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel --exclude-external --text=XML file.sidl</B><BR>
</TT></BLOCKQUOTE><P>
or simply
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -E -tXML file.sidl</B><BR>
</TT></BLOCKQUOTE><P>In both cases, the use of the default repository is assumed for resolving 
symbols. In addition, the output will appear in the default output directory. 
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note25" HREF="#text25">1</A></DT><DD CLASS="dd-thefootnotes">Assuming the “<TT>--suppress-timestamp</TT>” option
was not used.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note26" HREF="#text26">2</A></DT><DD CLASS="dd-thefootnotes">For information on additional command line options, refer to 
Section <A HREF="#s:basics_commandline">4.2</A>.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter HTML Interface Documentation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc79">Chapter 17</A>  HTML Interface Documentation</H1><!--SEC END --><P><A NAME="c:html"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc80">17.1</A>  Introduction</H2><!--SEC END --><P>Babel can automatically create interface documentation using the HTML
backend. This capability is modeled after the javadoc documentation
available with Java. It is invoked with the <TT>--text=html</TT> command
line option.
</P><!--TOC part Advanced Topics-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc81">Part III</A><BR>
Advanced Topics</H1></TD></TR>
</TABLE><!--SEC END --><!--TOC chapter Remote Method Invocation-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc82">Chapter 18</A>  Remote Method Invocation</H1><!--SEC END --><P><A NAME="c:build"></A></P><P><BR>
</P><!--TOC section What is RMI?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc83">18.1</A>  What is RMI?</H2><!--SEC END --><P><A NAME="s:RMIintro"></A>
<A NAME="@default1836"></A></P><P>In classic Babel, all calls are in-process. That is, everything Babel
generates is loaded into the same process. This means inter-language
Babel calls use the same mechanisms as normal function calls. This
makes calls between languages extremely fast. However, many systems
also have a need for Remote Procedure Calls (RPC),<A NAME="@default1837"></A> that is, calls made
between different processes, or even machines over a network. Remote
Method Invocation (RMI) is Babel’s answer to this need.</P><P>RMI is Object Oriented RPC. However, unlike RPC where calls are made
to procedures on a specified machine, in RMI calls are made on
objects. The call is run on whichever machine the object resides on.</P><P>There are several reasons why an application may choose to use
RMI. The main reasons are wrapping code tied to particular hardware,
wrapping code tied to a particular operating system release,
coarse-grained parallel<A NAME="@default1838"></A> execution, or greater encapsulation. With RMI,
you can make code that’s tied to a particular machine available to
programs running on other platforms. You can utilize multi-CPU<A NAME="@default1839"></A>
systems to concurrently solve problems using RMI. RMI can solve
problems that sometimes occur when you put two codes in the same
address space. For example, two Fortran codes may use the same logical
unit numbers (similar to C file numbers), or two codes may both need a
customized form of a third party library. Bringing both codes into the
same process may cause a symbol collision for the third party library,
and one code gets the wrong version of the library.</P><P>Despite the radical low-level differences between RMI and classic
Babel, the user interfaces are nearly identical. In fact, if a
library writer does not care if an object is remote or not, they
simply do not need to know. RMI support requires a few simple calls to 
set up the infrastructure, but almost everything else is handled 
automatically by the Babel runtime library. Babel also has a few RMI
support functions and a special remote constructor. </P><!--TOC section Babel RMI Concepts-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc84">18.2</A>  Babel RMI Concepts</H2><!--SEC END --><P><A NAME="s:RMIconcepts"></A></P><P>For normal function calls, arguments are passed by initializing
registers and pushing things onto the system stack. In RMI, function
arguments and return values are passed by a network protocol. From a
programmers point of view, the only difference between normal and
network function calls is that network function calls have more
failure modes. Anything that can disturb a network connection, such as
a router going offline, can cause a RMI call to fail.</P><P>Conceptually, the RMI view of the world can be thought of as 1 or more
Babel Object Servers (BOSs) <A NAME="@default1840"></A><A NAME="@default1841"></A>
that a client can connect to in order to create
or use objects on those servers. Of course, any server can also
connect as a client to any other server, and any client can become a
server simply by starting up a BOS of it’s own.</P><P>This makes Babel RMI very flexible, and accepting of whatever
client-server relationships the application writers choose to use.
Web Services <A NAME="@default1842"></A> users of Babel tend to use traditional client-server
models, while scientific distributed systems<A NAME="@default1843"></A> 
users tend toward
peer-to-peer usage.</P><!--TOC subsection RMI Protocols-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.2.1  RMI Protocols</H3><!--SEC END --><P><A NAME="ss:RMIprotocols"></A>
<A NAME="@default1844"></A></P><P>The first thing any user of Babel RMI has to do is choose a Babel RMI
protocol. Babel RMI can use any protocol that implements the Babel
RMI API, but a client and a server using different protocols probably
cannot communicate. </P><P>A Babel RMI protocol may be built on any low level protocol (such as
TCP/IP) that the protocol implementer wishes to use. This should not
affect the user at all. The protocol controls the details of how
arguments and return values are converted to a stream of bytes that
can be shipped across the network and read by the other process.</P><P>Currently there is only one protocol that fully implements the Babel
RMI API, and it is included with Babel in the runtime/sidlx <A NAME="@default1845"></A>
directory. It is called “Simple Protocol.”<A NAME="@default1846"></A> 
<A NAME="@default1847"></A> However, there are many
other protocols currently under development (at least four.) Soon
there will be a number of choices, including protocols specifically
tuned for high-performance scientific computing, web services, and
CORBA[<A HREF="#CORBA"></A>]<A NAME="@default1848"></A> compatibility.</P><!--TOC subsection Babel Object Server-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.2.2  Babel Object Server</H3><!--SEC END --><P><A NAME="ss:RMIservers"></A></P><P>The next thing that a user needs is a BOS to connect to. The BOS is
implemented by the protocol writers as a library. As mentioned
before, the BOS may be run by itself, by a small driver program, or run
as part of a program that also acts as a client. 
There is an example of a small driver program in contrib/babel-rmi/orb.</P><P>The BOS is accessed by a protocol specific URL. A URL<A NAME="@default1849"></A>
is a string the uniquely identifies a network resource. Most people are aware of
Internet URLs like: <TT>http://www.llnl.gov/CASC/components/babel.html</TT>
(which is the URL for the Babel web page). Babel RMI also uses URLs, but
they are mostly protocol specific. Babel RMI only uses the portion of
the URL up to the first non-alphanumeric character to identify the
protocol that is being used. The rest of the URL is passed on to the protocol.
This means that while “Simple Protocol” URLs look like this:</P><P><TT>simhandle://pc3.nowhere.com:9999/</TT></P><P>one can also imagine URLs of the form:</P><P><TT>weird://05:16:5B:BD:E1:73/</TT></P><P>for the weird protocol, or:</P><P><TT>weird+SSL://05:16:5B:BD:E1:73/</TT></P><P>for running the weird protocol over SSL. Babel RMI itself does not attempt
to parse anything past the first non-alphanumeric character, so most
of the URL is entirely protocol dependent.</P><!--TOC subsection Object Creation and Connection-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.2.3  Object Creation and Connection</H3><!--SEC END --><P><A NAME="ss:RMIcreateconnect"></A>
<A NAME="@default1850"></A> <A NAME="@default1851"></A> <A NAME="@default1852"></A> <A NAME="@default1853"></A></P><P>There are two main ways of accessing objects on a remote server,
creation and connection. </P><P>A client may create a remote object with the Babel built-in
<FONT COLOR=maroon><I><TT>static _createRemote(in string URL)</TT></I></FONT> method. This asks the remote
server given in the URL to create an object. For example, the C function</P><P><TT>foo_Bar b = foo_Bar__createRemote(‘‘simhandle://pc3:9999/’’);</TT></P><P>will create an object of type foo.Bar on the server running on pc3
port<A NAME="@default1854"></A><A NAME="@default1855"></A> 9999 using the “Simple Protocol.”</P><P><TT>foo_Bar b</TT> may now be passed around exactly like a normal Babel object,
except that all calls on b will actually run on pc3.</P><P>However, in some cases, an object already exists on a remote server
that the user just wants to access. In this case, the object can be
connected to via the built-in <FONT COLOR=maroon><I><TT>static _connect(in string URL)</TT></I></FONT> method. The only
difference is, in this case the URL must include an object ID to
uniquely identify the object desired on the BOS. For example:</P><P><TT>foo_Bar b = foo_Bar__connect(‘‘simhandle://pc3:9999/Bar1025’’);</TT></P><P>here again, <TT>foo_Bar b</TT> may now be used exactly like any other Babel
object. To relate back to normal Babel, connection is kind of like an
active addRef. The user actively goes and gets his own reference to a
given object.</P><P><TT>_connect</TT> is actually used by Babel internally whenever objects
are passed remotely as arguments. In fact, users will probably rarely
use connect directly, most often it will be done automatically by
Babel when objects are passed remotely. <TT>_connect</TT> is exposed to the
user mostly for Web Services, where the objectID may always be the
same, and for special boot strapping uses.</P><!--TOC subsection RMI Arguments-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.2.4  RMI Arguments</H3><!--SEC END --><P><A NAME="ss:RMIobjargs"></A></P><P>All basic types are passed by value in Babel RMI. They are
actually copied across the network. This is reasonable since they are
small. Arrays are also copy-only, so anytime an array is passed
remotely through Babel RMI, it is actually copied to the remote
machine.</P><P>Because arrays are copy-only for RMI, there is a noticeable difference
in the behavior of an <TT>in array</TT><A NAME="@default1856"></A> argument between a non-RMI call
and an RMI call. For the non-RMI call, the code implementing the
method can change elements of the incoming array. Because the caller
and callee share the same array, the caller’s copy of the array will
also be changed. For an RMI call, even if the code implementing the
method changes elements of the incoming array, the caller’s copy can
never be modified because the client and server each have a distinct
copy of the array data.</P><P>There are two ways one can pass objects <A NAME="@default1857"></A>
<A NAME="@default1858"></A> <A NAME="@default1859"></A> in Babel RMI, by
reference, and by copy. The default method is pass-by-reference.
For example, server A calls a function foo on server B,
and passes a local object Bar as an argument. In this case A will actually
pass the URL of Bar to B, B will then call <TT>_connect</TT> on the URL, which
connects back to the object Bar on A.</P><P>Pass-by-copy (also called serialization) <A NAME="@default1860"></A>
<A NAME="@default1861"></A> is different. Pass-by-copy
means that a new object is actually created locally on B, and
filled in with the values from the object Bar on A. The result is two
distinct local objects, one on A and one on B. In order to pass
by copy, copy must be used as an argument modifier in the SIDL file.
For example:</P><P><FONT COLOR=maroon><I><TT>copy Bar retBar(copy in Foo f)</TT></I></FONT></P><P>This sidl function takes a copy of a Foo and returns a copy of a Bar. </P><P>Passing by copy also requires the object being passed implements
<FONT COLOR=maroon><I><TT>sidl.io.Serializable</TT></I></FONT>:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"> <FONT COLOR=maroon><I>   1 <B>package</B> sidl.io <B>version</B> 9.15 {
    2   <B>interface</B> Serializable {
    3     <B>void</B> packObj( <B>in</B> Serializer ser );
    4     <B>void</B> unpackObj( <B>in</B> Deserializer des );
    5   }
    6 }</I></FONT></TD></TR>
</TABLE><P>Serializable declares two methods, packObj and <A NAME="@default1862"></A> <A NAME="@default1863"></A>
unPackObj. packObj serializes the internal object data to a string.
unPackObj reinstates the data into the new object by unserializing it
from a string. The library developer must implement these functions
because Babel does not know what data is in the object, or how it
should be serialized. Examples of packObj and unpackObj
implementations can be found
in <FONT COLOR=maroon><I><TT>sidl.rmi.SIDLException</TT></I></FONT> and <FONT COLOR=maroon><I><TT>sidl.rmi.NetworkException</TT></I></FONT>.</P><!--TOC subsection Casting Remote Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.2.5  Casting Remote Objects</H3><!--SEC END --><P><A NAME="ss:RMIobjargs"></A>
<A NAME="@default1864"></A></P><P>Babel RMI casting works the same as normal Babel casting, the user
calls casts an object to a new type, and gets a new reference back of
the object of the new type. In normal Babel, the new reference
points to the same IOR object as the old reference. This is because
all Babel objects are internally represented as the type they were
created as, so
casting is simply a matter of checking if the internal Babel type
extends the target type or not.</P><P>Babel RMI objects are more complex, a cast may result in a new stub.
If <TT>_connect()</TT> is called on a remote object, the object can be
connected as a super type of its actual type, such as an interface.
If this object is later cast to a more derived type, a new local
object stub must be created. These two stubs must be
deleteRef’d individually.</P><P>Here is an example where foo_Quux extends foo_Bar. The first is what the user
should do, the second is an error. </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar fb = foo_Bar__connect("simhandle://pc1:9999/quux1234", &amp;_ex);
foo_Quux fz = foo_Quux__cast(fb);
foo_Bar_deleteRef(fb);
foo_Quux_deleteRef(fz); //object is destroyed</TD></TR>
</TABLE><P>Do not do this:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar fb = foo_Bar__connect("simhandle://pc1:9999/quux1234", &amp;_ex);
foo_Quux fz = foo_Quux__cast(fb);
foo_Bar_deleteRef(fb);
foo_Quux_deleteRef(fb); //ERROR!!!</TD></TR>
</TABLE><!--TOC section Babel RMI Usage-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc85">18.3</A>  Babel RMI Usage</H2><!--SEC END --><P><A NAME="s:RMIusage"></A></P><P>The previous section generally covered the capabilities of RMI. This
section covers the actual usage of those features. </P><!--TOC subsection Adding Protocols-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.3.1  Adding Protocols</H3><!--SEC END --><P><A NAME="ss:RMIaddprotocols"></A>
<A NAME="@default1865"></A> <A NAME="@default1866"></A></P><P>In a normal Babel RMI client program, the first thing that needs to be
done is adding any protocols that the user plans to use to the
ProtocolFactory. The ProtocolFactory is a mapping from protocol
prefix that normally proceeds a URL, and the protocol’s actual
implementation. The only method the user ever needs to access is <TT>addProtocol</TT>. </P><P><FONT COLOR=maroon><I><TT>static bool addProtocol( in string prefix, in string typeName );</TT></I></FONT></P><P><TT>addProtocol</TT> takes the protocol prefix and the fully qualified SIDL
protocol typename. It returns <TT>TRUE</TT> on success. For example, normally the
shortname for the “Simple Protocol” protocol is “simhandle.” So
we would call the ProtocolFactory like this:</P><P><TT>sidl_rmi__addProtocol(‘‘simhandle’’,’’sidl.rmi.SimHandle’’);</TT></P><P>Now Babel RMI knows what to call when it encounters a URL prefixed by “simhandle://”.</P><!--TOC subsection Built-in Functions-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.3.2  Built-in Functions</H3><!--SEC END --><P><A NAME="ss:RMIbuiltins"></A></P><P>We already covered two important built-in Babel RMI functions in
Section <A HREF="#ss:RMIcreateconnect">18.2.3</A>. They were the
<TT>_create[Remote]</TT> and <TT>_connect</TT> static built-in functions,
which remotely create an object or connect to an already existing
remote object respectively.</P><P>There are three other important RMI related built-in functions that a
user may find useful. The first two are related:</P><P><FONT COLOR=maroon><I><TT>bool _isRemote();</TT></I></FONT><A NAME="@default1867"></A><A NAME="@default1868"></A></P><P><FONT COLOR=maroon><I><TT>bool _isLocal();</TT></I></FONT><A NAME="@default1869"></A><A NAME="@default1870"></A></P><P><TT>_isLocal()</TT> and <TT>_isRemote()</TT> are
opposites. <TT>_isRemote()</TT> returns <TT>TRUE</TT> if the object it is called
on is a remote object. <TT>_isLocal()</TT>, on the other hand, returns
<TT>TRUE</TT> if the object is implemented locally. </P><P>Many Babel RMI users will never need these functions. If you don’t
care where an object exists, or you already know statically, these
methods are totally superfluous. However, since calls on remote
objects have serious performance implications, we included these functions
for convenience.</P><P>There is one other important RMI related built-in:</P><P><FONT COLOR=maroon><I><TT>string _getURL();</TT></I></FONT><A NAME="@default1871"></A><A NAME="@default1872"></A></P><P>This function returns the URL of the object it is called on. This is
straight forward for Remote objects, but for local objects it may have
some interesting side effects. First, if there is no BOS running
locally, no local objects can be exported remotely. Therefore no local
object will have a URL. In this case <TT>_getURL()</TT> returns
<TT>NULL</TT>. However, if there is a BOS running, then local object
may have a URL. In this case, if the object has already been
exported, <TT>_getURL()</TT> will return the URL in the
<FONT COLOR=maroon><I><TT>sidl.rmi.InstanceRegistry</TT></I></FONT>, if the object is not in the
<FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>, Babel will add it, thereby automatically
generating a URL for the object. To reiterate, a possible side-effect
of calling <TT>_getURL()</TT> is that the object it is called on my be
added to the <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>.</P><!--TOC subsection Passing Objects from a client-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.3.3  Passing Objects from a client</H3><!--SEC END --><P><A NAME="ss:RMIclientexport"></A></P><P>If there is no BOS running locally, (that is, your process is strictly
a client) you cannot expose your local objects to remote machines by reference.
However, that doesn’t mean you can’t pass objects around. The client
can still pass references to remote objects on other remote servers,
and can still pass both local and remote objects by copy. For this
section, we will take our examples from this SIDL:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> foo <B>version</B> 0.1 {

  <B>class</B> Bar {
    <B>void</B> setBaz(<B>in</B> foo.Baz bz);
    <B>void</B> setBazCopy(<B>in</B> copy foo.Baz bz);
    //returns the registered Baz, or a new one if none exists
    foo.Baz returnBaz();
  }

  <B>class</B> Baz {}
}</I></FONT></TD></TR>
</TABLE><P>From the above SIDL, you can see that the following C code is perfectly legal for a client:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar fb = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);
foo_Baz fz = foo_Bar_returnBaz(fb, &amp;_ex);
foo_Baz_runSimulation(fz, &amp;_ex);</TD></TR>
</TABLE><P>It’s legal because the remote call returns a reference to another
remote object, the client never actually exports any of it’s local objects.</P><P>The following chunk is also legal, because it passes a remote object
to a different remote server. (Passing it to the same remote server
would be OK too.)</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar fb = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);
foo_Baz fz = foo_Baz__createRemote("simhandle://pc2:9999", &amp;_ex);
foo_Bar_setBaz(fb, fz, &amp;_ex);</TD></TR>
</TABLE><P>And the following is ALSO legal, because clients can pass local
objects remotely by copy, they just can’t pass local objects by
reference. (This allows users to drive a remote simulation on a
cluster from a regular workstation with nothing but a simple client.)</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar fb = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);
foo_Baz fz = foo_Baz__create(&amp;_ex);  //Local object
foo_Bar_setBazCopy(fb, fz, &amp;_ex);    //Pass by copy</TD></TR>
</TABLE><P>However this final bit of code will throw an exception if run by a
client that has no BOS:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* X ILLEGAL X WILL THROW EXCEPTION X     */</I></FONT>

foo_Bar fb = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);
foo_Baz fz = foo_Baz__create(&amp;_ex); //Local object
foo_Bar_setBaz(fb, fz, &amp;_ex);       //Pass by reference X BAD! X

<FONT COLOR="blue"><I>/* X ILLEGAL X WILL THROW EXCEPTION X     */</I></FONT></TD></TR>
</TABLE><!--TOC section Babel Object Servers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc86">18.4</A>  Babel Object Servers</H2><!--SEC END --><P><A NAME="s:RMIBOS"></A>
<A NAME="@default1873"></A></P><P>Now that we’ve seen how to use a client, we will take a look at
running a Babel Object Server.</P><!--TOC subsection Starting up a Babel Object Server-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.4.1  Starting up a Babel Object Server</H3><!--SEC END --><P><A NAME="ss:RMIstartBOS"></A></P><P>Babel Object Servers are generally easy to start up, although each BOS
may have a different construction interface. Here is an example of
starting up the “Simple Protocol” </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlx_rmi_SimpleOrb echo = NULL;
<B>int</B> tid;
sidl_rmi_ServerInfo si = NULL;
<B>int</B> port_number = 9999;

echo = sidlx_rmi_SimpleOrb__create(&amp;ex);SIDL_CHECK(ex);
sidlx_rmi_SimpleOrb_requestPort( echo, port_number, &amp;ex);SIDL_CHECK(ex);
tid = sidlx_rmi_SimpleOrb_run( echo, &amp;ex );SIDL_CHECK(ex);
si = sidl_rmi_ServerInfo__cast(echo,&amp;ex);SIDL_CHECK(ex);
sidl_rmi_ServerRegistry_registerServer(si, &amp;ex);SIDL_CHECK(ex);
sidl_rmi_ServerInfo_deleteRef(si,&amp;ex);SIDL_CHECK(ex);

pthread_join(tid, NULL); //Optional PTHREAD join</TD></TR>
</TABLE><P>Notice that before the server is run, <TT>requestPort</TT> must be
called. There are actually two versions of <TT>requestPort</TT>:
<TT>requestPort</TT>, and <TT>requestPort[InRange]</TT>.
<TT>requestPort</TT> takes one argument, a TCP port number (integer). The
port number is the TCP port that the BOS should
listen to for connections. <TT>requestPort[InRange]</TT> takes two
integers, which denote a range of ports the BOS may try. Because only
one server can listen on any TCP port, if the port is already in use
by another program, <TT>requestPort</TT> may fail.
<TT>requestPort[InRange]</TT> gets around this by giving the BOS a
range of ports to try. The BOS will try ports in this range until
the whole range is exhausted or it could successfully bind to a port.</P><P><TT>run</TT> returns a long. This return argument is meant to hold the
thread id of the thread waiting for connections. The user may wish to join on the
thread in order to keep the “Simple Protocol” server from exiting
prematurely. (We are now past the “Simple Protocol” specific portion
of this section)</P><P>After calling <TT>run</TT> the server is running, but you won’t be able to export any local
objects until you register the server with the
<FONT COLOR=maroon><I><TT>sidl.rmi.ServerRegistry</TT></I></FONT><A NAME="@default1874"></A>. Every BOS must be registered with the
<FONT COLOR=maroon><I><TT>ServerRegistry</TT></I></FONT>, and therefore every BOS must implement the
<FONT COLOR=maroon><I><TT>sidl.rmi.ServerInfo</TT></I></FONT> <A NAME="@default1875"></A> interface. This interface is what allows
the server to interact with the <FONT COLOR=maroon><I><TT>ServerRegistry</TT></I></FONT>. </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>class</B> ServerRegistry {
  <B>static void</B> registerServer(<B>in</B> sidl.rmi.ServerInfo si);
  <B>static string</B> getServerURL(<B>in string</B> objID);
  <B>static string</B> isLocalObject(<B>in string</B> url);
  <B>static array</B>&lt;sidl.io.Serializable,1&gt; getExceptions();
}</I></FONT></TD></TR>
</TABLE><P>The <FONT COLOR=maroon><I><TT>ServerRegistry</TT></I></FONT> is a singleton class that Babel RMI uses
internally to interface with the BOS. It interfaces through the
<FONT COLOR=maroon><I><TT>sidl.rmi.ServerInfo</TT></I></FONT> interface:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>interface</B> ServerInfo {
  <B>string</B> getServerURL(<B>in string</B> objID);
  <B>string</B> isLocalObject(<B>in string</B> url);
  <B>array</B>&lt;sidl.io.Serializable,1&gt; getExceptions();
}</I></FONT></TD></TR>
</TABLE><P>Simply cast the BOS to a <FONT COLOR=maroon><I><TT>ServerInfo</TT></I></FONT> and register it with the <FONT COLOR=maroon><I><TT>ServerRegistry</TT></I></FONT>.</P><P>The user is never really meant to use the <FONT COLOR=maroon><I><TT>ServerInfo</TT></I></FONT>
interface. In some cases a user may wish to call
<TT>getExceptions()</TT> through the <FONT COLOR=maroon><I><TT>ServerRegistry</TT></I></FONT>.
<TT>getExceptions()</TT> is an advanced function. Usually,
if an exception is raised in the BOS by a remote
call, the exception is returned back to the caller. However, in some
cases this is not possible. In those cases the BOS logs the
exceptions. Later, a user may use getExceptions to get the logged
exceptions. </P><P>NOTE: Currently the <FONT COLOR=maroon><I><TT>ServerRegistry</TT></I></FONT> can only handle one
<FONT COLOR=maroon><I><TT>ServerInfo</TT></I></FONT>. This means that Babel can effectively only support
one BOS at a time for exporting local objects. (There are hairy ways
around this) This is because there are a lot of issues that appear
when a user can export objects with a number of different protocols
that we have not dealt with. This may be researched further in the future.</P><!--TOC subsection Publishing Babel Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.4.2  Publishing Babel Objects</H3><!--SEC END --><P><A NAME="ss:RMIpublishobj"></A></P><P>Once you have a BOS up and running, you are free to export your local
object to remote servers. (And, depending on your BOS, remote clients
may be able to create and access objects on your BOS.) Exporting an
object basically means that remote Babel processes can access the
object. In implementation, this means that the object is accessible
through the <FONT COLOR=maroon><I><TT>sidl.rmi.InstanceRegistry</TT></I></FONT><A NAME="@default1876"></A>. The
<FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT> maps objectIDs to objects, and vice-versa.
This is what allows a remote client to get a handle to your object
with nothing more than a URL.</P><P>There are 3 ways for an object to end up in the
<FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>. The first, and easiest, is simply to pass a
local object by-reference as an argument in a remote call. The
last example in <A HREF="#ss:RMIclientexport">18.3.3</A> works if a BOS is running.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* THIS WORKS IF A BOS IS RUNNING   */</I></FONT>
foo_Bar fb = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);
foo_Baz fz = foo_Baz__create(&amp;_ex); //Local object
foo_Bar_setBaz(fb, fz, &amp;_ex);       //BOS is running, OK!</TD></TR>
</TABLE><P>Another possibility is simply to call <TT>_getURL()</TT><A NAME="@default1877"></A> on the local
object when a BOS is running. This will add the object to the
<FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>, so theoretically a remote client could access
it. Although realistically the remote client would have to get the
URL somehow.</P><P>The third possibility is to add it to the <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT> 
yourself. The <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT> class:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>class</B> InstanceRegistry {
  <B>static string</B> registerInstance( <B>in</B> sidl.BaseClass instance );
  <B>static string</B> registerInstance[ByString]( <B>in</B> sidl.BaseClass instance,
                                            <B>in string</B> instanceID);
  <B>static</B> sidl.BaseClass getInstance[ByString]( <B>in string</B> instanceID );
  <B>static string</B> getInstance[ByClass]( <B>in</B> sidl.BaseClass instance );
  <B>static</B> sidl.BaseClass removeInstance[ByString]( <B>in string</B> instanceID );
  <B>static string</B> removeInstance[ByClass]( <B>in</B> sidl.BaseClass instance );
}</I></FONT></TD></TR>
</TABLE><P>calling <FONT COLOR=maroon><I><TT>registerInstance</TT></I></FONT> by itself results in the same thing as
calling <TT>_getURL</TT> on the object, it puts the object in the
registry, and returns a unique objectID. However, by calling
<FONT COLOR=maroon><I><TT>registerInstance[ByString]</TT></I></FONT>, the user can supply their own
objectID. This is useful for WebServices and bootstrapping. It is
possible to explicitly publish an object with a special name. In
fact, the InstanceRegistry allows aliasing, the same object can be in
the registry multiple times with different names.</P><P>However, there is one issue with using
<FONT COLOR=maroon><I><TT>registerInstance[ByString]</TT></I></FONT>.<A NAME="@default1878"></A>
What if there is already an object
in the registry with that name? There are two possible cases, if the
object under that name is the same object you are trying to register,
the call is idempotent, it does nothing. However, if a different object in the
registry already has that name, the <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT> registers
the new object under a similar, but unique name. Usually a
combination of the instanceID passed in by the user and a unique
integer. This is usually the correct thing to do, but if the user
really wants the object under the original name, they must call
<TT>removeInstance[ByString]</TT> on the object that currently has that
name, and re-register the new object.</P><P>NOTE: The <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT> does not
addRef<A NAME="@default1879"></A> 
objects when they are inserted into it. You must not destroy an object you wish to be
accessible remotely. This means that if you create an object, insert
it into the instanceRegistry, and then deleteRef it, it will be
destroyed. You must keep a reference to it until you wish to remove
it from the InstanceRegistry. (The InstanceRegistry does, however,
addRef an objects that are gotten from it. If you call
<FONT COLOR=maroon><I><TT>getInstance[ByString]</TT></I></FONT>, you will get a reference to that object
and are free to deleteRef it.)</P><!--TOC subsection De-publishing Babel Objects-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.4.3  De-publishing Babel Objects</H3><!--SEC END --><P><A NAME="ss:RMIdepublishobj"></A>
<A NAME="@default1880"></A><A NAME="@default1881"></A></P><P>There are two ways to remove an object from the
<FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>. The first, and most automatic, is for it’s
reference count to reach 0. When an object is destroyed it is
automatically removed from the <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>.</P><P>The other way to remove an object is to call
<FONT COLOR=maroon><I><TT>removeInstance[ByString]</TT></I></FONT> or <FONT COLOR=maroon><I><TT>removeInstance[ByClass]</TT></I></FONT>.
These will remove the objects from the registry without destroying
them. They do not addRef however. So, if you create an object, insert
it into the <FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT>, remove it from the
<FONT COLOR=maroon><I><TT>InstanceRegistry</TT></I></FONT> and then deleteRef it, it will be destroyed.
(Assuming no one else has addRef’d it in the meantime.)</P><!--TOC section Non-Blocking Babel RMI-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc87">18.5</A>  Non-Blocking Babel RMI</H2><!--SEC END --><P><A NAME="s:RMInonblock"></A>
<A NAME="@default1882"></A></P><P>Non-Blocking RMI is an even more advanced topic, but it is essential to
high-speed distributed computing<A NAME="@default1883"></A>. Non-Blocking RMI allows the user to
mix work and communication. Many scientific computing related methods
may take a very long time to complete, and the client might like to do
some work while waiting. Non-blocking calls return immediately after
sending the information to the server. When the response comes back,
the user can make a special call to access the data. During the time
between the send and the receive, the client is free to do other work.</P><P>There are two types of Non-blocking RMI in Babel, Nonblocking and
oneway<A NAME="@default1884"></A><A NAME="@default1885"></A>. Both are declared as attributes on the method in SIDL. The
difference is that with oneway communication, the client does not
expect any return values. A oneway method will not even return an
exception, unless it occurs during communication with the server. On
the other hand, a non-blocking call can have return arguments. The
user will send a request, and get a <FONT COLOR=maroon><I><TT>sidl.rmi.Ticket</TT></I></FONT>. Later, the
user may use the <FONT COLOR=maroon><I><TT>Ticket</TT></I></FONT><A NAME="@default1886"></A><A NAME="@default1887"></A> to receive the out arguments. </P><!--TOC subsection Protocols-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.5.1  Protocols</H3><!--SEC END --><P><A NAME="ss:RMInonblockprotocols"></A></P><!--TOC subsection Nonblocking SIDL-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.5.2  Nonblocking SIDL</H3><!--SEC END --><P><A NAME="ss:RMInonblockSIDL"></A></P><P>The SIDL declaring calls to be nonblocking and/or oneway:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> foo <B>version</B> 0.2 {
  <B>class</B> Bar {
    <B>nonblocking double</B> runSimulation(<B>in double</B> x, <B>inout</B> y, <B>out</B> z);
    <B>oneway void</B> initSimulation(<B>in string</B> name, <B>in int</B> flags);
  }
}</I></FONT></TD></TR>
</TABLE><P>Notice that the nonblocking call may take any arguments, but only in
arguments are allowed for the oneway call.</P><P><A NAME="@default1888"></A></P><!--TOC subsection Tickets-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.5.3  Tickets</H3><!--SEC END --><P><A NAME="ss:RMInonblockTickets"></A></P><P>As mentioned previously, non-blocking RMI uses the class
<FONT COLOR=maroon><I><TT>sidl.rmi.Ticket</TT></I></FONT> to handle the return values of non-blocking
methods. There are actually two interfaces implemented
by the Protocol that are used. <FONT COLOR=maroon><I><TT>sidl.rmi.Ticket</TT></I></FONT> and
<FONT COLOR=maroon><I><TT>sidl.rmi.TicketBook</TT></I></FONT><A NAME="@default1889"></A><A NAME="@default1890"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>interface</B> Ticket {
  <B>void</B> block();
  <B>bool</B> test();
  TicketBook createEmptyTicketBook();
  Response getResponse();  //For internal Babel use
}

<B>interface</B> TicketBook <B>extends</B> Ticket {
  <B>void</B> insertWithID( <B>in</B> Ticket t, <B>in int</B> id );
  <B>int</B> insert( <B>in</B> Ticket t );
  <B>int</B> removeReady( <B>out</B> Ticket t );
  <B>bool</B> isEmpty();
}</I></FONT></TD></TR>
</TABLE><P><FONT COLOR=maroon><I><TT>sidl.rmi.TicketBook</TT></I></FONT> is, obviously, a collection of
<FONT COLOR=maroon><I><TT>Tickets.</TT></I></FONT> A Ticket represents the out arguments of a single
non-blocking call. The user may <TT>test()</TT> if the call has
returned yet, or <TT>block()</TT> until it does. The user can also get
an empty <FONT COLOR=maroon><I><TT>TicketBook.</TT></I></FONT> </P><P>The <FONT COLOR=maroon><I><TT>TicketBook</TT></I></FONT> is a little more complex. It extends
<FONT COLOR=maroon><I><TT>Ticket</TT></I></FONT> as well as creating some of it’s own functions. It is
mostly just to allow a user to make a large amount of nonblocking
calls and work while they return. This is a common design paradigm
in highly parallel scientific computing. In the case of
<FONT COLOR=maroon><I><TT>TicketBook</TT></I></FONT>, it is assumed the user will input a bunch of
Tickets with IDs. Then he can either <TT>block()</TT> on all of them
(waitall), <TT>test()</TT> to see if any have returned, or block on
<TT>removeReady</TT> (waitany). <TT>removeReady</TT> will return the id
that the <FONT COLOR=maroon><I><TT>Ticket</TT></I></FONT> was inserted with so that the user may identify
it. Perhaps with a case statement.</P><P>One odd thing about <FONT COLOR=maroon><I><TT>TicketBook</TT></I></FONT> is that you can insert multiple
tickets with the same name. <FONT COLOR=maroon><I><TT>TicketBook</TT></I></FONT> will not warn you or
throw an exception if you double up on the same name. If two
different Tickets are put in the TicketBook with the same name, there
is guarantee about what order they will come out in, even if you remove
by name.</P><!--TOC subsection Non-blocking Usage-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.5.4  Non-blocking Usage</H3><!--SEC END --><P><A NAME="ss:RMInonblockUsage"></A></P><P>The examples in this section will be written in C using the SIDL file
given in Section <A HREF="#ss:RMInonblockSIDL">18.5.2</A>.</P><P>Calling a oneway Babel RMI function is syntactically exactly like calling a normal
Babel function. The difference is just the danger of not being able
to receive any exceptions beyond the initial communication. Example:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar b1 = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);SIDL_CHECK(_ex);

foo_Bar_initSimulation(b1, "Test Simulation 1", 0, &amp;_ex); SIDL_CHECK(_ex);</TD></TR>
</TABLE><P>Non-blocking calls are a bit more complex, requiring <FONT COLOR=maroon><I><TT>Tickets</TT></I></FONT>
in order to get the return values. Here’s an example program, now
using a non-blocking call. Notice that the inout argument y is passed
as an in argument in the send (as a value), and an out argument in the
recv (as a pointer).</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar b1 = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);SIDL_CHECK(_ex);
sidl_rmi_Ticket t = NULL;
<B>double</B> x, y, z;

foo_Bar_initSimulation(b1, "Test Simulation 1", 0, &amp;_ex); SIDL_CHECK(_ex);
t = foo_Bar_runSimulation_send(b1, x, y, &amp;_ex); SIDL_CHECK(_ex);
<FONT COLOR="blue"><I>/* ... Work ... */</I></FONT>
foo_Bar_runSimulation_recv(b, t, &amp;y, &amp;z, &amp;_ex); SIDL_CHECK(_ex); //blocks on <B>return</B>
sidl_rmi_Ticket_deleteRef(t , &amp;_ex); SIDL_CHECK(_ex);</TD></TR>
</TABLE><P>Now, next is an example of a more complex program, that utilizes the
power of <FONT COLOR=maroon><I><TT>TicketBooks</TT></I></FONT> to make multiple remote calls, work, and
deal with the responses when they return.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">foo_Bar b1 = foo_Bar__createRemote("simhandle://pc1:9999", &amp;_ex);SIDL_CHECK(_ex);
foo_Bar b2 = foo_Bar__createRemote("simhandle://pc2:9999", &amp;_ex);SIDL_CHECK(_ex);
foo_Bar b3 = foo_Bar__createRemote("simhandle://pc3:9999", &amp;_ex);SIDL_CHECK(_ex);

sidl_rmi_Ticket t = NULL;
sidl_rmi_TicketBook tb = NULL;
<B>double</B> x, y, z;
<B>int</B> id1, id2, id3, tmpid;

foo_Bar_initSimulation(b1, "Test Simulation 1", 0, &amp;_ex); SIDL_CHECK(_ex);
foo_Bar_initSimulation(b2, "Test Simulation 2", 0, &amp;_ex); SIDL_CHECK(_ex);
foo_Bar_initSimulation(b3, "Test Simulation 3", 0, &amp;_ex); SIDL_CHECK(_ex);

t = foo_Bar_runSimulation_send(b1, x, y, &amp;_ex); SIDL_CHECK(_ex);
tb = sidl_rmi_Ticket_createEmptyTicketBook(t, &amp;_ex); SIDL_CHECK(_ex);
id1 = sidl_rmi_TicketBook_insert(tb, t, &amp;_ex); SIDL_CHECK(_ex);
sidl_rmi_Ticket_deleteRef(t , &amp;_ex); SIDL_CHECK(_ex);

t = foo_Bar_runSimulation_send(b2, x, y, &amp;_ex); SIDL_CHECK(_ex);
id2 = sidl_rmi_TicketBook_insert(tb, t, &amp;_ex); SIDL_CHECK(_ex);
sidl_rmi_Ticket_deleteRef(t , &amp;_ex); SIDL_CHECK(_ex);

t = foo_Bar_runSimulation_send(b3, x, y, &amp;_ex); SIDL_CHECK(_ex);
id3 = sidl_rmi_TicketBook_insert(tb, t, &amp;_ex); SIDL_CHECK(_ex);
sidl_rmi_Ticket_deleteRef(t , &amp;_ex); SIDL_CHECK(_ex);

<FONT COLOR="blue"><I>/* ... Work ... */</I></FONT>

<B>while</B>(!sidl_tmi_TicketBook_isEmpty(tb, &amp;_ex)) {
  SIDL_CHECK(_ex);
  tmpid = sidl_tmi_TicketBook_removeReady(&amp;t,&amp;_ex); SIDL_CHECK(_ex);
  <B>switch</B>(tmpid) {
  <B>case</B> id1:
    foo_Bar_runSimulation_recv(b, t, &amp;y, &amp;z, &amp;_ex); SIDL_CHECK(_ex);
    <FONT COLOR="blue"><I>/* Do something with data from Simulation 1 */</I></FONT>
    <B>break</B>;
  <B>case</B> id2:
    foo_Bar_runSimulation_recv(b, t, &amp;y, &amp;z, &amp;_ex); SIDL_CHECK(_ex);
    <FONT COLOR="blue"><I>/* Do something with data from Simulation 2 */</I></FONT>
    <B>break</B>;
  <B>case</B> id3:
    foo_Bar_runSimulation_recv(b, t, &amp;y, &amp;z, &amp;_ex); SIDL_CHECK(_ex);
    <FONT COLOR="blue"><I>/* Do something with data from Simulation 3 */</I></FONT>
    <B>break</B>;

  }
  sidl_rmi_Ticket_deleteRef(t , &amp;_ex); SIDL_CHECK(_ex);
}</TD></TR>
</TABLE><!--TOC chapter Building Portable Polyglot Software-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc88">Chapter 19</A>  Building Portable Polyglot Software</H1><!--SEC END --><P><A NAME="c:build"></A></P><P><EM>Babel generates very portable source code for multilingual programing.
There is also an art and science to transforming the source code to 
binary assets without breaking the language encapsulation Babel is
trying to create. This chapter discusses the details: from the mundane
issues of file layout, to the arcana of linker and loader flags.
</EM></P><P><BR>
</P><!--TOC section Layout of Generated Files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc89">19.1</A>  Layout of Generated Files</H2><!--SEC END --><P><A NAME="s:filelayout"></A>
<A NAME="@default1891"></A>
Babel generates a lot of files. Many of these files you never have to 
look at in an editor, but they must all be compiled and properly linked
into an application (see Section <A HREF="#s:libgrouping">19.2</A>). 
In this section we discuss several flags that can affect where
files are generated.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B><TT><CODE>--</CODE>output-directory<CODE>=</CODE></TT></B><FONT COLOR=maroon><I>path</I></FONT><BR>
This sets the root directory of where your files will be generated.
The path can be absolute, or relative to the current working directory.</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>generate-subdirs</TT></B><BR>
This option forces files to be laid out in a directory hierarchy 
following the package hierarchy in the SIDL file. This arrangement
is required for the Java and Python languages, so those generators
force this option on and allow no means to turn it off.
For C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, and Fortran 90/95, the default is that all files are
generated in the single output directory with no package-named
subdirectories.</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>language-subdir</TT></B><BR>
This option was contributed by a user. This option appends a 
language-specific subdirectory (e. g. c, python, f77) to the end
of the path.</LI><LI CLASS="li-itemize"><B><TT><CODE>--</CODE>hide-glue</TT></B><BR>
This option was contributed by a user. The intent here is to separate
the Impl files (which must be modified) from all other files.
If this flag is set, then wherever an Impl file gets generated, 
all the corresponding Skels, Stubs, IORs, etc get generated in
a subdirectory named <CODE>glue</CODE>.
</LI></UL><P>Arbitrary combinations of the above flags are allowed. Regardless
of the order they appear in the commandline, they are applied to the
resulting path in the order they are presented above. For example
if a SIDL file <TT>pkg.sidl</TT> defines a <FONT COLOR=maroon><I><TT>Cls</TT></I></FONT> class in the <FONT COLOR=maroon><I><TT>pkg</TT></I></FONT> package, 
and the user runs Babel as follows:
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>babel -lugo there -sc</B><BR>
</TT></BLOCKQUOTE><P>
Then the majority of the sources will be generated in the <TT>there/pkg/c/glue/</TT> directory
(except the Impl files which will occur one directory up in <TT>there/pkg/c/</TT>).
Note the use of equivalent short-form commands in this example.
If readers wish to review long and short forms of command line arguments, 
see Table <A HREF="#tbl:basics_commandline_args">4.1</A> on page <A HREF="#tbl:basics_commandline_args">??</A>. </P><P>Note that many of these options were contributed by users and are not
employed in Babel’s own build. Instead, we tend to put a SIDL file in
a directory and then generate client-side or server-side bindings in 
either <TT>runXXX/</TT> or <TT>libXXX/</TT> subdirectories, respectively (where <TT>XXX</TT> 
is a language name).
We don’t use the <B><TT><CODE>--</CODE>generate-subdirs</TT></B> or <B><TT><CODE>--</CODE>hide-glue</TT></B>
flags because they place source files that belong in the same library in different
directories. Automake, which Babel uses as part of its build system, works much more
reliably when all the sources that go into a library appear in the same directory
as the library to be. The <B><TT><CODE>--</CODE>language-subdir</TT></B> has a similar effect
to what we do manually, but doesn’t capture if it was client-side or server-side.
In our tests and demos, we tend to build these separately because we want to exercise
different drivers with different implementations.</P><P>The GNUmakefile generated by the <CODE>--</CODE><TT>makefile</TT> command line
option does not attempt to address all the possible combination of
flags affecting the layout of generated files. It assumes that you
generate files in the default locations.</P><!--TOC section Grouping compiled assets into Libraries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc90">19.2</A>  Grouping compiled assets into Libraries</H2><!--SEC END --><P><A NAME="s:libgrouping"></A></P><P>Babel enables one to completely encapsulate language dependencies inside
a static or dynamically loaded library. This means that one can take
a SIDL file and a compiled library, generate the bindings they want in 
their language of choice from the SIDL file, link against the library, 
and use it never knowing what the original implementation language was.</P><!--TOC subsection Basics of Compilation and Linkage-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.2.1  Basics of Compilation and Linkage</H3><!--SEC END --><P><A NAME="ss:compilebootcamp"></A></P><P>What we generally think of as a compiler is really an ensemble of related
tools. Generally there is a preprocessing step where very simple transformations
occur (e. g. #define, #include directives and others). Next, the compiler
proper executes and typically transforms your sourcecode into assembler or
some other intermediate form. Optimizers work on this intermediate form and
do perform additional transformations. Most big vendors of C, C++, and Fortran
compilers have a common optimizer for all languages. Next, assemblers transform
the optimized codes into platform-specific binaries. But this is not the end.
The binaries may be linked together into libraries or programs. Libraries can 
be linked against other libraries, and eventually multiple programs. 
The main difference is that a program has additional instructions to bootstrap 
itself, do some interaction with the operating system, receive an argument list, 
and call <TT>main()</TT>. To see all this in action, try building a “hello world”
type program in your favorite language, and run the “compiler” with an additional
flag such as <B><TT>-v</TT></B>, <B><TT><CODE>--</CODE>verbose</TT></B>, or whatever.</P><P>For example, this is what I get from a g77 compiler.
</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>g77 hello_world.f</B><BR>
% <B>./a.out</B><BR>
Hello World!
% <B>g77 -v hello_world.f</B><BR>
Driving: g77 -v hello_world.f -lfrtbegin -lg2c -lm -shared-libgcc<BR>
Reading specs from /usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2/specs<BR>
Configured with: ../gcc-3.2/configure --prefix=/usr/local/gcc/3.2<BR>
Thread model: posix<BR>
gcc version 3.2<BR>
 /usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2/f771 hello_world.f -quiet -dumpbase hello_world.f -version -o /tmp/ccp2GBGE.s<BR>
GNU F77 version 3.2 (i686-pc-linux-gnu)<BR>
	compiled by GNU C version 3.2.<BR>
 as --traditional-format -V -Qy -o /tmp/ccEiIsHc.o /tmp/ccp2GBGE.s<BR>
GNU assembler version 2.11.90.0.8 (i386-redhat-linux) using BFD version 2.11.90.0.8<BR>
 /usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2/collect2 -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 /usr/lib/crt1.o /usr/lib/crti.o /usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2/crtbegin.o -L/usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2 -L/usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2/../../.. /tmp/ccEiIsHc.o -lfrtbegin -lg2c -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/local/gcc/3.2/lib/gcc-lib/i686-pc-linux-gnu/3.2/crtend.o /usr/lib/crtn.o<BR>
</TT></BLOCKQUOTE><P>For the purposes of this discussion, we will make a distinction between 
linking to build a library and linking to build an executable. Even though
these processes have similar names, they perform very different kinds
of code transformations.</P><!--TOC subsection Circular Dependencies and Single-Pass Linkers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.2.2  Circular Dependencies and Single-Pass Linkers</H3><!--SEC END --><P>
<A NAME="@default1892"></A><A NAME="@default1893"></A>
<A NAME="@default1894"></A></P><P>Almost all linkers are single pass. This means that when linking an executable, 
linkers will run through the list of libraries exactly once trying to resolve symbols
Ever get libraries listed in the wrong order and an executable wouldn’t get built?
Ever have to list the same libraries over and over again to build an executable?
These are both side-effects of single pass linkers. The symbols in question
are essentially jumps in the instruction code corresponding to subroutines that
are defined elsewhere. When linking a final executable, all these symbols
need to be resolved. When linking libraries, multiple undefined symbols
are commonplace.</P><P>Having to list libraries over and over again in the link line when compiling
the final executable typically indicates a circular dependency between libraries.
Circular dependencies are much better kept within a single library.
Even though linkers are single-pass between libraries, they exhaustively search within them.</P><P>This is important because all the files generated by Babel have a circular dependency 
in each Babel type. The stub makes calls on the IOR, the IOR calls the Skel, the Skel 
calls the Impl, but the Impl also may make calls on a Stub. Just like C++ has a <TT>this</TT>
object, and Python has a <TT>self</TT>, Babel objects have a stub for them to 
call methods on themselves and dispatch properly through Babel’s IOR layer.</P><!--TOC subsection IOR as single point of access-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.2.3  IOR as single point of access</H3><!--SEC END --><P><A NAME="ss:IORsinglepointaccess"></A></P><P>When building a Babelized library, it’s important to note if your code has 
dependencies to other Babel types not in your library. These types often appear as
base classes, argument types, or even exception types. Your library will need
stubs corresponding to all these types, so it is best to put these in your library
as well. We call these external stubs. </P><P>Many have tried to minimize replication of Babel stubs by removing the external stubs
and letting the library link directly against the stubs in an external library. 
This is a mistake because the external library may be implemented in a different
language, and the stubs may be for a different language binding. By bundling 
the external stubs specific to your implementation with the implementation’s library, 
you are ensuring that the only access your library has with any other Babelized library
is through the IOR. This is a good thing. The Babel IOR is the same for all language
bindings and essentially forms the binary interface by which all Babel objects interact.</P><!--TOC section Dynamic vs. Static Linking-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">19.3</A>  Dynamic vs. Static Linking</H2><!--SEC END --><P><A NAME="s:linking"></A>
<A NAME="@default1895"></A><A NAME="@default1896"></A></P><P>Most UNIX users are very comfortable with statically linked libraries
(e. g. <TT>libXXX.a</TT>). Most are aware of “shared object files” in 
UNIX (with the form <TT>libXXX.so</TT>) though few actually build them. 
Even fewer still are familiar with dynamically linked libraries, 
called DLL’s in Microsoft (after the common <TT>.dll</TT> suffix), which involve
actually selecting and loading dynamic libraries at run time based on their 
string name. MacOSX uses the novel suffix <TT>libXXX.dynlib</TT>.
(In most UNIX systems, including Linux and Solaris, .so “shared object files” are actually
dynamically linked libraries.) This section serves as a quick overview of how Babel handles 
both static and dynamic libraries, including runtime loading.</P><!--TOC subsection Linkers and Position Independent Code (PIC)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.3.1  Linkers and Position Independent Code (PIC)</H3><!--SEC END --><P><A NAME="ss:pic"></A>
<A NAME="@default1897"></A>
In a static library, the linker simply copies needed compilation units 
from the library to the executable. The static library can subsequently
be deleted with no adverse affects to the executable. This also causes
common libraries to be duplicated in every executable that links against
it, and for the resulting executables to be quite large.</P><P>In a shared library, the linker simply inserts in the executable enough
information to find the library and load it when the executable is invoked.
This typically happens before the program ever gets to <TT>main()</TT>.
This keeps executables small and allows commonly used libraries to be
reused without copying, but it also means that the executable can fail
if the library is renamed, moved, deleted, or even if the user’s
environment changes sufficiently. </P><P>A necessary (but not sufficient) condition for shared libraries to
work is that all the compilation units (<TT>*.o</TT>) contained must be
explicitly compiled as <EM>position independent code</EM> (PIC).
Position independent code has an added level of indirection in
critical areas since details (such as addresses to jump to in
subroutine calls) are not known until runtime. Even though shared
libraries are very useful, PIC causes a small but measurable
degradation in performance, making static linked libraries with
non-PIC code a viable option for performance-critical situations.</P><P>A dynamic-linked library is a shared library with one added feature, 
it can be loaded explicitly by the user at runtime by passing the string
name into <TT>dlopen()</TT>. Dynamic-linked libraries (DLL’s) also require
compilation as PIC, though many compilers (including GCC) have special 
commands for each<SUP><A NAME="text27" HREF="#note27">1</A></SUP>.</P><!--TOC subsection Tracking Down Problems-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.3.2  Tracking Down Problems</H3><!--SEC END --><P>
<A NAME="@default1898"></A><A NAME="@default1899"></A></P><P>When tracking down problems with Babel libraries, to UNIX tools <B><TT>nm</TT></B> and
<B><TT>ldd</TT></B> are your friends. <B><TT>nm</TT></B> will print the list of linker symbols
in a file, including details such as whether the symbol is defined or not.
<B><TT>ldd</TT></B> lists dynamic dependencies of a shared libraries or executables, indicating
where it will look for these symbols when loaded.</P><P>Recall the Fortran hello world example in section <A HREF="#ss:compilebootcamp">19.2.1</A>. Even though
we may think this is all done with static linking, using these tools we find out the truth.</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>ldd a.out</B><BR>
        libg2c.so.0 =&gt; /usr/local/gcc/3.2/lib/libg2c.so.0 (0x400180000)<BR>
        libm.so.6 =&gt; /lib/i686/libm.so.6 (0x4004a000)<BR>
        libgcc_s.so.1 =&gt; //usr/local/gcc/3.2/lib/libgcc_s.so.1 (0x4006d000)<BR>
        libc.so.6 =&gt; /lib/i686/libc.so.6 (0x40076000)<BR>
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)<BR>
</TT></BLOCKQUOTE><P>Here, we clearly see that five libraries are shared libraries that will be loaded
after the executable is invoked, but before we get to the main program.
Some of these libraries make sense: <TT>libg2c</TT> is a Fortran to C support library, 
<TT>libc</TT> is the C standard library, but why is <TT>libm</TT> listed... its a
library of transcendental functions (e. g. sin(), cos()) why would it be included?
The answer becomes obvious when using ldd on <TT>libg2c</TT>. The Fortran support
library has dependencies on the math library, so our Fortran executable inherits 
that dependency too.</P><BLOCKQUOTE CLASS="quotation"><TT>
% <B>nm a.out | grep ’ U ’</B><BR>
        U __cxa_atexit@@GLIBC_2.1.3<BR>
        U __libc_start_main@@GLIBC_2.0<BR>
        U do_lio<BR>
        U e_wsle<BR>
        U exit@@GLIBC_2.0<BR>
        U f_exit<BR>
        U f_init<BR>
        U f_setarg<BR>
        U f_setsig<BR>
        U s_stop<BR>
        U s_wsle
</TT></BLOCKQUOTE><P><B><TT>nm</TT></B> (and grep) shows us 11 symbols that are were left undefined in our
final hello world application. A little more nm|greping about will help us find that 
symbols starting with <TT>f_</TT> are defined in libg2c.</P><!--TOC section SIDL Library Issues-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc92">19.4</A>  SIDL Library Issues</H2><!--SEC END --><P><A NAME="s:sidl_lib"></A></P><P>As mentioned in Section <A HREF="#s:sidl_runtime">6.6</A>, the Babel toolkit includes the
SIDL runtime library. The library provides a base interface, class,
and exception as the foundation. This is how Babel provides object-oriented
features to non-object-oriented languages. In order to support the runtime
system and build the SIDL library, it also provides DLL and Loader classes.</P><P><A NAME="@default1900"></A>Babel generated code depends critically on <TT>babel_config.h</TT> to correctly
define a lot of platform specific details. One detail that changes too 
frequently to encode in <TT>babel_config.h</TT> is whether or not the software 
is being compiled is position independent code (PIC). This detail is commonly 
added to the compilation instruction using the flags (e. g. <TT>-fPIC -DPIC</TT>
<SUP><A NAME="text28" HREF="#note28">2</A></SUP>). The first flag tells the compiler to generate position independent 
code. The second defines the preprocessor macro <TT>PIC</TT>. Looking now at 
<TT>babel_config.h</TT>, we see that either <TT>SIDL_DYNAMIC_LIBRARY</TT> or 
<TT>SIDL_STATIC_LIBRARY</TT> are defined depending on whether or not <TT>PIC</TT> 
is defined.</P><P>As described in Section <A HREF="#ss:pic">19.3.1</A>, Babel tends to focus on static libraries 
and dynamic linked libraries; not worrying much about <A NAME="@default1901"></A>shared libraries. The 
main reason is that for every last drop of performance, people would want 
static libraries. To support Java and Python (and the CCA model) dynamic 
loading is required. There’s no real benefit to doing shared libraries that 
can’t be dynamically loaded, so in developing Babel, we focus on the other two 
linkage situations.</P><!--TOC section Language Bindings for the <TT>sidl</TT> Package-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc93">19.5</A>  Language Bindings for the <TT>sidl</TT> Package</H2><!--SEC END --><P>The implementation and C stubs for the <TT>sidl</TT> package are stored
in <TT>libsidl.so</TT> and <TT>libsidl.a</TT>, shared and static libraries
that are installed when you install babel. You can determine the
directory where these libraries are stored by running
<TT>babel-config --libdir</TT>. Normally, running <TT>babel-config
--libdir</TT> will yield something like <TT>/usr/lib</TT> or
<TT>/usr/local/lib</TT>; however, your system administrator may have
chosen a different directory by specifying a <TT>--prefix</TT> when they
configured Babel (see Section <A HREF="#s:configure">3.1.1</A>). The IOR header files
and C stub header files are installed in the directory shown by
<TT>babel-config --includedir</TT>.</P><P>Babel also provides precompiled stubs for the <TT>sidl</TT> package for
the C++, F77, F90, Java and UC++ language bindings. These libraries are
also installed in <TT>babel-config --libdir</TT>, and they are named
<TT>libsidlstubs_cxx.so</TT>, <TT>libsidlstubs_ucxx.so</TT>,
Codelibsidlstubs_f77.so, and <TT>libsidlstubs_f90.so</TT>. 
Similarly named static archives and libtool <TT>.la</TT> files are also
inalled in <TT>babel-config --libdirst</TT>. The header files for these
languages are installed in subdirectories of <TT>babel-config
--includedir</TT> named <TT>Cxx</TT>, <TT>F77</TT>, <TT>F90</TT>, and
<TT>UCxx</TT>.</P><!--TOC section SCL Files for Dynamic Loading-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc94">19.6</A>  SCL Files for Dynamic Loading</H2><!--SEC END --><P>
<A NAME="@default1902"></A></P><P>If you generate a dynamic-linked library containing implementations of
SIDL classes, you must also generate a SIDL Class List file (SCL
file). An SCL file contains metadata about zero or more dynamic-linked
libraries; for each dynamic-linked library, the SCL file has the list
of SIDL classes implemented in that library. The
<TT>sidl.Loader.findLibrary</TT> method searches SCL files when trying
to find the implementation (or some other aspect) of a SIDL class.</P><P>The SCL file is an XML file with three kinds of elements. The top
level element is <TT>scl</TT> which contains zero or more <TT>library</TT>
elements. The <TT>library</TT> element has several attributes, and it
contains zero or more <TT>class</TT> elements. The <TT>library</TT>
element has three required attributes, <TT>uri</TT>, <TT>scope</TT> and
<TT>resolution</TT>, and two optional attributes, <TT>md5</TT> and
<TT>sha1</TT>. The <TT>uri</TT> is a local filename including path or a
network <TT>url</TT> indicating where the library is stored. The
<TT>scope</TT> attribute allows developers to suggest whether the
library should be loaded in a <TT>local</TT> or the <TT>global</TT>
namespace. The developer can suggest <TT>lazy</TT> or <TT>now</TT> symbol
resolution using the <TT>scope</TT> attribute. The <TT>md5</TT> and
<TT>sha1</TT> are optional message digests to confirm that the library
has not been modified or replaced. The <TT>class</TT> element has two
required elements, <TT>name</TT> and <TT>desc</TT>. The <TT>name</TT> field
is the name of the class, and <TT>desc</TT> indicates what kind of
information is held in the library. Each class contained in the
dynamic-linked library should be listed in the SCL file. For now, the
only <TT>desc</TT> values with standardized meanings of <TT>ior/impl</TT>,
<TT>java</TT> and <TT>python/impl</TT>. <TT>ior/impl</TT> indicates the
dynamic-linked library contains the IOR object and implementation for
the class, and <TT>java</TT> indicates that the library has the Java JNI
wrapper object code. <TT>python/impl</TT> has the Python skeletons and
implementation libraries.</P><P>Here is an the SCL file for the SIDL runtime library installed in
<TT>/usr/local</TT>.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>XML</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">&lt;?xml version="1.0" ?&gt;
&lt;scl&gt;
  &lt;library uri="/usr/local/lib/libsidl.la" scope="global" resolution="now" &gt;
    &lt;class name="SIDL.BaseClass" desc="ior/impl" /&gt;
    &lt;class name="SIDL.ClassInfoI" desc="ior/impl" /&gt;
    &lt;class name="SIDL.DLL" desc="ior/impl" /&gt;
    &lt;class name="SIDL.Loader" desc="ior/impl" /&gt;
    &lt;class name="SIDL.Boolean" desc="java" /&gt;
    &lt;class name="SIDL.Character" desc="java" /&gt;
    &lt;class name="SIDL.DoubleComplex" desc="java" /&gt;
    &lt;class name="SIDL.Double" desc="java" /&gt;
    &lt;class name="SIDL.FloatComplex" desc="java" /&gt;
    &lt;class name="SIDL.Float" desc="java" /&gt;
    &lt;class name="SIDL.Integer" desc="java" /&gt;
    &lt;class name="SIDL.Long" desc="java" /&gt;
    &lt;class name="SIDL.Opaque" desc="java" /&gt;
    &lt;class name="SIDL.SIDLException" desc="ior/impl" /&gt;
    &lt;class name="SIDL.String" desc="java" /&gt;
  &lt;/library&gt;
&lt;/scl&gt;</TD></TR>
</TABLE><P>
It’s worth noting that the <TT>uri</TT> can be a libtool metadata file 
(<TT>.la</TT>) when the library is located on the local file system or a
dynamic-linked library file (<TT>.so</TT> or another machine dependent
suffix). You cannot have a libtool <TT>.la</TT> when the library is
remote (e.g., <TT>ftp:</TT> or <TT>http:</TT>) because libtool expects the
files references in the <TT>.la</TT> file to be local and in particular
directories.</P><P>The GNUmakefile generated with the <CODE>--</CODE><TT>makefile</TT> Babel
option contains rules to automatically generate .scl files for each of
the supported Babel languages.</P><!--TOC section Deployment of Babel-Enabled Libraries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc95">19.7</A>  Deployment of Babel-Enabled Libraries</H2><!--SEC END --><P>
<A NAME="@default1903"></A></P><P>At this point, there is no standard — or even recommended — model for 
deploying Babel enabled libraries. Below are a few examples of how our
developers are currently packaging their code.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Server Source Only</B></DT><DD CLASS="dd-description">
With this option your users are expected to have Babel installed on their 
system. In this mode, developers simply include a SIDL file and their 
corresponding implementation files. The user in this case must build the 
software, call Babel to generate the client bindings in the language of 
choice, and link it all together into a final application.</DD><DT CLASS="dt-description"><B>Client and Server Source</B></DT><DD CLASS="dd-description">
This option tries to hide Babel as much as possible. In this mode, the 
developer pre-generates many different client language bindings and 
distributes them along with their code and the sources for the Babel 
runtime library. Then the user has a “batteries included” package 
that’s ready to run out of the box. The user may not even be aware that 
Babel has been used unless they pay careful attention to how the package 
was built.</DD><DT CLASS="dt-description"><B>Server Libraries Only</B></DT><DD CLASS="dd-description">
Finally, in this mode only the SIDL file and the precompiled shared library 
files are distributed. This is not an open-source solution, though users 
still need to build the language bindings to access the shared library.</DD></DL><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note27" HREF="#text27">1</A></DT><DD CLASS="dd-thefootnotes"><TT>-fpic</TT> for SO’s, <TT>-fPIC</TT> for DLL’s
</DD><DT CLASS="dt-thefootnotes"><A NAME="note28" HREF="#text28">2</A></DT><DD CLASS="dd-thefootnotes">The actual command to the compiler varies, <TT>-fPIC</TT> is understood 
by GCC
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Creating Objects with Pre-Initialized State-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc96">Chapter 20</A>  Creating Objects with Pre-Initialized State</H1><!--SEC END --><P><A NAME="c:backdoor"></A>
</P><DIV CLASS="center">
<FONT SIZE=7>or<BR>
Wrapping Native objects with Babel
</FONT>
</DIV><P><A NAME="@default1904"></A><A NAME="@default1905"></A><A NAME="@default1906"></A> 
<A NAME="@default1907"></A> <A NAME="@default1908"></A> 
<A NAME="@default1909"></A> <A NAME="@default1910"></A> 
<A NAME="@default1911"></A> <A NAME="@default1912"></A></P><P><BR>
</P><!--TOC section Introduction to the Backdoor Initializer-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc97">20.1</A>  Introduction to the Backdoor Initializer</H2><!--SEC END --><P><A NAME="s:intro"></A></P><P>Internally, every Babel object holds an implementation language
specific pointer to the object’s private state data. If the object is
implemented in C, the pointer points to a struct named <TT>struct
package_Class__data</TT>. In Java, the private data pointer points to a
Java object of the implementation type, <TT>Class_Impl</TT>, which calls
are made on, and which actually holds the object state. The type of
the private data is entirely implementation language dependent. The
data is usually created or set by the Babel objects user-implemented constructor.</P><P>With the Backdoor Initializer, Babel allows a Babel user to set
this private data pointer at construction with pre-initialized state.
Of course, this is very dangerous. This can only be done if the
client language creating the Babel object is the same as the language
the object is implemented in, and if the pre-initialized state is of
the correct type. If either of these constraints is unsatisfied, the
behavior of the backdoor initializer in undefined.</P><P><A NAME="@default1913"></A>
Object construction is a very language specific problem, and therefore
this Babel feature is exposed differently in each language. However,
in every language, there is some way provided for the class implementor
to determine in the constructor code whether the object is being
constructed normally, or if the user provided pre-initialized state.
In most languages there is a second constructor provided<A NAME="@default1914"></A>, only in
Python is an argument used to determine if the user provided
pre-initialized state or not. Most class implementers will not need to do anything
with the new constructor. In the case of Backdoor Initialization,
usually the right thing to do in a constructor is to do nothing, since
the object state was preinitialized by the client. The constructor
only needs to be used if the state of the object cannot fully be
represented by its private data. For example, an object that opens a
TCP/IP connection during construction would almost certainly need that
code in the backdoor constructor as well.</P><!--TOC section Motivation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc98">20.2</A>  Motivation</H2><!--SEC END --><P><A NAME="s:modivation"></A></P><P>The Backdoor Initializer is not a feature that most Babel users will
need. However, there are certain cases where the Backdoor Initializer
is absolutely required. The most obvious usage case is for wrapping
up native objects in a Babelized interface. The allows the
implementation language to access the data directly, but other
languages must use the provided Babel interface. It was exactly this
usage case that inspired the creation of the Backdoor Initializer.</P><P>A customer needed to use a Java visualization program to view a graph
generated by a C++ library. The customer did not want to modify the
Java program significantly. Instead, he created the graph data
structure used by the visualizer in Java, and wrapped it in a Babel
interface. He was then able to pass the Babelized object to the C++
library, which made calls on the Babel interface to add nodes and
edges to the graph. When the C++ library finished, the Java visualizer
was able to use the graph as if it was created natively in Java. The
visualizer code did not have to be modified in any way to use the graph!</P><!--TOC section Example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">20.3</A>  Example</H2><!--SEC END --><P><A NAME="s:example"></A></P><P>In this chapter we will use a single example for all Babel supported
languages. This example is taken from the wrapper regression test.
In this test, there are two sidl classes, <TT>wrapper.Data</TT> and
<TT>wrapper.User</TT>. </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> wrapper <B>version</B> 1.0 {

  <B>class</B> Data {
    <B>void</B> setString(<B>in string</B> s);
    <B>void</B> setInt(<B>in int</B> i);
  }

  <B>class</B> User {
     <B>void</B> accept(<B>in</B> wrapper.Data data);
  }
}</I></FONT></TD></TR>
</TABLE><P><TT>wrapper.Data</TT> wraps up some native data, which will be modified by
the <TT>wrapper.User.accept()</TT> call. In this case, the data is just a
string and an integer. In order to show the new constructor
functionality, we set string called d_ctortest to “ctor was run” in
the new constructor. </P><P>To reiterate, the client program creates and wraps language specific data in a
<TT>wrapper.Data</TT> babel object. The alternate constructor code is
run, which sets the d_ctortest string. The object is then passed to
<TT>wrapper.User.accept()</TT>, which sets the data. The client program
can then directly access the data and read what was set by User.accept().</P><!--TOC section The Backdoor Initializer in C-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc100">20.4</A>  The Backdoor Initializer in C</H2><!--SEC END --><P><A NAME="s:c"></A></P><P><A NAME="@default1915"></A><A NAME="@default1916"></A>
In C, the Backdoor Initializer is used through a new <TT>_create</TT>
like static method, <TT>_wrapObj</TT>. <TT>_wrapObj</TT> takes a
pointer to the private data to be wrapped (a simple struct defined in
<TT>wrapper_Data__Impl.h</TT>).</P><P>from wrapper_Data_Impl.h:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>struct</B> wrapper_Data__data {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data._data) */</I></FONT>
  <B>char</B>* d_ctortest;
  <B>char</B>* d_string;
  <B>int</B> d_int;
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data._data) */</I></FONT>
};</TD></TR>
</TABLE><P>From wrapper_Data_Impl.c; notice the new constructor <TT>ctor2</TT><A NAME="@default1917"></A>,
which is only called with backdoor initialization.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>void</B> impl_wrapper_Data__ctor2(
  <FONT COLOR="blue"><I>/* in */</I></FONT> wrapper_Data self,
  <FONT COLOR="blue"><I>/* in */</I></FONT> <B>void</B>* private_data,
  <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex) {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2) */</I></FONT>
  <B>struct</B> wrapper_Data__data *dptr = (<B>struct</B> wrapper_Data__data *) private_data;
  dptr-&gt;d_ctorTest = "ctor was run";
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data._ctor2) */</I></FONT>
}

<B>void</B> impl_wrapper_Data_setString(
  <FONT COLOR="blue"><I>/* in */</I></FONT> wrapper_Data self,
  <FONT COLOR="blue"><I>/* in */</I></FONT> <B>const char</B>* s,
  <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex) {
  *_ex = 0;
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data.setString) */</I></FONT>
  <B>struct</B> wrapper_Data__data *dptr =
    wrapper_Data__get_data(self);
  <B>if</B> (dptr) {
    dptr-&gt;d_string = "Hello World!";
  }
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data.setString) */</I></FONT>
}

<B>void</B> impl_wrapper_Data_setInt(
  <FONT COLOR="blue"><I>/* in */</I></FONT> wrapper_Data self,
  <FONT COLOR="blue"><I>/* in */</I></FONT> int32_t i,
  <FONT COLOR="blue"><I>/* out */</I></FONT> sidl_BaseInterface *_ex) {
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.begin(wrapper.Data.setInt) */</I></FONT>
  <B>struct</B> wrapper_Data__data *dptr =
    wrapper_Data__get_data(self);
  <B>if</B> (dptr) {
    dptr-&gt;d_int = 3;
  }
  <FONT COLOR="blue"><I>/* DO-NOT-DELETE splicer.end(wrapper.Data.setInt) */</I></FONT>
}</TD></TR>
</TABLE><P>from the client program wraptest.c: (Note that we must include wrapper_Data_Impl.h)
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>#include</B> "wrapper_User.h"
<B>#include</B> "wrapper_Data.h"
<B>#include</B> "wrapper_Data_Impl.h"
<B>int</B> main(<B>int</B> argc, <B>char</B>** argv) {

  sidl_BaseInterface exception = NULL;
  wrapper_Data data = NULL;
  wrapper_User user = NULL;
  <B>struct</B> wrapper_Data__data *d_data = NULL;
  <B>struct</B> wrapper_Data__data *dptr = NULL;

  <FONT COLOR="blue"><I>/*Create the data*/</I></FONT>
  dptr = malloc(<B>sizeof</B>(<B>struct</B> wrapper_Data__data));
  <FONT COLOR="blue"><I>/*Wrap the data*/</I></FONT>
  data = wrapper_Data__wrapObj(dptr, &amp;exception);
  user = wrapper_User__create(&amp;exception);

  ASSERT( strcmp(d_data-&gt;d_ctortest, "ctor was run") == 0);

  <FONT COLOR="blue"><I>/* Test the data setting*/</I></FONT>
  wrapper_User_accept(user, data, &amp;exception);

  ASSERT( strcmp(d_data-&gt;d_string, "Hello World!") == 0);
  ASSERT( d_data-&gt;d_int == 3);

  <B>return</B> 0;
}</TD></TR>
</TABLE><!--TOC section The Backdoor Initializer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc101">20.5</A>  The Backdoor Initializer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN></H2><!--SEC END --><P><A NAME="s:f77"></A>
<A NAME="@default1918"></A><A NAME="@default1919"></A>
In <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, using the Backdoor Initializer is similar to using it
in C. There is a special new constructor named <TT>_wrapObj</TT> that
takes the private data pointer. </P><P>Of course, dynamically allocating data in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> is tricky, and
requires very close cooperation with the Impl class that uses the
data. Most of the complexity of this example code is caused by those
problems, not so much the Backdoor Initializer itself.</P><P><A NAME="@default1920"></A>
Since we need to store 2 strings and an integer, we create 3 sidl arrays to
hold the private data. We create an opaque array of 2 elements called pdata to hold
the other two arrays. Then we create a string array of 2 elements
called a_string, and an integer array of 1 element called a_int.
d_string is element 0 of the string array, and d_ctortest is element
1. We then place a_string into pdata as element 0, and a_int in pdata
as element 1. We then call <TT>_wrapObj</TT>, which takes pdata as an
in argument as the first argument, and the object we are creating,
data, as an out argument as the second argument. </P><P>Notice that we don’t have to include an Impl files to <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
since, there aren’t actually any types.</P><P>Fairly complex, but here’s the client code from wraptest.f:
</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      program wraptest
      implicit none
      integer*8 data, user, pdata, backup, throwaway
      integer*8 a_string, a_int
      integer*4 d_int
      character*80 d_string
      character*80 d_ctortest
      character*80 d_silly

c     pdata is the internal data, and holds two arrays, string an int.
      call sidl_opaque__array_create1d_f(2, pdata)
      call sidl_string__array_create1d_f(2, a_string)
      call sidl_int__array_create1d_f(1, a_int)

c     initialize the data arrays
      call sidl_string__array_set1_f(a_string, 0, d_string)
      call sidl_string__array_set1_f(a_string, 1, d_ctortest)
      call sidl_int__array_set1_f(a_int, 0, d_int)

c     initilize pdata
      call sidl_opaque__array_set1_f(pdata, 0, a_string)
      call sidl_opaque__array_set1_f(pdata, 1, a_int)

      call wrapper_User__create_f(user, throwaway)

c     private data first, then the object being created
      call wrapper_Data__wrapObj_f(pdata, data, throwaway)

      call sidl_opaque__array_get1_f(pdata, 0, a_string)
      call sidl_string__array_get1_f(a_string, 1, d_ctortest)

      print *, d_ctortest

      call wrapper_User_accept_f(user, data, throwaway)

      call sidl_string__array_get1_f(a_string, 0, d_string)
      call sidl_int__array_get1_f(a_int, 0, d_int)

      print *, d_string, ' ', d_int

      call wrapper_User_deleteRef_f(user, throwaway)
      call wrapper_Data_deleteRef_f(data, throwaway)
      end</TD></TR>
</TABLE><P> 	</P><P>and the Impl side code from wrapper_Data_Impl.f
</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine wrapper_Data__ctor2_fi(self, private_data, exception)
        implicit none
        integer*8 self
        integer*8 private_data
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2)
        integer*8 a_string, pdata
        character*80 d_string, d_ctortest
        call sidl_opaque__array_get1_f(private_data, 0, a_string)
        call sidl_string__array_set1_f(a_string, 1, 'ctor was run')
C       DO-NOT-DELETE splicer.end(wrapper.Data._ctor2)
        end

        subroutine wrapper_Data_setString_fi(self, s, exception)
        implicit none
        integer*8 self
        character*(*) s
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(wrapper.Data.setString)
        integer*8 data, a_string
        call wrapper_Data__get_data_f(self, data)
        if (data .ne. 0) then
           call sidl_opaque__array_get1_f(data, 0, a_string)
           call sidl_string__array_set1_f(a_string, 0, s)
        endif
C       DO-NOT-DELETE splicer.end(wrapper.Data.setString)
        end

        subroutine wrapper_Data_setInt_fi(self, i, exception)
        implicit none
        integer*8 self
        integer*4 i
        integer*8 exception

C       DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)
        integer*8 data, a_int
        call wrapper_Data__get_data_f(self, data)
        if (data .ne. 0) then
           call sidl_opaque__array_get1_f(data, 1, a_int)
           call sidl_int__array_set1_f(a_int, 0, i)
        endif
C       DO-NOT-DELETE splicer.end(wrapper.Data.setInt)
        end</TD></TR>
</TABLE><!--TOC section The Backdoor Initializer in Fortran 90/95-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc102">20.6</A>  The Backdoor Initializer in Fortran 90/95</H2><!--SEC END --><P><A NAME="s:f90"></A></P><P><A NAME="@default1921"></A><A NAME="@default1922"></A>
The Fortran 90/95 backdoor initializer is very similar to C. Fortran 90/95
also has a <TT>_wrapObj</TT>, but it is actually defined in
the wrapper_Data_Mod.F90 file, along with the private data type
definition. </P><P>Here is the private data definition from wrapper_Data_Mod.F90:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  type wrapper_Data_priv
    <B>sequence</B>
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(wrapper.Data.private_data)
    ! Insert-Code-Here {wrapper.Data.private_data} (private data members)</I></FONT>
     character(<B>len</B>=256)     :: d_ctortest
     character(<B>len</B>=256)     :: d_string
     integer(<B>kind</B>=sidl_int) :: d_int
    <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data.private_data)</I></FONT>
  end type wrapper_Data_priv</TD></TR>
</TABLE><P>Here is the client code from wraptest.F90. Notice wrapper_Data_impl
is used. From wraptest.F90:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#<B>include</B> "wrapper_User_fAbbrev.h"
#<B>include</B> "wrapper_Data_fAbbrev.h"
#<B>include</B> "synch_RegOut_fAbbrev.h"
#<B>include</B> "synch_ResultType_fAbbrev.h"

program wraptest
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> wrapper_User
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  type(sidl_BaseInterface_t) :: throwaway_exception
  type(wrapper_Data_wrap) :: pd

  type(wrapper_Data_t) :: data
  type(wrapper_User_t) :: user

  <B>allocate</B>(pd%d_private_data)
  pd%d_private_data%d_int = 0
  pd%d_private_data%d_string = 'place holder'
  pd%d_private_data%d_ctortest = 'place holder'

  call new(user, throwaway_exception)
  call wrapObj(pd, data, throwaway_exception)

  print *, pd%d_private_data%d_ctortest

  call accept(user, data, throwaway_exception)

  print *, pd%d_private_data%d_string, ' ', pd%d_private_data%d_int

  call deleteRef(user, throwaway_exception)
  call deleteRef(data, throwaway_exception)
  <FONT COLOR="blue"><I>! Private data [should be] deallocated by the Impl dtor.</I></FONT>

  call close(tracker, throwaway_exception)
  call deleteRef(tracker, throwaway_exception)
end program wraptest</TD></TR>
</TABLE><P>Finally, the Impl code from wrapper_Data_Impl.F90: 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>recursive</B> subroutine wrapper_Data__ctor2_mi(self, private_data, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  implicit <B>none</B>
  type(wrapper_Data_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  type(wrapper_Data_wrap) :: private_data
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2)</I></FONT>
  private_data%d_private_data%d_ctortest = 'ctor was run'
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data._ctor2)</I></FONT>
end subroutine wrapper_Data__ctor2_mi

<B>recursive</B> subroutine wrapper_Data_setString_mi(self, s, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  implicit <B>none</B>
  type(wrapper_Data_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  character (<B>len</B>=*) :: s <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out
! DO-NOT-DELETE splicer.begin(wrapper.Data.setString)</I></FONT>
  type(wrapper_Data_wrap) :: dp
  call wrapper_Data__get_data_m(self, dp)
  dp%d_private_data%d_string = s
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data.setString)</I></FONT>
end subroutine wrapper_Data_setString_mi

<B>recursive</B> subroutine wrapper_Data_setInt_mi(self, i, exception)
  <B>use</B> sidl
  <B>use</B> sidl_BaseInterface
  <B>use</B> sidl_RuntimeException
  <B>use</B> wrapper_Data
  <B>use</B> wrapper_Data_impl
  implicit <B>none</B>
  type(wrapper_Data_t) :: self <FONT COLOR="blue"><I>! in</I></FONT>
  integer (<B>kind</B>=sidl_int) :: i <FONT COLOR="blue"><I>! in</I></FONT>
  type(sidl_BaseInterface_t) :: exception <FONT COLOR="blue"><I>! out

! DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)</I></FONT>
  type(wrapper_Data_wrap) :: dp
  call wrapper_Data__get_data_m(self, dp)
  dp%d_private_data%d_int = i

<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(wrapper.Data.setInt)</I></FONT>
end subroutine wrapper_Data_setInt_mi</TD></TR>
</TABLE><!--TOC section The Backdoor Initializer in C++-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">20.7</A>  The Backdoor Initializer in C++</H2><!--SEC END --><P><A NAME="s:Cxx"></A>
<A NAME="@default1923"></A></P><P>In Object Oriented languages there is no <TT>_wrapObj</TT> method
exposed to the user. Instead, the same functionality is achieved
simply by calling “new” on the Impl class. Interestingly, this
means the constructor functionality is NOT placed in a Babel
<TT>ctor</TT> method, but is, instead, actually in the default object constructor.</P><P>Here is the private data definition from wrapper_Data_Impl.hxx:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">
namespace wrapper {
  class Data_impl : public virtual ::wrapper::Data

....
  public:
    char* d_string;
    int d_int;
    char* d_ctorTest;

....
  };  // end class Data_impl
} // end namespace wrapper</TD></TR>
</TABLE><P>Here is the client code from wraptest.cxx. Notice wrapper_Data_Impl
is included.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#include "wrapper_User.hxx"
#include "wrapper_Data.hxx"
#include "wrapper_Data_Impl.hxx"

int main(int argc, char **argv) {
  wrapper::Data_impl data;
  wrapper::User user = wrapper::User::_create();

  ASSERT( data.d_ctorTest == "ctor was run");

  /* Test the data setting*/
  user.accept(data);

  ASSERT( data.d_string == "Hello World!");
  ASSERT( data.d_int == 3);
  return 0;
}</TD></TR>
</TABLE><P>Finally, the Impl code from wrapper_Data_Impl.cxx, notice where the
constructor code is placed. 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>C++</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">// speical constructor, used for data wrapping(required).
// Do not put code here unless you really know what you're doing!
wrapper::Data_impl::Data_impl() : StubBase(reinterpret_cast&lt;
  void*&gt;(::wrapper::Data::_wrapObj(this)),false) , _wrapped(true) {
  // DO-NOT-DELETE splicer.begin(wrapper.Data._ctor2)
  d_ctorTest = "ctor was run";
  // DO-NOT-DELETE splicer.end(wrapper.Data._ctor2)
}

void wrapper::Data_impl::setString_impl (
  /* in */const ::std::string&amp; s ) {
  // DO-NOT-DELETE splicer.begin(wrapper.Data.setString)
  d_string = "Hello World!";
  // DO-NOT-DELETE splicer.end(wrapper.Data.setString)
}

void wrapper::Data_impl::setInt_impl (
  /* in */int32_t i )
{
  // DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)
  d_int = 3;
  // DO-NOT-DELETE splicer.end(wrapper.Data.setInt)
}</TD></TR>
</TABLE><!--TOC section The Backdoor Initializer in Java-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc104">20.8</A>  The Backdoor Initializer in Java</H2><!--SEC END --><P><A NAME="s:Java"></A>
<A NAME="@default1924"></A></P><P>In Object Oriented languages there is no <TT>_wrapObj</TT> method
exposed to the user. Instead, the same functionality is achieved
simply by calling “new” on the Impl class. Interestingly, this
means the constructor functionality is NOT placed in a Babel
<TT>ctor</TT> method, but is, instead, actually in the default object constructor.</P><P>Here is an excerpt from the class definition for wrapper.Data_Impl:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <B>public</B> String d_string;
  <B>public int</B> d_int;
  <B>public</B> String d_ctorTest;

  <B>public</B> Data_Impl(){
    d_ior = _wrap(<B>this</B>);
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(wrapper.Data._wrap)</I></FONT>
    d_ctorTest = "ctor was run";
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(wrapper.Data._wrap)</I></FONT>
  }

  <B>public void</B> setString_Impl (
    <FONT COLOR="blue"><I>/*in*/</I></FONT> java.lang.String s )
    <B>throws</B> sidl.RuntimeException.Wrapper
  {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(wrapper.Data.setString)</I></FONT>
    d_string = s;
    <B>return</B> ;
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(wrapper.Data.setString)</I></FONT>
  }

  <B>public void</B> setInt_Impl (
    <FONT COLOR="blue"><I>/*in*/</I></FONT> <B>int</B> i )
    <B>throws</B> sidl.RuntimeException.Wrapper
  {
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.begin(wrapper.Data.setInt)</I></FONT>
    d_int = i;
    <B>return</B> ;
    <FONT COLOR="blue"><I>// DO-NOT-DELETE splicer.end(wrapper.Data.setInt)</I></FONT>
  }</TD></TR>
</TABLE><P>Here is the client code from WrapTest.java: 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Java</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>public static void</B> main(String args[]) {
  wrapper.Data_Impl d_data = <B>new</B> wrapper.Data_Impl();
  wrapper.User d_user = <B>new</B> wrapper.User();
  System.out.println(d_data.d_ctorTest);
  d_user.accept(d_data);
  System.out.println(d_data.d_string, d_data.d_int);
}</TD></TR>
</TABLE><!--TOC section The Backdoor Initializer in Python-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc105">20.9</A>  The Backdoor Initializer in Python</H2><!--SEC END --><P><A NAME="s:Java"></A>
<A NAME="@default1925"></A></P><P>In Object Oriented languages there is no <TT>_wrapObj</TT> method
exposed to the user. Instead, the same functionality is achieved
simply by calling “new” on the Impl class. </P><P>However, writing the Python backdoor constructor is a little trickier
than Java or C++. This is because there is no overloading in Python,
so multiple constructors were a problem. Instead, the class
implementor needs to determine if the object is being constructed
directly by the user, or through the normal Babel process. This can
be achieved with an if statement. If the argument <TT>IORself ==
None</TT>, then the user has called the backdoor constructor, if
<TT>IORself != None</TT>, it is a normal Babel construction.</P><P>Here is an excerpt from the class definition for wrapper.Data_Impl.Data:
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>class</B> Data:
  <B>def</B> __init__(self, IORself = None):
    <B>if</B> (IORself == None):
      self.__IORself = wrapper.Data.Data(impl = self)
    <B>else</B>:
      self.__IORself = IORself
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(__init__)</I></FONT>
    <B>if</B>(IORself == None):
      self.d_string = "placeholder value"
      self.d_ctortest = "ctor was run"
      self.d_int = 0
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(__init__)</I></FONT>

  <B>def</B> setString(self, s):
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(setString)</I></FONT>
    self.d_string = s
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(setString)</I></FONT>

  <B>def</B> setInt(self, i):
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.begin(setInt)</I></FONT>
    self.d_int = i
    <FONT COLOR="blue"><I># DO-NOT-DELETE splicer.end(setInt)</I></FONT></TD></TR>
</TABLE><P>Here is the client code from WrapTest.java: 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Python</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>import</B> wrapper.User
<B>import</B> wrapper.Data
<B>import</B> wrapper.Data_Impl

<B>if</B> __name__ == '__main__':
  user = wrapper.User.User()
  data = wrapper.Data_Impl.Data()

  <B>print</B> data.d_ctortest
  user.accept(data._getStub())
  <B>print</B> data.d_string + " " + d_int
0</TD></TR>
</TABLE><!--TOC chapter Interface Contracts-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc106">Chapter 21</A>  Interface Contracts</H1><!--SEC END --><P><A NAME="c:contracts"></A>
<A NAME="@default1926"></A>
<A NAME="@default1927"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc107">21.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:contracts_intro"></A>
Interface contracts help improve software quality through their support
for the explicit definition and enforcement of expected behaviors at call 
boundaries.
<EM>Quality</EM>, as defined by the Institute of Electrical and Electronics 
Engineers (IEEE) [<A HREF="#ieee90"></A>], is the degree to which a system, component, 
or process meets its specifications, needs, or expectations.
Therefore, interface contracts may be used to address quality in terms of 
defining the expected behaviors of callers (or clients) and callee’s
(i. e., servers or implementations) of methods.
Specifications, in the form of executable assertions, have a long history 
of adding value to the software development process by helping ensure 
software is implemented and used correctly.
Parnas [<A HREF="#parnas72"></A>] advocated machine testable, implementation-neutral 
component specifications in 1971. 
Thirty years later, Baudry <EM>et al</EM>. [<A HREF="#baudry01"></A>] found components
with high encapsulation and well-defined, contractually-specified
interfaces to be more effective at improving the quality of systems
than implementation-dependent assertions used for defensive
programming.
Babel supports both the optional specification and automated enforcement 
of interface contracts.</P><P>Executable, programming language-neutral constraints on the (public) 
methods of interfaces and classes are supported in SIDL.
These specifications define the software behaviors required and expected
at call boundaries regardless of the programming language(s) used to 
implement the methods.
The associated constraints may be checked at runtime through a variety 
of enforcement options intended for different phases of the software 
life cycle.</P><!--TOC section Specifications-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc108">21.2</A>  Specifications</H2><!--SEC END --><P><A NAME="s:contracts_specs"></A>
<A NAME="@default1928"></A>
<A NAME="@default1929"></A></P><P>Interface contracts consist of one or more clauses defining expected 
behaviors at method call boundaries.
The behaviors are specified through assertions, which may include 
built-in or user-defined function calls.
An example for calculating the sum of two vectors<SUP><A NAME="text29" HREF="#note29">1</A></SUP> is shown below. 
All callers of this method are required to provide two one-dimensional, SIDL 
arrays of the same size and, assuming the preconditions are satisfied, all 
implementations are expected to ensure they return a non-null, one-dimensional 
array of the same size (as the first SIDL array).
The specification includes the invocation of two built-in functions: 
<TT>dimen</TT> and <TT>size</TT>.
Violations of an assertion within a clause results in the raising of a 
clause-specific exception; namely, <TT>sidl.PreViolation</TT> if
the caller violates the contract or <TT>sidl.PostViolation</TT> 
if the implementation violates the contract.
Hence, this example defines constraints that are to hold immediately 
prior to (or preconditions on) and immediately upon return from (or
postconditions of) executing the <TT>vuSum</TT> method defined in the
<TT>Utils</TT> class within the <TT>vect</TT> package.</P><P><A NAME="@default1930"></A>
<A NAME="@default1931"></A>
<A NAME="@default1932"></A>
<A NAME="@default1933"></A><A NAME="@default1934"></A>
<A NAME="@default1935"></A>
<A NAME="@default1936"></A>
<A NAME="@default1937"></A>
<A NAME="@default1938"></A>
<A NAME="@default1939"></A>
<A NAME="@default1940"></A>
<A NAME="@default1941"></A>
<A NAME="@default1942"></A>
<A NAME="@default1943"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect <B>version</B> 1.0 {
  <B>class</B> Utils {
    /* ... */

    /**
     * Return the sum of the specified vectors.
     */
    <B>static array</B>&lt;<B>double</B>&gt; vuSum(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v)
      <B>throws</B>
        sidl.PreViolation, sidl.PostViolation;
      <B>require</B>
        not_null_u: u != null;
        u_is_1d : dimen(u) == 1;
        not_null_v: v != null;
        v_is_1d : dimen(v) == 1;
        same_size: size(u) == size(v);
      <B>ensure</B>
        no_side_effects : is pure;
        result_not_null: result != null;
        result_is_1d : dimen(result) == 1;
        result_correct_size: size(result) == size(u);
  }

    /* ... */
}</I></FONT></TD></TR>
</TABLE><P>The remainder of this section elaborates on the contents of contract clauses.
Clauses consist of assertion expressions specified using an Eiffel-inspired
syntax.
SIDL expressions may contain basic and advanced operations as well as
built-in and user-defined function calls. 
The detection of contract violations result in the automatic raising of
clause-specific exceptions.</P><!--TOC subsection Contract Clauses-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.2.1  Contract Clauses</H3><!--SEC END --><P><A NAME="ss:contract_clauses"></A>
<A NAME="@default1944"></A>
<A NAME="@default1945"></A></P><P>There are three types of contract clauses associated with interfaces:
preconditions, postconditions, and class invariants.
<EM>Preconditions</EM> declare constraints on invocation of a method while
<A NAME="@default1946"></A>
<A NAME="@default1947"></A><A NAME="@default1948"></A>
<EM>postconditions</EM> constrain its effects.
<A NAME="@default1949"></A>
<A NAME="@default1950"></A><A NAME="@default1951"></A>
Class invariants specify properties unchanged throughout the life of an 
instance of a class so apply to all of the defined methods.
<A NAME="@default1952"></A><A NAME="@default1953"></A>
<A NAME="@default1954"></A>
While all three clause types share a common format for specifying these
constraints<SUP><A NAME="text30" HREF="#note30">2</A></SUP>, their location with the specification varies.</P><P>As introduced in Section <A HREF="#ss:intro_contract_clauses">6.5</A>, the format of
a contract clause starts with a clause keyword followed by one or more
assertion expressions. 
The syntax was borrowed from the classic Eiffel [<A HREF="#meyer97"></A>] clauses
established by Bertrand Meyer.
The figure below shows the SIDL format, including all supported clause types. 
Each expression may be preceded by a label.
If thoughtfully written, the label can provide a succinct “description” of
the purpose of the assertion to aid debugging, since labels are automatically 
included in the exception message of a violated contract clause.
Expressions are described in Section <A HREF="#ss:contracts_expressions">21.2.2</A>.</P><P><A NAME="@default1955"></A>
<A NAME="@default1956"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">   &lt;require | ensure | invariant&gt;
      [label-1:]  &lt;assertion-expression-1&gt;;
     [[label-2:]  &lt;assertion-expression-2&gt;;
                           ...
      [label-n:]  &lt;assertion-expression-n&gt;;]</TD></TR>
</TABLE><P>Since preconditions and postconditions are associated with specific methods,
their definitions are optional extensions in SIDL.
The figure below shows the basic structure of a SIDL method specification,
including the relative locations of the preconditions, or <TT>require</TT>, 
and postconditions, or <TT>ensure</TT>, clauses. 
When contract clauses are added to the specification, each method’s
<TT>throws</TT> clause <EM>must</EM> explicitly list the appropriate
contract clause violation exception<SUP><A NAME="text31" HREF="#note31">3</A></SUP>.
Exceptions are described in Section <A HREF="#ss:contracts_violations">21.2.3</A>.</P><P><A NAME="@default1957"></A>
<A NAME="@default1958"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [throws &lt;exception&gt;];
      [require &lt;contract-clause-expressions&gt;]
      [ensure &lt;contract-clause-expressions&gt;]</TD></TR>
</TABLE><P>Class invariants apply to all specified methods associated with a class so,
instead of requiring them to be defined for each method, the <TT>invariant</TT> 
clause is provided. 
The clause, which may be specified for an interface or class, must appear
before method definitions start. 
The basic structures of interface and class specifications, to include the
invariant clause, appear below.</P><P><A NAME="@default1959"></A>
<A NAME="@default1960"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  [ abstract ] class &lt;name&gt; [ extends &lt;scoped-class-name&gt; ]
                 [ implements-all &lt;scoped-interface-name-list&gt; ] {
                 [ invariant &lt;contract-clause-expressions&gt; ]
    [ abstract | final | static ] &lt;method-1&gt;
  [ [ abstract | final | static ] &lt;method-2&gt;
                       ...
    [ abstract | final | static ] &lt;method-n&gt; ]
  } [;]

  interface &lt;name&gt; [ extends &lt;scoped-interface-name-list&gt; ] {
    [ invariant &lt;contract-clause-expressions&gt; ]
    &lt;method-1&gt;
  [ &lt;method-2&gt;
       ...
    &lt;method-n&gt; ]
  } [;]</TD></TR>
</TABLE><P><A NAME="@default1961"></A>
<A NAME="@default1962"></A>
SIDL contract clauses can be inherited.
However, all assertion expressions — directly defined and inherited — 
are aggregated on a clause basis and checks built by essentially 
<EM>and</EM>’ing them.
This results in effectively strengthening (i. e., applying <EM>and then</EM>) 
to the inherited clauses; rather, than the proper notion of weakening 
(i. e., applying <EM>or else</EM> to) inherited precondition clauses.
No optimization is performed on the resulting checks either.
The interested reader should consult [<A HREF="#meyer97"></A>] and [<A HREF="#mitchell02"></A>] for 
more information on (proper) contract inheritance behavior. </P><P>Hence, SIDL’s interface contract specifications are based on three types of 
contract clauses: preconditions, postconditions, and class invariants.
While all three share a common basic format — keyword followed by a
list of assertion expressions — they appear in different locations
within the specification. 
Specifically, postconditions follow preconditions within the definition
of a method; while class invariants are specified before methods in
class and interface definitions.</P><!--TOC subsection Assertion Expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.2.2  Assertion Expressions</H3><!--SEC END --><P><A NAME="ss:contracts_expressions"></A>
<A NAME="@default1963"></A>
<A NAME="@default1964"></A></P><P><A NAME="@default1965"></A>
<A NAME="@default1966"></A>
</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 21.1: Operators available for use in SIDL assertion expressions.</TD></TR>
</TABLE></DIV>
<A NAME="tbl:contractOps"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP><B>OPERATOR(S)</B></TD><TD ALIGN=center NOWRAP><B>DESCRIPTION</B></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>&lt;</TT>, <TT>&lt;=</TT></TD><TD ALIGN=center NOWRAP>Is less than, Is less than or equal to</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>==</TT>, <TT>!=</TT></TD><TD ALIGN=center NOWRAP>Is equal to, Is not equal to</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>&gt;</TT>, <TT>&gt;=</TT></TD><TD ALIGN=center NOWRAP>Is greater than, Is greater than or equal to</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>+</TT>, <TT>-</TT></TD><TD ALIGN=center NOWRAP>Addition, Subtraction</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>*</TT>, <TT>/</TT></TD><TD ALIGN=center NOWRAP>Multiplication, Division</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>**</TT></TD><TD ALIGN=center NOWRAP>Power</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>and</TT></TD><TD ALIGN=center NOWRAP>Logical and</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>iff</TT></TD><TD ALIGN=center NOWRAP>If and only if</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>implies</TT></TD><TD ALIGN=center NOWRAP>Implies</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>is</TT></TD><TD ALIGN=center NOWRAP>Is (paired with the <TT>pure</TT> keyword)</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>mod</TT></TD><TD ALIGN=center NOWRAP>Modulo</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>not</TT></TD><TD ALIGN=center NOWRAP>Is not</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>or</TT></TD><TD ALIGN=center NOWRAP>Inclusive or</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>rem</TT></TD><TD ALIGN=center NOWRAP>Remainder</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>xor</TT></TD><TD ALIGN=center NOWRAP>Exclusive or</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Assertion expressions represent properties that must be true at the 
execution point corresponding to their containing contract clause.
These expressions are composed of operators and operands.
Individual operands may take the form of arguments, results, constants, 
or function calls.
Arguments and results make sense only for clauses associated with specific
methods (i. e., preconditions and postconditions).
Constant values and function calls may be specified in any contract clause.</P><P>Basic expression syntax is supported, including the use of parentheses
to indicate precedence. Expressions may involve unary or binary
operators. They may be as basic as a simple comparison
(e. g. <TT>u != null</TT>) or involve multiple comparisons
(e. g. <TT>(u != null) implies (size(u) &gt;= 0)</TT><SUP><A NAME="text32" HREF="#note32">4</A></SUP>). Regardless of the number of sub-expressions, every
assertion expression must evaluate to a boolean result.</P><P><A NAME="@default1967"></A>
<A NAME="@default1968"></A>
SIDL assertion expression operators include those operators available in most 
common programming languages, as well as some advanced operators, such as 
<TT>iff</TT> (for <EM>if and only if</EM>) and <TT>implies</TT>.
Table <A HREF="#tbl:contractOps">21.1</A> provides a complete list.
Advanced operations, for universal and existential quantification, are also
supported, though through built-in functions described later in this section.
The associated operands may take the form of arguments, results, constant 
values, and method calls. </P><P><A NAME="@default1969"></A>
<A NAME="@default1970"></A>
Precondition and postcondition clauses may include constraints on the
arguments and results of the associated method. 
Arguments are referenced using their names as specified in the method’s 
parameter list.
<A NAME="@default1971"></A>
<A NAME="@default1972"></A>
The method’s result, which is not named in the specification, is represented
in the expression by the generic <TT>result</TT> keyword, which takes on the
method’s return type.</P><P><A NAME="@default1973"></A>
<A NAME="@default1974"></A>
</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 21.2: Special keywords available for use in SIDL assertion expressions.</TD></TR>
</TABLE></DIV>
<A NAME="tbl:contractKeywords"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP><B>KEYWORD</B></TD><TD ALIGN=center NOWRAP><B>MEANING</B></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>false</TT></TD><TD ALIGN=center NOWRAP>False</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>null</TT></TD><TD ALIGN=center NOWRAP>Null reference</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>pure</TT></TD><TD ALIGN=center NOWRAP>Side effect-free</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>result</TT></TD><TD ALIGN=center NOWRAP>Method result</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>true</TT></TD><TD ALIGN=center NOWRAP>True</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P><A NAME="@default1975"></A>
<A NAME="@default1976"></A>
Constants, such as boolean and numeric values, are also supported. 
Table <A HREF="#tbl:contractKeywords">21.2</A>, which lists all of the keywords allowed
in SIDL assertion expressions, includes recognized boolean and pointer value
representations.
The table also includes two special keywords: <TT>pure</TT> and <TT>result</TT>.
<A NAME="@default1977"></A>
<A NAME="@default1978"></A>
The former, when paired with the <TT>is</TT> operator, as in <TT>is pure</TT>,
represents a non-executable postcondition annotation used to indicate 
implementations of the method <EM>should</EM> be side effect-free.
This property is necessary so the method (or function) can be safely used in 
an interface contract; however, there is no support in the toolkit for
statically analyzing source code (in <EM>any</EM> of the supported programming 
languages) to ensure the property is true for implementations of the interface.
As mentioned previously, <TT>result</TT> represents the value returned by the
associated method.</P><P><A NAME="@default1979"></A>
<A NAME="@default1980"></A>
Function calls are supported within contract clauses to enable the definition
of richer constraints.
They enable restrictions on object properties, which are not visible in SIDL, 
and (interface- or class-specific) logic enhancing contract expressiveness.
The functions may be built-in or in scope, user-defined methods.</P><P><A NAME="@default1981"></A>
<A NAME="@default1982"></A>
</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 21.3: Built-in SIDL interface contract functions, where <I>expr</I> can be one 
of: <I>u</I> <I>r</I> <I>v</I>, <I>u</I> <I>r</I> <I>n</I>, and <I>n</I> <I>r</I> <I>v</I> with <I>u</I>, <I>v</I> ∈ <EM>SIDL arrays</EM>, 
<I>n</I> ∈ <EM>Numbers</EM>, and <I>r</I> ∈ {&lt;, &gt;, &lt;=, &gt;=, ==, !=}. 
The relation <I>u</I> <I>r</I> <I>v</I> is equivalent to
∀ <I>i</I> ∈ 0 .. (<I>size</I>(<I>u</I>)−1), <I>u</I>[<I>i</I>] <I>r</I> <I>v</I>[<I>i</I>]; <I>u</I> <I>r</I> <I>n</I> to
∀ <I>i</I> ∈ 0 .. (<I>size</I>(<I>u</I>)−1), <I>u</I>[<I>i</I>] <I>r</I> <I>n</I>; and <I>n</I> <I>r</I> <I>v</I> to
∀ <I>i</I> ∈ 0 .. (<I>size</I>(<I>v</I>)−1), <I>n</I> <I>r</I> <I>u</I>[<I>i</I>].</TD></TR>
</TABLE></DIV>
<A NAME="tbl:builtinFuncs"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP><B>FUNCTION</B></TD><TD VALIGN=top ALIGN=left><B>RETURNS</B></TD><TD VALIGN=top ALIGN=center NOWRAP><B>COMPLEXITY</B></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>dimen(<I>u</I>)</TD><TD VALIGN=top ALIGN=left>Dimension of array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>irange(<I>x</I>, <I>n<SUB>low</SUB></I>, <I>n<SUB>high</SUB></I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if <I>x</I> falls within the integer range of <I>n<SUB>low</SUB></I>..<I>n<SUB>high</SUB></I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>lower(<I>u</I>, <I>d</I>)</TD><TD VALIGN=top ALIGN=left>Lower index of the <I>d<SUP>th</SUP></I> dimension of array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>nearEqual(<I>x</I>, <I>y</I>, <I>t</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if real values <I>x</I> and <I>y</I> are within the specified tolerance, <I>t</I>,
of being equal.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>range(<I>x</I>, <I>r<SUB>low</SUB></I>, <I>r<SUB>high</SUB></I>, <I>t</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if the real value <I>x</I> falls within the specified tolerance, <I>t</I>, of
the range <I>r<SUB>low</SUB></I>..<I>r<SUB>high</SUB></I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>size(<I>u</I>)</TD><TD VALIGN=top ALIGN=left>Allocated size of array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>stride(<I>u</I>, <I>d</I>)</TD><TD VALIGN=top ALIGN=left>Stride of the <I>d<SUP>th</SUP></I> dimension of array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>upper(<I>u</I>, <I>d</I>)</TD><TD VALIGN=top ALIGN=left>Upper index of the <I>d<SUP>th</SUP></I> dimension of array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(1)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>all(<I>expr</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if the expression <I>expr</I> evaluates to <I>true</I> for each 
element in the specified array(s). For example, <TT>all(<I>u</I> &lt; <I>v</I>)</TT> 
returns <I>true</I> if the value of each element in array <I>u</I> is less than the 
value of the corresponding element in array <I>v</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>any(<I>expr</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if at least one element in the specified array(s) satisfies the
expression <I>expr</I>. For example, <TT>any(<I>u</I> = 0)</TT> 
returns <I>true</I> upon encountering the first element in array <I>u</I> whose value 
equals zero but returns <I>false</I> if none of the elements have values equal zero.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>count(<I>expr</I>)</TD><TD VALIGN=top ALIGN=left>The total number of array elements satisfying the expression <I>expr</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>irange(<I>u</I>, <I>n<SUB>low</SUB></I>, <I>n<SUB>high</SUB></I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if all elements in the array, <I>u</I>, fall within the integer range
<I>n<SUB>low</SUB></I>..<I>n<SUB>high</SUB></I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>max(<I>u</I>)</TD><TD VALIGN=top ALIGN=left>The maximum of the values of the elements in array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>min(<I>u</I>)</TD><TD VALIGN=top ALIGN=left>The minimum of the values of the elements in array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>nearEqual(<I>u</I>, <I>v</I>, <I>t</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if the corresponding elements in arrays <I>u</I> and <I>v</I> are within the
specified tolerance, <I>t</I>, of being equal.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>none(<I>expr</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if none of the elements in the specified array(s) satisfies the
expression <I>expr</I>. For example, <TT>none(<I>u</I> &gt;= 0.0)</TT> 
returns <I>true</I> if none of the elements of array <I>u</I> have values greater 
than or equal to 0.0.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>nonDecr(<I>u</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if the values of the elements in array <I>u</I> are in non-decreasing order.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>nonIncr(<I>u</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if the values of the elements in array <I>u</I> are in non-increasing order.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>range(<I>u</I>, <I>r<SUB>low</SUB></I>, <I>r<SUB>high</SUB></I>, <I>t</I>)</TD><TD VALIGN=top ALIGN=left><I>True</I> if all elements in array <I>u</I> fall within the specified tolerance, <I>t</I>,
of <I>r<SUB>low</SUB></I> .. <I>r<SUB>high</SUB></I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>sum(<I>u</I>)</TD><TD VALIGN=top ALIGN=left>Returns the total of the values of all elements in array <I>u</I>.</TD><TD VALIGN=top ALIGN=center NOWRAP>O(<I>n</I>)</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P><A NAME="@default1983"></A>
<A NAME="@default1984"></A>
Built-in functions, described in Table <A HREF="#tbl:builtinFuncs">21.3</A>, provide scalar 
and SIDL array features, with the latter enabling universal (e. g. <TT>all</TT>)
and existential (e. g. <TT>any</TT>) quantification.
Array property and simple numeric value comparator functions operate in 
constant-time. 
Other array-based operations, such as existential and universal quantifiers, 
are linear in the size of the arrays.
Their complexity is mentioned here because it is relevant to some of the
experimental enforcement policies described in 
Section <A HREF="#s:contracts_enforcement">21.3</A>.</P><P><A NAME="@default1985"></A>
<A NAME="@default1986"></A>
Allowing the specification of user-defined functions within contract clauses 
poses a risk in that implementors may erroneously come to depend on them — and
their side effects — for proper implementation behavior. 
This is a <EM>mistake</EM>. 
The runtime enforcement of interface contracts is optional and, therefore,
cannot be relied upon for correct functionality.
<A NAME="@default1987"></A>
<A NAME="@default1988"></A>
This is why Babel requires the contract of user-defined functions intended 
or able to be used in the contract of another method to include the 
<TT>is pure</TT> postcondition annotation described previously.</P><P>In summary, SIDL contract clauses contain a list of one or more simple or 
compound expressions, each evaluating to a boolean value.
Expressions may contain any of twenty built-in, basic or advanced operators;
method arguments and results (only in precondition and postcondition clauses);
special keywords; boolean and numeric constants; twenty built-in scalar and
SIDL array functions; and in scope, user-defined functions.
While there is a potential danger associated with allowing user-defined 
functions within contract clauses, the ability is supported to enable richer 
constraints and provide a mechanism for identifying and prototyping 
potential domain-specific contract features.</P><!--TOC subsection Contract Violations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.2.3  Contract Violations</H3><!--SEC END --><P><A NAME="ss:contracts_violations"></A>
<A NAME="@default1989"></A>
<A NAME="@default1990"></A>
<A NAME="@default1991"></A>
<A NAME="@default1992"></A></P><P>Enforcement is performed on a contract clause basis so, if an assertion
does not hold, a clause-specific exception is automatically raised.
That is, the <TT>sidl.PreViolation</TT> exception is raised when 
preconditions are violated; <TT>sidl.PostViolation</TT> 
raised for postcondition violations; and 
<TT>sidl.InvViolation</TT> for invariants violations.
The exceptions, as defined in <TT>sidl.sidl</TT>, are shown below.
The label, if any, of the associated assertion expression is included
in the exception message; therefore, meaningful labels can aid testing
and debugging.</P><P><A NAME="@default1993"></A>
<A NAME="@default1994"></A>
<A NAME="@default1995"></A>
<A NAME="@default1996"></A>
<A NAME="@default1997"></A>
<A NAME="@default1998"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;PreViolation&lt;/code&gt; indicates an assertion within a precondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PreViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {}

  /**
   * &lt;code&gt;PostViolation&lt;/code&gt; indicates an assertion within a postcondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PostViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {}

  /**
   * &lt;code&gt;InvViolation&lt;/code&gt; indicates an assertion within a invariant
   * clause of the interface contract has been violated.
   */
  <B>class</B> InvViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }</I></FONT></TD></TR>
</TABLE><!--TOC section Enforcement-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc109">21.3</A>  Enforcement</H2><!--SEC END --><P><A NAME="s:contracts_enforcement"></A>
<A NAME="@default1999"></A>
<A NAME="@default2000"></A></P><P>Interface contract enforcement is based on a global policy set at runtime.
The policy establishes the contract clauses of interest and the frequency 
at which they should be checked.
These two options support traditional contract/assertion enforcement
as well as experimental strategies.
The policy also supports enforcement tracing, though a discussion of this 
feature is provided separately in Section <A HREF="#ss:contracts_tracing">21.3.4</A>.</P><P><A NAME="@default2001"></A>
<A NAME="@default2002"></A>
The enforcement policy should reflect the goals of the run which, as 
mentioned in Section <A HREF="#ss:intro_contract_enforcement">6.5</A>, are often 
tied to the phase in the software’s life cycle.
Available enforcement options range from traditional to experimental,
with the former focused on aiding testing, debugging, and deployment.
Some experimental options support a reduced level of enforcement intended
for performance-contrained environments, while others are for gathering 
data to facilitate gaining insights into the nature of interface contract 
enforcement.</P><P>The SIDL specification of the enforcement policy is:</P><P><A NAME="@default2003"></A>
<A NAME="@default2004"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /**
     * Sets the enforcement policy to always check the specified
     * type(s) of contracts.  This is equivalent to calling
     * setPolicy() with ALWAYS as the enforcement frequency
     * and the specified (or default) contract class.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceAll(<B>in</B> ContractClass contractClass,
                              <B>in bool</B>          clearStats);

    /**
     * Sets the policy options to disable all contract enforcement.
     * This is equivalent to calling setPolicy() with NEVER as the
     * enforcement frequency.
     *
     * @param clearStats  TRUE if enforcement statistics are to be
     *                      cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceNone(<B>in bool</B> clearStats);

    /**
     * Sets enforcement policy and options.  This method should be
     * invoked directly to avoid the default enforcement behavior.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param enforceFreq    Enforcement frequency
     *                         [Default = ALWAYS]
     * @param interval       Sampling interval representing the
     *                         period (for PERIODIC) or maximum
     *                         random number/window (for RANDOM)
     *                         [Default = 0 if negative specified]
     * @param overheadLimit  Limit on performance overhead [0.0 .. 1.0)
     *                         [Default = 0.0 (or 0%) if negative]
     * @param appAvgPerCall  Average extra, application-specific
     *                         execution time, normalized by calls
     *                         to annotated methods
     *                         [Default = 0.0 if negative]
     * @param annealLimit    Limit on simulated annealing function
     *                         to ensure its termination
     *                         (0.0 .. 2.72]
     *                         [Default = 2.72 if negative specified]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setPolicy(<B>in</B> ContractClass contractClass,
                          <B>in</B> EnforceFreq   enforceFreq,
                          <B>in int</B>           interval,
                          <B>in double</B>        overheadLimit,
                          <B>in double</B>        appAvgPerCall,
                          <B>in double</B>        annealLimit,
                          <B>in bool</B>          clearStats);

    /**
     * Returns TRUE if contract enforcement is enabled; FALSE otherwise.
     */
    <B>static bool</B> areEnforcing();

    /**
     * Returns the contract classification policy option.
     */
    <B>static</B> ContractClass getContractClass();

    /**
     * Returns the enforcement frequency policy option.
     */
    <B>static</B> EnforceFreq getEnforceFreq();

    /**
     * Returns the interval for PERIODIC (i.e., the interval) or
     * RANDOM (i.e., the maximum random number).  Returns 0 by default.
     */
    <B>static int</B> getSamplingInterval();

    /**
     * Returns the desired enforcement overhead limit for
     * performance-driven frequency options (i.e., ADAPTFIT,
     * ADAPTTIMING, and SIMANNEAL).  Returns 0.0 by default.
     */
    <B>static double</B> getOverheadLimit();

    /**
     * Returns the average assumed execution time associated
     * with the program or application.  Returns 0.0 by default.
     */
    <B>static double</B> getAppAvgPerCall();

    /**
     * Returns the annealing limit for SIMANNEAL enforcement
     * frequency option.  Returns 0.0 by default.
     */
    <B>static double</B> getAnnealLimit();

    /**
     * Returns the name, or description, of the enforcement policy.
     * The caller is responsible for calling sidl_String_free()
     * on the name when done with it.
     *
     * @param useAbbrev   TRUE if the abbreviated name is to be
     *                    returned.
     */
    <B>static string</B> getPolicyName(<B>in bool</B> useAbbrev);

    /**
     * Prints statistics data to the file with the specified name.
     * The file is opened (for append) and closed on each call.
     *
     * @param filename   Name of the file to which the statistics
     *                     data should be written.
     * @param header     TRUE if the header line is to be printed
     *                     prior to the statistics line (for compressed
     *                     output only).
     * @param prefix     String description for identifying information,
     *                     if any, intended to preceed the statistics
     *                     data.  Useful for distinguishing between
     *                     different objects, for example.
     * @param compressed TRUE if the enforcer state is to be dumped
     *                     on a single line with semi-colon separators
     *                     between fields.
     */
    <B>static void</B> dumpStats(<B>in string</B> filename,
                          <B>in bool</B>   header,
                          <B>in string</B> prefix,
                          <B>in bool</B>   compressed);

    /**
     * Starts enforcement trace file generation.
     *
     * @param filename    Name of the destination trace file.
     * @param traceLevel  Level of trace timing and reporting required.
     *                      [Default = NONE]
     */
    <B>static void</B> startTrace(<B>in string</B>        filename,
                           <B>in</B> EnfTraceLevel traceLevel);

    /**
     * Returns TRUE if contract enforcement tracing is enabled;
     * FALSE otherwise.
     */
    <B>static bool</B> areTracing();

    /**
     * Returns the name of the trace file.  If one was not provided,
     * the default name is returned.
     */
    <B>static string</B> getTraceFilename();

    /**
     * Returns the level of enforcement tracing.
     */
    <B>static</B> EnfTraceLevel getTraceLevel();

    /**
     * Terminates enforcement trace file generation.  Takes a final
     * timestamp and logs the remaining trace information.
     */
    <B>static void</B> endTrace();
  }</I></FONT></TD></TR>
</TABLE><P>This class provides the ability to set and query enforcement 
options and statistics, as well as enforcement tracing.
Two options establish the enforcement policy: contract clause 
classifications and enforcement frequency.
Classification options identify either the clause or characteristics of 
the assertions within clauses.
Some classification options reflect traditional contract enforcement 
strategies while others enable data gathering.
Enforcement frequency options distinguish between traditional enforcement 
— where all associated contract clauses are checked — and sampling-based
enforcement.
Contract enforcement data, collected at runtime, is available for analysis.
Enforcement tracing provides a mechanism for collecting data needed
for experimental sampling options.</P><!--TOC subsection Contract Classification Options-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.3.1  Contract Classification Options</H3><!--SEC END --><P><A NAME="ss:contracts_classes"></A>
<A NAME="@default2005"></A>
<A NAME="@default2006"></A>
<A NAME="@default2007"></A>
<A NAME="@default2008"></A></P><P>Contract clause classifications distinguish between clauses based
on their type or characteristics of the contained assertions.
Clause types are used for more traditional enforcement strategies;
whereas assertion characteristics are intended for gathering data on
the nature of contract clauses actually encountered during execution. </P><P>The SIDL specification for contract clause classification options is:</P><P><A NAME="@default2009"></A>
<A NAME="@default2010"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * Contract classification.  The classification is used to filter
   * contract clauses by the corresponding characteristic(s).
   */
  <B>enum</B> ContractClass {
    /**
     * All classifications of interface contract clauses.
     */
    ALLCLASSES,
    /**
     * Only constant-time complexity, or O(1), clauses.
     */
    CONSTANT,
    /**
     * Only cubic-time complexity, or O(n^3), clauses.
     */
    CUBIC,
    /**
     * Only invariant clauses.
     */
    INVARIANTS,
    /**
     * Invariant plus postcondition clauses.
     */
    INVPOST,
    /**
     * Invariant plus precondition clauses.
     */
    INVPRE,
    /**
     * Only linear-time complexity, or O(n), clauses.
     */
    LINEAR,
    /**
     * Method calls.  Only clauses containing at least one method call.
     */
    METHODCALLS,
    /**
     * Only postcondition clauses.
     */
    POSTCONDS,
    /**
     * Only precondition clauses.
     */
    PRECONDS,
    /**
     * Precondition plus postcondition clauses.
     */
    PREPOST,
    /**
     * Only quadratic-time complexity, or O(n^2), clauses.
     */
    QUADRATIC,
    /**
     * Only quartic-time complexity, or O(n^4), clauses.
     */
    QUARTIC,
    /**
     * Only quintic-time complexity, or O(n^5), clauses.
     */
    QUINTIC,
    /**
     * Results.  Only clauses containing at least one assertion on an
     * out, inout, or result argument.
     */
    RESULTS,
    /**
     * Only septic-time complexity, or O(n^7), clauses.
     */
    SEPTIC,
    /**
     * Only sextic-time complexity, or O(n^6), clauses.
     */
    SEXTIC,
    /**
     * Simple expressions.  Only clauses consisting solely of
     * simple expressions (i.e., no method calls).
     */
    SIMPLEEXPRS,
  };</I></FONT></TD></TR>
</TABLE><P><A NAME="@default2011"></A>
<A NAME="@default2012"></A>
Traditional “unit” testing with contracts at least conceptually 
starts with determining whether implementations comply with their 
specifications — assuming they are given inputs that always satisfy 
the stated preconditions.
In this case, the <TT>POSTCONDS</TT> or <TT>INVPOST</TT> option will 
enable enforcement of postcondition clauses and, in the latter case, 
invariant clauses.</P><P>This level of testing will include determining how robust the
implementations are when they are given invalid inputs.
The <TT>PRECONDS</TT> or <TT>INVPRE</TT> option could be used <EM>if</EM> 
it is determined the implementations function properly using valid 
inputs.
Both options enable precondition clause enforcement.
The latter includes invariant clauses.</P><P>The <TT>PREPOST</TT> or <TT>ALLCLASSES</TT> option can be used if the 
two aforementioned phases are combined.
These options will enable checking precondition and postcondition clauses.
If invariants are present, the latter option, which is the default,
additionally enables their enforcement.</P><P><A NAME="@default2013"></A>
<A NAME="@default2014"></A>
Once implementations pass compliance testing, an integration testing
phase is entered where an assessment is made of how they function in
the context of the callers. 
At this point, if unit testing is sufficiently rigorous, the 
<TT>PRECONDS</TT> or <TT>INVPRE</TT> option could be used in execution 
time-constrained environments.</P><P>The thoroughness of the test suite is an important factor affecting
the quality of the software.
If the test suite is not sufficiently thorough, there is a risk of 
not exposing non-compliance of contract clauses in downstream methods.
This situation can be of particular concern if there are dependencies 
involving valid sequences of method calls not exercised by the test suite.</P><P>The remaining classification options are intended for gathering data
on the nature of the assertions within the contract clauses actually 
encountered during execution of a given program.
Some options are based on the complexity of the associated assertions,
inferred from the dimensions of SIDL arrays, such as <TT>CONSTANT</TT>,
and <TT>LINEAR</TT>.
Clearly, contract clauses involving checks of multi-dimensional arrays
can be time consuming if they involve accessing many or all elements of 
large arrays.
Another pair of options are based on the presence or absence of method
calls (i. e., <TT>METHODCALLS</TT> and <TT>SIMPLEEXPRS</TT>, respectively).
These options are provided since contract clauses including method calls 
may, depending on the work performed in the methods, be very time consuming 
to check.
The final option is <TT>RESULTS</TT>, which is used to enable checking
of clauses containing out, inout, or result arguments.
It is reasoned that the data from using these options could be used for
determining sources of and alternative enforcement options for high contract 
enforcement overhead.
<A NAME="@default2015"></A>
<A NAME="@default2016"></A>
Such an investigation could be important in an environment where nightly 
regression tests cannot finish in a timely manner when checking all contract
clauses encountered, for example.</P><P>Hence, contract clause classifications support traditional clause
enforcement options — for checking preconditions, postconditions,
and (class) invariants — as well as experimental options. 
The experimental options focus on the nature of assertions within contract 
clauses, in terms of their complexity or the presence of method calls, for 
example.
These atypical options are intended for gathering data on the nature of
contract clauses actually enforced by applications. </P><!--TOC subsection Enforcement Frequency Options-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.3.2  Enforcement Frequency Options</H3><!--SEC END --><P><A NAME="ss:contracts_frequency"></A>
<A NAME="@default2017"></A>
<A NAME="@default2018"></A>
<A NAME="@default2019"></A>
<A NAME="@default2020"></A></P><P>Enforcement frequency options range from fully and partially enabling to
disabling contract enforcement. 
Historically, contract/assertion enforcement is fully enabled during testing 
and debugging but disabled during deployment.
One of the reasons for disabling enforcement during deployment is that 
its retention has historically been considered to be too time consuming.
However, there are alternatives.
Some, as described in Section <A HREF="#ss:contracts_classes">21.3.1</A>, take the form of
enforcing select contract clauses. 
However, partial enforcement strategies based on sampling techniques can be 
combined with contract clause classifications to further limit enforcement.</P><P>The SIDL specification for enforcement frequency options is:</P><P><A NAME="@default2021"></A>
<A NAME="@default2022"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * Contract clause enforcement frequency.
   */
  <B>enum</B> EnforceFreq {
    /**
     * Never.  Disable enforcement by completely by-passing checks
     * regardless of the selected contract classification.
     */
    NEVER,
    /**
     * Always.  Every clause of the selected contract classification
     * is enforced.
     */
    ALWAYS,
    /**
     * Adaptive fit.  Check clauses of the selected contract classification
     * only if they will not result in exceeding the overhead limit based
     * on accumulations of estimated execution times.
     */
    ADAPTFIT,
    /**
     * Adaptive timing.  Check clauses of the selected contract classification
     * only if their estimated execution time is within the overhead limit
     * applied to the estimated time of the corresponding method.
     */
    ADAPTTIMING,
    /**
     * Periodic.  Check clauses of the selected contract classification
     * at the specified interval.
     */
    PERIODIC,
    /**
     * Random.  Check clauses of the selected contract classifcation on a
     * random basis using the specified maximum.
     */
    RANDOM,
    /**
     * Simulated Annealing.  Essentially Adaptive fit but checks are
     * allowed to randomly exceed the overhead limit with decreasing
     * probability over time.
     */
    SIMANNEAL,
  };</I></FONT></TD></TR>
</TABLE><P>Basic enforcement frequency options are: <TT>ALWAYS</TT>, <TT>NEVER</TT>,
<TT>PERIODIC</TT>, and <TT>RANDOM</TT>.
Enabling checking all contract clauses (of the desired classification)
involves using the <TT>ALWAYS</TT> option while disabling checking 
any contract clauses (regardless of classification) occurs when the 
<TT>NEVER</TT> option is used.
The remaining two options represent very basic sampling strategies.
<TT>PERIODIC</TT> checks clauses encountered at a specified interval
while <TT>RANDOM</TT> checks a random clause (within an interval).
<A NAME="@default2023"></A>
<A NAME="@default2024"></A>
While these two options can potentially reduce enforcement overhead,
that is the extra time it takes to check the contracts, the reduction
cannot be guaranteed in general, since these options do not consider
the nature or (execution time) cost of the associated assertions.</P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">WARNING:</DIV>
The current implementation of the experimental, performance-constrained
enforcement policies has not been rigorously tested since its integration 
into the Babel/SIDL source code repository. Examples shown here reflect
results for basic enforcement during regression testing.
</BLOCKQUOTE><HR SIZE=2><P><BR>

The remaining options, which are experimental, are intended for use
in performance-constrained environments (e. g. nightly regression 
testing of very large applications and deployment).
The options — adaptive timing (<TT>ADAPTTIMING</TT>), adaptive fit 
(<TT>ADAPTFIT</TT>), and simulated annealing (<TT>SIMANNEAL</TT>) —
rely on <EM>a priori</EM> execution time estimates to conduct 
performance-driven filtering of contract clauses.
<EM>Adaptive timing</EM> checks whether the execution time estimate of the 
contract clause is within the user-specified overhead limit relative to the 
estimate for the time required to execute the method.
<EM>Adaptive fit</EM> checks whether the execution time estimate of a clause,
added to the accumulated time of all previously checked clauses, remains
within the overhead limit of the accumulated execution time of invoked methods.
Finally, <EM>simulated annealing</EM> is essentially <TT>AdaptiveFit</TT> with 
an allowance for exceeding the overhead limit, but with decreasing 
probability over time.</P><P>The SIDL specification snippet for setting options associated with
enforcement sampling is shown below.</P><P><A NAME="@default2025"></A>
<A NAME="@default2026"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    ...

    /**
     * Sets enforcement policy and options.  This method should be
     * invoked directly to avoid the default enforcement behavior.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param enforceFreq    Enforcement frequency
     *                         [Default = ALWAYS]
     * @param interval       Sampling interval representing the
     *                         period (for PERIODIC) or maximum
     *                         random number/window (for RANDOM)
     *                         [Default = 0 if negative specified]
     * @param overheadLimit  Limit on performance overhead [0.0 .. 1.0)
     *                         [Default = 0.0 (or 0%) if negative]
     * @param appAvgPerCall  Average extra, application-specific
     *                         execution time, normalized by calls
     *                         to annotated methods
     *                         [Default = 0.0 if negative]
     * @param annealLimit    Limit on simulated annealing function
     *                         to ensure its termination
     *                         (0.0 .. 2.72]
     *                         [Default = 2.72 if negative specified]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setPolicy(<B>in</B> ContractClass contractClass,
                          <B>in</B> EnforceFreq   enforceFreq,
                          <B>in int</B>           interval,
                          <B>in double</B>        overheadLimit,
                          <B>in double</B>        appAvgPerCall,
                          <B>in double</B>        annealLimit,
                          <B>in bool</B>          clearStats);
    ...
  }</I></FONT></TD></TR>
</TABLE><P>Although the method’s documentation describes each parameter,
it is worth noting that the interval is only relevant for the basic sampling 
techniques and the three following parameters for one or more experimental 
enforcement frequency option.</P><P><A NAME="@default2027"></A>
<A NAME="@default2028"></A>
Execution time estimates, which are expected to be provided on a per-class
basis, are assumed to be in a file conforming to the following naming
convention: <B><EM>package-name</EM>_<EM>class-name</EM>.dat</B>. 
For example, the SIDL specification below defines a package called 
<EM>vect</EM> with a <EM>Utils</EM> class.</P><P><A NAME="@default2029"></A>
<A NAME="@default2030"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> vect
{
  ...
  <B>class</B> Utils {
    /* Method signatures */
  }
}</I></FONT></TD></TR>
</TABLE><P>The corresponding file containing execution time estimates 
needs to be called <B>vect_Utils.dat</B>. 
The first line of the file is expected to contain two space-separated 
numbers: invariant complexity, <EM>n</EM>, and estimated average time 
to execute the invariants. 
If the are no invariants, then the first line should contain two zeros.
Subsequent lines are expected to provide similar information for each 
method in the class, with zeros used when the clause does not apply.
Specifically, lines for method estimates are expected to start with 
the method’s index, taken from the class’ IOR header file, followed 
by its precondition clause complexity, postcondition clause complexity, 
average execution time (<EM>without contract enforcement</EM>), average 
execution time of the preconditions clause, and average execution time 
of the postconditions clause. 
Supporting complexity information in the data file allows you to override
the default complexity inferred from the the presence of SIDL arrays.</P><P>The file below illustrates an example estimates data file for a class that
does not have an invariant clause.</P><P><A NAME="@default2031"></A>
<A NAME="@default2032"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Data</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">0 0.0
12 0 1 62.34285714285714 2.7 45.857142857142854
13 0 1 44.13 3.54 166.76
6 0 0 65.04 22.8 0.0
11 0 0 301.64285714285717 4.6571428571428575 0.0
10 0 0 184.71428571428572 4.328571428571428 0.0
9 0 0 97.86666666666666 4.1 0.0
7 0 0 173.82 3.24 0.0
16 0 0 301.77777777777777 3.2666666666666666 2.566666666666667
15 0 0 214.4142857142857 2.6714285714285713 3.0714285714285716
17 0 0 174.41 3.43 2.55
18 0 0 231.01818181818183 3.2 2.481818181818182
14 0 0 177.31428571428572 2.5 4.014285714285714
8 0 0 204.10526315789474 2.4263157894736844 0.0</TD></TR>
</TABLE><P>The units for the execution time estimates must be consistent
across all of the estimate files association with your application program.</P><P>In summary, the enforcement frequency option is used to determine how often
contract clauses are checked.
Traditional enforcement is supported through <TT>ALWAYS</TT> and <TT>NEVER</TT>
frequencies.
Basic sampling is provided by the <TT>PERIODIC</TT> and <TT>RANDOM</TT>
frequencies.
Finally, three experimental sampling options — <TT>ADAPTFIT</TT>, 
<TT>ADAPTTIMING</TT>, and <TT>SIMANNEAL</TT> — intended for 
performance-constrained environments adapt enforcement based on the
enforcement context, using execution time estimates.</P><!--TOC subsection Enforcement Statistics-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.3.3  Enforcement Statistics</H3><!--SEC END --><P><A NAME="ss:enforcement_stats"></A>
<A NAME="@default2033"></A>
<A NAME="@default2034"></A></P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">WARNING:</DIV>
The current implementation of enforcement statistics gathering and
reporting has not been rigorously tested since its integration 
into the Babel/SIDL source code repository. Examples shown here reflect
results for basic enforcement during regression testing.
</BLOCKQUOTE><HR SIZE=2><P><BR>

Data on contract enforcement is collected at runtime for 
subsequent analysis.
This feature is especially important for determining relevant alternative
enforcement options for long-running regression tests and deployment.</P><P>The SIDL specification snippet for reporting enforcement statistics
is given below.</P><P><A NAME="@default2035"></A>
<A NAME="@default2036"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    ...
    /**
     * Prints statistics data to the file with the specified name.
     * The file is opened (for append) and closed on each call.
     *
     * @param filename   Name of the file to which the statistics
     *                     data should be written.
     * @param header     TRUE if the header line is to be printed
     *                     prior to the statistics line (for compressed
     *                     output only).
     * @param prefix     String description for identifying information,
     *                     if any, intended to preceed the statistics
     *                     data.  Useful for distinguishing between
     *                     different objects, for example.
     * @param compressed TRUE if the enforcer state is to be dumped
     *                     on a single line with semi-colon separators
     *                     between fields.
     */
    <B>static void</B> dumpStats(<B>in string</B> filename,
                          <B>in bool</B>   header,
                          <B>in string</B> prefix,
                          <B>in bool</B>   compressed);
    ...
  }</I></FONT></TD></TR>
</TABLE><P>The file below illustrates snippets from the results of running the vector 
utilities contracts regression test available in the Babel source code 
distribution.
The lines from the file have been reformatted to fit the width of the page.</P><P><A NAME="@default2037"></A>
<A NAME="@default2038"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">Prefix; Timestamp; Policy; Interval; AnnealLimit; OHLimit;
  procPerCall; RandSkip; CD; methTime; clauseTime;
  TotalRequested; TotalAllowed; Method; Checked; Okay; Violated; MethExcepts

After full checking; Fri Oct 15 16:33:49 2010; Always; 0; 2.72; 0.00;
  0.000; 0; 0; 20371; 524;
  146; 146; vuIsZero; 5; 2; 3; 0
After full checking; Fri Oct 15 16:33:49 2010; Always; 0; 2.72; 0.00;
  0.000; 0; 0; 20371; 524;
  146; 146; vuIsUnit; 5; 2; 3; 0
  ...

After precondition checking; Fri Oct 15 16:33:49 2010; Pre; 0; 2.72; 0.00;
  0.000; 0; 0; 64; 8;
  5; 3; vuIsZero; 5; 2; 3; 0
After precondition checking; Fri Oct 15 16:33:49 2010; Pre; 0; 2.72; 0.00;
  0.000; 0; 0; 64; 8;
  5; 3; vuIsUnit; 5; 2; 3; 0
  ...

After Postcondition checking; Fri Oct 15 16:33:49 2010; Post; 0; 2.72; 0.00;
  0.000; 0; 0; 96; 95;
  6; 3; vuIsZero; 5; 2; 3; 0
After Postcondition checking; Fri Oct 15 16:33:49 2010; Post; 0; 2.72; 0.00;
  0.000; 0; 0; 96; 95;
  6; 3; vuIsUnit; 5; 2; 3; 0
  ...

After no checking; Fri Oct 15 16:33:49 2010; Never; 0; 2.72; 0.00;
  0.000; 0; 0; 255; 0;
  34; 0; vuIsZero; 5; 2; 3; 0
After no checking; Fri Oct 15 16:33:49 2010; Never; 0; 2.72; 0.00;
  0.000; 0; 0; 255; 0;
  34; 0; vuIsUnit; 5; 2; 3; 0
  ...</TD></TR>
</TABLE><!--TOC subsection Enforcement Tracing-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->21.3.4  Enforcement Tracing</H3><!--SEC END --><P><A NAME="ss:contracts_tracing"></A>
<A NAME="@default2039"></A>
<A NAME="@default2040"></A></P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">WARNING:</DIV>
The current implementation of enforcement tracing has not been rigorously 
tested since its integration into the Babel/SIDL source code repository. 
</BLOCKQUOTE><HR SIZE=2><P><BR>

Enforcement tracing is an advanced, experimental feature used to instrument 
contract enforcement with execution timing calls.
This feature aids the collection of data for two purposes.
The primary goal is to obtain data for establishing execution time estimates
for contract clause, method, and program execution time estimates.
An alternative, which has not yet received the attention it deserves,
is to provide input for simulating the execution time overhead of
interface contract enforcement.</P><P>The SIDL specification snippet for enforcement tracing controls within
the enforcement policy class is given below.</P><P><A NAME="@default2041"></A>
<A NAME="@default2042"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    ...

    /**
     * Starts enforcement trace file generation.
     *
     * @param filename    Name of the destination trace file.
     * @param traceLevel  Level of trace timing and reporting required.
     *                      [Default = NONE]
     */
    <B>static void</B> startTrace(<B>in string</B>        filename,
                           <B>in</B> EnfTraceLevel traceLevel);

    /**
     * Returns TRUE if contract enforcement tracing is enabled;
     * FALSE otherwise.
     */
    <B>static bool</B> areTracing();

    /**
     * Returns the name of the trace file.  If one was not provided,
     * the default name is returned.
     */
    <B>static string</B> getTraceFilename();

    /**
     * Returns the level of enforcement tracing.
     */
    <B>static</B> EnfTraceLevel getTraceLevel();

    /**
     * Terminates enforcement trace file generation.  Takes a final
     * timestamp and logs the remaining trace information.
     */
    <B>static void</B> endTrace();
  }</I></FONT></TD></TR>
</TABLE><P>Enforcement tracing is initiated with the <TT>startTrace</TT> call
and terminated with <TT>endTrace</TT>.
Accessor methods — <TT>areTracing</TT>, <TT>getTraceFilename</TT>,
and <TT>getTraceLevel</TT> — are provided for convenience but
are not expected to be used by in general.
Timing data is output to the file specified in the startTrace call
as it is collected, so the traces can be very large if there are 
numerous calls to instrumented methods.</P><P>The SIDL specification for enforcement tracing options is:</P><P><A NAME="@default2043"></A>
<A NAME="@default2044"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * Contract enforcement tracing levels.  Enforcement traces rely on
   * runtime timing automatically inserted within the middleware.
   */
  <B>enum</B> EnfTraceLevel {
    /**
     * None.  No tracing is to be performed.
     */
    NONE,
    /**
     * Core.  Time trace start and end only.  This can be useful for
     * simple program timing.
     */
    CORE,
    /**
     * Basic enforcement tracing.  CORE plus interface contract clause timing.
     */
    BASIC,
    /**
     * Overhead of enforcement decisions.  BASIC plus timing of
     * enforcement decisions.  (Experimental feature.)
     */
    OVERHEAD,
  };</I></FONT></TD></TR>
</TABLE><P>So, tracing is disabled with the <TT>NONE</TT> option.
The time between <TT>startTrace</TT> and <TT>endTrace</TT> calls is
measured using the <TT>CORE</TT> option.
Additionally, the time for checking contract clauses is obtained
using the <TT>BASIC</TT> option while the enforcement decisions 
themselves are also timed with the <TT>OVERHEAD</TT> option.</P><P><A NAME="@default2045"></A>
<A NAME="@default2046"></A>
Hence, SIDL’s experimental enforcement tracing feature facilitates 
gathering data for establishing the execution time estimates needed 
for performance-driven enforcement.
The calling program is responsible for starting and stopping tracing
through the methods provided in SIDL’s enforcement policy class.
Tracing data is currently output as it is collected, resulting in
additional file I/O overhead during execution.</P><!--TOC section Summary-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc110">21.4</A>  Summary</H2><!--SEC END --><P><A NAME="s:contracts_summary"></A>
This chapter describes extensions to the Babel toolkit for the specification
and enforcement of interface contracts. 
SIDL allows the specification of executable, Eiffel-inspired precondition, 
postcondition, and class invariant clauses. 
Each clause may contain one or more assertion expressions using traditional
and advanced operators as well as built-in and user-defined functions.
The SIDL Runtime currently supports global interface contract enforcement,
on a clause basis, through a range of enforcement options combining
contract clause classification and enforcement frequency options.
Optional enforcement tracing, which can be used to collect relevant execution 
time data, is also supported.
Detected violations result in clause-specific exceptions identifying the 
violated assertion.</P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">WARNING:</DIV>
Not all capabilities described in this chapter have been tested.
In particular, regression tests exercising class invariants and a
number of the built-in functions available for use in contract clauses
are still pending. In addition, built-in functions are currently 
limited to one- and two-dimensional arrays.
Furthermore, the experimental enforcement policies and enforcement
tracing need to be re-tested after their integration into the Babel/SIDL
repository.
</BLOCKQUOTE><HR SIZE=2><P><BR>
</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note29" HREF="#text29">1</A></DT><DD CLASS="dd-thefootnotes">The vector sum
example is derived from Babel regression tests.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note30" HREF="#text30">2</A></DT><DD CLASS="dd-thefootnotes">Interface contract clauses should <EM>never</EM> replace 
defensive programming data checks since clause enforcement may be disabled 
during deployment. 
The data checks of defensive programming, on the other hand, should be 
executed on <EM>every</EM> run since they are needed to protect against 
serious, undesirable side-effects that include abrupt, unexplained 
termination.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note31" HREF="#text31">3</A></DT><DD CLASS="dd-thefootnotes">The explicit inclusion of
contract clause exceptions in a method’s <TT>throws</TT> clause is currently
necessary for proper exception handling in the generated C/C++ bindings.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note32" HREF="#text32">4</A></DT><DD CLASS="dd-thefootnotes">The
null check is actually needed here because the built-in
<TT>size()</TT> function does not gracefully handle a null array
argument.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Troubleshooting-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc111">Chapter 22</A>  Troubleshooting</H1><!--SEC END --><P><A NAME="c:troubleshooting"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc112">22.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:intro_errors"></A>
This appendix provides an overview of common problems that Babel users have 
encountered. Additional insights may be found in Chapter <A HREF="#c:lessons">23</A>.</P><!--TOC section Common Errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc113">22.2</A>  Common Errors</H2><!--SEC END --><P><A NAME="s:common_errors"></A>
This section focuses on common errors encountered by Babel users. The errors 
have been separated into those related to SIDL parsing, XML parsing, and 
compilation.</P><!--TOC subsection SIDL Parsing Errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->SIDL Parsing Errors</H3><!--SEC END --><P>
<A NAME="@default2047"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<EM><B>Babel: Error: when trying to resolve remaining args...Error 
: ÄnArgumentfails to resolve as a symbol or file.</B></EM> For a symbol, Babel 
attempts to find it in the repository(ies) specified on the command line or, 
if none specified, in the default repository. Check the repository being used 
to ensure that XML exists for the appropriate version of the symbol. If it is 
not present, generate the XML for it first then try again.<BR>

</LI></UL><!--TOC subsection XML Parsing Errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->XML Parsing Errors</H3><!--SEC END --><!--TOC subsection Compilation Errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Compilation Errors</H3><!--SEC END --><!--TOC section Common Warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc114">22.3</A>  Common Warnings</H2><!--SEC END --><P><A NAME="s:common_warns"></A>
This section focuses on common warnings encountered by Babel users. Again, 
warnings have been separated into those related to SIDL parsing, XML parsing, 
and compilation.</P><!--TOC subsection SIDL Parsing Warnings-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->SIDL Parsing Warnings</H3><!--SEC END --><P>
<A NAME="@default2048"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<B><EM>Babel: Warning: When creating repository...File 
Repository+Fileïs not a repository directory"</EM>.</B>
First verify that the specified directory is actually a repository directory. 
That is, that it contains symbol interfaces defined by XML files. If not,
correct the repository option then try again.<BR>

</LI></UL><!--TOC subsection XML Parsing Warnings-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->XML Parsing Warnings</H3><!--SEC END --><!--TOC subsection Compilation Warnings-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->Compilation Warnings</H3><!--SEC END --><!--TOC chapter Lessons Learned-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc115">Chapter 23</A>  Lessons Learned</H1><!--SEC END --><P><A NAME="c:lessons"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc116">23.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:intro_lessons"></A>
This appendix focuses on providing tips, tricks, and advice submitted by 
Babel/SIDL users. We have generally provided the information verbatim.</P><!--TOC section Compilation Consistency is Key-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc117">23.2</A>  Compilation Consistency is Key</H2><!--SEC END --><P><EM><B>Steve Smith, 24 September 2001</B></EM></P><P>Basically “be consistent” is the biggest lesson we found. </P><P>When compiling C++ codes, you may have conflicts if you use different
compile options. Under KCC we found -no_exceptions caused problems if
parts were compiled with/without the flag. 
There are most likely other compile flags which turn features on/off 
which would cause similar problems. 
This caused a core dump immediately when core file was
loaded. This is somewhat obvious but if you are linking together several
different codes from a variety of developers you need to examine the
compile flags very carefully. This problem is probably more likely with
C++ due to the greater number of code generation options (e. g. RTTI,
exceptions etc).</P><P>A much more subtle problem occurred when we had a C shared library which
called functions in a C++ shared library. We initially used gcc to create
the C shared library and KCC to create the C++ shared library. The
application would core dump when a dynamic cast was attempted. This was
solved by using the <TT>cc</TT> compiler wrapper that is part of the KCC
distribution (which uses the native <TT>cc</TT>). So you need to be aware of not
only what is in your .so and how it is compiled but all the .so’s that you
are using.</P><P>If you have several versions of a library, say during a debugging process,
make sure you are using the correct versions of things. The <TT>ldd</TT> command
is very useful for making sure you getting the shared libraries that you
think you should be linking to. Along these lines, keep your
LD_LIBRARY_PATH as simple as possible when debugging.</P><P>In retrospect this does not look like a large number of problems, but
figuring out the second problem took a long time since I focused on how the
C++ library was being created rather than where the real problem was being
introduced. It wasn’t until after I had exhausted a long list of other
potential conflicts that I started messing with the C library compilation. 
</P><!--TOC part Appendices-->
<TABLE CLASS="center"><TR><TD><H1 CLASS="part"><!--SEC ANCHOR --><A NAME="htoc118">Part IV</A><BR>
Appendices</H1></TD></TR>
</TABLE><!--SEC END --><P><A NAME="p:appendices"></A>
</P><!--TOC chapter Reserved Words-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc119">Appendix A</A>  Reserved Words</H1><!--SEC END --><P><A NAME="c:reserved"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc120">A.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:intro_reserved"></A>
This appendix lists SIDL’s reserved words. Other words and constructs that 
are problematic in particular language bindings are also listed.</P><!--TOC section Reserved Words-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc121">A.2</A>  Reserved Words</H2><!--SEC END --><P><A NAME="s:sidl_reserved"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table A.1: SIDL Reserved Words</TD></TR>
</TABLE></DIV><A NAME="tbl:sidlreservedwords"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=right NOWRAP><B>RESERVED WORD</B> 	</TD><TD ALIGN=left NOWRAP><B>ROLE</B></TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>abstract</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>optional modifier for <FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>array</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>bool</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>char</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>class</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>user defined datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>copy</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>argument modifer</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>double</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>enum</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>user defined datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>extends</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>inheritance mode</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>final</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>package and method modifier</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>float</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>implements</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>inheritance mode</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>inheritance mode</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>import</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>bring other packages into current scope</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>in</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>argument mode</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>inout</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>argument mode</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>int</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>interface</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>user defined datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>local</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>method modifier</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>long</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>nonblocking</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP>method modifier</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>oneway</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>method modifier</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>out</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>argument mode</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>package</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>scoping construct</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>static</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>method modifier</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>string</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>builtin datatype</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>throws</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>exception declaration</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>version</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>assign version number to package</TD></TR>
<TR><TD ALIGN=right NOWRAP><FONT COLOR=maroon><I><TT>void</TT></I></FONT> 		</TD><TD ALIGN=left NOWRAP>declares method as not returning a type</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Table <A HREF="#tbl:sidlreservedwords">A.1</A> lists all the words that are
part of the SIDL grammar and cannot be used as a package, enum, 
interface, class, or argument name.</P><!--TOC section Suggested Things To Avoid-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc122">A.3</A>  Suggested Things To Avoid</H2><!--SEC END --><P><A NAME="s:sidl_avoid"></A></P><P>Since SIDL maps onto many other languages
there are a great number of words and constructs 
that are harmless in SIDL, but cause great trouble
in generated language bindings. We list known 
problems in Table <A HREF="#tbl:sidlshouldbereserved">A.2</A>.</P><P>In addition, the following should be avoided:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Reserved words in all of the supported languages. This is a long list
only some of which appear here.
</LI><LI CLASS="li-itemize">Methods with the same name as a class (this is a constructor in C++).
</LI><LI CLASS="li-itemize">Packages, Classes, Interfaces, Methods or Arguments that differ only 
by case. Not all languages are case sensitive but, since Babel’s focus is 
language interoperability, Babel must make allowances.
</LI></UL><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table A.2: Other words/constructs to avoid</TD></TR>
</TABLE></DIV><A NAME="tbl:sidlshouldbereserved"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><B>WORD</B></TD><TD ALIGN=center NOWRAP><B>C</B></TD><TD ALIGN=center NOWRAP><B>C++</B></TD><TD ALIGN=center NOWRAP><B>Java</B></TD><TD ALIGN=center NOWRAP><B>Python</B></TD><TD ALIGN=center NOWRAP><B>word</B></TD><TD ALIGN=left NOWRAP><B>C</B></TD><TD ALIGN=center NOWRAP><B>C++</B></TD><TD ALIGN=center NOWRAP><B>Java</B></TD><TD ALIGN=center NOWRAP><B>Python</B></TD></TR>
<TR><TD ALIGN=left NOWRAP>abstract	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>lambda</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>and		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>long</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>and_eq		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>mutable</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>asm		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>namespace</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>assert		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>native</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>auto		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>new</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>bitand		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>not</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>bitor		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>not_eq</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>bool		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>null</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>boolean		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>operator</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>break		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>or</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>case		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>or_eq</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>catch		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>package</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>char		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>pass</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>class		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>print</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>compl		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>private</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>const		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>protected</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>const_cast	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>public</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>continue	</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>raise</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>def		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>register</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>default		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>reinterpret_cast</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>del		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>return</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>delete		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>short</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>do		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>signed</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>double		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>sizeof</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>dynamic_cast	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>static</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>elif		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>static_cast</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>else		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>strictfp</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>enum		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>struct</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>except		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>super</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>exec		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>switch</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>explicit	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>synchronized</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>export		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>template</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>extends		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>this</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>extern		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>throw</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>false		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>throws</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>final		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>transient</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>finally		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>true</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>float		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>try</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>for		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>typedef</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>friend		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>typeid</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>from		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>typename</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>global		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>union</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>goto		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>unsigned</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>if		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>using</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>implements	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>virtual</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>import		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>void</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>inline		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>volatile</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>instanceof	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>wchar_t</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>int		</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>while</TD><TD ALIGN=left NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>X</TD></TR>
<TR><TD ALIGN=left NOWRAP>interface	</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>xor</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP>is		</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>xor_eq</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>X</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC chapter SIDL Grammar-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc123">Appendix B</A>  SIDL Grammar</H1><!--SEC END --><P><A NAME="c:grammar"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc124">B.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:intro_grammar"></A>
This appendix provides an overview of the Scientific Interface Definition 
Language (SIDL) grammar. For simplicity, the grammar is described in 
extended BNF.</P><!--TOC section Backus-Naur Form-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc125">B.2</A>  Backus-Naur Form</H2><!--SEC END --><P><A NAME="s:sidl_bnf"></A>
<A NAME="@default2049"></A></P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">FIX ME!</DIV>
This section is dated. It needs to be brought up-to-date to reflect
changes associated with the introduction of the new parser.
</BLOCKQUOTE><HR SIZE=2><P><BR>

The grammar described here was extracted from the JavaCC productions defined 
in the Babel source code. Since the comments associated with the productions 
appeared to be sufficiently descriptive, they have been retained to serve as 
the explanation of the key productions.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">/*
 * The following lexical tokens are ignored.
 */
SKIP : {
   &lt; " " &gt;
 | &lt; "\n" &gt;
 | &lt; "\r" &gt;
 | &lt; "\t" &gt;
 | &lt; "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") &gt;
 | &lt; "/**/" &gt;
 | &lt; "/*" (~["*"])+ "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" &gt;
   { checkComment(image, input_stream.getBeginLine(),
                  input_stream.getEndLine()); }
 | &lt; "[" &gt;
 | &lt; "]" &gt;
}

/*
 * The following lexical states define the transitions necessary to
 * parse documentation comments.  Documentation comments may appear
 * anywhere in the file, although they are only saved if they preceed
 * definition or method productions.  Documentation comments are
 * represented by "special tokens" in the token list.
 */
SPECIAL_TOKEN : {
   &lt; T_COMMENT : "/**" &gt; : BEGIN_DOC_COMMENT
}

&lt;BEGIN_DOC_COMMENT&gt; SKIP : {
   &lt; " " &gt;
 | &lt; "\t" &gt;
 | &lt; "*/" &gt;                   : DEFAULT
 | &lt; ("\n" | "\r" | "\r\n") &gt; : LINE_DOC_COMMENT
 | &lt; "" &gt;                     : IN_DOC_COMMENT
}

&lt;LINE_DOC_COMMENT&gt; SKIP : {
   &lt; " " &gt;
 | &lt; "\t" &gt;
 | &lt; "*/" &gt;      : DEFAULT
 | &lt; "*" (" ")?&gt; : IN_DOC_COMMENT
 | &lt; "" &gt;        : IN_DOC_COMMENT
}

&lt;IN_DOC_COMMENT&gt; SPECIAL_TOKEN : {
   &lt; "*/" &gt;                   { trimMatch(matchedToken); } : DEFAULT
 | &lt; ("\n" | "\r" | "\r\n") &gt; { trimMatch(matchedToken); } : LINE_DOC_COMMENT
}

&lt;IN_DOC_COMMENT&gt; MORE : {
   &lt; ~[] &gt;
}

/*
 * The following keywords are the lexical tokens in the SIDL grammar.
 */
TOKEN : {
   &lt; T_ABSTRACT       : "abstract" &gt;
 | &lt; T_CLASS          : "class" &gt;
 | &lt; T_COPY           : "copy" &gt;
 | &lt; T_ENUM           : "enum" &gt;
 | &lt; T_EXTENDS        : "extends" &gt;
 | &lt; T_IMPORT        : "import" &gt;
 | &lt; T_IN             : "in" &gt;
 | &lt; T_INOUT          : "inout" &gt;
 | &lt; T_FINAL          : "final" &gt;
 | &lt; T_IMPLEMENTS     : "implements" &gt;
 | &lt; T_IMPLEMENTS_ALL : "implements-all" &gt;
 | &lt; T_INTERFACE      : "interface" &gt;
 | &lt; T_LOCAL          : "local" &gt;
 | &lt; T_ONEWAY         : "oneway" &gt;
 | &lt; T_OUT            : "out" &gt;
 | &lt; T_PACKAGE        : "package" &gt;
 | &lt; T_REQUIRE        : "require" &gt;
 | &lt; T_STATIC         : "static" &gt;
 | &lt; T_THROWS         : "throws" &gt;
 | &lt; T_VERSION        : "version" &gt;
 | &lt; T_VOID           : "void" &gt;

 | &lt; T_ARRAY          : "array" &gt;
 | &lt; T_RARRAY         : "rarray" &gt;
 | &lt; T_BOOLEAN        : "bool" &gt;
 | &lt; T_CHAR           : "char" &gt;
 | &lt; T_DCOMPLEX       : "dcomplex" &gt;
 | &lt; T_DOUBLE         : "double" &gt;
 | &lt; T_FCOMPLEX       : "fcomplex" &gt;
 | &lt; T_FLOAT          : "float" &gt;
 | &lt; T_INT            : "int" &gt;
 | &lt; T_LONG           : "long" &gt;
 | &lt; T_OPAQUE         : "opaque" &gt;
 | &lt; T_STRING         : "string" &gt;

 | &lt; T_IDENTIFIER     : &lt;T_LETTER&gt; (&lt;T_LETTER&gt; | &lt;T_DIGIT&gt; | "_")* &gt;
 | &lt; T_VERSION_STRING : &lt;T_INTEGER&gt; ("." &lt;T_INTEGER&gt;)+ &gt;
 | &lt; T_INTEGER        : (["-","+"])? (&lt;T_DIGIT&gt;)+ &gt;
 | &lt; T_DIGIT          : ["0"-"9"] &gt;
 | &lt; T_LETTER         : ["a"-"z","A"-"Z"] &gt;

 | &lt; T_CLOSE_ANGLE    : "&gt;" &gt;
 | &lt; T_CLOSE_CURLY    : "}" &gt;
 | &lt; T_CLOSE_PAREN    : ")" &gt;
 | &lt; T_COMMA          : "," &gt;
 | &lt; T_EQUALS         : "=" &gt;
 | &lt; T_OPEN_ANGLE     : "&lt;" &gt;
 | &lt; T_OPEN_CURLY     : "{" &gt;
 | &lt; T_OPEN_PAREN     : "(" &gt;
 | &lt; T_SEMICOLON      : ";" &gt;
 | &lt; T_SCOPE          : "." &gt;

 | &lt; T_COLUMN_MAJOR   : "column-major" &gt;
 | &lt; T_ROW_MAJOR      : "row-major" &gt;

 | &lt; T_CATCH_ALL      : ~[] &gt;
}

/**
 * A SIDL Specification contains zero or more version productions followed
 * by zero or more import productions followed by zero or more package
 * productions followed by the end-of-file.  Before leaving the specification
 * scope, resolve all references in the symbol table.
 */
Specification ::= ( Require )* ( Import )* ( Package )* &lt;EOF&gt;

/**
 * A SIDL Require production begins with a "require" token and is followed
 * by a scoped identifer, a "version" token, and a version number.  The
 * scoped identifier must be not defined.  The version number is specified
 * in the general form "V1.V2...Vn" where Vi is a non-negative integer.
 */
Require ::=
  &lt;T_REQUIRE&gt; ScopedIdentifier
  &lt;T_VERSION&gt; ( &lt;T_INTEGER&gt; | &lt;T_VERSION_STRING&gt; ) &lt;T_SEMICOLON&gt;

/**
 * A SIDL Import production begins with an "import" token and is followed
 * by a scoped identifier which is optionally followed by a "version" token
 * and a version number.  The scoped identifier must be defined and it must
 * be a package.  The version number is specified in the general form
 * "V1.V2...Vn" where Vi is a non-negative integer.  A particular package
 * may only be included in one import statement.  The import package name
 * is added to the default search path.  At the end of the parse, any import
 * statements that were not used to resolve a symbol name are output as
 * warnings.
 */
Import ::=
  &lt;T_IMPORT&gt; ScopedIdentifier
  [ &lt;T_VERSION&gt; ( &lt;T_INTEGER&gt; | &lt;T_VERSION_STRING&gt;) ] &lt;T_SEMICOLON&gt;

/**
 * The SIDL package specification begins with a "package" token followed by
 * a scoped identifier.  The new package namespace begins with an open curly
 * brace, a set of zero or more definitions, and a close curly brace.  The
 * closing curly brace may be followed by an optional semicolon.  The package
 * identifier must have a version defined for it, and it must not have been
 * previously defined as a symbol or used as a forward reference.  The parent
 * of the package must itself be a package and must have been defined.  The
 * symbols within the curly braces will be defined within the package scope.
 */
Package ::=
  [ &lt;T_FINAL&gt; ] &lt;T_PACKAGE&gt; ScopedIdentifier
  [ &lt;T_VERSION&gt; ( &lt;T_INTEGER&gt; | &lt;T_VERSION_STRING&gt; ) ]
  &lt;T_OPEN_CURLY&gt; ( Definition )* &lt;T_CLOSE_CURLY&gt; [ &lt;T_SEMICOLON&gt; ]

/**
 * A SIDL Definition production consists of a class, interface, enumerated
 * type, or package.
 */
Definition ::= ( Class | Enum | Interface | Package )

/**
 * A SIDL class specification begins with an optional abstract keyword
 * followed by the class token followed by an identifier.  The abstract
 * keyword is required if and only if there are abstract methods in the
 * class.  The class keyword is followed by an identifer.  The identifier
 * string may not have been previously defined, although it may have been
 * used as a forward reference.  The identifier string may be preceeded
 * by a documentation comment.  A class may optionally extend another class;
 * if no class is specified, then the class will automatically extend the
 * SIDL base class (unless it is itself the SIDL base class).  Then parse
 * the implements-all and implements clauses.  The interfaces parsed during
 * implements-all are saved in a set and then all those methods are defined
 * at the end of the class definition.  The methods block begins with an
 * open curly-brace followed by zero or more methods followed by a close
 * curly-brace and optional semicolon.
 */
Class ::=
  [ &lt;T_ABSTRACT&gt; ] &lt;T_CLASS&gt; Identifier
  [ &lt;T_EXTENDS&gt; ScopedIdentifier ]
  [ &lt;T_IMPLEMENTS_ALL&gt; AddInterface ( &lt;T_COMMA&gt; AddInterface )* ]
  [ &lt;T_IMPLEMENTS&gt; AddInterface ( &lt;T_COMMA&gt; AddInterface )* ]
  &lt;T_OPEN_CURLY&gt; ( ClassMethod )* &lt;T_CLOSE_CURLY&gt; [ &lt;T_SEMICOLON&gt; ]

/**
 * The SIDL enumeration specification begins with an "enum" token followed by
 * an identifier.  The enumerator list begins with an open curly brace, a set
 * of one or more definitions, and a close curly brace.  The closing curly
 * brace may be followed by an optional semicolon.  The enumeration symbol
 * identifier must have a version defined for it, and it must not have been
 * previously defined as a symbol.  Forward references are not allowed for
 * enumerated types.  This routine creates the enumerated class and then
 * grabs the list of enumeration symbols and their optional values.
 */
Enum ::=
  &lt;T_ENUM&gt; Identifier &lt;T_OPEN_CURLY&gt; Enumerator ( &lt;T_COMMA&gt; Enumerator )*
  &lt;T_CLOSE_CURLY&gt; [ &lt;T_SEMICOLON&gt; ]

/**
 * The SIDL enumerator specification consists of an identifier followed
 * by an optional assignment statement beginning with an equals and followed
 * by an integer value.  This routine adds the new enumeration symbol to
 * the list and then returns.
 */
Enumerator ::= Identifier [ &lt;T_EQUALS&gt; &lt;T_INTEGER&gt; ]

/**
 * A SIDL interface specification begins with the interface token followed
 * by an identifier.  An interface may have an extends block consisting of
 * a comma-separated sequence of interfaces.  The methods block begins with
 * an open curly-brace followed by zero or more methods followed by a close
 * curly-brace and optional semicolon.  Interfaces may be preceeded by a
 * documentation comment.  The identifier string may not have been previously
 * defined, although it may have been used as a forward reference.  If the
 * interface does not extend another interface, then it must extend the base
 * SIDL interface (unless, of course, this is the definition for the base
 * SIDL interface).
 */
Interface ::=
  &lt;T_INTERFACE&gt; Identifier [ &lt;T_EXTENDS&gt; AddInterface
  ( &lt;T_COMMA&gt; AddInterface )* ]
  &lt;T_OPEN_CURLY&gt; ( InterfaceMethod )* &lt;T_CLOSE_CURLY&gt; [ &lt;T_SEMICOLON&gt; ]

/**
 * This production parses the next scoped identifier and validates that
 * the name exists and is an interface symbol.  Then each of its methods
 * are checked for validity with the existing methods.  If everything
 * checks out, then the new interface is added to the existing object.
 */
AddInterface ::= ScopedIdentifier

/**
 * This production parses the SIDL method description for a class method.
 * A class method may start with abstract, final, or static.  An error is
 * thrown if the method has already been defined in the class object or if
 * the method name is the same as the class name.  An error is also thrown
 * if a method has been defined in a parent class and (1) the signatures
 * do not match, (2) either of the methods is static, (3) the existing method
 * is final, or (4) the new method is abstract but the existing method was
 * not abstract.
 */
ClassMethod ::= [ ( &lt;T_ABSTRACT&gt; | &lt;T_FINAL&gt; | &lt;T_STATIC&gt; ) ] Method

/**
 * This method parses a SIDL method and then checks whether it can be
 * added to the interface object.  An error is thrown if the method has
 * already been added to the interface object or if the method name is
 * the same as the interface name.  An error is also thrown if a previous
 * method was defined with the same name but a different signature.
 */
InterfaceMethod ::= Method

/**
 * The SIDL method production has a return type, a method identifier,
 * an optional argument list, an optional communication modifier, and
 * an optional throws clause.  The return type may be void (no return
 * type) or any valid SIDL type.  The method is built piece by piece.
 */
Method ::=
  ( &lt;T_VOID&gt; | [ &lt;T_COPY&gt; ] Type() ) Identifier [ &lt;T_IDENTIFIER&gt; ]
  &lt;T_OPEN_PAREN&gt; [ Argument ( &lt;T_COMMA&gt; Argument )* ] &lt;T_CLOSE_PAREN&gt;
  [ &lt;T_LOCAL&gt; | &lt;T_ONEWAY&gt; ] [ &lt;T_THROWS&gt; ScopedIdentifier
  ( &lt;T_COMMA&gt; ScopedIdentifier )* ] &lt;T_SEMICOLON&gt;

/**
 * Parse a SIDL argument.  Arguments begin with an optional copy modifier
 * followed by in, out, or inout followed by a type and a formal argument.
 * The argument is returned on the top of the argument stack.  This routine
 * also checks that the copy modifier is used only for symbol objects.  For
 * all other types, copy is redundant.
 */
Argument ::= [ &lt;T_COPY&gt; ] ( &lt;T_IN&gt; | &lt;T_OUT&gt; | &lt;T_INOUT&gt; )
         (Type Identifier | Rarray)

/**
 * A SIDL type consists of one of the standard built-in types (boolean,
 * char, dcomplex, double, fcomplex, float, int, long, opaque, and string),
 * a user-defined type (interface, class, or enum), or an array.  This
 * production parses the type and pushes the resulting type object on
 * the top of the argument stack.
 */
Type ::=
  ( &lt;T_BOOLEAN&gt;
  | &lt;T_CHAR&gt;
  | &lt;T_DCOMPLEX&gt;
  | &lt;T_DOUBLE&gt;
  | &lt;T_FCOMPLEX&gt;
  | &lt;T_FLOAT&gt;
  | &lt;T_INT&gt;
  | &lt;T_LONG&gt;
  | &lt;T_OPAQUE&gt;
  | &lt;T_STRING&gt;
  | Array
  | SymbolType )

/**
 * Parse an array construct and push the resulting type and ordering
 * on top of the stack.  Only dimensions one through MAX_ARRAY_DIM
 * (inclusive) are supported.
 */
Array ::=
  &lt;T_ARRAY&gt; &lt;T_OPEN_ANGLE&gt; Type [ &lt;T_COMMA&gt; ( &lt;T_INTEGER&gt;
  [ &lt;T_COMMA&gt; ( &lt;T_COLUMN_MAJOR&gt; | &lt;T_ROW_MAJOR&gt; ) ]
  | ( &lt;T_COLUMN_MAJOR&gt;| &lt;T_ROW_MAJOR&gt; ) ) ] &lt;T_CLOSE_ANGLE&gt;

/**
 * Parse an rarray construct and push the resulting type and ordering
 * on top of the stack.  Only dimensions one through MAX_ARRAY_DIM
 * (inclusive) are supported.  And don't forget the indicies!
 */
Rarray ::= &lt;T_RARRAY&gt; &lt;T_OPEN_ANGLE&gt; Type [ &lt;T_COMMA&gt; &lt;T_INTEGER&gt; ]
       &lt;T_CLOSE_ANGLE&gt; Identifier
       &lt;T_OPEN_PAREN&gt; Identifier ( &lt;T_COMMA Identifier )*
       &lt;T_CLOSE_PAREN&gt;

/**
 * This production parses a scoped identifier and verifies that it is
 * either a forward reference or a symbol that may be used as a type
 * (either an enum, an interface, or a class).
 */
SymbolType ::= ScopedIdentifier

/**
 * All SIDL scoped names are of the general form "ID ( . ID )*".  Each
 * identifier ID is a string of letters, numbers, and underscores that
 * must begin with a letter.  The scope resolution operator "." separates
 * the identifiers in a name.
 */
ScopedIdentifier ::= Identifier ( &lt;T_SCOPE&gt; Identifier )*

/**
 * A SIDL identifier must start with a letter and may be followed by any
 * number of letters, numbers, or underscores.  It may not be a reserved
 * word in any of the SIDL implementation languages (e.g., C or C++).
 */
Identifier ::= &lt;T_IDENTIFIER&gt;</TD></TR>
</TABLE><!--TOC chapter Extensible Markup Language (XML)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc126">Appendix C</A>  Extensible Markup Language (XML)</H1><!--SEC END --><P><A NAME="c:xml"></A></P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc127">C.1</A>  Introduction</H2><!--SEC END --><P><A NAME="s:intro_xml"></A>
This appendix describes the XML representation of SIDL interfaces. Since the 
format of an XML file is dictated by a Document Type Declaration (DTD) file, 
the description will focus on the DTD associated with SIDL. </P><!--TOC section SIDL Document Type Declaration (DTD)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc128">C.2</A>  SIDL Document Type Declaration (DTD)</H2><!--SEC END --><P><A NAME="s:sidl_dtd"></A>
<A NAME="@default2050"></A>
Babel relies on several DTDs to describe and enforce the layout of conformant 
XML files. The DTD of primary importance for Babel is <TT>sidl.dtd</TT> because 
it describes the requisite tags and attributes corresponding to SIDL files. 
The contents of the DTD are given below.</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--
   File:        sidl.dtd
   Package:     SIDL XML
   Revision:    @(#) $Id: sidl.dtd 6289 2008-01-11 15:59:07Z dahlgren $
   Description: DTD for the SIDL XML database representation

   Copyright (c) 2000-2007, The Regents of the University of Calfornia.
   Produced at the Lawrence Livermore National Laboratory.
   Written by the Components Team &lt;components@llnl.gov&gt;
   UCRL-CODE-2002-054
   All rights reserved.

   This file is part of Babel. For more information, see
   http://www.llnl.gov/CASC/components/. Please read the COPYRIGHT file
   for Our Notice and the LICENSE file for the GNU Lesser General Public
   License.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU Lesser General Public License (as published by
   the Free Software Foundation) version 2.1 dated February 1999.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
   conditions of the GNU Lesser General Public License for more details.

   You should have recieved a copy of the GNU Lesser General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

   This file describes the DTD for a SIDL symbol represented in XML format.
   The root element is &lt;Symbol&gt;.

   PUBLIC ID "-//CCA//sidl Symbol DTD v1.3//EN"
--&gt;

&lt;!--
   Symbol Element

   Symbol is the root element for all SIDL XML schema.  The Symbol contains a
   SymbolName (fully qualified symbol name and version), Metadata, Comment,
   and one of Class, Enumeration, Interface, or Package.
--&gt;

&lt;!ENTITY % symbols "Class | Enumeration | Interface | Package | Struct"&gt;
&lt;!ELEMENT Symbol (SymbolName, Metadata, Comment, (%symbols;))&gt;

&lt;!--
   SymbolName Element

   A SymbolName represents a fully qualified symbol name along with its
   version.  It is of the form:

   &lt;SymbolName name="sidl.SomeName" version="1.3.4"/&gt;
--&gt;

&lt;!ELEMENT SymbolName EMPTY&gt;
&lt;!ATTLIST SymbolName name     CDATA #REQUIRED
                     version  CDATA #REQUIRED&gt;

&lt;!--
   Metadata Element

   The Metadata element contains any useful descriptive data about the symbol.
   The time and date of creation is required, but all other information is
   optional.  The date and time must follow the ISO-8601 standard.  The
   entries in the metadata element are (key,value) pairs.
--&gt;

&lt;!ELEMENT Metadata (MetadataEntry)*&gt;
&lt;!ATTLIST Metadata date CDATA #REQUIRED&gt;

&lt;!ELEMENT MetadataEntry EMPTY&gt;
&lt;!ATTLIST MetadataEntry key   CDATA #REQUIRED
                        value CDATA #REQUIRED&gt;

&lt;!--
   Comment Element

   Comment elements support a very simple HTML description using the
   html-lite.dtd HTML subset.  See html-lite.dtd for more details.
--&gt;

&lt;!ENTITY % html-lite PUBLIC "-//CCA//sidl HTML DTD v1.0//EN" "html-lite.dtd"&gt;
%html-lite;

&lt;!ELEMENT Comment %html-block;&gt;

&lt;!--
   Package Element

   The Package element contains the symbols that exist within a package.
   In the PackageSymbol element, note that the name is relative to the
   package (thus, sidl.Class is represented by Class within package sidl).

   A true final attribute indicates that this package is not reentrant. It
   defaults to true to handle old XML files. In previous versions, all
   packages were non-reentrant.
--&gt;

&lt;!ELEMENT Package (Attributes?, PackageSymbol)*&gt;

&lt;!ELEMENT Attributes (Attribute)* &gt;

&lt;!ELEMENT Attribute EMPTY&gt;
&lt;!ATTLIST Attribute name CDATA          #REQUIRED
                    value CDATA         #IMPLIED&gt;

&lt;!--
If the version attribute isn't provided, the symbol has the same version
as the containing package. This is to provide backward compatibility with
previous released versions of the DTD. Someday the version may become
REQUIRED, so always include it.
--&gt;
&lt;!ELEMENT PackageSymbol EMPTY&gt;
&lt;!ATTLIST PackageSymbol name CDATA                               #REQUIRED
                        type (class | enum| interface | package | struct) #REQUIRED
                        version CDATA                            #IMPLIED&gt;

&lt;!ELEMENT Struct (Attributes?, StructItem*) &gt;

&lt;!ELEMENT StructItem (Type) &gt;
&lt;!ATTLIST StructItem name CDATA                                 #REQUIRED&gt;

&lt;!--
   Enumeration Element

   The Enumeration element consists of a collection of Enumerator elements
   that describe a relative symbol name, its integer value, and whether the
   value was assigned by the parser or in the SIDL input file.
--&gt;

&lt;!ELEMENT Enumeration (Attributes?, Enumerator+) &gt;

&lt;!ELEMENT Enumerator (Comment)?&gt;
&lt;!ATTLIST Enumerator name     CDATA          #REQUIRED
                     value    CDATA          #REQUIRED
                     fromuser (false | true) #REQUIRED&gt;

&lt;!--
   Class Element

   The Class element consists of a class extended by this class, a block
   of interfaces implemented by this class, and a block of methods declared
   or defined by this class.  The methods block does not include methods
   declared or defined by parents.  The elements AllParentInterfaces and
   AllParentClasses include all parents of this class.
--&gt;

&lt;!ELEMENT Class (Attributes?, Extends, ImplementsBlock,
                 AllParentClasses, AllParentInterfaces,
                 MethodsBlock, Contract?)&gt;

&lt;!ELEMENT Extends (SymbolName)?&gt;

&lt;!ELEMENT ImplementsBlock (SymbolName)*&gt;

&lt;!--
   Interface Element

   The Interface element consists of a block of interfaces that this
   interface extends (element ExtendsBlock) and a block of methods
   declared by this interface (element MethodsBlock).  The methods block
   element contains only those methods declared or re-declared by this
   interface and does not include all those methods defined by the
   parent interfaces.  The AllParentInterfaces element block includes
   all parent interfaces that this interface extends.
--&gt;

&lt;!ELEMENT Interface (Attributes?, ExtendsBlock, AllParentInterfaces,
                     MethodsBlock, Contract?)&gt;

&lt;!ELEMENT ExtendsBlock (SymbolName)*&gt;

&lt;!--
   AllParentClasses and AllParentInterfaces Elements

   These elements define a collection of zero or more SymbolName elements
   that are the parent classes and parent interfaces of a class or interface.
--&gt;

&lt;!ELEMENT AllParentClasses (SymbolName)*&gt;

&lt;!ELEMENT AllParentInterfaces (SymbolName)*&gt;

&lt;!--
   MethodsBlock Element

   The MethodsBlock element defines a collection of zero or more methods
   that belong to a SIDL interface or class.
--&gt;

&lt;!ELEMENT MethodsBlock (Method)*&gt;

&lt;!--
   Method Element

   The Method element defines the signature for a single method in a class or
   interface.  The name of the method is obtained from the shortname.  If
   method name overloading is not supported, the extension is appended to the
   short name to build the method name.
--&gt;

&lt;!ELEMENT Method (Attributes?, Comment, Type, ArgumentList, ThrowsList, ImplicitThrowsList, From?, Contract?)&gt;
&lt;!ATTLIST Method shortname     CDATA                                #REQUIRED
                 extension     CDATA                                #REQUIRED&gt;

&lt;!ELEMENT ArgumentList (Argument)*&gt;

&lt;!ELEMENT ThrowsList (SymbolName)*&gt;

&lt;!ELEMENT ImplicitThrowsList (SymbolName)*&gt;

&lt;!ELEMENT From EMPTY &gt;
&lt;!ATTLIST From parentname    CDATA      #REQUIRED
               parentversion CDATA      #REQUIRED
               shortname     CDATA      #REQUIRED
               extension     CDATA      #IMPLIED &gt;

&lt;!ELEMENT Contract (Assertion)*&gt;

&lt;!--
   Argument Element

   The SIDL Argument element defines a SIDL method argument.
--&gt;

&lt;!ELEMENT Argument (Attributes?, Type)&gt;
&lt;!ATTLIST Argument mode (in | inout | out) #REQUIRED
                   name CDATA              #REQUIRED&gt;

&lt;!--
   Type Element

   The Type element describes a SIDL type, which may be a built-in type
   such as boolean or int, an array, or a user-defined symbol.  If the
   type description is a primitive type, then no sub-elements are allowed.
   If the type is a symbol, then the single sub-element must be a symbol
   name.  If the type is an array, then the single sub-element must be
   an array element
--&gt;

&lt;!ENTITY % simpletypes "boolean | char | double | float | integer | long | string" &gt;
&lt;!ELEMENT Type (SymbolName | Array)?&gt;
&lt;!ATTLIST Type type (void | %simpletypes; | fcomplex | dcomplex | opaque | symbol  | array    ) #REQUIRED&gt;

&lt;!ELEMENT Index (Expression)+&gt;

&lt;!ELEMENT Array (Type?,Index?)&gt;
&lt;!ATTLIST Array order (unspecified | column-major | row-major) #REQUIRED
                dim   CDATA "0" &gt;

&lt;!--
   Assertion Element

   The SIDL Assertion element defines a SIDL assertion.
--&gt;
&lt;!ELEMENT Assertion (Comment, Expression)&gt;
&lt;!ATTLIST Assertion tag  CDATA                                 #REQUIRED
                    type ( invariant | require     | require_else
                         | ensure    | ensure_then )           #REQUIRED&gt;

&lt;!--
   Expression Element

   The SIDL Assertion Expression element defines a valid assertion expression.
--&gt;
&lt;!ELEMENT Expression ( BinaryExpression | ComplexNumber | MethodCall
                              | Terminal | UnaryExpression)&gt;
&lt;!ATTLIST Expression parens (true | false)              "false"&gt;

&lt;!--
   BinaryExpression Element

   The SIDL Binary Expression element defines a binary assertion expression.
--&gt;
&lt;!ELEMENT BinaryExpression (Expression, Expression)&gt;
&lt;!ATTLIST BinaryExpression op ( and          | divide        | equals
                              | expon        | greater_than  | greater_equal
                              | iff          | implies       | less_equal
                              | less_greater | less_than     | minus
                              | modulus      | multiply      | not_equal
                              | or           | plus          | power
                              | remainder    | shift_left    | shift_right
                              | xor          | bit-and       | bit-or
                              | bit-xor
                              )                              #REQUIRED&gt;

&lt;!--
   ComplexNumber Element

   The  Complex Number element defines a complex number assertion expression.
--&gt;
&lt;!ELEMENT ComplexNumber EMPTY&gt;
&lt;!ATTLIST ComplexNumber type      (float | double)         #REQUIRED
                        real      CDATA                    #REQUIRED
                        imaginary CDATA                    #REQUIRED&gt;

&lt;!--
   MethodCall Element

   The SIDL Method Call element defines a method call assertion expression.
   Note that any arguments must be within the scope of the assertion.  For
   invariants, expressions can only contain literals (i.e., NO state or
   attributes).  For methods, expressions can also contain any arguments
   that are being passed to the method.
--&gt;
&lt;!ELEMENT MethodCall (Expression*)&gt;
&lt;!ATTLIST MethodCall name CDATA                            #REQUIRED&gt;

&lt;!--
   Terminal Element

   The  Simple Expression element defines expressions that do not have
   operators; namely, identifiers and literals.  Note the only valid literals
   are boolean, character, double, float, integer, and string and identifiers
   are symbols.
--&gt;
&lt;!ELEMENT Terminal EMPTY &gt;
&lt;!ATTLIST Terminal etype ( identifier | %simpletypes; )  #REQUIRED
                       value CDATA                    #REQUIRED&gt;

&lt;!--
   UnaryExpression Element

   The SIDL Unary Expression element defines a unary assertion expression.
--&gt;
&lt;!ELEMENT UnaryExpression (Expression)&gt;
&lt;!ATTLIST UnaryExpression op  (complement | is | minus | not | plus )
                                                          #REQUIRED&gt;</TD></TR>
</TABLE><P>Babel assumes that comments will conform to the HTML-lite comment format. So,
Babel relies on <TT>comment.dtd</TT> to validate whether SIDL
documentation comments follow the HTML-lite comment format, which is 
described in <TT>html-lite.dtd</TT>. The most current versions of all of 
these DTDs can also be found in the source distribution in the 
<TT>babel/compiler/gov/llnl/babel/dtds</TT> directory.</P><P><B>NOTE:</B> Any XML interface description that complies with the SIDL DTD 
can be used as input to Babel. 
</P><!--TOC chapter Glossary-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc129">Appendix D</A>  Glossary</H1><!--SEC END --><P><A NAME="c:glossary"></A></P><!--TOC section abstract-->
<H2 CLASS="section"><!--SEC ANCHOR -->abstract</H2><!--SEC END --><P><A NAME="@default2051"></A></P><P><B>OOP concept:</B> Abstract describes something
that is declared but not fully defined. For example, an abstract
method is a method that is declared as a part of a class, but has no
implementation. It cannot be called, it is only meant to be
inherited by derived classes.<BR>

<B>SIDL keyword:</B> Abstract is an optional modifier for both
<FONT COLOR=maroon><I><TT>class</TT></I></FONT>es and <FONT COLOR=maroon><I><TT>method</TT></I></FONT>s. An abstract method is a method
that has no implementation, it’s a way of declaring a method that
every subclass must implement for itself. An abstract class has one
or more abstract methods, and therefore cannot be instantiated.</P><!--TOC section array-->
<H2 CLASS="section"><!--SEC ANCHOR -->array</H2><!--SEC END --><P><A NAME="@default2052"></A></P><P><B>Datastructure:</B> An array is a fixed size, numerically
indexed, set of variables. Arrays have in language support in almost
all modern programming languages.</P><P><B>Babel:</B> Babel has built in support for arrays of
every data type, including objects. Babel allows these arrays such that they may be
shared by differing languages.</P><!--TOC section BLAS-->
<H2 CLASS="section"><!--SEC ANCHOR -->BLAS</H2><!--SEC END --><P><A NAME="@default2053"></A></P><P>Basic Linear Algebra Subprograms.
BLAS is a famous library for doing matrix and vector algebra. 
More information may be found at: http://www.netlib.org/blas/ </P><!--TOC section Babel Object Server-->
<H2 CLASS="section"><!--SEC ANCHOR -->Babel Object Server</H2><!--SEC END --><P><A NAME="@default2054"></A></P><P>A Babel Object Server (BOS) is a network server process or thread that
provides babel objects via Remote Method Invocation (RMI). Normally a
BOS is run as a background thread on a normal Babel process to allow
the process to publish objects for access by RMI enabled clients. There is not
a single protocol that a BOS must use to communicate over Babel RMI, but
clients and BOSs must use the same protocol if they are expected to communicate.</P><!--TOC section BNF-->
<H2 CLASS="section"><!--SEC ANCHOR -->BNF</H2><!--SEC END --><P><A NAME="@default2055"></A></P><P>BackusNaur Form. BNF is a formal
way to describe computer languages and other formal languages. </P><!--TOC section bool-->
<H2 CLASS="section"><!--SEC ANCHOR -->bool</H2><!--SEC END --><P><A NAME="@default2056"></A></P><P><B>Definition:</B> bool is a short form of the word
boolean. A boolean is a logical data type that holds 1 bit of data, i. e. it
is either true or false. It is used for Boolean Algebra.</P><P><B>SIDL keyword:</B> bool is a data type built into SIDL, an
instance of which is either true or false. For efficiency sake, the underlying storage
of bool is not 1 bit. </P><!--TOC section borrowed arrays-->
<H2 CLASS="section"><!--SEC ANCHOR -->borrowed arrays</H2><!--SEC END --><P><A NAME="@default2057"></A></P><P><B>Babel:</B> A borrowed array is a SIDL array that does not manage its own data.
The data is provided by some third party, who is also in charge of
deallocating the data. It is useful for sending data through Babel, but the
developer must beware in case the third party deallocates the
array data before the program has finished with it.</P><!--TOC section CCA-->
<H2 CLASS="section"><!--SEC ANCHOR -->CCA</H2><!--SEC END --><P><A NAME="@default2058"></A></P><P>Common Component Architecture http://www.ccaforum.org/ </P><!--TOC section char-->
<H2 CLASS="section"><!--SEC ANCHOR -->char</H2><!--SEC END --><P><A NAME="@default2059"></A></P><P><B>Definition:</B> char is a short form of the word
character. A character is a letter, number, puctuation mark, or other
such symbol use in writing. In programming, a character is often
defined by the 8 bit ASCII encoding.</P><P><B>SIDL keyword:</B> char is a data type built into SIDL. It stores 1 byte of data, or
enough for 1 ASCII character. </P><!--TOC section class-->
<H2 CLASS="section"><!--SEC ANCHOR -->class</H2><!--SEC END --><P><A NAME="@default2060"></A></P><P><B>OOP concept:</B> A class is a definition for a
particular kind of object. It may define the data and methods that
will be included in an actual instance of the object.</P><P><B>SIDL keyword:</B> class is a SIDL keyword. 
In SIDL a class definition only defines 
methods. Methods may be static or instance methods. (They are
instance methods by default.) If any instance method in a class is
declared abstract, the class cannot be instantiated as an object, and
is called an abstract class. Otherwise, it can be instantiated and is
called a concrete class.</P><!--TOC section concrete class-->
<H2 CLASS="section"><!--SEC ANCHOR -->concrete class</H2><!--SEC END --><P><A NAME="@default2061"></A></P><P><B>OOP concept:</B> A concrete class is a class where 
all the class’s instance methods have
implementations. (ie. there are no abstract methods) A concrete class may
be instantiated as an object.</P><!--TOC section COM-->
<H2 CLASS="section"><!--SEC ANCHOR -->COM</H2><!--SEC END --><P><A NAME="@default2062"></A></P><P>Common Object Model http://www.microsoft.com/ Microsoft’s IDL based
language interoperability suite.</P><!--TOC section component-->
<H2 CLASS="section"><!--SEC ANCHOR -->component</H2><!--SEC END --><P><A NAME="@default2063"></A></P><P><B>OOP concept:</B> Components are “plug-and-play” 
software libraries designed with standard,
clearly defined interfaces. They are the epitome of modular design. 
Because components communicate only through well-defined interfaces, 
when an application needs to be modified, a single component can be
modified (or exchanged for a similar component), without fear of 
disrupting the other components making up the application.</P><!--TOC section component architecture-->
<H2 CLASS="section"><!--SEC ANCHOR -->component architecture</H2><!--SEC END --><P><A NAME="@default2064"></A></P><P><B>OOP concept:</B> A component architecture defines the
specifics of setting up a system for programming with components in
that architecture. For example, how components are
imported and how they communicate are some of the questions that must
be answered in a component architecture design.</P><!--TOC section copy-->
<H2 CLASS="section"><!--SEC ANCHOR -->copy</H2><!--SEC END --><P><A NAME="@default2065"></A></P><P><B>SIDL keyword:</B> copy is a SIDL keyword. It is planned
that in future version of
babel it will be used as a parameter modifier for parameters passed to
RMI functions, currently however, this feature is unimplemented. </P><!--TOC section CORBA-->
<H2 CLASS="section"><!--SEC ANCHOR -->CORBA</H2><!--SEC END --><P><A NAME="@default2066"></A></P><P>Common Object Request Broker Architecture http://www.omg.org CORBA
allows different programs by different vendors to communicate though
an IDL interface specification. In CORBA this glue code is called the
“Broker.”</P><!--TOC section dcomplex-->
<H2 CLASS="section"><!--SEC ANCHOR -->dcomplex</H2><!--SEC END --><P><A NAME="@default2067"></A></P><P><B>Definition:</B> The sum of a real number and an
imaginary number is called a complex number. Babel supports complex
numbers as a basic type via the basic types “fcomplex” and “dcomplex.”</P><P><B>SIDL keyword:</B> dcomplex is a data type built into SIDL. The name is short for
“double complex.” It stores a complex number via 2 64-bit floating
point variables, one for the real part, and one for the imaginary
part. </P><!--TOC section dense-->
<H2 CLASS="section"><!--SEC ANCHOR -->dense</H2><!--SEC END --><P> <A NAME="@default2068"></A></P><P><B>Definition:</B> A dense array is an array where all the dimensions are “densely
packed,” or, in terms of memory addressing, there are no “spaces”
between array elements. For example, if a one-dimensional SIDL array
of 10 elements is created, it will be densely packed. However, if a
slice of the array is taken with a stride of 2, the resulting array
will use the same data as the original array. However, the new array
will be only five elements long, and will only consist of the even
elements of the original array. This is not densely packed. Example:</P><P>Array 1: 0 1 2 3 4 5 6 7 8 9</P><P>Array 2: 0 – 2 – 4 – 6 – 8 – </P><!--TOC section developer-->
<H2 CLASS="section"><!--SEC ANCHOR -->developer</H2><!--SEC END --><P><A NAME="@default2069"></A></P><P><B>Babel:</B> There are two anticipated user types for Babel, both are kinds of
programmers. The person referred to as the “developer” is the person
developing a Babelized library. The “user” is the person who writes
a program using a Babelized library.</P><!--TOC section DLL-->
<H2 CLASS="section"><!--SEC ANCHOR -->DLL</H2><!--SEC END --><P><A NAME="@default2070"></A></P><P><B>Definition:</B> Dynamically Linked Library. A type of library that can be linked to
dynamically at runtime by passing its name as a string to the
dlopen() function.</P><!--TOC section double-->
<H2 CLASS="section"><!--SEC ANCHOR -->double</H2><!--SEC END --><P><A NAME="@default2071"></A></P><P><B>Definition:</B> A double is a 64-bit floating point number.</P><P><B>SIDL keyword:</B> SIDL support double as a basic type.</P><!--TOC section DTD-->
<H2 CLASS="section"><!--SEC ANCHOR -->DTD</H2><!--SEC END --><P><A NAME="@default2072"></A></P><P>Document Type Definition. Defines the grammar of the XML
files. http://www.w3.org/2002/xmlspec/</P><!--TOC section dynamic linking-->
<H2 CLASS="section"><!--SEC ANCHOR -->dynamic linking</H2><!--SEC END --><P><A NAME="@default2073"></A></P><P><B>Definition:</B> The action of dynamically linking to DLLs at runtime. </P><!--TOC section enum-->
<H2 CLASS="section"><!--SEC ANCHOR -->enum</H2><!--SEC END --><P><A NAME="@default2074"></A></P><P><B>Definition:</B> Enum is a shortend form of the word
enumeration. An enumeration is used to assign numbers to a set of
variable names, that is, enumerate the set of variable names. </P><P><B>SIDL keyword:</B> enum is a reserved word in SIDL. It is used for defining
enumerations. In Babel, enumerations are a way of binding
integer constants to names.</P><!--TOC section enumeration-->
<H2 CLASS="section"><!--SEC ANCHOR -->enumeration</H2><!--SEC END --><P> <A NAME="@default2075"></A></P><P>In Babel, enumerations are a way of binding integer constants to names.
See subsection <A HREF="#ssec:basics:fundamental:enums">6.3</A>.</P><!--TOC section exception-->
<H2 CLASS="section"><!--SEC ANCHOR -->exception</H2><!--SEC END --><P><A NAME="@default2076"></A></P><P><B>Definition:</B> The idea of an exception is that if a method encounters a problem it
cannot handle, it interrupts its execution and “throws” and
exception. Hopefully some function up the call stack will “catch”
the exception and know what to do about the problem. It is a useful
form of error handing that SIDL supports. Exception is not a reserved word
in SIDL (but <FONT COLOR=maroon><I><TT>throw</TT></I></FONT> is).</P><!--TOC section extends-->
<H2 CLASS="section"><!--SEC ANCHOR -->extends</H2><!--SEC END --><P><A NAME="@default2077"></A></P><P><B>OOP concept:</B> See inheritance.</P><P><B>SIDL keyword:</B> extends is a SIDL reserved word. It is used to declare “like-type”
inheritance. For example, a class may extend another class, or an
interface may extend multiple interfaces, but a class cannot extend an
interface, nor can an interface extend a class.</P><!--TOC section external stubs-->
<H2 CLASS="section"><!--SEC ANCHOR -->external stubs</H2><!--SEC END --><P> <A NAME="@default2078"></A></P><P>When building a Babelized library, its also important to note if your code has 
dependencies to other Babel types not in your library. These types often appear as
base classes, argument types, or even exception types. Your library will need
stubs corresponding to all these types, so it is best to put these in your library
as well. We call these external stubs. See subsection <A HREF="#ss:IORsinglepointaccess">19.2.3</A></P><!--TOC section external types-->
<H2 CLASS="section"><!--SEC ANCHOR -->external types</H2><!--SEC END --><P><A NAME="@default2079"></A></P><P>External Types are variable or object types that are not defined in
the current class. In a class foo.Bar, sidl.Integer, or
sidl.BaseClass would be external types.</P><!--TOC section fcomplex-->
<H2 CLASS="section"><!--SEC ANCHOR -->fcomplex</H2><!--SEC END --><P><A NAME="@default2080"></A></P><P>fcomplex is a data type built into SIDL. The name is short for
“float complex.” It stores a complex number via 2 32-bit floating
point variables, one for the real part, and one for the imaginary
part. </P><!--TOC section final-->
<H2 CLASS="section"><!--SEC ANCHOR -->final</H2><!--SEC END --><P><A NAME="@default2081"></A></P><P>final is a SIDL reserved word. It is a method modifier. A final
method is inherited by subclasses, but its implementation can never
be overwritten. It is the “final” version of the implementation.</P><!--TOC section float-->
<H2 CLASS="section"><!--SEC ANCHOR -->float</H2><!--SEC END --><P><A NAME="@default2082"></A></P><P>float is a data type built into SIDL. It is a 32-bit floating point
number. float is short for floating point.</P><!--TOC section full name-->
<H2 CLASS="section"><!--SEC ANCHOR -->full name</H2><!--SEC END --><P><A NAME="@default2083"></A></P><P>Overloaded Babelized methods called from non-object oriented
languages, such as C and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, have 2 method names. The full
name consists of the concatenation of the package name, class name, 
method name and type extension. The short name is missing the type
extension. See subsection <A HREF="#sec:overloading">6.7</A>.</P><!--TOC section fundamental types-->
<H2 CLASS="section"><!--SEC ANCHOR -->fundamental types</H2><!--SEC END --><P><A NAME="@default2084"></A></P><P>Fundamental types are the basic types that SIDL supports natively.
bool, int, char, long, float, double, fcomplex, dcomplex, opaque, and string.</P><!--TOC section glue-->
<H2 CLASS="section"><!--SEC ANCHOR -->glue</H2><!--SEC END --><P><A NAME="@default2085"></A></P><P>Most of the code that Babel generates is “glue” code. “Glue” code
sits between the caller and the implementation to allow communication
between them. We use the term glue to refer to the stub, IOR, and skel
files.</P><!--TOC section HTML-->
<H2 CLASS="section"><!--SEC ANCHOR -->HTML</H2><!--SEC END --><P><A NAME="@default2086"></A></P><P>Hypertext Markup Language http://www.w3.org/MarkUp/</P><!--TOC section implementation-->
<H2 CLASS="section"><!--SEC ANCHOR -->implementation</H2><!--SEC END --><P><A NAME="@default2087"></A></P><P>In Babel, the implementation is the code placed in the server side
Impl files. It is the code that Babel used glue code to allow you to
call to.</P><!--TOC section implements-->
<H2 CLASS="section"><!--SEC ANCHOR -->implements</H2><!--SEC END --><P><A NAME="@default2088"></A></P><P>implements is a SIDL reserved word. It is used when a class inherits
from one or more interfaces. However, in this case the word
“to implement” is not quite taken seriously. If a class implements
an interface it inherits its methods, and may be cast to that
interface, but if the programmer actually wished to implement any of
the interface methods, he must redeclare them in the SIDL class. Any
un-redeclared method is assumed abstract and will not appear in the
Impl files. If there are any abstract methods in a class, that class
is automatically abstract. </P><!--TOC section implements-all-->
<H2 CLASS="section"><!--SEC ANCHOR -->implements-all</H2><!--SEC END --><P><A NAME="@default2089"></A></P><P>implements-all is a SIDL reserved word. It takes the place of
“implements.” It is used when a class inherits
from one or more interfaces, and the programmer
definitely wants to write implementation code for each method in the
named interfaces. If the programmer uses “implements-all” he does
not have to redeclare the interface methods. See Section <A HREF="#sec:basics:objects:babelom">6.7</A>.</P><!--TOC section import-->
<H2 CLASS="section"><!--SEC ANCHOR -->import</H2><!--SEC END --><P><A NAME="@default2090"></A></P><P>import is a SIDL reserved word. It is used to bring other packages
into scope. Packages may be accompanied by a version number.</P><!--TOC section in-->
<H2 CLASS="section"><!--SEC ANCHOR -->in</H2><!--SEC END --><P><A NAME="@default2091"></A></P><P>in is a SIDL reserved word. Each parameter passed though Babel must
be declared as in, out, or inout. Each of these modes has certain
rules and implication associated with it. In means “pass this variable by
value to the implementation.” See Section <A HREF="#s:basics_sidl">6.2</A>. </P><!--TOC section independent arrays-->
<H2 CLASS="section"><!--SEC ANCHOR -->independent arrays</H2><!--SEC END --><P><A NAME="@default2092"></A></P><P>Independent arrays are arrays that manage their own data. When all
the references to an independent are deleted, the array data is
garbage collected. The other kind of array is a borrowed array.</P><!--TOC section inheritance-->
<H2 CLASS="section"><!--SEC ANCHOR -->inheritance</H2><!--SEC END --><P> 
<A NAME="@default2093"></A></P><P>In normal object-oriented programming, inheritance is the ability 
of a “super” or “parent” class or interface to pass its characteristics 
(methods and instance variables) on to its subclasses, 
allowing subclasses to reuse these characteristics.</P><P>Of course, in SIDL we cannot define instance variables, so in SIDL
inheritance only refers to method inheritance. In SIDL inheritance is
is declared with the reserved words <FONT COLOR=maroon><I><TT>extends</TT></I></FONT> and <FONT COLOR=maroon><I><TT>implements</TT></I></FONT>.</P><!--TOC section inout-->
<H2 CLASS="section"><!--SEC ANCHOR -->inout</H2><!--SEC END --><P><A NAME="@default2094"></A></P><P>inout is a SIDL reserved word. Each parameter passed though Babel must
be declared as in, out, or inout. Each of these modes has certain
rules and implication associated with it. Inout means “pass this variable by
reference to the implementation. The implementation may do whatever
it wants with the reference, but it should return something. Possibly
a new variable.” See Section <A HREF="#s:basics_sidl">6.2</A>. </P><!--TOC section instance method-->
<H2 CLASS="section"><!--SEC ANCHOR -->instance method</H2><!--SEC END --><P><A NAME="@default2095"></A></P><P>An instance method is a method that must be associated with an object
instance. These methods probably rely on some state in the instance, so
they cannot be divorced from it. In Object Oriented languages, you
call these methods on an instance, in Babelized non-OO languages like
C, you pass an instance in as the first argument to one of these methods.</P><!--TOC section int-->
<H2 CLASS="section"><!--SEC ANCHOR -->int</H2><!--SEC END --><P><A NAME="@default2096"></A></P><P>int is a data type built into SIDL. It is a 32-bit integer variable
int is short for integer. </P><!--TOC section int32_t and int64_t-->
<H2 CLASS="section"><!--SEC ANCHOR -->int32_t and int64_t</H2><!--SEC END --><P><A NAME="@default2097"></A><A NAME="@default2098"></A></P><P>The ANSI C standard way of declaring an integer that is definitely 32
or 64 bits.</P><!--TOC section interface-->
<H2 CLASS="section"><!--SEC ANCHOR -->interface</H2><!--SEC END --><P><A NAME="@default2099"></A></P><P>An interface is a declaration of a set of methods with no information 
given about their implementation. All interface methods are
abstract. An interface cannot be instantiated. However, a class may
inherit from multiple interfaces. The purpose of interfaces is to
give objects that are conceptually similar but internally different a
common interface so that code may treat them the same, or seamlessly
exchange them.</P><!--TOC section interprocess-->
<H2 CLASS="section"><!--SEC ANCHOR -->interprocess</H2><!--SEC END --><P><A NAME="@default2100"></A></P><P>Interprocess means “between processes.” It is normally used to
refer to “interprocess communication,” where two or more processes
find some way to communicate. Interprocess communication is one
of the goals of babel with RMI. </P><!--TOC section IOR-->
<H2 CLASS="section"><!--SEC ANCHOR -->IOR</H2><!--SEC END --><P><A NAME="@default2101"></A></P><P>Intermediate Object Representation. IOR code is where Babel does all
its work maintaining arrays, Babel objects, reference counting, etc.</P><!--TOC section JNI-->
<H2 CLASS="section"><!--SEC ANCHOR -->JNI</H2><!--SEC END --><P><A NAME="@default2102"></A></P><P>Java Native Interface. The JNI is what allows Java to call to C and
C++. It is referred to as calling native code because while Java runs in a
virtual machine, but C and C++ run on the real machine, or run “natively.”</P><!--TOC section language interoperability-->
<H2 CLASS="section"><!--SEC ANCHOR -->language interoperability</H2><!--SEC END --><P><A NAME="@default2103"></A></P><P>Language interoperability is Babel’s main purpose. Language 
interoperability technology allows different computer languages to
call each other methods and communicate despite problems with calling
conventions and differing variable types.</P><!--TOC section local-->
<H2 CLASS="section"><!--SEC ANCHOR -->local</H2><!--SEC END --><P><A NAME="@default2104"></A></P><P>A method (or other identifier) is considered local if it is defined or
declared in the current class or method. Sometimes a more specific
term like, “local to the method” or “local to the class” is used.
There is also a SIDL keyword local that modifies methods. If a method
is local is can only be called in-process, and cannot be exported over RMI.</P><!--TOC section long-->
<H2 CLASS="section"><!--SEC ANCHOR -->long</H2><!--SEC END --><P><A NAME="@default2105"></A></P><P>long is a data type built into SIDL. It is a 64-bit integer variable
long is short for long integer. Note: Python sometimes has trouble
with longs, see Section <A HREF="#s:python:notes">??</A> for more details. </P><!--TOC section method-->
<H2 CLASS="section"><!--SEC ANCHOR -->method</H2><!--SEC END --><P><A NAME="@default2106"></A></P><P>Method is the word commonly used in Java for what is called, in some
other languages, a function, subroutine, or procedure. Methods are a
piece a code that is called by a name. Instance methods depend on an
object instance, and are allowed to read and manipulate that objects
data. A static method does not depend on an instance, and therefore
can only access class data and what data is passed in to the method. </P><!--TOC section namespace-->
<H2 CLASS="section"><!--SEC ANCHOR -->namespace</H2><!--SEC END --><P><A NAME="@default2107"></A></P><P>A namespace is a way of logically divvying up globally accessible names.
This helps in avoiding conflicts between globally
accessible methods, classes, data, etc. They are mainly a feature of C++.</P><!--TOC section nonblocking-->
<H2 CLASS="section"><!--SEC ANCHOR -->nonblocking</H2><!--SEC END --><P><A NAME="@default2108"></A></P><P>nonblocking is a SIDL method attribute. A nonblocking method is split into
two parts. The invocation, method_send(), makes the call and
immediately returns a sidl.rmi.Ticket. Later, the Ticket can be
used to check if the method has returned, and retrieve the out
arguments if it has with method_recv(). Nonblocking methods are
really only useful with RMI where it allows the client to mix
computation and communication more freely. </P><!--TOC section non-strided-->
<H2 CLASS="section"><!--SEC ANCHOR -->non-strided</H2><!--SEC END --><P><A NAME="@default2109"></A></P><P>A non-strided array is a dense array. See the glossary entry for dense.</P><!--TOC section Object model-->
<H2 CLASS="section"><!--SEC ANCHOR -->Object model</H2><!--SEC END --><P><A NAME="@default2110"></A></P><P>The Object Model is the of rules that regulates the definition,
creation, and use of classes and objects in a language. To read about
the SIDL object model see Section <A HREF="#sec:basics:objects">6.7</A>.</P><!--TOC section OMG-->
<H2 CLASS="section"><!--SEC ANCHOR -->OMG</H2><!--SEC END --><P><A NAME="@default2111"></A></P><P>Object Management Group http://www.omg.org/</P><!--TOC section oneway-->
<H2 CLASS="section"><!--SEC ANCHOR -->oneway</H2><!--SEC END --><P><A NAME="@default2112"></A></P><P>oneway is a SIDL method attribute. A oneway method is guaranteed to
have no out arguments at all, it cannot even throw exceptions. This
is so it can be invoked by a oneway message on RMI. oneway is really
only useful with RMI.</P><!--TOC section opaque-->
<H2 CLASS="section"><!--SEC ANCHOR -->opaque</H2><!--SEC END --><P><A NAME="@default2113"></A></P><P>opaque ia a data type build into SIDL. The word opaque is an
adjective meaning “not transparent.” In SIDL, an opaque is
a 64-bit variable that cannot be touched or modified by the
holder. It is normally used to hold pointers that cannot be
understood by the current language or in the current context. </P><!--TOC section out-->
<H2 CLASS="section"><!--SEC ANCHOR -->out</H2><!--SEC END --><P><A NAME="@default2114"></A></P><P>out is a SIDL reserved word. Each parameter passed though Babel must
be declared as in, out, or out. Each of these modes has certain
rules and implication associated with it. Out means “pass this (null)
variable by reference to the implementation. The implementation is
expected to fill the reference with a new variable to be passed back
to the client.” See Section <A HREF="#s:basics_sidl">6.2</A>. </P><!--TOC section package-->
<H2 CLASS="section"><!--SEC ANCHOR -->package</H2><!--SEC END --><P><A NAME="@default2115"></A></P><P>A package is a container and namespace for conceptually linked
classes and interfaces. Generally it is good practice to have one
package per SIDL file.</P><!--TOC section pass-by-copy-->
<H2 CLASS="section"><!--SEC ANCHOR -->pass-by-copy</H2><!--SEC END --><P><A NAME="@default2116"></A></P><P>Pass-by-copy referes to one of the two major ways arguments are passed
to methods (the other is pass-by-reference). In a pass-by-copy
scheme, arguments are always copied when they are passed, so that
changeing the value of argument in the callee does not effect the
value of the caller’s variable. 
This is particularly important to Babel RMI, where object can be
passed either by copy or reference. </P><!--TOC section pass-by-reference-->
<H2 CLASS="section"><!--SEC ANCHOR -->pass-by-reference</H2><!--SEC END --><P><A NAME="@default2117"></A></P><P>Pass-by-reference referes to one of the two major ways arguments are passed
to methods (the other is pass-by-copy). In a pass-by-reference
scheme, arguments remain in their original memory localtion and a
pointer to them is passed to the callee method. This means that if the
callee changes the value of an argument, the value of the caller’s
variable changes as well. 
This is particularly important to Babel RMI, where object can be
passed either by copy or reference. </P><!--TOC section pass-by-value-->
<H2 CLASS="section"><!--SEC ANCHOR -->pass-by-value</H2><!--SEC END --><P><A NAME="@default2118"></A></P><P>See pass-by-copy</P><!--TOC section PIC-->
<H2 CLASS="section"><!--SEC ANCHOR -->PIC</H2><!--SEC END --><P><A NAME="@default2119"></A></P><P>Position Independent Code is for making dynamically loadable
libraries. PIC contains and extra level of indirection to allow the
correct methods to be found dynamically at runtime.</P><!--TOC section preprocessing-->
<H2 CLASS="section"><!--SEC ANCHOR -->preprocessing</H2><!--SEC END --><P><A NAME="@default2120"></A></P><P>Code preprocessing is a step, prior to compilation, where various
simple, automatic code modifications are made. For example, int C, #include
files are included, and #define macros are textually duplicated
throughout the code. In some cases, such as Babel Fortran 90/95, method
names are “mangled” to reduce their size under the method name
character limit.</P><!--TOC section private data-->
<H2 CLASS="section"><!--SEC ANCHOR -->private data</H2><!--SEC END --><P><A NAME="@default2121"></A></P><P>Private data is data that is only accessible locally, inside an
object. In Babel, all Babel object data is private and cannot be
accessed by other SIDL objects.</P><!--TOC section process-->
<H2 CLASS="section"><!--SEC ANCHOR -->process</H2><!--SEC END --><P><A NAME="@default2122"></A></P><P>A process is a running program that exists in its own memory space
and can therefore run in parallel with other processes.</P><!--TOC section protocol-->
<H2 CLASS="section"><!--SEC ANCHOR -->protocol</H2><!--SEC END --><P><A NAME="@default2123"></A></P><P>A protocol is formal description of message formats and the rules
that two computers must follow in order to exchange messages.</P><P>Babel RMI may use any protocol that implements the Babel RMI API.
This API is defined in sidl.io.Serializer and sidl.io.Deserializer.</P><!--TOC section reference counting-->
<H2 CLASS="section"><!--SEC ANCHOR -->reference counting</H2><!--SEC END --><P><A NAME="@default2124"></A></P><P>Reference counting is the form of garbage collection used in Babel.
Each object keeps a “reference count.” When that count reaches zero,
the object is destroyed and the memory reclaimed. In some languages
teh counting is handled automatically, in some, like C, the developer must
explicitly add and subtract from the reference count. (Using the
functions addRef and deleteRef.) The internal implementation of
deleteRef literally has an if statement that says “If the count is 0,
free this memory,” so if the reference count of an object goes below
one, all references to the object are immediately invalid.</P><!--TOC section Remote Method Invocation-->
<H2 CLASS="section"><!--SEC ANCHOR -->Remote Method Invocation</H2><!--SEC END --><P><A NAME="@default2125"></A></P><P>Remote Method Invocation (RMI) is Object Oriented Remote Procedure
Call (RPC). Where RPC allows a user to call procedures on remote
machines, RMI allows the user to call methods on objects that may or
may not exist on a remote machine. This has the advantage of being
more natural and makes local and remote object interchangeable.</P><!--TOC section reverse engineering-->
<H2 CLASS="section"><!--SEC ANCHOR -->reverse engineering</H2><!--SEC END --><P><A NAME="@default2126"></A></P><P>Reverse Engineering is the practice of inspecting the behavior of an 
existing program to understand more about how it works. Babel does
not support this, or any forms of inspecting or modifying compiled code.</P><!--TOC section RMI-->
<H2 CLASS="section"><!--SEC ANCHOR -->RMI</H2><!--SEC END --><P><A NAME="@default2127"></A></P><P>See Remote Method Invocation</P><!--TOC section RPC-->
<H2 CLASS="section"><!--SEC ANCHOR -->RPC</H2><!--SEC END --><P><A NAME="@default2128"></A></P><P>See Remote Method Invocation</P><!--TOC section serialization-->
<H2 CLASS="section"><!--SEC ANCHOR -->serialization</H2><!--SEC END --><P><A NAME="@default2129"></A></P><P>Serialization is a process to encode a data structure as a sequence of
bytes. This is the method used by most object oriented system to save objects to
files or pass objects over a network connection. Babel RMI uses
serialization to pass objects by copy over the network. </P><!--TOC section shared library-->
<H2 CLASS="section"><!--SEC ANCHOR -->shared library</H2><!--SEC END --><P><A NAME="@default2130"></A></P><P>A shared library is a set of methods that may be used by multiple
different programs without recompilation of the library. </P><!--TOC section short name-->
<H2 CLASS="section"><!--SEC ANCHOR -->short name</H2><!--SEC END --><P><A NAME="@default2131"></A></P><P>Overloaded Babelized methods called from non-object oriented
languages, such as C and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, have 2 method names. The full
name consists of the concatenation of the package name, class name, 
method name and type extension. The short name is missing the type
extension. See subsection <A HREF="#sec:overloading">6.7</A>.</P><!--TOC section SIDL-->
<H2 CLASS="section"><!--SEC ANCHOR -->SIDL</H2><!--SEC END --><P><A NAME="@default2132"></A></P><P>Scientific Interface Definition Language. The language used by Babel
to describe how Babel glue code should be generated. 
See Chapter <A HREF="#c:basics">6</A>.</P><!--TOC section single process-->
<H2 CLASS="section"><!--SEC ANCHOR -->single process</H2><!--SEC END --><P><A NAME="@default2133"></A></P><P>A single process program is a program that only uses one process to
complete its work. One of the features of Babel is that it is able
to facilitate language interoperability in a single process, which
saves the extra overhead of interprocess communication.</P><!--TOC section skeleton-->
<H2 CLASS="section"><!--SEC ANCHOR -->skeleton</H2><!--SEC END --><P><A NAME="@default2134"></A></P><P>The Babel skeleton code is the opposite of the Babel stub code. The
Stub code facilitates the method call from client to IOR, and the
skeleton code facilitates the method call from IOR to implementation.</P><!--TOC section SO-->
<H2 CLASS="section"><!--SEC ANCHOR -->SO</H2><!--SEC END --><P><A NAME="@default2135"></A></P><P>Shared Object. A Unix catch all term for shared and dynamically
loadable libraries.</P><!--TOC section SPMD-->
<H2 CLASS="section"><!--SEC ANCHOR -->SPMD</H2><!--SEC END --><P><A NAME="@default2136"></A></P><P>Single Program Multiple Data. The term used to describe parallel
programs that use multiple processes running the same code working on
different data to solve a problem.</P><!--TOC section state (of an object)-->
<H2 CLASS="section"><!--SEC ANCHOR -->state (of an object)</H2><!--SEC END --><P><A NAME="@default2137"></A></P><P>Object state refers to the data that an object holds. For example, if
an object holds one integer, that integer holds the objects state. It
is assumed that instance methods modify or use an object’s state in
some way. If a method does not use the object state in any way, it should
probably be a static method.</P><!--TOC section static-->
<H2 CLASS="section"><!--SEC ANCHOR -->static</H2><!--SEC END --><P><A NAME="@default2138"></A></P><P>A static method is a method that does not depend on an object instance
to run. It should have no need of any data of any particular object,
it should only depend on the data that is passed into it. As such,
unlike instance methods, it does not need to run on an instance of the
class it is associated with. In Babelized C, this means the first
argument to the function is not an object instance. In Java, this
means the function not called on an object, but referenced by the
class name. </P><!--TOC section static linking-->
<H2 CLASS="section"><!--SEC ANCHOR -->static linking</H2><!--SEC END --><P><A NAME="@default2139"></A></P><P>Static linking refers to the practice of linking code at compile time,
rather than dynamically at runtime. It has a speed advantage over
dynamically linked code, but lack flexibility.</P><!--TOC section string-->
<H2 CLASS="section"><!--SEC ANCHOR -->string</H2><!--SEC END --><P><A NAME="@default2140"></A></P><P>string is a data type built into SIDL. It stores a set of characters.
It has no predefined length.</P><!--TOC section stub-->
<H2 CLASS="section"><!--SEC ANCHOR -->stub</H2><!--SEC END --><P><A NAME="@default2141"></A></P><P>The Babel stub code is the opposite of the Babel skeleton code. The
Stub code facilitates the method call from client to IOR, and the
skeleton code facilitates the method call from IOR to implementation.</P><!--TOC section SWIG-->
<H2 CLASS="section"><!--SEC ANCHOR -->SWIG</H2><!--SEC END --><P><A NAME="@default2142"></A></P><P>Simplified Wrapper and Interface Generator http://www.swig.org/
SWIG is a language interoperability tool that is not IDL based, but
has certain other drawbacks.</P><!--TOC section tarball-->
<H2 CLASS="section"><!--SEC ANCHOR -->tarball</H2><!--SEC END --><P><A NAME="@default2143"></A></P><P>Tarball is a common way to refer to a set of directories and files
organized into a single file using the Unix tar command. It is often gzipped.</P><!--TOC section throws-->
<H2 CLASS="section"><!--SEC ANCHOR -->throws</H2><!--SEC END --><P><A NAME="@default2144"></A></P><P>throws is a SIDL reserved word. It is used the tell SIDL that a
method may throw the named SIDL exception, and code should be
generated to pass it to the client.</P><!--TOC section type-->
<H2 CLASS="section"><!--SEC ANCHOR -->type</H2><!--SEC END --><P><A NAME="@default2145"></A></P><P>A type describes what sort of information a variable stores, and usually 
how much space that information takes up. Classes and interfaces are
user defined types, there are also fundamental types like int and bool.</P><!--TOC section URL-->
<H2 CLASS="section"><!--SEC ANCHOR -->URL</H2><!--SEC END --><P><A NAME="@default2146"></A></P><P>Uniform Resource Locater. Often thought of as a pointer to a web resource.</P><!--TOC section user-->
<H2 CLASS="section"><!--SEC ANCHOR -->user</H2><!--SEC END --><P><A NAME="@default2147"></A></P><P>There are two anticipated user types for Babel, both are kinds of
programmers. The person referred to as the “developer” is the person
developing a Babelized library. The “user” is the person who writes
a program using a Babelized library.</P><!--TOC section version-->
<H2 CLASS="section"><!--SEC ANCHOR -->version</H2><!--SEC END --><P><A NAME="@default2148"></A></P><P>version is a reserved word in Babel that is used to declare a version
for a given package, or to declare what version of a given package
should be used.</P><!--TOC section virtual-->
<H2 CLASS="section"><!--SEC ANCHOR -->virtual</H2><!--SEC END --><P><A NAME="@default2149"></A></P><P>Virtual is the opposite of final. All SIDL methods are virtual by
default. A virtual method is a method that may be overridden in
subclasses. </P><!--TOC section VM-->
<H2 CLASS="section"><!--SEC ANCHOR -->VM</H2><!--SEC END --><P><A NAME="@default2150"></A></P><P>Virtual Machine</P><!--TOC section void-->
<H2 CLASS="section"><!--SEC ANCHOR -->void</H2><!--SEC END --><P><A NAME="@default2151"></A></P><P>a reserved word in Babel, used to state that a function has no return type.</P><!--TOC section VPATH-->
<H2 CLASS="section"><!--SEC ANCHOR -->VPATH</H2><!--SEC END --><P><A NAME="@default2152"></A></P><P>If you want to build software in a separate directory from
where the tarball was untarred, this is called a “VPATH build”.
VPATH<A NAME="@default2153"></A> builds are useful if you want to 
build Babel multiple times 
with various compilers, flags, or you have a shared file system 
across multiple platforms. It separates the code you generate
from things that you were given. </P><!--TOC section XML-->
<H2 CLASS="section"><!--SEC ANCHOR -->XML</H2><!--SEC END --><P><A NAME="@default2154"></A></P><P>Extensible Markup Language. http://www.w3.org/XML/ A standardized
data exchange format.</P><!--TOC chapter Index-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Index</H1><!--SEC END --><P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
–prefix, <A HREF="#@default44">3.1.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">.hh files, <A HREF="#@default624">9.3.2</A>
</LI><LI CLASS="li-indexenv">.hxx files, <A HREF="#@default625">9.3.2</A>
</LI><LI CLASS="li-indexenv">.scl files, <A HREF="#@default1902">19.6</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">64bit Linux, <A HREF="#@default64">3.2.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">#include, <A HREF="#@default430">8.3.2</A>, <A HREF="#@default619">9.3.2</A>
</LI><LI CLASS="li-indexenv">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A, <A HREF="#@default77">3.2.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><SPAN STYLE="font-variant:small-caps">fortran 77</SPAN><UL CLASS="indexenv"><LI CLASS="li-indexenv">
_wrapObj, <A HREF="#@default1919">20.5</A>
</LI><LI CLASS="li-indexenv">array alignment, <A HREF="#@default247">6.4</A>
</LI><LI CLASS="li-indexenv">array example, <A HREF="#@default248">6.4</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default804">10.2.3</A>
</LI><LI CLASS="li-indexenv">basic types, <A HREF="#@default777">10.2.3</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default834">10.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default942">10.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default946">10.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default827">10.2.4</A>
</LI><LI CLASS="li-indexenv">constructor, <A HREF="#@default952">10.4.3</A>
</LI><LI CLASS="li-indexenv">ctor2, <A HREF="#@default1918">20.5</A>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default760">10.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
array, <A HREF="#@default794">10.2.3</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default803">10.2.3</A>
</LI><LI CLASS="li-indexenv">class, <A HREF="#@default793">10.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default796">10.2.3</A>
</LI><LI CLASS="li-indexenv">interface, <A HREF="#@default792">10.2.3</A>
</LI><LI CLASS="li-indexenv">opaque, <A HREF="#@default791">10.2.3</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default783">10.2.3</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default778">10.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">direct array access, <A HREF="#@default245">6.4</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default797">10.2.3</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default880">10.3.5</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default758">10.2.2</A>, <A HREF="#@default869">10.3.5</A>, <A HREF="#@default976">10.4.4</A>
</LI><LI CLASS="li-indexenv">extra out argument, <A HREF="#@default870">10.3.5</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default883">10.3.6</A>, <A HREF="#@default981">10.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default983">10.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default889">10.3.7</A>, <A HREF="#@default914">10.3.7</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default915">10.3.7</A>, <A HREF="#@default933">10.3.7</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default934">10.3.7</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default753">10.2.2</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default751">10.2.1</A>
</LI><LI CLASS="li-indexenv">object data, <A HREF="#@default1920">20.5</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default838">10.3.2</A>
</LI><LI CLASS="li-indexenv">object references, <A HREF="#@default795">10.2.3</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default862">10.3.4</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default784">10.2.3</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default887">10.3.6</A>, <A HREF="#@default986">10.4.5</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default885">10.3.6</A>, <A HREF="#@default984">10.4.5</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default949">10.4.3</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default856">10.3.3</A>
</LI><LI CLASS="li-indexenv">string length limits, <A HREF="#@default782">10.2.3</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default779">10.2.3</A>
</LI><LI CLASS="li-indexenv">subroutines, <A HREF="#@default755">10.2.2</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default826">10.2.4</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">abstract, <A HREF="#@default2051">D</A>
</LI><LI CLASS="li-indexenv">abstract classes, <A HREF="#@default338">6.7</A>, <A HREF="#@default1482">13.2.3</A>
</LI><LI CLASS="li-indexenv">access<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default816">10.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">addRef, <A HREF="#@default183">6.4</A>, <A HREF="#@default220">6.4</A>, <A HREF="#@default437">8.3.3</A>, <A HREF="#@default1064">11.2.3</A>, <A HREF="#@default1288">12.2.4</A>
</LI><LI CLASS="li-indexenv">addSearchPath<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default642">9.3.4</A>, <A HREF="#@default861">10.3.3</A>, <A HREF="#@default1110">11.3.3</A>, <A HREF="#@default1334">12.3.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">allocate, <A HREF="#@default1054">11.2.3</A>, <A HREF="#@default1278">12.2.4</A>
</LI><LI CLASS="li-indexenv">array, <A HREF="#@default403">8.2.3</A>, <A HREF="#@default584">9.2.3</A>, <A HREF="#@default776">10.2.3</A>, <A HREF="#@default790">10.2.3</A>, <A HREF="#@default1013">11.2.3</A>, <A HREF="#@default1032">11.2.3</A>, <A HREF="#@default1040">11.2.3</A>, <A HREF="#@default1257">12.2.4</A>, <A HREF="#@default1473">13.2.3</A>, <A HREF="#@default2052">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default599">9.2.3</A>, <A HREF="#@default812">10.2.3</A>, <A HREF="#@default964">10.4.3</A>
</LI><LI CLASS="li-indexenv">initialization, <A HREF="#@default174">6.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default153">6.4</A>, <A HREF="#@default413">8.2.3</A>, <A HREF="#@default593">9.2.3</A>, <A HREF="#@default806">10.2.3</A>, <A HREF="#@default1052">11.2.3</A>, <A HREF="#@default1276">12.2.4</A>, <A HREF="#@default1499">13.2.3</A>, <A HREF="#@default1687">14.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
borrowed, <A HREF="#@default164">6.4</A>
</LI><LI CLASS="li-indexenv">C macros, <A HREF="#@default251">6.4</A>
</LI><LI CLASS="li-indexenv">destruction, <A HREF="#@default165">6.4</A>
</LI><LI CLASS="li-indexenv">enforced ordering, <A HREF="#@default162">6.4</A>
</LI><LI CLASS="li-indexenv">function table, <A HREF="#@default211">6.4</A>
</LI><LI CLASS="li-indexenv">generic, <A HREF="#@default157">6.4</A>, <A HREF="#@default1062">11.2.3</A>, <A HREF="#@default1286">12.2.4</A>
</LI><LI CLASS="li-indexenv">independent, <A HREF="#@default163">6.4</A>
</LI><LI CLASS="li-indexenv">internal structure, <A HREF="#@default266">6.4</A>
</LI><LI CLASS="li-indexenv">NULL, <A HREF="#@default168">6.4</A>
</LI><LI CLASS="li-indexenv">normal, <A HREF="#@default152">6.4</A>
</LI><LI CLASS="li-indexenv">ordering, <A HREF="#@default155">6.4</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default170">6.4</A>
</LI><LI CLASS="li-indexenv">r-arrays, <A HREF="#@default159">6.4</A>, <A HREF="#@default415">8.2.3</A>, <A HREF="#@default594">9.2.3</A>, <A HREF="#@default807">10.2.3</A>, <A HREF="#@default1076">11.2.3</A>, <A HREF="#@default1300">12.2.4</A>, <A HREF="#@default1500">13.2.3</A>, <A HREF="#@default1664">14.2.2</A>, <A HREF="#@default1688">14.2.3</A>
</LI><LI CLASS="li-indexenv">raw, <A HREF="#@default160">6.4</A>
</LI><LI CLASS="li-indexenv">smartcopy, <A HREF="#@default167">6.4</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default173">6.4</A>
</LI><LI CLASS="li-indexenv">types, <A HREF="#@default172">6.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">autoconf, <A HREF="#@default47">3.1.2</A>, <A HREF="#@default73">3.2.4</A>
</LI><LI CLASS="li-indexenv">automake, <A HREF="#@default49">3.1.2</A>, <A HREF="#@default72">3.2.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Babel<UL CLASS="indexenv"><LI CLASS="li-indexenv">
Application architecture, <A HREF="#@default5">2.1</A>
</LI><LI CLASS="li-indexenv">command line, <A HREF="#@default80">4.2</A>
</LI><LI CLASS="li-indexenv">command line arg. table, <A HREF="#@default82">4.2</A>
</LI><LI CLASS="li-indexenv">command line examples, <A HREF="#@default83">4.2</A>
</LI><LI CLASS="li-indexenv">customers, <A HREF="#@default15">2.3</A>
</LI><LI CLASS="li-indexenv">dynamic linking, <A HREF="#@default1895">19.3</A>
</LI><LI CLASS="li-indexenv">feedback, <A HREF="#@default4">1</A>
</LI><LI CLASS="li-indexenv">file layout options, <A HREF="#@default1891">19.1</A>
</LI><LI CLASS="li-indexenv">getting, <A HREF="#@default3">1</A>
</LI><LI CLASS="li-indexenv">installation, <A HREF="#@default56">3.1.4</A>
</LI><LI CLASS="li-indexenv">internal dependencies, <A HREF="#@default1894">19.2.2</A>
</LI><LI CLASS="li-indexenv">library deployment, <A HREF="#@default1903">19.7</A>
</LI><LI CLASS="li-indexenv">object model, <A HREF="#@default331">6.7</A>
</LI><LI CLASS="li-indexenv">overview, <A HREF="#@default0">1</A>
</LI><LI CLASS="li-indexenv">Real World Example, <A HREF="#@default6">2.1</A>
</LI><LI CLASS="li-indexenv">required software, <A HREF="#@default58">3.2</A>
</LI><LI CLASS="li-indexenv">Supported Languages, <A HREF="#@default8">2.1</A>
</LI><LI CLASS="li-indexenv">static linking, <A HREF="#@default1896">19.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Babel Object Server, <A HREF="#@default1841">18.2</A>, <A HREF="#@default2054">D</A>
</LI><LI CLASS="li-indexenv">BaseException, <A HREF="#@default119">6.2</A>
</LI><LI CLASS="li-indexenv">BLAS, <A HREF="#@default2053">D</A>
</LI><LI CLASS="li-indexenv">BNF, <A HREF="#@default2055">D</A>
</LI><LI CLASS="li-indexenv">BOS, <A HREF="#@default1840">18.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
startup, <A HREF="#@default1873">18.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">babel_config, <A HREF="#@default1900">19.4</A>
</LI><LI CLASS="li-indexenv">backdoor initializer, <A HREF="#@default1912">20</A>
</LI><LI CLASS="li-indexenv">bool, <A HREF="#@default393">8.2.3</A>, <A HREF="#@default574">9.2.3</A>, <A HREF="#@default766">10.2.3</A>, <A HREF="#@default1004">11.2.3</A>, <A HREF="#@default1248">12.2.4</A>, <A HREF="#@default1464">13.2.3</A>, <A HREF="#@default2056">D</A>
</LI><LI CLASS="li-indexenv">borrow, <A HREF="#@default181">6.4</A>, <A HREF="#@default218">6.4</A>
</LI><LI CLASS="li-indexenv">borrowed arrays, <A HREF="#@default2057">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">C<UL CLASS="indexenv"><LI CLASS="li-indexenv">
#include, <A HREF="#@default431">8.3.2</A>
</LI><LI CLASS="li-indexenv">_wrapObj, <A HREF="#@default1916">20.4</A>
</LI><LI CLASS="li-indexenv">array macros, <A HREF="#@default250">6.4</A>
</LI><LI CLASS="li-indexenv">array structure, <A HREF="#@default267">6.4</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default411">8.2.3</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default424">8.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default530">8.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default534">8.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default419">8.2.4</A>
</LI><LI CLASS="li-indexenv">constructor, <A HREF="#@default544">8.4.3</A>
</LI><LI CLASS="li-indexenv">ctor2, <A HREF="#@default1915">20.4</A>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default387">8.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default410">8.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default404">8.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">destructor, <A HREF="#@default547">8.4.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default405">8.2.3</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default464">8.3.6</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default451">8.3.5</A>, <A HREF="#@default453">8.3.6</A>, <A HREF="#@default548">8.4.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
helpers, <A HREF="#@default460">8.3.6</A>, <A HREF="#@default549">8.4.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">extra out argument, <A HREF="#@default454">8.3.6</A>
</LI><LI CLASS="li-indexenv">header files, <A HREF="#@default428">8.3.2</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default471">8.3.7</A>, <A HREF="#@default557">8.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default559">8.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default477">8.3.8</A>, <A HREF="#@default500">8.3.8</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default501">8.3.8</A>, <A HREF="#@default519">8.3.8</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default520">8.3.8</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default383">8.2.2</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default380">8.2.1</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default434">8.3.3</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default443">8.3.5</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default475">8.3.7</A>, <A HREF="#@default562">8.4.5</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default473">8.3.7</A>, <A HREF="#@default560">8.4.5</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default539">8.4.3</A>
</LI><LI CLASS="li-indexenv">sidlArrayAddr, <A HREF="#@default265">6.4</A>
</LI><LI CLASS="li-indexenv">sidlArrayDim, <A HREF="#@default253">6.4</A>
</LI><LI CLASS="li-indexenv">sidlArrayElem, <A HREF="#@default263">6.4</A>
</LI><LI CLASS="li-indexenv">sidlLength, <A HREF="#@default259">6.4</A>
</LI><LI CLASS="li-indexenv">sidlLower, <A HREF="#@default255">6.4</A>
</LI><LI CLASS="li-indexenv">sidlStride, <A HREF="#@default261">6.4</A>
</LI><LI CLASS="li-indexenv">sidlUpper, <A HREF="#@default257">6.4</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default441">8.3.4</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default418">8.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">C++<UL CLASS="indexenv"><LI CLASS="li-indexenv">
#include, <A HREF="#@default620">9.3.2</A>
</LI><LI CLASS="li-indexenv">array base class, <A HREF="#@default622">9.3.2</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default169">6.4</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default611">9.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default718">9.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default722">9.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default608">9.2.4</A>, <A HREF="#@default631">9.3.3</A>
</LI><LI CLASS="li-indexenv">constructor, <A HREF="#@default732">9.4.3</A>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default568">9.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default591">9.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default585">9.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">destructor, <A HREF="#@default736">9.4.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default586">9.2.3</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default656">9.3.6</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default650">9.3.6</A>, <A HREF="#@default737">9.4.4</A>
</LI><LI CLASS="li-indexenv">extra out argument, <A HREF="#@default651">9.3.6</A>
</LI><LI CLASS="li-indexenv">header files, <A HREF="#@default615">9.3.2</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default659">9.3.7</A>, <A HREF="#@default744">9.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default746">9.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Impl Constructor, <A HREF="#@default1923">20.7</A>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default665">9.3.8</A>, <A HREF="#@default688">9.3.8</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default689">9.3.8</A>, <A HREF="#@default707">9.3.8</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default708">9.3.8</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">main header file, <A HREF="#@default618">9.3.2</A>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default566">9.2.2</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default564">9.2.1</A>
</LI><LI CLASS="li-indexenv">object creation, <A HREF="#@default629">9.3.3</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default626">9.3.3</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default605">9.2.3</A>, <A HREF="#@default643">9.3.5</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default663">9.3.7</A>, <A HREF="#@default749">9.4.5</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default661">9.3.7</A>, <A HREF="#@default747">9.4.5</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default726">9.4.3</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default637">9.3.4</A>
</LI><LI CLASS="li-indexenv">stub base class, <A HREF="#@default621">9.3.2</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default607">9.2.4</A>, <A HREF="#@default630">9.3.3</A>
</LI><LI CLASS="li-indexenv">typedefs, <A HREF="#@default623">9.3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">C/C++ compiler, <A HREF="#@default65">3.2.2</A>
</LI><LI CLASS="li-indexenv">CCA, <A HREF="#@default2058">D</A>
</LI><LI CLASS="li-indexenv">Chasm, <A HREF="#@default62">3.2.1</A>
</LI><LI CLASS="li-indexenv">COM, <A HREF="#@default10">2.2</A>, <A HREF="#@default150">6.4</A>, <A HREF="#@default2062">D</A>
</LI><LI CLASS="li-indexenv">CORBA, <A HREF="#@default11">2.2</A>, <A HREF="#@default151">6.4</A>, <A HREF="#@default1848">18.2.1</A>, <A HREF="#@default2066">D</A>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default829">10.2.4</A>, <A HREF="#@default1695">14.2.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default875">10.3.5</A>, <A HREF="#@default1097">11.3.2</A>, <A HREF="#@default1127">11.3.5</A>, <A HREF="#@default1216">11.4.4</A>, <A HREF="#@default1321">12.3.2</A>, <A HREF="#@default1351">12.3.5</A>, <A HREF="#@default1435">12.4.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">char, <A HREF="#@default394">8.2.3</A>, <A HREF="#@default575">9.2.3</A>, <A HREF="#@default767">10.2.3</A>, <A HREF="#@default1005">11.2.3</A>, <A HREF="#@default1249">12.2.4</A>, <A HREF="#@default1465">13.2.3</A>, <A HREF="#@default2059">D</A>
</LI><LI CLASS="li-indexenv">circular dependencies, <A HREF="#@default1892">19.2.2</A>
</LI><LI CLASS="li-indexenv">class, <A HREF="#@default402">8.2.3</A>, <A HREF="#@default583">9.2.3</A>, <A HREF="#@default775">10.2.3</A>, <A HREF="#@default789">10.2.3</A>, <A HREF="#@default1012">11.2.3</A>, <A HREF="#@default1030">11.2.3</A>, <A HREF="#@default1038">11.2.3</A>, <A HREF="#@default1256">12.2.4</A>, <A HREF="#@default1472">13.2.3</A>, <A HREF="#@default2060">D</A>
</LI><LI CLASS="li-indexenv">class invariants, <A HREF="#@default34">2.3</A>, <A HREF="#@default278">6.5</A>, <A HREF="#@default287">6.5</A>, <A HREF="#@default1953">21.2.1</A>
</LI><LI CLASS="li-indexenv">classes, <A HREF="#@default107">6.2</A>, <A HREF="#@default336">6.7</A>
</LI><LI CLASS="li-indexenv">client, <A HREF="#@default423">8.3</A>, <A HREF="#@default610">9.3</A>, <A HREF="#@default833">10.3</A>, <A HREF="#@default1085">11.3</A>, <A HREF="#@default1309">12.3</A>, <A HREF="#@default1531">13.3</A>, <A HREF="#@default1697">14.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation, <A HREF="#@default425">8.3.1</A>, <A HREF="#@default612">9.3.1</A>, <A HREF="#@default835">10.3.1</A>, <A HREF="#@default1087">11.3.1</A>, <A HREF="#@default1311">12.3.1</A>, <A HREF="#@default1533">13.3.1</A>, <A HREF="#@default1699">14.3.1</A>
</LI><LI CLASS="li-indexenv">writing, <A HREF="#@default94">5.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">column-major order, <A HREF="#@default156">6.4</A>
</LI><LI CLASS="li-indexenv">command line arguments, <A HREF="#@default81">4.2</A>, <A HREF="#@default427">8.3.1</A>, <A HREF="#@default533">8.4.1</A>, <A HREF="#@default614">9.3.1</A>, <A HREF="#@default721">9.4.1</A>, <A HREF="#@default837">10.3.1</A>, <A HREF="#@default945">10.4.1</A>, <A HREF="#@default1089">11.3.1</A>, <A HREF="#@default1196">11.4.1</A>, <A HREF="#@default1313">12.3.1</A>, <A HREF="#@default1420">12.4.1</A>, <A HREF="#@default1535">13.3.1</A>, <A HREF="#@default1632">13.4.1</A>, <A HREF="#@default1701">14.3.1</A>, <A HREF="#@default1806">14.4.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
Python, <A HREF="#@default1727">14.3.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">comments, <A HREF="#@default127">6.2</A>
</LI><LI CLASS="li-indexenv">compiler compatibility, <A HREF="#@default38">2.4</A>
</LI><LI CLASS="li-indexenv">component, <A HREF="#@default2063">D</A>
</LI><LI CLASS="li-indexenv">component architecture, <A HREF="#@default2064">D</A>
</LI><LI CLASS="li-indexenv">concrete class, <A HREF="#@default2061">D</A>
</LI><LI CLASS="li-indexenv">configure, <A HREF="#@default41">3.1.1</A>
</LI><LI CLASS="li-indexenv">connect, <A HREF="#@default1852">18.2.3</A>
</LI><LI CLASS="li-indexenv">constructor<UL CLASS="indexenv"><LI CLASS="li-indexenv">
alternate, <A HREF="#@default1913">20.1</A>
</LI><LI CLASS="li-indexenv">example, <A HREF="#@default731">9.4.3</A>, <A HREF="#@default954">10.4.3</A>, <A HREF="#@default1206">11.4.3</A>, <A HREF="#@default1429">12.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">copy, <A HREF="#@default208">6.4</A>, <A HREF="#@default241">6.4</A>, <A HREF="#@default368">6.7</A>, <A HREF="#@default2065">D</A>
</LI><LI CLASS="li-indexenv">create1d, <A HREF="#@default177">6.4</A>, <A HREF="#@default214">6.4</A>, <A HREF="#@default1058">11.2.3</A>, <A HREF="#@default1282">12.2.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default956">10.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">create2dCol, <A HREF="#@default178">6.4</A>, <A HREF="#@default215">6.4</A>, <A HREF="#@default1060">11.2.3</A>, <A HREF="#@default1284">12.2.4</A>
</LI><LI CLASS="li-indexenv">create2dRow, <A HREF="#@default179">6.4</A>, <A HREF="#@default216">6.4</A>, <A HREF="#@default1059">11.2.3</A>, <A HREF="#@default1283">12.2.4</A>
</LI><LI CLASS="li-indexenv">createCol, <A HREF="#@default175">6.4</A>, <A HREF="#@default212">6.4</A>, <A HREF="#@default1056">11.2.3</A>, <A HREF="#@default1280">12.2.4</A>
</LI><LI CLASS="li-indexenv">createRemote, <A HREF="#@default1851">18.2.3</A>
</LI><LI CLASS="li-indexenv">createRow, <A HREF="#@default176">6.4</A>, <A HREF="#@default213">6.4</A>, <A HREF="#@default1057">11.2.3</A>, <A HREF="#@default1281">12.2.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default602">9.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">ctor2, <A HREF="#@default1914">20.1</A>, <A HREF="#@default1917">20.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">DLL, <A HREF="#@default2070">D</A>
</LI><LI CLASS="li-indexenv">DTD, <A HREF="#@default2072">D</A>
</LI><LI CLASS="li-indexenv">data<UL CLASS="indexenv"><LI CLASS="li-indexenv">
preinitialized, <A HREF="#@default1909">20</A>
</LI><LI CLASS="li-indexenv">private, <A HREF="#@default1908">20</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">data type<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1498">13.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1492">13.2.3</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default1485">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default388">8.2.3</A>, <A HREF="#@default569">9.2.3</A>, <A HREF="#@default761">10.2.3</A>, <A HREF="#@default999">11.2.3</A>, <A HREF="#@default1243">12.2.4</A>, <A HREF="#@default1459">13.2.3</A>, <A HREF="#@default1667">14.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
abstract classes, <A HREF="#@default1481">13.2.3</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default412">8.2.3</A>, <A HREF="#@default592">9.2.3</A>, <A HREF="#@default805">10.2.3</A>, <A HREF="#@default1051">11.2.3</A>, <A HREF="#@default1275">12.2.4</A>, <A HREF="#@default1686">14.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default406">8.2.3</A>, <A HREF="#@default587">9.2.3</A>, <A HREF="#@default798">10.2.3</A>, <A HREF="#@default1045">11.2.3</A>, <A HREF="#@default1269">12.2.4</A>, <A HREF="#@default1682">14.2.3</A>
</LI><LI CLASS="li-indexenv">int, <A HREF="#@default1675">14.2.3</A>
</LI><LI CLASS="li-indexenv">interfaces, <A HREF="#@default1479">13.2.3</A>
</LI><LI CLASS="li-indexenv">long, <A HREF="#@default1670">14.2.3</A>
</LI><LI CLASS="li-indexenv">opaque, <A HREF="#@default1691">14.2.3</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default1021">11.2.3</A>, <A HREF="#@default1265">12.2.4</A>
</LI><LI CLASS="li-indexenv">pointers, <A HREF="#@default785">10.2.3</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default780">10.2.3</A>, <A HREF="#@default1016">11.2.3</A>, <A HREF="#@default1260">12.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">dcomplex, <A HREF="#@default397">8.2.3</A>, <A HREF="#@default578">9.2.3</A>, <A HREF="#@default770">10.2.3</A>, <A HREF="#@default824">10.2.3</A>, <A HREF="#@default1008">11.2.3</A>, <A HREF="#@default1252">12.2.4</A>, <A HREF="#@default1468">13.2.3</A>, <A HREF="#@default2067">D</A>
</LI><LI CLASS="li-indexenv">deallocate, <A HREF="#@default1055">11.2.3</A>, <A HREF="#@default1279">12.2.4</A>
</LI><LI CLASS="li-indexenv">decaf, <A HREF="#@default1">1</A>
</LI><LI CLASS="li-indexenv">deleteRef, <A HREF="#@default184">6.4</A>, <A HREF="#@default221">6.4</A>, <A HREF="#@default439">8.3.3</A>, <A HREF="#@default1065">11.2.3</A>, <A HREF="#@default1100">11.3.2</A>, <A HREF="#@default1289">12.2.4</A>, <A HREF="#@default1324">12.3.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default842">10.3.2</A>, <A HREF="#@default851">10.3.2</A>, <A HREF="#@default877">10.3.5</A>, <A HREF="#@default968">10.4.3</A>, <A HREF="#@default1103">11.3.2</A>, <A HREF="#@default1129">11.3.5</A>, <A HREF="#@default1218">11.4.4</A>, <A HREF="#@default1327">12.3.2</A>, <A HREF="#@default1353">12.3.5</A>, <A HREF="#@default1437">12.4.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">dense, <A HREF="#@default2068">D</A>
</LI><LI CLASS="li-indexenv">dependency debugging, <A HREF="#@default1899">19.3.2</A>
</LI><LI CLASS="li-indexenv">destruction<UL CLASS="indexenv"><LI CLASS="li-indexenv">
remote objects, <A HREF="#@default1880">18.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">destructor<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default735">9.4.3</A>, <A HREF="#@default966">10.4.3</A>, <A HREF="#@default1210">11.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">developer, <A HREF="#@default16">2.3</A>, <A HREF="#@default2069">D</A>
</LI><LI CLASS="li-indexenv">dimen, <A HREF="#@default201">6.4</A>, <A HREF="#@default234">6.4</A>
</LI><LI CLASS="li-indexenv">distributed systems, <A HREF="#@default1843">18.2</A>, <A HREF="#@default1883">18.5</A>
</LI><LI CLASS="li-indexenv">double, <A HREF="#@default392">8.2.3</A>, <A HREF="#@default573">9.2.3</A>, <A HREF="#@default765">10.2.3</A>, <A HREF="#@default1003">11.2.3</A>, <A HREF="#@default1247">12.2.4</A>, <A HREF="#@default1463">13.2.3</A>, <A HREF="#@default2071">D</A>
</LI><LI CLASS="li-indexenv">double underscores, <A HREF="#@default95">5.2.3</A>
</LI><LI CLASS="li-indexenv">dynamic linking, <A HREF="#@default2073">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">ensure, <A HREF="#@default209">6.4</A>, <A HREF="#@default242">6.4</A>
</LI><LI CLASS="li-indexenv">enum, <A HREF="#@default398">8.2.3</A>, <A HREF="#@default579">9.2.3</A>, <A HREF="#@default771">10.2.3</A>, <A HREF="#@default1009">11.2.3</A>, <A HREF="#@default1253">12.2.4</A>, <A HREF="#@default1469">13.2.3</A>, <A HREF="#@default2074">D</A>
</LI><LI CLASS="li-indexenv">enumeration, <A HREF="#@default2075">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default408">8.2.3</A>, <A HREF="#@default589">9.2.3</A>, <A HREF="#@default801">10.2.3</A>, <A HREF="#@default1048">11.2.3</A>, <A HREF="#@default1272">12.2.4</A>, <A HREF="#@default1495">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default148">6.3</A>, <A HREF="#@default407">8.2.3</A>, <A HREF="#@default588">9.2.3</A>, <A HREF="#@default799">10.2.3</A>, <A HREF="#@default1046">11.2.3</A>, <A HREF="#@default1270">12.2.4</A>, <A HREF="#@default1493">13.2.3</A>, <A HREF="#@default1683">14.2.3</A>
</LI><LI CLASS="li-indexenv">environment variables, <A HREF="#@default1537">13.3.2</A>, <A HREF="#@default1703">14.3.2</A>
</LI><LI CLASS="li-indexenv">example<UL CLASS="indexenv"><LI CLASS="li-indexenv">
Args.Cdouble, <A HREF="#@default1662">14.2.2</A>, <A HREF="#@default1724">14.3.4</A>, <A HREF="#@default1808">14.4.2</A>
</LI><LI CLASS="li-indexenv">access, <A HREF="#@default815">10.2.3</A>
</LI><LI CLASS="li-indexenv">addSearchPath, <A HREF="#@default641">9.3.4</A>, <A HREF="#@default860">10.3.3</A>, <A HREF="#@default1109">11.3.3</A>, <A HREF="#@default1333">12.3.3</A>
</LI><LI CLASS="li-indexenv">array, <A HREF="#@default598">9.2.3</A>, <A HREF="#@default811">10.2.3</A>, <A HREF="#@default963">10.4.3</A>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default832">10.2.4</A>, <A HREF="#@default874">10.3.5</A>, <A HREF="#@default1096">11.3.2</A>, <A HREF="#@default1126">11.3.5</A>, <A HREF="#@default1215">11.4.4</A>, <A HREF="#@default1320">12.3.2</A>, <A HREF="#@default1350">12.3.5</A>, <A HREF="#@default1434">12.4.4</A>, <A HREF="#@default1520">13.2.4</A>
</LI><LI CLASS="li-indexenv">constructor, <A HREF="#@default543">8.4.3</A>, <A HREF="#@default730">9.4.3</A>, <A HREF="#@default953">10.4.3</A>, <A HREF="#@default1205">11.4.3</A>, <A HREF="#@default1428">12.4.3</A>
</LI><LI CLASS="li-indexenv">create1d, <A HREF="#@default955">10.4.3</A>
</LI><LI CLASS="li-indexenv">createRow, <A HREF="#@default603">9.2.3</A>
</LI><LI CLASS="li-indexenv">deleteRef, <A HREF="#@default843">10.3.2</A>, <A HREF="#@default850">10.3.2</A>, <A HREF="#@default876">10.3.5</A>, <A HREF="#@default967">10.4.3</A>, <A HREF="#@default1102">11.3.2</A>, <A HREF="#@default1128">11.3.5</A>, <A HREF="#@default1217">11.4.4</A>, <A HREF="#@default1326">12.3.2</A>, <A HREF="#@default1352">12.3.5</A>, <A HREF="#@default1436">12.4.4</A>
</LI><LI CLASS="li-indexenv">destructor, <A HREF="#@default545">8.4.3</A>, <A HREF="#@default734">9.4.3</A>, <A HREF="#@default965">10.4.3</A>, <A HREF="#@default1209">11.4.3</A>
</LI><LI CLASS="li-indexenv">ExceptionTest.Fib, <A HREF="#@default386">8.2.2</A>, <A HREF="#@default461">8.3.6</A>, <A HREF="#@default552">8.4.4</A>, <A HREF="#@default567">9.2.2</A>, <A HREF="#@default653">9.3.6</A>, <A HREF="#@default739">9.4.4</A>, <A HREF="#@default759">10.2.2</A>, <A HREF="#@default873">10.3.5</A>, <A HREF="#@default978">10.4.4</A>, <A HREF="#@default1124">11.3.5</A>, <A HREF="#@default1214">11.4.4</A>, <A HREF="#@default1348">12.3.5</A>, <A HREF="#@default1433">12.4.4</A>, <A HREF="#@default1452">13.2.2</A>, <A HREF="#@default1453">13.2.2</A>, <A HREF="#@default1454">13.2.2</A>, <A HREF="#@default1565">13.3.7</A>, <A HREF="#@default1635">13.4.2</A>, <A HREF="#@default1642">13.4.4</A>, <A HREF="#@default1740">14.3.7</A>, <A HREF="#@default1816">14.4.5</A>
</LI><LI CLASS="li-indexenv">enumeration<UL CLASS="indexenv"><LI CLASS="li-indexenv">
car, <A HREF="#@default802">10.2.3</A>, <A HREF="#@default1047">11.2.3</A>, <A HREF="#@default1271">12.2.4</A>, <A HREF="#@default1494">13.2.3</A>
</LI><LI CLASS="li-indexenv">color, <A HREF="#@default409">8.2.3</A>, <A HREF="#@default590">9.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">example.withState, <A HREF="#@default951">10.4.3</A>, <A HREF="#@default971">10.4.3</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default553">8.4.4</A>, <A HREF="#@default742">9.4.4</A>, <A HREF="#@default878">10.3.5</A>, <A HREF="#@default1566">13.3.7</A>, <A HREF="#@default1643">13.4.4</A>, <A HREF="#@default1741">14.3.7</A>, <A HREF="#@default1817">14.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
C, <A HREF="#@default462">8.3.6</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default654">9.3.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1277">12.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Fortran 90/95<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1053">11.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">foo.bar, <A HREF="#@default541">8.4.3</A>, <A HREF="#@default542">8.4.3</A>, <A HREF="#@default546">8.4.3</A>, <A HREF="#@default728">9.4.3</A>, <A HREF="#@default729">9.4.3</A>, <A HREF="#@default733">9.4.3</A>, <A HREF="#@default1509">13.2.3</A>, <A HREF="#@default1514">13.2.3</A>, <A HREF="#@default1519">13.2.4</A>
</LI><LI CLASS="li-indexenv">get, <A HREF="#@default972">10.4.3</A>
</LI><LI CLASS="li-indexenv">get1, <A HREF="#@default969">10.4.3</A>, <A HREF="#@default974">10.4.3</A>
</LI><LI CLASS="li-indexenv">getClassInfo, <A HREF="#@default852">10.3.2</A>
</LI><LI CLASS="li-indexenv">getName, <A HREF="#@default854">10.3.2</A>
</LI><LI CLASS="li-indexenv">import<UL CLASS="indexenv"><LI CLASS="li-indexenv">
error, <A HREF="#@default1715">14.3.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">instantiation, <A HREF="#@default446">8.3.5</A>, <A HREF="#@default635">9.3.3</A>, <A HREF="#@default646">9.3.5</A>, <A HREF="#@default657">9.3.6</A>, <A HREF="#@default740">9.4.4</A>, <A HREF="#@default865">10.3.4</A>, <A HREF="#@default881">10.3.5</A>, <A HREF="#@default957">10.4.3</A>, <A HREF="#@default979">10.4.4</A>, <A HREF="#@default1098">11.3.2</A>, <A HREF="#@default1114">11.3.4</A>, <A HREF="#@default1130">11.3.5</A>, <A HREF="#@default1219">11.4.4</A>, <A HREF="#@default1322">12.3.2</A>, <A HREF="#@default1338">12.3.4</A>, <A HREF="#@default1354">12.3.5</A>, <A HREF="#@default1438">12.4.4</A>, <A HREF="#@default1525">13.2.4</A>, <A HREF="#@default1550">13.3.4</A>, <A HREF="#@default1552">13.3.4</A>, <A HREF="#@default1559">13.3.6</A>, <A HREF="#@default1645">13.4.4</A>, <A HREF="#@default1725">14.3.4</A>, <A HREF="#@default1733">14.3.6</A>, <A HREF="#@default1819">14.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
array, <A HREF="#@default600">9.2.3</A>, <A HREF="#@default813">10.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">isSame, <A HREF="#@default845">10.3.2</A>, <A HREF="#@default1104">11.3.2</A>, <A HREF="#@default1328">12.3.2</A>
</LI><LI CLASS="li-indexenv">isType, <A HREF="#@default847">10.3.2</A>
</LI><LI CLASS="li-indexenv">MyPackage.MyClass, <A HREF="#@default725">9.4.2</A>
</LI><LI CLASS="li-indexenv">not_null, <A HREF="#@default1132">11.3.5</A>, <A HREF="#@default1221">11.4.4</A>, <A HREF="#@default1356">12.3.5</A>, <A HREF="#@default1440">12.4.4</A>
</LI><LI CLASS="li-indexenv">num.Linsol, <A HREF="#@default414">8.2.3</A>, <A HREF="#@default537">8.4.2</A>, <A HREF="#@default606">9.2.3</A>, <A HREF="#@default809">10.2.3</A>, <A HREF="#@default1078">11.2.3</A>, <A HREF="#@default1079">11.2.3</A>, <A HREF="#@default1302">12.2.4</A>, <A HREF="#@default1303">12.2.4</A>
</LI><LI CLASS="li-indexenv">Overload.Sample, <A HREF="#@default445">8.3.5</A>, <A HREF="#@default645">9.3.5</A>, <A HREF="#@default864">10.3.4</A>, <A HREF="#@default1113">11.3.4</A>, <A HREF="#@default1337">12.3.4</A>, <A HREF="#@default1558">13.3.6</A>, <A HREF="#@default1732">14.3.6</A>
</LI><LI CLASS="li-indexenv">objarg.Subclass, <A HREF="#@default1529">13.2.4</A>
</LI><LI CLASS="li-indexenv">overloading, <A HREF="#@default448">8.3.5</A>, <A HREF="#@default648">9.3.5</A>, <A HREF="#@default867">10.3.4</A>, <A HREF="#@default1116">11.3.4</A>, <A HREF="#@default1340">12.3.4</A>, <A HREF="#@default1561">13.3.6</A>, <A HREF="#@default1735">14.3.6</A>
</LI><LI CLASS="li-indexenv">postconditions, <A HREF="#@default492">8.3.8</A>, <A HREF="#@default680">9.3.8</A>, <A HREF="#@default904">10.3.7</A>, <A HREF="#@default1155">11.3.7</A>, <A HREF="#@default1379">12.3.7</A>, <A HREF="#@default1591">13.3.9</A>, <A HREF="#@default1765">14.3.9</A>, <A HREF="#@default1936">21.2</A>
</LI><LI CLASS="li-indexenv">preconditions, <A HREF="#@default491">8.3.8</A>, <A HREF="#@default679">9.3.8</A>, <A HREF="#@default903">10.3.7</A>, <A HREF="#@default1154">11.3.7</A>, <A HREF="#@default1378">12.3.7</A>, <A HREF="#@default1590">13.3.9</A>, <A HREF="#@default1764">14.3.9</A>, <A HREF="#@default1935">21.2</A>
</LI><LI CLASS="li-indexenv">primes, <A HREF="#@default597">9.2.3</A>, <A HREF="#@default810">10.2.3</A>, <A HREF="#@default1672">14.2.3</A>
</LI><LI CLASS="li-indexenv">SIDL_CATCH, <A HREF="#@default465">8.3.6</A>, <A HREF="#@default514">8.3.8</A>, <A HREF="#@default702">9.3.8</A>, <A HREF="#@default926">10.3.7</A>, <A HREF="#@default1177">11.3.7</A>, <A HREF="#@default1401">12.3.7</A>, <A HREF="#@default1613">13.3.9</A>, <A HREF="#@default1787">14.3.9</A>
</LI><LI CLASS="li-indexenv">SIDL_CHECK, <A HREF="#@default515">8.3.8</A>, <A HREF="#@default703">9.3.8</A>, <A HREF="#@default927">10.3.7</A>, <A HREF="#@default1178">11.3.7</A>, <A HREF="#@default1402">12.3.7</A>, <A HREF="#@default1614">13.3.9</A>, <A HREF="#@default1788">14.3.9</A>
</LI><LI CLASS="li-indexenv">SIDL_CLEAR, <A HREF="#@default467">8.3.6</A>
</LI><LI CLASS="li-indexenv">SIDL_THROW, <A HREF="#@default555">8.4.4</A>
</LI><LI CLASS="li-indexenv">Subclass, <A HREF="#@default1523">13.2.4</A>, <A HREF="#@default1530">13.2.4</A>
</LI><LI CLASS="li-indexenv">SuperInterface, <A HREF="#@default1524">13.2.4</A>
</LI><LI CLASS="li-indexenv">set, <A HREF="#@default817">10.2.3</A>, <A HREF="#@default1527">13.2.4</A>
</LI><LI CLASS="li-indexenv">set1, <A HREF="#@default819">10.2.3</A>, <A HREF="#@default959">10.4.3</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default504">8.3.8</A>, <A HREF="#@default521">8.3.8</A>, <A HREF="#@default692">9.3.8</A>, <A HREF="#@default709">9.3.8</A>, <A HREF="#@default916">10.3.7</A>, <A HREF="#@default931">10.3.7</A>, <A HREF="#@default1167">11.3.7</A>, <A HREF="#@default1182">11.3.7</A>, <A HREF="#@default1391">12.3.7</A>, <A HREF="#@default1406">12.3.7</A>, <A HREF="#@default1603">13.3.9</A>, <A HREF="#@default1618">13.3.9</A>, <A HREF="#@default1777">14.3.9</A>, <A HREF="#@default1792">14.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default522">8.3.8</A>, <A HREF="#@default710">9.3.8</A>, <A HREF="#@default932">10.3.7</A>, <A HREF="#@default1183">11.3.7</A>, <A HREF="#@default1407">12.3.7</A>, <A HREF="#@default1619">13.3.9</A>, <A HREF="#@default1793">14.3.9</A>
</LI><LI CLASS="li-indexenv">sidl.BaseClass, <A HREF="#@default421">8.2.4</A>, <A HREF="#@default436">8.3.3</A>, <A HREF="#@default633">9.3.3</A>, <A HREF="#@default830">10.2.4</A>, <A HREF="#@default1094">11.3.2</A>, <A HREF="#@default1318">12.3.2</A>
</LI><LI CLASS="li-indexenv">sidl.BaseInterface, <A HREF="#@default440">8.3.3</A>, <A HREF="#@default634">9.3.3</A>, <A HREF="#@default831">10.2.4</A>, <A HREF="#@default841">10.3.2</A>, <A HREF="#@default849">10.3.2</A>, <A HREF="#@default1095">11.3.2</A>, <A HREF="#@default1101">11.3.2</A>, <A HREF="#@default1319">12.3.2</A>, <A HREF="#@default1325">12.3.2</A>
</LI><LI CLASS="li-indexenv">sidl.ClassInfo, <A HREF="#@default848">10.3.2</A>
</LI><LI CLASS="li-indexenv">sidl.Loader, <A HREF="#@default640">9.3.4</A>, <A HREF="#@default859">10.3.3</A>, <A HREF="#@default1108">11.3.3</A>, <A HREF="#@default1332">12.3.3</A>
</LI><LI CLASS="li-indexenv">sidl.PostViolation, <A HREF="#@default497">8.3.8</A>, <A HREF="#@default507">8.3.8</A>, <A HREF="#@default685">9.3.8</A>, <A HREF="#@default695">9.3.8</A>, <A HREF="#@default909">10.3.7</A>, <A HREF="#@default919">10.3.7</A>, <A HREF="#@default1160">11.3.7</A>, <A HREF="#@default1170">11.3.7</A>, <A HREF="#@default1384">12.3.7</A>, <A HREF="#@default1394">12.3.7</A>, <A HREF="#@default1596">13.3.9</A>, <A HREF="#@default1606">13.3.9</A>, <A HREF="#@default1770">14.3.9</A>, <A HREF="#@default1780">14.3.9</A>, <A HREF="#@default1941">21.2</A>
</LI><LI CLASS="li-indexenv">sidl.PreViolation, <A HREF="#@default496">8.3.8</A>, <A HREF="#@default506">8.3.8</A>, <A HREF="#@default684">9.3.8</A>, <A HREF="#@default694">9.3.8</A>, <A HREF="#@default908">10.3.7</A>, <A HREF="#@default918">10.3.7</A>, <A HREF="#@default1159">11.3.7</A>, <A HREF="#@default1169">11.3.7</A>, <A HREF="#@default1383">12.3.7</A>, <A HREF="#@default1393">12.3.7</A>, <A HREF="#@default1595">13.3.9</A>, <A HREF="#@default1605">13.3.9</A>, <A HREF="#@default1769">14.3.9</A>, <A HREF="#@default1779">14.3.9</A>, <A HREF="#@default1940">21.2</A>
</LI><LI CLASS="li-indexenv">sort.SimpleCounter, <A HREF="#@default1202">11.4.3</A>, <A HREF="#@default1207">11.4.3</A>, <A HREF="#@default1211">11.4.3</A>, <A HREF="#@default1426">12.4.3</A>, <A HREF="#@default1430">12.4.3</A>
</LI><LI CLASS="li-indexenv">splicer blocks, <A HREF="#@default535">8.4.2</A>, <A HREF="#@default723">9.4.2</A>, <A HREF="#@default947">10.4.2</A>, <A HREF="#@default1198">11.4.2</A>, <A HREF="#@default1422">12.4.2</A>, <A HREF="#@default1636">13.4.2</A>, <A HREF="#@default1809">14.4.2</A>
</LI><LI CLASS="li-indexenv">stride, <A HREF="#@default821">10.2.3</A>
</LI><LI CLASS="li-indexenv">swallows<UL CLASS="indexenv"><LI CLASS="li-indexenv">
unladen, <A HREF="#@default962">10.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">test.HelloWorld, <A HREF="#@default1545">13.3.3</A>, <A HREF="#@default1549">13.3.4</A>
</LI><LI CLASS="li-indexenv">vuDot, <A HREF="#@default305">6.5</A>
</LI><LI CLASS="li-indexenv">vuSum, <A HREF="#@default487">8.3.8</A>, <A HREF="#@default505">8.3.8</A>, <A HREF="#@default675">9.3.8</A>, <A HREF="#@default693">9.3.8</A>, <A HREF="#@default899">10.3.7</A>, <A HREF="#@default917">10.3.7</A>, <A HREF="#@default1150">11.3.7</A>, <A HREF="#@default1168">11.3.7</A>, <A HREF="#@default1374">12.3.7</A>, <A HREF="#@default1392">12.3.7</A>, <A HREF="#@default1586">13.3.9</A>, <A HREF="#@default1604">13.3.9</A>, <A HREF="#@default1760">14.3.9</A>, <A HREF="#@default1778">14.3.9</A>, <A HREF="#@default1931">21.2</A>
</LI><LI CLASS="li-indexenv">X.Y.Z, <A HREF="#@default382">8.2.1</A>, <A HREF="#@default432">8.3.2</A>, <A HREF="#@default1657">14.2.1</A>, <A HREF="#@default1679">14.2.3</A>, <A HREF="#@default1696">14.2.4</A>, <A HREF="#@default1711">14.3.3</A>, <A HREF="#@default1717">14.3.3</A>, <A HREF="#@default1718">14.3.3</A>, <A HREF="#@default1719">14.3.3</A>
</LI><LI CLASS="li-indexenv">X.Y.Zmodule, <A HREF="#@default1714">14.3.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">exception, <A HREF="#@default2076">D</A>
</LI><LI CLASS="li-indexenv">exception handling<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default554">8.4.4</A>, <A HREF="#@default743">9.4.4</A>, <A HREF="#@default879">10.3.5</A>, <A HREF="#@default1567">13.3.7</A>, <A HREF="#@default1644">13.4.4</A>, <A HREF="#@default1742">14.3.7</A>, <A HREF="#@default1818">14.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
C, <A HREF="#@default463">8.3.6</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default655">9.3.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">sidl.PostViolation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default923">10.3.7</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default511">8.3.8</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default699">9.3.8</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1398">12.3.7</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1174">11.3.7</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1610">13.3.9</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1784">14.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">sidl.PreViolation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default922">10.3.7</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default510">8.3.8</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default698">9.3.8</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1397">12.3.7</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1173">11.3.7</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1609">13.3.9</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1783">14.3.9</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default1486">13.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default757">10.2.2</A>, <A HREF="#@default871">10.3.5</A>, <A HREF="#@default977">10.4.4</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default452">8.3.5</A>, <A HREF="#@default455">8.3.6</A>, <A HREF="#@default550">8.4.4</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default652">9.3.6</A>, <A HREF="#@default738">9.4.4</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1241">12.2.3</A>, <A HREF="#@default1344">12.3.5</A>, <A HREF="#@default1432">12.4.4</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default997">11.2.2</A>, <A HREF="#@default1120">11.3.5</A>, <A HREF="#@default1213">11.4.4</A>
</LI><LI CLASS="li-indexenv">implicit runtime, <A HREF="#@default385">8.2.2</A>, <A HREF="#@default756">10.2.2</A>, <A HREF="#@default995">11.2.2</A>, <A HREF="#@default1239">12.2.3</A>
</LI><LI CLASS="li-indexenv">implicit runtime exception, <A HREF="#@default115">6.2</A>, <A HREF="#@default363">6.7</A>, <A HREF="#@default456">8.3.6</A>, <A HREF="#@default872">10.3.5</A>, <A HREF="#@default1121">11.3.5</A>, <A HREF="#@default1345">12.3.5</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1564">13.3.7</A>, <A HREF="#@default1641">13.4.4</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1678">14.2.3</A>, <A HREF="#@default1739">14.3.7</A>, <A HREF="#@default1815">14.4.5</A>
</LI><LI CLASS="li-indexenv">sidl.InvViolation, <A HREF="#@default296">6.5</A>, <A HREF="#@default1995">21.2.3</A>
</LI><LI CLASS="li-indexenv">sidl.PostViolation, <A HREF="#@default295">6.5</A>, <A HREF="#@default509">8.3.8</A>, <A HREF="#@default697">9.3.8</A>, <A HREF="#@default921">10.3.7</A>, <A HREF="#@default1172">11.3.7</A>, <A HREF="#@default1396">12.3.7</A>, <A HREF="#@default1608">13.3.9</A>, <A HREF="#@default1782">14.3.9</A>, <A HREF="#@default1994">21.2.3</A>
</LI><LI CLASS="li-indexenv">sidl.PreViolation, <A HREF="#@default294">6.5</A>, <A HREF="#@default508">8.3.8</A>, <A HREF="#@default696">9.3.8</A>, <A HREF="#@default920">10.3.7</A>, <A HREF="#@default1171">11.3.7</A>, <A HREF="#@default1395">12.3.7</A>, <A HREF="#@default1607">13.3.9</A>, <A HREF="#@default1781">14.3.9</A>, <A HREF="#@default1993">21.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">execution environment, <A HREF="#@default1539">13.3.2</A>, <A HREF="#@default1705">14.3.2</A>
</LI><LI CLASS="li-indexenv">extends, <A HREF="#@default345">6.7</A>, <A HREF="#@default2077">D</A>
</LI><LI CLASS="li-indexenv">external stubs, <A HREF="#@default2078">D</A>
</LI><LI CLASS="li-indexenv">external types, <A HREF="#@default2079">D</A>
</LI><LI CLASS="li-indexenv">extra arguments, <A HREF="#@default384">8.2.2</A>, <A HREF="#@default754">10.2.2</A>, <A HREF="#@default992">11.2.2</A>, <A HREF="#@default1236">12.2.3</A>, <A HREF="#@default1659">14.2.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1274">12.2.4</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default1310">12.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1417">12.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1421">12.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">cast, <A HREF="#@default1307">12.2.5</A>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default1305">12.2.5</A>
</LI><LI CLASS="li-indexenv">constructor, <A HREF="#@default1427">12.4.3</A>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default1242">12.2.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1273">12.2.4</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1267">12.2.4</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default1263">12.2.4</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default1258">12.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1268">12.2.4</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default1349">12.3.5</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default1240">12.2.3</A>, <A HREF="#@default1342">12.3.5</A>, <A HREF="#@default1431">12.4.4</A>
</LI><LI CLASS="li-indexenv">extra out argument, <A HREF="#@default1343">12.3.5</A>
</LI><LI CLASS="li-indexenv">file extension, <A HREF="#@default1230">12.2.1</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default1358">12.3.6</A>, <A HREF="#@default1442">12.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default1444">12.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default1364">12.3.7</A>, <A HREF="#@default1389">12.3.7</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default1390">12.3.7</A>, <A HREF="#@default1408">12.3.7</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default1409">12.3.7</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default1235">12.2.3</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default1232">12.2.2</A>
</LI><LI CLASS="li-indexenv">object creation, <A HREF="#@default1317">12.3.2</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default1314">12.3.2</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default1335">12.3.4</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default1264">12.2.4</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default1362">12.3.6</A>, <A HREF="#@default1447">12.4.5</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default1360">12.3.6</A>, <A HREF="#@default1445">12.4.5</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default1424">12.4.3</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default1330">12.3.3</A>
</LI><LI CLASS="li-indexenv">string length limits, <A HREF="#@default1262">12.2.4</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default1259">12.2.4</A>
</LI><LI CLASS="li-indexenv">subroutines, <A HREF="#@default1237">12.2.3</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default1304">12.2.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Fortran 90/95<UL CLASS="indexenv"><LI CLASS="li-indexenv">
_wrapObj, <A HREF="#@default1922">20.6</A>
</LI><LI CLASS="li-indexenv">array alignment, <A HREF="#@default246">6.4</A>
</LI><LI CLASS="li-indexenv">array example, <A HREF="#@default249">6.4</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default1050">11.2.3</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default1086">11.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1193">11.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1197">11.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">cast, <A HREF="#@default1083">11.2.4</A>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default1081">11.2.4</A>
</LI><LI CLASS="li-indexenv">constructor, <A HREF="#@default1204">11.4.3</A>
</LI><LI CLASS="li-indexenv">ctor2, <A HREF="#@default1921">20.6</A>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default998">11.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
array, <A HREF="#@default1031">11.2.3</A>, <A HREF="#@default1039">11.2.3</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default1049">11.2.3</A>
</LI><LI CLASS="li-indexenv">class, <A HREF="#@default1029">11.2.3</A>, <A HREF="#@default1037">11.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1043">11.2.3</A>
</LI><LI CLASS="li-indexenv">interface, <A HREF="#@default1027">11.2.3</A>, <A HREF="#@default1035">11.2.3</A>
</LI><LI CLASS="li-indexenv">opaque, <A HREF="#@default1023">11.2.3</A>, <A HREF="#@default1033">11.2.3</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default1019">11.2.3</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default1014">11.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">destructor, <A HREF="#@default1208">11.4.3</A>
</LI><LI CLASS="li-indexenv">direct array
access, <A HREF="#@default244">6.4</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1044">11.2.3</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default1125">11.3.5</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default996">11.2.2</A>, <A HREF="#@default1118">11.3.5</A>, <A HREF="#@default1212">11.4.4</A>
</LI><LI CLASS="li-indexenv">extra out argument, <A HREF="#@default1119">11.3.5</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default1134">11.3.6</A>, <A HREF="#@default1223">11.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default1225">11.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default1140">11.3.7</A>, <A HREF="#@default1165">11.3.7</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default1166">11.3.7</A>, <A HREF="#@default1184">11.3.7</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default1185">11.3.7</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default991">11.2.2</A>
</LI><LI CLASS="li-indexenv">NULL, <A HREF="#@default1041">11.2.3</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default988">11.2.1</A>
</LI><LI CLASS="li-indexenv">object creation, <A HREF="#@default1093">11.3.2</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default1090">11.3.2</A>
</LI><LI CLASS="li-indexenv">object references, <A HREF="#@default1026">11.2.3</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default1111">11.3.4</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default1020">11.2.3</A>
</LI><LI CLASS="li-indexenv">pointers, <A HREF="#@default1025">11.2.3</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default1138">11.3.6</A>, <A HREF="#@default1228">11.4.5</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default1136">11.3.6</A>, <A HREF="#@default1226">11.4.5</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default1200">11.4.3</A>
</LI><LI CLASS="li-indexenv">set_null, <A HREF="#@default1042">11.2.3</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default1106">11.3.3</A>
</LI><LI CLASS="li-indexenv">string length limits, <A HREF="#@default1018">11.2.3</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default1015">11.2.3</A>
</LI><LI CLASS="li-indexenv">subroutines, <A HREF="#@default993">11.2.2</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default1080">11.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">fcomplex, <A HREF="#@default396">8.2.3</A>, <A HREF="#@default577">9.2.3</A>, <A HREF="#@default769">10.2.3</A>, <A HREF="#@default825">10.2.3</A>, <A HREF="#@default1007">11.2.3</A>, <A HREF="#@default1251">12.2.4</A>, <A HREF="#@default1467">13.2.3</A>, <A HREF="#@default2080">D</A>
</LI><LI CLASS="li-indexenv">final, <A HREF="#@default103">6.2</A>, <A HREF="#@default350">6.7</A>, <A HREF="#@default2081">D</A>
</LI><LI CLASS="li-indexenv">first, <A HREF="#@default210">6.4</A>, <A HREF="#@default243">6.4</A>
</LI><LI CLASS="li-indexenv">float, <A HREF="#@default391">8.2.3</A>, <A HREF="#@default572">9.2.3</A>, <A HREF="#@default764">10.2.3</A>, <A HREF="#@default1002">11.2.3</A>, <A HREF="#@default1246">12.2.4</A>, <A HREF="#@default1462">13.2.3</A>, <A HREF="#@default2082">D</A>
</LI><LI CLASS="li-indexenv">framework, <A HREF="#@default2">1</A>
</LI><LI CLASS="li-indexenv">from, <A HREF="#@default139">6.2</A>
</LI><LI CLASS="li-indexenv">full name, <A HREF="#@default376">6.7</A>, <A HREF="#@default800">10.2.3</A>, <A HREF="#@default994">11.2.2</A>, <A HREF="#@default1203">11.4.3</A>, <A HREF="#@default1238">12.2.3</A>, <A HREF="#@default1521">13.2.4</A>, <A HREF="#@default1569">13.3.7</A>, <A HREF="#@default1647">13.4.4</A>, <A HREF="#@default1660">14.2.2</A>, <A HREF="#@default2083">D</A>
</LI><LI CLASS="li-indexenv">fundamental types, <A HREF="#@default140">6.3</A>, <A HREF="#@default2084">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default426">8.3.1</A>, <A HREF="#@default613">9.3.1</A>, <A HREF="#@default836">10.3.1</A>, <A HREF="#@default1088">11.3.1</A>, <A HREF="#@default1312">12.3.1</A>, <A HREF="#@default1534">13.3.1</A>, <A HREF="#@default1700">14.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default532">8.4.1</A>, <A HREF="#@default720">9.4.1</A>, <A HREF="#@default944">10.4.1</A>, <A HREF="#@default1195">11.4.1</A>, <A HREF="#@default1419">12.4.1</A>, <A HREF="#@default1631">13.4.1</A>, <A HREF="#@default1805">14.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">generic arrays, <A HREF="#@default158">6.4</A>, <A HREF="#@default1063">11.2.3</A>, <A HREF="#@default1287">12.2.4</A>
</LI><LI CLASS="li-indexenv">get, <A HREF="#@default192">6.4</A>, <A HREF="#@default227">6.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default973">10.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">get1, <A HREF="#@default185">6.4</A>, <A HREF="#@default222">6.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default970">10.4.3</A>, <A HREF="#@default975">10.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">get2, <A HREF="#@default186">6.4</A>, <A HREF="#@default223">6.4</A>
</LI><LI CLASS="li-indexenv">get3, <A HREF="#@default187">6.4</A>, <A HREF="#@default224">6.4</A>
</LI><LI CLASS="li-indexenv">get4, <A HREF="#@default188">6.4</A>, <A HREF="#@default225">6.4</A>
</LI><LI CLASS="li-indexenv">get5, <A HREF="#@default189">6.4</A>
</LI><LI CLASS="li-indexenv">get5-7, <A HREF="#@default226">6.4</A>
</LI><LI CLASS="li-indexenv">get6, <A HREF="#@default190">6.4</A>
</LI><LI CLASS="li-indexenv">get7, <A HREF="#@default191">6.4</A>
</LI><LI CLASS="li-indexenv">getClassInfo<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default853">10.3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">getName<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default855">10.3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">getURL, <A HREF="#@default1872">18.3.2</A>, <A HREF="#@default1877">18.4.2</A>
</LI><LI CLASS="li-indexenv">glue, <A HREF="#@default2085">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Hello World, <A HREF="#@default84">5</A>
</LI><LI CLASS="li-indexenv">HTML, <A HREF="#@default2086">D</A>
</LI><LI CLASS="li-indexenv">header files, <A HREF="#@default429">8.3.2</A>, <A HREF="#@default616">9.3.2</A>
</LI><LI CLASS="li-indexenv">hooks<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default884">10.3.6</A>, <A HREF="#@default982">10.4.5</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default472">8.3.7</A>, <A HREF="#@default558">8.4.5</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default660">9.3.7</A>, <A HREF="#@default745">9.4.5</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1359">12.3.6</A>, <A HREF="#@default1443">12.4.5</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1135">11.3.6</A>, <A HREF="#@default1224">11.4.5</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1571">13.3.8</A>, <A HREF="#@default1649">13.4.5</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1745">14.3.8</A>, <A HREF="#@default1822">14.4.6</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Impl files, <A HREF="#@default88">5.2.1</A>
</LI><LI CLASS="li-indexenv">InstanceRegistry, <A HREF="#@default1876">18.4.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
object name, <A HREF="#@default1878">18.4.2</A>
</LI><LI CLASS="li-indexenv">reference counting, <A HREF="#@default1879">18.4.2</A>
</LI><LI CLASS="li-indexenv">remove, <A HREF="#@default1881">18.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">IOR, <A HREF="#@default2101">D</A>
</LI><LI CLASS="li-indexenv">IOR files, <A HREF="#@default87">5.2.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default529">8.4</A>, <A HREF="#@default717">9.4</A>, <A HREF="#@default941">10.4</A>, <A HREF="#@default1192">11.4</A>, <A HREF="#@default1416">12.4</A>, <A HREF="#@default1628">13.4</A>, <A HREF="#@default1802">14.4</A>, <A HREF="#@default2087">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generate, <A HREF="#@default86">5.2.1</A>
</LI><LI CLASS="li-indexenv">generation, <A HREF="#@default531">8.4.1</A>, <A HREF="#@default719">9.4.1</A>, <A HREF="#@default943">10.4.1</A>, <A HREF="#@default1194">11.4.1</A>, <A HREF="#@default1418">12.4.1</A>, <A HREF="#@default1630">13.4.1</A>, <A HREF="#@default1804">14.4.1</A>
</LI><LI CLASS="li-indexenv">writing, <A HREF="#@default85">5.2.1</A>, <A HREF="#@default93">5.2.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation inheritance, <A HREF="#@default341">6.7</A>
</LI><LI CLASS="li-indexenv">implements, <A HREF="#@default343">6.7</A>, <A HREF="#@default2088">D</A>
</LI><LI CLASS="li-indexenv">implements-all, <A HREF="#@default347">6.7</A>, <A HREF="#@default2089">D</A>
</LI><LI CLASS="li-indexenv">import, <A HREF="#@default133">6.2</A>, <A HREF="#@default2090">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
error<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default1716">14.3.3</A>
</LI></UL>
</LI></UL>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">imports, <A HREF="#@default1544">13.3.3</A>, <A HREF="#@default1710">14.3.3</A>
</LI><LI CLASS="li-indexenv">in, <A HREF="#@default111">6.2</A>, <A HREF="#@default365">6.7</A>, <A HREF="#@default2091">D</A>
</LI><LI CLASS="li-indexenv">independent arrays, <A HREF="#@default2092">D</A>
</LI><LI CLASS="li-indexenv">inheritance, <A HREF="#@default2093">D</A>
</LI><LI CLASS="li-indexenv">inheritance example, <A HREF="#@default342">6.7</A>
</LI><LI CLASS="li-indexenv">inout, <A HREF="#@default113">6.2</A>, <A HREF="#@default367">6.7</A>, <A HREF="#@default2094">D</A>
</LI><LI CLASS="li-indexenv">install directory, <A HREF="#@default43">3.1.1</A>
</LI><LI CLASS="li-indexenv">installation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
Debian, <A HREF="#@default40">3.1</A>
</LI><LI CLASS="li-indexenv">RPMs, <A HREF="#@default39">3.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">instance method, <A HREF="#@default2095">D</A>
</LI><LI CLASS="li-indexenv">instantiation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default447">8.3.5</A>, <A HREF="#@default601">9.2.3</A>, <A HREF="#@default636">9.3.3</A>, <A HREF="#@default647">9.3.5</A>, <A HREF="#@default658">9.3.6</A>, <A HREF="#@default741">9.4.4</A>, <A HREF="#@default814">10.2.3</A>, <A HREF="#@default866">10.3.4</A>, <A HREF="#@default882">10.3.5</A>, <A HREF="#@default958">10.4.3</A>, <A HREF="#@default980">10.4.4</A>, <A HREF="#@default1099">11.3.2</A>, <A HREF="#@default1115">11.3.4</A>, <A HREF="#@default1131">11.3.5</A>, <A HREF="#@default1220">11.4.4</A>, <A HREF="#@default1323">12.3.2</A>, <A HREF="#@default1339">12.3.4</A>, <A HREF="#@default1355">12.3.5</A>, <A HREF="#@default1439">12.4.4</A>, <A HREF="#@default1526">13.2.4</A>, <A HREF="#@default1551">13.3.4</A>, <A HREF="#@default1553">13.3.4</A>, <A HREF="#@default1560">13.3.6</A>, <A HREF="#@default1646">13.4.4</A>, <A HREF="#@default1726">14.3.4</A>, <A HREF="#@default1734">14.3.6</A>, <A HREF="#@default1820">14.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">int, <A HREF="#@default389">8.2.3</A>, <A HREF="#@default570">9.2.3</A>, <A HREF="#@default762">10.2.3</A>, <A HREF="#@default1000">11.2.3</A>, <A HREF="#@default1244">12.2.4</A>, <A HREF="#@default1460">13.2.3</A>, <A HREF="#@default1676">14.2.3</A>, <A HREF="#@default2096">D</A>
</LI><LI CLASS="li-indexenv">int32_t, <A HREF="#@default2097">D</A>
</LI><LI CLASS="li-indexenv">int64_t, <A HREF="#@default2098">D</A>
</LI><LI CLASS="li-indexenv">interface, <A HREF="#@default401">8.2.3</A>, <A HREF="#@default582">9.2.3</A>, <A HREF="#@default774">10.2.3</A>, <A HREF="#@default788">10.2.3</A>, <A HREF="#@default1011">11.2.3</A>, <A HREF="#@default1028">11.2.3</A>, <A HREF="#@default1036">11.2.3</A>, <A HREF="#@default1255">12.2.4</A>, <A HREF="#@default1471">13.2.3</A>, <A HREF="#@default2099">D</A>
</LI><LI CLASS="li-indexenv">interface contracts, <A HREF="#@default12">2.2</A>, <A HREF="#@default125">6.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
class invariants, <A HREF="#@default33">2.3</A>, <A HREF="#@default277">6.5</A>, <A HREF="#@default286">6.5</A>
</LI><LI CLASS="li-indexenv">enforcement, <A HREF="#@default311">6.5</A>, <A HREF="#@default1999">21.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default890">10.3.7</A>, <A HREF="#@default912">10.3.7</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default478">8.3.8</A>, <A HREF="#@default502">8.3.8</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default666">9.3.8</A>, <A HREF="#@default690">9.3.8</A>
</LI><LI CLASS="li-indexenv">classification option, <A HREF="#@default2007">21.3.1</A>, <A HREF="#@default2009">21.3.1</A>
</LI><LI CLASS="li-indexenv">execution time estimates, <A HREF="#@default2027">21.3.2</A>, <A HREF="#@default2045">21.3.4</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1365">12.3.7</A>, <A HREF="#@default1387">12.3.7</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1141">11.3.7</A>, <A HREF="#@default1163">11.3.7</A>
</LI><LI CLASS="li-indexenv">fequency option, <A HREF="#@default2019">21.3.2</A>, <A HREF="#@default2021">21.3.2</A>
</LI><LI CLASS="li-indexenv">integration testing, <A HREF="#@default2013">21.3.1</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1576">13.3.9</A>, <A HREF="#@default1599">13.3.9</A>
</LI><LI CLASS="li-indexenv">options, <A HREF="#@default2005">21.3.1</A>, <A HREF="#@default2017">21.3.2</A>
</LI><LI CLASS="li-indexenv">overhead, <A HREF="#@default2023">21.3.2</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1750">14.3.9</A>, <A HREF="#@default1773">14.3.9</A>
</LI><LI CLASS="li-indexenv">policy, <A HREF="#@default2001">21.3</A>, <A HREF="#@default2003">21.3</A>
</LI><LI CLASS="li-indexenv">regression testing, <A HREF="#@default2015">21.3.1</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default313">6.5</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default315">6.5</A>
</LI><LI CLASS="li-indexenv">setPolicy, <A HREF="#@default2025">21.3.2</A>
</LI><LI CLASS="li-indexenv">statistics, <A HREF="#@default2033">21.3.3</A>, <A HREF="#@default2035">21.3.3</A>
</LI><LI CLASS="li-indexenv">trace level, <A HREF="#@default2043">21.3.4</A>
</LI><LI CLASS="li-indexenv">tracing, <A HREF="#@default2041">21.3.4</A>
</LI><LI CLASS="li-indexenv">unit testing, <A HREF="#@default2011">21.3.1</A>
</LI><LI CLASS="li-indexenv">vectUtils enforcement statistics, <A HREF="#@default2037">21.3.3</A>
</LI><LI CLASS="li-indexenv">vectUtils estimates, <A HREF="#@default2031">21.3.2</A>
</LI><LI CLASS="li-indexenv">vectUtils specification, <A HREF="#@default2029">21.3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">example<UL CLASS="indexenv"><LI CLASS="li-indexenv">
vuDot, <A HREF="#@default306">6.5</A>
</LI><LI CLASS="li-indexenv">vuSum, <A HREF="#@default486">8.3.8</A>, <A HREF="#@default674">9.3.8</A>, <A HREF="#@default898">10.3.7</A>, <A HREF="#@default1149">11.3.7</A>, <A HREF="#@default1373">12.3.7</A>, <A HREF="#@default1585">13.3.9</A>, <A HREF="#@default1759">14.3.9</A>, <A HREF="#@default1930">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">invariant clause, <A HREF="#@default35">2.3</A>
</LI><LI CLASS="li-indexenv">postcondition clause, <A HREF="#@default31">2.3</A>
</LI><LI CLASS="li-indexenv">postconditions, <A HREF="#@default29">2.3</A>, <A HREF="#@default274">6.5</A>, <A HREF="#@default283">6.5</A>, <A HREF="#@default483">8.3.8</A>, <A HREF="#@default671">9.3.8</A>, <A HREF="#@default895">10.3.7</A>, <A HREF="#@default1146">11.3.7</A>, <A HREF="#@default1370">12.3.7</A>, <A HREF="#@default1582">13.3.9</A>, <A HREF="#@default1756">14.3.9</A>, <A HREF="#@default1950">21.2.1</A>
</LI><LI CLASS="li-indexenv">precondition clause, <A HREF="#@default27">2.3</A>
</LI><LI CLASS="li-indexenv">preconditions, <A HREF="#@default25">2.3</A>, <A HREF="#@default271">6.5</A>, <A HREF="#@default280">6.5</A>, <A HREF="#@default480">8.3.8</A>, <A HREF="#@default668">9.3.8</A>, <A HREF="#@default892">10.3.7</A>, <A HREF="#@default1143">11.3.7</A>, <A HREF="#@default1367">12.3.7</A>, <A HREF="#@default1579">13.3.9</A>, <A HREF="#@default1753">14.3.9</A>, <A HREF="#@default1947">21.2.1</A>
</LI><LI CLASS="li-indexenv">SIDL, <A HREF="#@default22">2.3</A>, <A HREF="#@default269">6.5</A>, <A HREF="#@default1927">21</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
exceptions, <A HREF="#@default292">6.5</A>, <A HREF="#@default1991">21.2.3</A>
</LI><LI CLASS="li-indexenv">expressions, <A HREF="#@default1963">21.2.2</A>
</LI><LI CLASS="li-indexenv">functions, <A HREF="#@default1979">21.2.2</A>, <A HREF="#@default1981">21.2.2</A>, <A HREF="#@default1983">21.2.2</A>
</LI><LI CLASS="li-indexenv">inheritance, <A HREF="#@default1961">21.2.1</A>
</LI><LI CLASS="li-indexenv">method arguments, <A HREF="#@default1969">21.2.2</A>
</LI><LI CLASS="li-indexenv">method results, <A HREF="#@default1971">21.2.2</A>
</LI><LI CLASS="li-indexenv">operators, <A HREF="#@default1965">21.2.2</A>, <A HREF="#@default1967">21.2.2</A>
</LI><LI CLASS="li-indexenv">side effects, <A HREF="#@default1977">21.2.2</A>, <A HREF="#@default1985">21.2.2</A>, <A HREF="#@default1987">21.2.2</A>
</LI><LI CLASS="li-indexenv">special keywords, <A HREF="#@default1973">21.2.2</A>, <A HREF="#@default1975">21.2.2</A>
</LI><LI CLASS="li-indexenv">syntax, <A HREF="#@default290">6.5</A>, <A HREF="#@default303">6.5</A>, <A HREF="#@default1944">21.2.1</A>, <A HREF="#@default1955">21.2.1</A>, <A HREF="#@default1957">21.2.1</A>, <A HREF="#@default1959">21.2.1</A>
</LI><LI CLASS="li-indexenv">tracing, <A HREF="#@default2039">21.3.4</A>
</LI><LI CLASS="li-indexenv">violations, <A HREF="#@default1989">21.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">setEnforceAll<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default913">10.3.7</A>, <A HREF="#@default935">10.3.7</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default503">8.3.8</A>, <A HREF="#@default523">8.3.8</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default691">9.3.8</A>, <A HREF="#@default711">9.3.8</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1388">12.3.7</A>, <A HREF="#@default1410">12.3.7</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1164">11.3.7</A>, <A HREF="#@default1186">11.3.7</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1600">13.3.9</A>, <A HREF="#@default1620">13.3.9</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1774">14.3.9</A>, <A HREF="#@default1794">14.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">setEnforceNone<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default936">10.3.7</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default524">8.3.8</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default712">9.3.8</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1411">12.3.7</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1187">11.3.7</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1621">13.3.9</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1795">14.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">specifications, <A HREF="#@default1928">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interfaces, <A HREF="#@default105">6.2</A>, <A HREF="#@default334">6.7</A>, <A HREF="#@default1480">13.2.3</A>
</LI><LI CLASS="li-indexenv">interprocess, <A HREF="#@default2100">D</A>
</LI><LI CLASS="li-indexenv">is_null, <A HREF="#@default1068">11.2.3</A>, <A HREF="#@default1122">11.3.5</A>, <A HREF="#@default1292">12.2.4</A>, <A HREF="#@default1346">12.3.5</A>
</LI><LI CLASS="li-indexenv">isColumnOrder, <A HREF="#@default206">6.4</A>, <A HREF="#@default239">6.4</A>, <A HREF="#@default1066">11.2.3</A>, <A HREF="#@default1290">12.2.4</A>
</LI><LI CLASS="li-indexenv">isLocal, <A HREF="#@default1870">18.3.2</A>
</LI><LI CLASS="li-indexenv">isRemote, <A HREF="#@default1868">18.3.2</A>
</LI><LI CLASS="li-indexenv">isRowOrder, <A HREF="#@default207">6.4</A>, <A HREF="#@default240">6.4</A>, <A HREF="#@default1067">11.2.3</A>, <A HREF="#@default1291">12.2.4</A>
</LI><LI CLASS="li-indexenv">isSame<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default844">10.3.2</A>, <A HREF="#@default1105">11.3.2</A>, <A HREF="#@default1329">12.3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">isType<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default846">10.3.2</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default66">3.2.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
Array subclasses, <A HREF="#@default1506">13.2.3</A>
</LI><LI CLASS="li-indexenv">abstract classes, <A HREF="#@default1478">13.2.3</A>
</LI><LI CLASS="li-indexenv">array<UL CLASS="indexenv"><LI CLASS="li-indexenv">
constructor, <A HREF="#@default1510">13.2.3</A>, <A HREF="#@default1511">13.2.3</A>, <A HREF="#@default1512">13.2.3</A>, <A HREF="#@default1513">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">array dimensional cast, <A HREF="#@default1508">13.2.3</A>
</LI><LI CLASS="li-indexenv">arrays, <A HREF="#@default1497">13.2.3</A>
</LI><LI CLASS="li-indexenv">basic types, <A HREF="#@default1474">13.2.3</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default1532">13.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1629">13.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1633">13.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">borrow, <A HREF="#@default1504">13.2.3</A>
</LI><LI CLASS="li-indexenv">CLASSPATH, <A HREF="#@default1540">13.3.2</A>
</LI><LI CLASS="li-indexenv">cast, <A HREF="#@default1518">13.2.4</A>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default1516">13.2.4</A>
</LI><LI CLASS="li-indexenv">data type<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1496">13.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1490">13.2.3</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default1483">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default1458">13.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
abstract classes, <A HREF="#@default1477">13.2.3</A>
</LI><LI CLASS="li-indexenv">interfaces, <A HREF="#@default1475">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">ensure, <A HREF="#@default1503">13.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1491">13.2.3</A>
</LI><LI CLASS="li-indexenv">environment variables, <A HREF="#@default1536">13.3.2</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default1568">13.3.7</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default1484">13.2.3</A>, <A HREF="#@default1563">13.3.7</A>, <A HREF="#@default1640">13.4.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
getMessage, <A HREF="#@default1487">13.2.3</A>
</LI><LI CLASS="li-indexenv">runtime, <A HREF="#@default1488">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">execution environment, <A HREF="#@default1538">13.3.2</A>
</LI><LI CLASS="li-indexenv">first, <A HREF="#@default1505">13.2.3</A>
</LI><LI CLASS="li-indexenv">Holder, <A HREF="#@default1457">13.2.2</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default1570">13.3.8</A>, <A HREF="#@default1648">13.4.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default1650">13.4.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Impl Constructor, <A HREF="#@default1924">20.8</A>
</LI><LI CLASS="li-indexenv">implementation-side inheritance, <A HREF="#@default1634">13.4.2</A>
</LI><LI CLASS="li-indexenv">imports, <A HREF="#@default1543">13.3.3</A>
</LI><LI CLASS="li-indexenv">inout arguments, <A HREF="#@default1456">13.2.2</A>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default1577">13.3.9</A>, <A HREF="#@default1601">13.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default1602">13.3.9</A>, <A HREF="#@default1622">13.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default1623">13.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interfaces, <A HREF="#@default1476">13.2.3</A>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default1451">13.2.2</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default1449">13.2.1</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default1546">13.3.4</A>
</LI><LI CLASS="li-indexenv">out arguments, <A HREF="#@default1455">13.2.2</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default1556">13.3.6</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default1574">13.3.8</A>, <A HREF="#@default1653">13.4.5</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default1572">13.3.8</A>, <A HREF="#@default1651">13.4.5</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default1638">13.4.3</A>
</LI><LI CLASS="li-indexenv">reference counting, <A HREF="#@default1522">13.2.4</A>
</LI><LI CLASS="li-indexenv">runtime exceptions, <A HREF="#@default1489">13.2.3</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default1554">13.3.5</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default1515">13.2.4</A>
</LI><LI CLASS="li-indexenv">unavailable array methods, <A HREF="#@default1502">13.2.3</A>
</LI><LI CLASS="li-indexenv">underscores, <A HREF="#@default1507">13.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Java GetOpt, <A HREF="#@default59">3.2.1</A>
</LI><LI CLASS="li-indexenv">JavaCC, <A HREF="#@default76">3.2.4</A>
</LI><LI CLASS="li-indexenv">JNI, <A HREF="#@default2102">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">LD_LIBRARY_PATH, <A HREF="#@default1541">13.3.2</A>, <A HREF="#@default1707">14.3.2</A>
</LI><LI CLASS="li-indexenv">language interoperability, <A HREF="#@default2103">D</A>
</LI><LI CLASS="li-indexenv">length, <A HREF="#@default205">6.4</A>, <A HREF="#@default238">6.4</A>, <A HREF="#@default1073">11.2.3</A>, <A HREF="#@default1297">12.2.4</A>
</LI><LI CLASS="li-indexenv">library debugging, <A HREF="#@default1898">19.3.2</A>
</LI><LI CLASS="li-indexenv">library dependencies, <A HREF="#@default1893">19.2.2</A>
</LI><LI CLASS="li-indexenv">libtool, <A HREF="#@default50">3.1.2</A>, <A HREF="#@default74">3.2.4</A>
</LI><LI CLASS="li-indexenv">loader, <A HREF="#@default639">9.3.4</A>, <A HREF="#@default858">10.3.3</A>, <A HREF="#@default1107">11.3.3</A>, <A HREF="#@default1331">12.3.3</A>
</LI><LI CLASS="li-indexenv">local, <A HREF="#@default354">6.7</A>, <A HREF="#@default2104">D</A>
</LI><LI CLASS="li-indexenv">long, <A HREF="#@default390">8.2.3</A>, <A HREF="#@default571">9.2.3</A>, <A HREF="#@default763">10.2.3</A>, <A HREF="#@default1001">11.2.3</A>, <A HREF="#@default1245">12.2.4</A>, <A HREF="#@default1461">13.2.3</A>, <A HREF="#@default1671">14.2.3</A>, <A HREF="#@default2105">D</A>
</LI><LI CLASS="li-indexenv">lower, <A HREF="#@default202">6.4</A>, <A HREF="#@default235">6.4</A>, <A HREF="#@default1071">11.2.3</A>, <A HREF="#@default1295">12.2.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Makefile<UL CLASS="indexenv"><LI CLASS="li-indexenv">
server example, <A HREF="#@default92">5.2.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Makefile.am, <A HREF="#@default48">3.1.2</A>
</LI><LI CLASS="li-indexenv">Makefile.in, <A HREF="#@default46">3.1.2</A>
</LI><LI CLASS="li-indexenv">m4, <A HREF="#@default52">3.1.2</A>, <A HREF="#@default75">3.2.4</A>
</LI><LI CLASS="li-indexenv">make, <A HREF="#@default45">3.1.2</A>
</LI><LI CLASS="li-indexenv">make check, <A HREF="#@default53">3.1.3</A>
</LI><LI CLASS="li-indexenv">make install, <A HREF="#@default55">3.1.4</A>
</LI><LI CLASS="li-indexenv">make installcheck, <A HREF="#@default57">3.1.5</A>
</LI><LI CLASS="li-indexenv">malloc, <A HREF="#@default20">2.3</A>
</LI><LI CLASS="li-indexenv">memory allocations, <A HREF="#@default19">2.3</A>
</LI><LI CLASS="li-indexenv">method, <A HREF="#@default2106">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
object, <A HREF="#@default1722">14.3.4</A>
</LI><LI CLASS="li-indexenv">overloading, <A HREF="#@default444">8.3.5</A>, <A HREF="#@default644">9.3.5</A>, <A HREF="#@default863">10.3.4</A>, <A HREF="#@default1112">11.3.4</A>, <A HREF="#@default1336">12.3.4</A>, <A HREF="#@default1557">13.3.6</A>, <A HREF="#@default1731">14.3.6</A>
</LI><LI CLASS="li-indexenv">static, <A HREF="#@default442">8.3.4</A>, <A HREF="#@default638">9.3.4</A>, <A HREF="#@default857">10.3.3</A>, <A HREF="#@default1729">14.3.5</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">methods, <A HREF="#@default109">6.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
full name, <A HREF="#@default377">6.7</A>
</LI><LI CLASS="li-indexenv">identification, <A HREF="#@default373">6.7</A>
</LI><LI CLASS="li-indexenv">overloading, <A HREF="#@default369">6.7</A>
</LI><LI CLASS="li-indexenv">short name, <A HREF="#@default375">6.7</A>
</LI><LI CLASS="li-indexenv">signature, <A HREF="#@default372">6.7</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">mode, <A HREF="#@default110">6.2</A>, <A HREF="#@default364">6.7</A>
</LI><LI CLASS="li-indexenv">multi-CPU, <A HREF="#@default1839">18.1</A>
</LI><LI CLASS="li-indexenv">multiple inheritance, <A HREF="#@default340">6.7</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Native objects, <A HREF="#@default1904">20</A>
</LI><LI CLASS="li-indexenv">NumPy, <A HREF="#@default68">3.2.3</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default381">8.2.1</A>, <A HREF="#@default565">9.2.1</A>, <A HREF="#@default752">10.2.1</A>, <A HREF="#@default989">11.2.1</A>, <A HREF="#@default1231">12.2.1</A>, <A HREF="#@default1233">12.2.2</A>, <A HREF="#@default1450">13.2.1</A>, <A HREF="#@default1656">14.2.1</A>
</LI><LI CLASS="li-indexenv">namespace, <A HREF="#@default2107">D</A>
</LI><LI CLASS="li-indexenv">no_null, <A HREF="#@default1069">11.2.3</A>, <A HREF="#@default1293">12.2.4</A>
</LI><LI CLASS="li-indexenv">non-strided, <A HREF="#@default2109">D</A>
</LI><LI CLASS="li-indexenv">nonblocking, <A HREF="#@default360">6.7</A>, <A HREF="#@default2108">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
segmentation fault, <A HREF="#@default1888">18.5.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">not, <A HREF="#@default1123">11.3.5</A>, <A HREF="#@default1347">12.3.5</A>
</LI><LI CLASS="li-indexenv">not_null, <A HREF="#@default1084">11.2.4</A>, <A HREF="#@default1308">12.2.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default1133">11.3.5</A>, <A HREF="#@default1222">11.4.4</A>, <A HREF="#@default1357">12.3.5</A>, <A HREF="#@default1441">12.4.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">numeric types, <A HREF="#@default142">6.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Object model, <A HREF="#@default2110">D</A>
</LI><LI CLASS="li-indexenv">OMG, <A HREF="#@default2111">D</A>
</LI><LI CLASS="li-indexenv">object<UL CLASS="indexenv"><LI CLASS="li-indexenv">
state, <A HREF="#@default1910">20</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">object data, <A HREF="#@default1911">20</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default435">8.3.3</A>, <A HREF="#@default627">9.3.3</A>, <A HREF="#@default839">10.3.2</A>, <A HREF="#@default1091">11.3.2</A>, <A HREF="#@default1315">12.3.2</A>, <A HREF="#@default1547">13.3.4</A>, <A HREF="#@default1721">14.3.4</A>
</LI><LI CLASS="li-indexenv">object model, <A HREF="#@default329">6.7</A>
</LI><LI CLASS="li-indexenv">object ownership rules, <A HREF="#@default332">6.7</A>
</LI><LI CLASS="li-indexenv">oneway, <A HREF="#@default357">6.7</A>, <A HREF="#@default1885">18.5</A>, <A HREF="#@default2112">D</A>
</LI><LI CLASS="li-indexenv">opaque, <A HREF="#@default146">6.3</A>, <A HREF="#@default399">8.2.3</A>, <A HREF="#@default580">9.2.3</A>, <A HREF="#@default772">10.2.3</A>, <A HREF="#@default787">10.2.3</A>, <A HREF="#@default1010">11.2.3</A>, <A HREF="#@default1024">11.2.3</A>, <A HREF="#@default1034">11.2.3</A>, <A HREF="#@default1254">12.2.4</A>, <A HREF="#@default1470">13.2.3</A>, <A HREF="#@default2113">D</A>
</LI><LI CLASS="li-indexenv">out, <A HREF="#@default112">6.2</A>, <A HREF="#@default366">6.7</A>, <A HREF="#@default2114">D</A>
</LI><LI CLASS="li-indexenv">overloading, <A HREF="#@default370">6.7</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default449">8.3.5</A>, <A HREF="#@default649">9.3.5</A>, <A HREF="#@default868">10.3.4</A>, <A HREF="#@default1117">11.3.4</A>, <A HREF="#@default1341">12.3.4</A>, <A HREF="#@default1562">13.3.6</A>, <A HREF="#@default1736">14.3.6</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">PIC, <A HREF="#@default1897">19.3.1</A>, <A HREF="#@default2119">D</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default67">3.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default171">6.4</A>, <A HREF="#@default1685">14.2.3</A>
</LI><LI CLASS="li-indexenv">bindings<UL CLASS="indexenv"><LI CLASS="li-indexenv">
generation<UL CLASS="indexenv"><LI CLASS="li-indexenv">
client, <A HREF="#@default1698">14.3.1</A>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1803">14.4.1</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">implementation, <A HREF="#@default1807">14.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">casting, <A HREF="#@default1693">14.2.4</A>
</LI><LI CLASS="li-indexenv">common problems, <A HREF="#@default1712">14.3.3</A>
</LI><LI CLASS="li-indexenv">data types, <A HREF="#@default1666">14.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
arrays, <A HREF="#@default1684">14.2.3</A>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1680">14.2.3</A>
</LI><LI CLASS="li-indexenv">int, <A HREF="#@default1673">14.2.3</A>
</LI><LI CLASS="li-indexenv">long, <A HREF="#@default1668">14.2.3</A>
</LI><LI CLASS="li-indexenv">opaque, <A HREF="#@default1690">14.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default1681">14.2.3</A>
</LI><LI CLASS="li-indexenv">environment variables, <A HREF="#@default1702">14.3.2</A>
</LI><LI CLASS="li-indexenv">exception handling, <A HREF="#@default1743">14.3.7</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default1677">14.2.3</A>, <A HREF="#@default1737">14.3.7</A>, <A HREF="#@default1814">14.4.5</A>
</LI><LI CLASS="li-indexenv">execution environment, <A HREF="#@default1704">14.3.2</A>
</LI><LI CLASS="li-indexenv">extension modules, <A HREF="#@default1811">14.4.3</A>
</LI><LI CLASS="li-indexenv">extra out argument, <A HREF="#@default1738">14.3.7</A>
</LI><LI CLASS="li-indexenv">hooks, <A HREF="#@default1744">14.3.8</A>, <A HREF="#@default1821">14.4.6</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
implementation, <A HREF="#@default1823">14.4.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Impl Constructor, <A HREF="#@default1925">20.9</A>
</LI><LI CLASS="li-indexenv">imports, <A HREF="#@default1709">14.3.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
problems, <A HREF="#@default1713">14.3.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">int, <A HREF="#@default1674">14.2.3</A>
</LI><LI CLASS="li-indexenv">interface contracts<UL CLASS="indexenv"><LI CLASS="li-indexenv">
enforcement, <A HREF="#@default1751">14.3.9</A>, <A HREF="#@default1775">14.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default1776">14.3.9</A>, <A HREF="#@default1796">14.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default1797">14.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">long, <A HREF="#@default1669">14.2.3</A>
</LI><LI CLASS="li-indexenv">method signatures, <A HREF="#@default1658">14.2.2</A>
</LI><LI CLASS="li-indexenv">NumPy, <A HREF="#@default69">3.2.3</A>
</LI><LI CLASS="li-indexenv">name space, <A HREF="#@default1655">14.2.1</A>
</LI><LI CLASS="li-indexenv">object management, <A HREF="#@default1720">14.3.4</A>
</LI><LI CLASS="li-indexenv">object methods, <A HREF="#@default1723">14.3.4</A>
</LI><LI CLASS="li-indexenv">overloaded methods, <A HREF="#@default1730">14.3.6</A>
</LI><LI CLASS="li-indexenv">PYTHONPATH, <A HREF="#@default1706">14.3.2</A>
</LI><LI CLASS="li-indexenv">post-methods, <A HREF="#@default1748">14.3.8</A>, <A HREF="#@default1826">14.4.6</A>
</LI><LI CLASS="li-indexenv">pre-methods, <A HREF="#@default1746">14.3.8</A>, <A HREF="#@default1824">14.4.6</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default1812">14.4.4</A>
</LI><LI CLASS="li-indexenv">return values, <A HREF="#@default1661">14.2.2</A>, <A HREF="#@default1663">14.2.2</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default1728">14.3.5</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default1692">14.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Python Meta Widgets, <A HREF="#@default70">3.2.3</A>
</LI><LI CLASS="li-indexenv">package, <A HREF="#@default100">6.2</A>, <A HREF="#@default2115">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
final, <A HREF="#@default102">6.2</A>
</LI><LI CLASS="li-indexenv">fully scoped, <A HREF="#@default132">6.2</A>
</LI><LI CLASS="li-indexenv">import, <A HREF="#@default134">6.2</A>
</LI><LI CLASS="li-indexenv">nesting, <A HREF="#@default131">6.2</A>
</LI><LI CLASS="li-indexenv">re-entrant, <A HREF="#@default138">6.2</A>
</LI><LI CLASS="li-indexenv">versions, <A HREF="#@default129">6.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">packObj, <A HREF="#@default1862">18.2.4</A>
</LI><LI CLASS="li-indexenv">parallel processing, <A HREF="#@default1838">18.1</A>
</LI><LI CLASS="li-indexenv">parameter passing conventions, <A HREF="#@default333">6.7</A>
</LI><LI CLASS="li-indexenv">pass-by-copy, <A HREF="#@default1859">18.2.4</A>, <A HREF="#@default2116">D</A>
</LI><LI CLASS="li-indexenv">pass-by-reference, <A HREF="#@default2117">D</A>
</LI><LI CLASS="li-indexenv">pass-by-value, <A HREF="#@default2118">D</A>
</LI><LI CLASS="li-indexenv">perl, <A HREF="#@default51">3.1.2</A>, <A HREF="#@default79">3.2.4</A>
</LI><LI CLASS="li-indexenv">pointer, <A HREF="#@default400">8.2.3</A>, <A HREF="#@default581">9.2.3</A>, <A HREF="#@default773">10.2.3</A>, <A HREF="#@default786">10.2.3</A>
</LI><LI CLASS="li-indexenv">pointer types, <A HREF="#@default1022">11.2.3</A>, <A HREF="#@default1266">12.2.4</A>
</LI><LI CLASS="li-indexenv">port, <A HREF="#@default1854">18.2.3</A>
</LI><LI CLASS="li-indexenv">post-methods<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default888">10.3.6</A>, <A HREF="#@default987">10.4.5</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default476">8.3.7</A>, <A HREF="#@default563">8.4.5</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default664">9.3.7</A>, <A HREF="#@default750">9.4.5</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1363">12.3.6</A>, <A HREF="#@default1448">12.4.5</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1139">11.3.6</A>, <A HREF="#@default1229">11.4.5</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1575">13.3.8</A>, <A HREF="#@default1654">13.4.5</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1749">14.3.8</A>, <A HREF="#@default1827">14.4.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">postconditions, <A HREF="#@default30">2.3</A>, <A HREF="#@default275">6.5</A>, <A HREF="#@default284">6.5</A>, <A HREF="#@default484">8.3.8</A>, <A HREF="#@default672">9.3.8</A>, <A HREF="#@default896">10.3.7</A>, <A HREF="#@default1147">11.3.7</A>, <A HREF="#@default1371">12.3.7</A>, <A HREF="#@default1583">13.3.9</A>, <A HREF="#@default1757">14.3.9</A>, <A HREF="#@default1951">21.2.1</A>
</LI><LI CLASS="li-indexenv">pre-methods<UL CLASS="indexenv"><LI CLASS="li-indexenv">
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, <A HREF="#@default886">10.3.6</A>, <A HREF="#@default985">10.4.5</A>
</LI><LI CLASS="li-indexenv">C, <A HREF="#@default474">8.3.7</A>, <A HREF="#@default561">8.4.5</A>
</LI><LI CLASS="li-indexenv">C++, <A HREF="#@default662">9.3.7</A>, <A HREF="#@default748">9.4.5</A>
</LI><LI CLASS="li-indexenv">Fortran 2003/2008, <A HREF="#@default1361">12.3.6</A>, <A HREF="#@default1446">12.4.5</A>
</LI><LI CLASS="li-indexenv">Fortran 90/95, <A HREF="#@default1137">11.3.6</A>, <A HREF="#@default1227">11.4.5</A>
</LI><LI CLASS="li-indexenv">Java, <A HREF="#@default1573">13.3.8</A>, <A HREF="#@default1652">13.4.5</A>
</LI><LI CLASS="li-indexenv">Python, <A HREF="#@default1747">14.3.8</A>, <A HREF="#@default1825">14.4.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">preconditions, <A HREF="#@default26">2.3</A>, <A HREF="#@default272">6.5</A>, <A HREF="#@default281">6.5</A>, <A HREF="#@default481">8.3.8</A>, <A HREF="#@default669">9.3.8</A>, <A HREF="#@default893">10.3.7</A>, <A HREF="#@default1144">11.3.7</A>, <A HREF="#@default1368">12.3.7</A>, <A HREF="#@default1580">13.3.9</A>, <A HREF="#@default1754">14.3.9</A>, <A HREF="#@default1948">21.2.1</A>
</LI><LI CLASS="li-indexenv">preinitilized data, <A HREF="#@default1907">20</A>
</LI><LI CLASS="li-indexenv">preprocessing, <A HREF="#@default2120">D</A>
</LI><LI CLASS="li-indexenv">private data, <A HREF="#@default540">8.4.3</A>, <A HREF="#@default727">9.4.3</A>, <A HREF="#@default950">10.4.3</A>, <A HREF="#@default1201">11.4.3</A>, <A HREF="#@default1425">12.4.3</A>, <A HREF="#@default1639">13.4.3</A>, <A HREF="#@default1813">14.4.4</A>, <A HREF="#@default2121">D</A>
</LI><LI CLASS="li-indexenv">process, <A HREF="#@default2122">D</A>
</LI><LI CLASS="li-indexenv">protocol, <A HREF="#@default1866">18.3.1</A>, <A HREF="#@default2123">D</A>
</LI><LI CLASS="li-indexenv">pthreads, <A HREF="#@default71">3.2.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">RarrayElem2, <A HREF="#@default417">8.2.3</A>, <A HREF="#@default538">8.4.2</A>
</LI><LI CLASS="li-indexenv">Remote Method Invocation, <A HREF="#@default2125">D</A>
</LI><LI CLASS="li-indexenv">RMI, <A HREF="#@default2127">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
addProtocol, <A HREF="#@default1865">18.3.1</A>
</LI><LI CLASS="li-indexenv">array behavior, <A HREF="#@default1856">18.2.4</A>
</LI><LI CLASS="li-indexenv">cast, <A HREF="#@default1864">18.2.5</A>
</LI><LI CLASS="li-indexenv">connect, <A HREF="#@default1850">18.2.3</A>
</LI><LI CLASS="li-indexenv">create, <A HREF="#@default1853">18.2.3</A>
</LI><LI CLASS="li-indexenv">getURL, <A HREF="#@default1871">18.3.2</A>
</LI><LI CLASS="li-indexenv">Introduction, <A HREF="#@default1836">18.1</A>
</LI><LI CLASS="li-indexenv">isLocal, <A HREF="#@default1869">18.3.2</A>
</LI><LI CLASS="li-indexenv">isRemote, <A HREF="#@default1867">18.3.2</A>
</LI><LI CLASS="li-indexenv">local, <A HREF="#@default356">6.7</A>
</LI><LI CLASS="li-indexenv">nonblocking, <A HREF="#@default362">6.7</A>, <A HREF="#@default1882">18.5</A>
</LI><LI CLASS="li-indexenv">object, <A HREF="#@default1857">18.2.4</A>
</LI><LI CLASS="li-indexenv">oneway, <A HREF="#@default359">6.7</A>, <A HREF="#@default1884">18.5</A>
</LI><LI CLASS="li-indexenv">pass-by-reference, <A HREF="#@default1858">18.2.4</A>
</LI><LI CLASS="li-indexenv">port, <A HREF="#@default1855">18.2.3</A>
</LI><LI CLASS="li-indexenv">protocol, <A HREF="#@default1844">18.2.1</A>
</LI><LI CLASS="li-indexenv">Simple Protocol, <A HREF="#@default1847">18.2.1</A>
</LI><LI CLASS="li-indexenv">serialization, <A HREF="#@default1861">18.2.4</A>
</LI><LI CLASS="li-indexenv">Ticket, <A HREF="#@default1886">18.5</A>
</LI><LI CLASS="li-indexenv">TicketBook, <A HREF="#@default1890">18.5.3</A>
</LI><LI CLASS="li-indexenv">URL, <A HREF="#@default1849">18.2.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">RPC, <A HREF="#@default1837">18.1</A>, <A HREF="#@default2128">D</A>
</LI><LI CLASS="li-indexenv">r-arrays, <A HREF="#@default161">6.4</A>, <A HREF="#@default416">8.2.3</A>, <A HREF="#@default595">9.2.3</A>, <A HREF="#@default808">10.2.3</A>, <A HREF="#@default1077">11.2.3</A>, <A HREF="#@default1301">12.2.4</A>, <A HREF="#@default1501">13.2.3</A>, <A HREF="#@default1665">14.2.2</A>, <A HREF="#@default1689">14.2.3</A>
</LI><LI CLASS="li-indexenv">re-entrant, <A HREF="#@default101">6.2</A>, <A HREF="#@default137">6.2</A>
</LI><LI CLASS="li-indexenv">reference counting, <A HREF="#@default18">2.3</A>, <A HREF="#@default422">8.2.4</A>, <A HREF="#@default438">8.3.3</A>, <A HREF="#@default628">9.3.3</A>, <A HREF="#@default840">10.3.2</A>, <A HREF="#@default1092">11.3.2</A>, <A HREF="#@default1316">12.3.2</A>, <A HREF="#@default1548">13.3.4</A>, <A HREF="#@default2124">D</A>
</LI><LI CLASS="li-indexenv">regression tests, <A HREF="#@default54">3.1.3</A>
</LI><LI CLASS="li-indexenv">restrict, <A HREF="#@default135">6.2</A>
</LI><LI CLASS="li-indexenv">reverse engineering, <A HREF="#@default36">2.4</A>, <A HREF="#@default2126">D</A>
</LI><LI CLASS="li-indexenv">row-major order, <A HREF="#@default154">6.4</A>
</LI><LI CLASS="li-indexenv">rst2man, <A HREF="#@default78">3.2.4</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">ServerInfo, <A HREF="#@default1875">18.4.1</A>
</LI><LI CLASS="li-indexenv">ServerRegistry, <A HREF="#@default1874">18.4.1</A>
</LI><LI CLASS="li-indexenv">SIDL, <A HREF="#@default9">2.2</A>, <A HREF="#@default96">6.2</A>, <A HREF="#@default2132">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
abstract classes, <A HREF="#@default339">6.7</A>
</LI><LI CLASS="li-indexenv">BaseClass, <A HREF="#@default322">6.6</A>
</LI><LI CLASS="li-indexenv">BaseException, <A HREF="#@default326">6.6</A>
</LI><LI CLASS="li-indexenv">BaseInterface, <A HREF="#@default320">6.6</A>, <A HREF="#@default324">6.6</A>
</LI><LI CLASS="li-indexenv">BNF, <A HREF="#@default2049">B.2</A>
</LI><LI CLASS="li-indexenv">class invariants, <A HREF="#@default1954">21.2.1</A>
</LI><LI CLASS="li-indexenv">classes, <A HREF="#@default106">6.2</A>, <A HREF="#@default337">6.7</A>
</LI><LI CLASS="li-indexenv">comments, <A HREF="#@default126">6.2</A>
</LI><LI CLASS="li-indexenv">data, <A HREF="#@default97">6.2</A>
</LI><LI CLASS="li-indexenv">data
types, <A HREF="#@default14">2.2</A>
</LI><LI CLASS="li-indexenv">ensure, <A HREF="#@default289">6.5</A>, <A HREF="#@default301">6.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default309">6.5</A>, <A HREF="#@default490">8.3.8</A>, <A HREF="#@default678">9.3.8</A>, <A HREF="#@default902">10.3.7</A>, <A HREF="#@default1153">11.3.7</A>, <A HREF="#@default1377">12.3.7</A>, <A HREF="#@default1589">13.3.9</A>, <A HREF="#@default1763">14.3.9</A>, <A HREF="#@default1934">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">enumerations, <A HREF="#@default149">6.3</A>
</LI><LI CLASS="li-indexenv">example<UL CLASS="indexenv"><LI CLASS="li-indexenv">
vuDot, <A HREF="#@default307">6.5</A>
</LI><LI CLASS="li-indexenv">vuSum, <A HREF="#@default488">8.3.8</A>, <A HREF="#@default676">9.3.8</A>, <A HREF="#@default900">10.3.7</A>, <A HREF="#@default1151">11.3.7</A>, <A HREF="#@default1375">12.3.7</A>, <A HREF="#@default1587">13.3.9</A>, <A HREF="#@default1761">14.3.9</A>, <A HREF="#@default1932">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default117">6.2</A>
</LI><LI CLASS="li-indexenv">extends, <A HREF="#@default346">6.7</A>
</LI><LI CLASS="li-indexenv">final, <A HREF="#@default351">6.7</A>
</LI><LI CLASS="li-indexenv">Generated code, <A HREF="#@default1828">15.3</A>
</LI><LI CLASS="li-indexenv">generate SIDL, <A HREF="#@default1829">15.5</A>
</LI><LI CLASS="li-indexenv">implements, <A HREF="#@default344">6.7</A>
</LI><LI CLASS="li-indexenv">implements-all, <A HREF="#@default348">6.7</A>
</LI><LI CLASS="li-indexenv">inheritance, <A HREF="#@default318">6.6</A>
</LI><LI CLASS="li-indexenv">interface contracts, <A HREF="#@default21">2.3</A>, <A HREF="#@default124">6.2</A>, <A HREF="#@default268">6.5</A>, <A HREF="#@default1926">21</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
class invariants, <A HREF="#@default32">2.3</A>, <A HREF="#@default276">6.5</A>, <A HREF="#@default285">6.5</A>, <A HREF="#@default1952">21.2.1</A>
</LI><LI CLASS="li-indexenv">classification option, <A HREF="#@default2008">21.3.1</A>, <A HREF="#@default2010">21.3.1</A>
</LI><LI CLASS="li-indexenv">clauses, <A HREF="#@default23">2.3</A>
</LI><LI CLASS="li-indexenv">enforcement, <A HREF="#@default312">6.5</A>, <A HREF="#@default479">8.3.8</A>, <A HREF="#@default667">9.3.8</A>, <A HREF="#@default891">10.3.7</A>, <A HREF="#@default1142">11.3.7</A>, <A HREF="#@default1366">12.3.7</A>, <A HREF="#@default1578">13.3.9</A>, <A HREF="#@default1752">14.3.9</A>, <A HREF="#@default2000">21.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
overhead, <A HREF="#@default2024">21.3.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">enforcement options, <A HREF="#@default2006">21.3.1</A>, <A HREF="#@default2018">21.3.2</A>
</LI><LI CLASS="li-indexenv">enforcement policy, <A HREF="#@default2002">21.3</A>, <A HREF="#@default2004">21.3</A>
</LI><LI CLASS="li-indexenv">enforcement statistics, <A HREF="#@default2034">21.3.3</A>, <A HREF="#@default2036">21.3.3</A>
</LI><LI CLASS="li-indexenv">enforcement trace level, <A HREF="#@default2044">21.3.4</A>
</LI><LI CLASS="li-indexenv">enforcement tracing, <A HREF="#@default2042">21.3.4</A>
</LI><LI CLASS="li-indexenv">exceptions, <A HREF="#@default293">6.5</A>, <A HREF="#@default1992">21.2.3</A>
</LI><LI CLASS="li-indexenv">execution time estimates, <A HREF="#@default2028">21.3.2</A>, <A HREF="#@default2046">21.3.4</A>
</LI><LI CLASS="li-indexenv">expressions, <A HREF="#@default1964">21.2.2</A>
</LI><LI CLASS="li-indexenv">frequency option, <A HREF="#@default2020">21.3.2</A>, <A HREF="#@default2022">21.3.2</A>
</LI><LI CLASS="li-indexenv">functions, <A HREF="#@default1980">21.2.2</A>, <A HREF="#@default1982">21.2.2</A>, <A HREF="#@default1984">21.2.2</A>
</LI><LI CLASS="li-indexenv">inheritance, <A HREF="#@default1962">21.2.1</A>
</LI><LI CLASS="li-indexenv">integration testing, <A HREF="#@default2014">21.3.1</A>
</LI><LI CLASS="li-indexenv">method arguments, <A HREF="#@default1970">21.2.2</A>
</LI><LI CLASS="li-indexenv">method results, <A HREF="#@default1972">21.2.2</A>
</LI><LI CLASS="li-indexenv">operators, <A HREF="#@default1966">21.2.2</A>, <A HREF="#@default1968">21.2.2</A>
</LI><LI CLASS="li-indexenv">postconditions, <A HREF="#@default28">2.3</A>, <A HREF="#@default273">6.5</A>, <A HREF="#@default282">6.5</A>, <A HREF="#@default485">8.3.8</A>, <A HREF="#@default673">9.3.8</A>, <A HREF="#@default897">10.3.7</A>, <A HREF="#@default1148">11.3.7</A>, <A HREF="#@default1372">12.3.7</A>, <A HREF="#@default1584">13.3.9</A>, <A HREF="#@default1758">14.3.9</A>, <A HREF="#@default1949">21.2.1</A>
</LI><LI CLASS="li-indexenv">preconditions, <A HREF="#@default24">2.3</A>, <A HREF="#@default270">6.5</A>, <A HREF="#@default279">6.5</A>, <A HREF="#@default482">8.3.8</A>, <A HREF="#@default670">9.3.8</A>, <A HREF="#@default894">10.3.7</A>, <A HREF="#@default1145">11.3.7</A>, <A HREF="#@default1369">12.3.7</A>, <A HREF="#@default1581">13.3.9</A>, <A HREF="#@default1755">14.3.9</A>, <A HREF="#@default1946">21.2.1</A>
</LI><LI CLASS="li-indexenv">regression testing, <A HREF="#@default2016">21.3.1</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default314">6.5</A>, <A HREF="#@default518">8.3.8</A>, <A HREF="#@default525">8.3.8</A>, <A HREF="#@default706">9.3.8</A>, <A HREF="#@default714">9.3.8</A>, <A HREF="#@default930">10.3.7</A>, <A HREF="#@default938">10.3.7</A>, <A HREF="#@default1181">11.3.7</A>, <A HREF="#@default1189">11.3.7</A>, <A HREF="#@default1405">12.3.7</A>, <A HREF="#@default1413">12.3.7</A>, <A HREF="#@default1617">13.3.9</A>, <A HREF="#@default1625">13.3.9</A>, <A HREF="#@default1791">14.3.9</A>, <A HREF="#@default1799">14.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default316">6.5</A>, <A HREF="#@default527">8.3.8</A>, <A HREF="#@default716">9.3.8</A>, <A HREF="#@default940">10.3.7</A>, <A HREF="#@default1191">11.3.7</A>, <A HREF="#@default1415">12.3.7</A>, <A HREF="#@default1627">13.3.9</A>, <A HREF="#@default1801">14.3.9</A>
</LI><LI CLASS="li-indexenv">setPolicy, <A HREF="#@default2026">21.3.2</A>
</LI><LI CLASS="li-indexenv">side effects, <A HREF="#@default1978">21.2.2</A>, <A HREF="#@default1986">21.2.2</A>, <A HREF="#@default1988">21.2.2</A>
</LI><LI CLASS="li-indexenv">special keywords, <A HREF="#@default1974">21.2.2</A>, <A HREF="#@default1976">21.2.2</A>
</LI><LI CLASS="li-indexenv">specifications, <A HREF="#@default1929">21.2</A>
</LI><LI CLASS="li-indexenv">syntax, <A HREF="#@default291">6.5</A>, <A HREF="#@default304">6.5</A>, <A HREF="#@default1945">21.2.1</A>, <A HREF="#@default1956">21.2.1</A>, <A HREF="#@default1958">21.2.1</A>, <A HREF="#@default1960">21.2.1</A>
</LI><LI CLASS="li-indexenv">tracing, <A HREF="#@default2040">21.3.4</A>
</LI><LI CLASS="li-indexenv">unit testing, <A HREF="#@default2012">21.3.1</A>
</LI><LI CLASS="li-indexenv">vectUtils enforcement statistics, <A HREF="#@default2038">21.3.3</A>
</LI><LI CLASS="li-indexenv">vectUtils estimates, <A HREF="#@default2032">21.3.2</A>
</LI><LI CLASS="li-indexenv">vectUtils specification, <A HREF="#@default2030">21.3.2</A>
</LI><LI CLASS="li-indexenv">violations, <A HREF="#@default1990">21.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">interfaces, <A HREF="#@default104">6.2</A>, <A HREF="#@default335">6.7</A>
</LI><LI CLASS="li-indexenv">invariants, <A HREF="#@default302">6.5</A>
</LI><LI CLASS="li-indexenv">local, <A HREF="#@default355">6.7</A>
</LI><LI CLASS="li-indexenv">methods, <A HREF="#@default108">6.2</A>
</LI><LI CLASS="li-indexenv">nonblocking, <A HREF="#@default361">6.7</A>
</LI><LI CLASS="li-indexenv">numeric types, <A HREF="#@default143">6.3</A>
</LI><LI CLASS="li-indexenv">object model, <A HREF="#@default330">6.7</A>
</LI><LI CLASS="li-indexenv">object orientated, <A HREF="#@default13">2.2</A>
</LI><LI CLASS="li-indexenv">oneway, <A HREF="#@default358">6.7</A>
</LI><LI CLASS="li-indexenv">opaque, <A HREF="#@default147">6.3</A>
</LI><LI CLASS="li-indexenv">packages, <A HREF="#@default99">6.2</A>
</LI><LI CLASS="li-indexenv">parsing errors, <A HREF="#@default2047">22.2</A>
</LI><LI CLASS="li-indexenv">parsing warnings, <A HREF="#@default2048">22.3</A>
</LI><LI CLASS="li-indexenv">postconditions<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default494">8.3.8</A>, <A HREF="#@default682">9.3.8</A>, <A HREF="#@default906">10.3.7</A>, <A HREF="#@default1157">11.3.7</A>, <A HREF="#@default1381">12.3.7</A>, <A HREF="#@default1593">13.3.9</A>, <A HREF="#@default1767">14.3.9</A>, <A HREF="#@default1938">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">preconditions<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default493">8.3.8</A>, <A HREF="#@default681">9.3.8</A>, <A HREF="#@default905">10.3.7</A>, <A HREF="#@default1156">11.3.7</A>, <A HREF="#@default1380">12.3.7</A>, <A HREF="#@default1592">13.3.9</A>, <A HREF="#@default1766">14.3.9</A>, <A HREF="#@default1937">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">Runtime Library, <A HREF="#@default317">6.6</A>
</LI><LI CLASS="li-indexenv">require, <A HREF="#@default288">6.5</A>, <A HREF="#@default300">6.5</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default308">6.5</A>, <A HREF="#@default489">8.3.8</A>, <A HREF="#@default677">9.3.8</A>, <A HREF="#@default901">10.3.7</A>, <A HREF="#@default1152">11.3.7</A>, <A HREF="#@default1376">12.3.7</A>, <A HREF="#@default1588">13.3.9</A>, <A HREF="#@default1762">14.3.9</A>, <A HREF="#@default1933">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">SIDLException, <A HREF="#@default328">6.6</A>
</LI><LI CLASS="li-indexenv">setEnforceAll, <A HREF="#@default526">8.3.8</A>, <A HREF="#@default713">9.3.8</A>, <A HREF="#@default937">10.3.7</A>, <A HREF="#@default1188">11.3.7</A>, <A HREF="#@default1412">12.3.7</A>, <A HREF="#@default1624">13.3.9</A>, <A HREF="#@default1798">14.3.9</A>
</LI><LI CLASS="li-indexenv">setEnforceNone, <A HREF="#@default528">8.3.8</A>, <A HREF="#@default715">9.3.8</A>, <A HREF="#@default939">10.3.7</A>, <A HREF="#@default1190">11.3.7</A>, <A HREF="#@default1414">12.3.7</A>, <A HREF="#@default1626">13.3.9</A>, <A HREF="#@default1800">14.3.9</A>
</LI><LI CLASS="li-indexenv">static, <A HREF="#@default353">6.7</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default145">6.3</A>
</LI><LI CLASS="li-indexenv">structure, <A HREF="#@default98">6.2</A>
</LI><LI CLASS="li-indexenv">types, <A HREF="#@default122">6.2</A>, <A HREF="#@default141">6.3</A>
</LI><LI CLASS="li-indexenv">versions, <A HREF="#@default128">6.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">SIDL_CATCH, <A HREF="#@default458">8.3.6</A>, <A HREF="#@default470">8.3.6</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default466">8.3.6</A>, <A HREF="#@default516">8.3.8</A>, <A HREF="#@default704">9.3.8</A>, <A HREF="#@default928">10.3.7</A>, <A HREF="#@default1179">11.3.7</A>, <A HREF="#@default1403">12.3.7</A>, <A HREF="#@default1615">13.3.9</A>, <A HREF="#@default1789">14.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">SIDL_CHECK, <A HREF="#@default450">8.3.5</A>, <A HREF="#@default457">8.3.6</A>, <A HREF="#@default469">8.3.6</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default517">8.3.8</A>, <A HREF="#@default705">9.3.8</A>, <A HREF="#@default929">10.3.7</A>, <A HREF="#@default1180">11.3.7</A>, <A HREF="#@default1404">12.3.7</A>, <A HREF="#@default1616">13.3.9</A>, <A HREF="#@default1790">14.3.9</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">SIDL_CLEAR, <A HREF="#@default459">8.3.6</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default468">8.3.6</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">SIDL_DLL_PATH, <A HREF="#@default1542">13.3.2</A>, <A HREF="#@default1708">14.3.2</A>
</LI><LI CLASS="li-indexenv">SIDL_THROW, <A HREF="#@default551">8.4.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default556">8.4.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">SIDLException, <A HREF="#@default121">6.2</A>
</LI><LI CLASS="li-indexenv">Simple Protocol, <A HREF="#@default1846">18.2.1</A>
</LI><LI CLASS="li-indexenv">Skel files, <A HREF="#@default89">5.2.1</A>
</LI><LI CLASS="li-indexenv">SO, <A HREF="#@default2135">D</A>
</LI><LI CLASS="li-indexenv">SPMD, <A HREF="#@default2136">D</A>
</LI><LI CLASS="li-indexenv">SWIG, <A HREF="#@default7">2.1</A>, <A HREF="#@default2142">D</A>
</LI><LI CLASS="li-indexenv">serialization, <A HREF="#@default1860">18.2.4</A>, <A HREF="#@default2129">D</A>
</LI><LI CLASS="li-indexenv">set, <A HREF="#@default200">6.4</A>, <A HREF="#@default233">6.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default818">10.2.3</A>, <A HREF="#@default1528">13.2.4</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">set1, <A HREF="#@default193">6.4</A>, <A HREF="#@default228">6.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default820">10.2.3</A>, <A HREF="#@default960">10.4.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">set2, <A HREF="#@default194">6.4</A>, <A HREF="#@default229">6.4</A>
</LI><LI CLASS="li-indexenv">set3, <A HREF="#@default195">6.4</A>, <A HREF="#@default230">6.4</A>
</LI><LI CLASS="li-indexenv">set4, <A HREF="#@default196">6.4</A>, <A HREF="#@default231">6.4</A>
</LI><LI CLASS="li-indexenv">set5, <A HREF="#@default197">6.4</A>
</LI><LI CLASS="li-indexenv">set5-7, <A HREF="#@default232">6.4</A>
</LI><LI CLASS="li-indexenv">set6, <A HREF="#@default198">6.4</A>
</LI><LI CLASS="li-indexenv">set7, <A HREF="#@default199">6.4</A>
</LI><LI CLASS="li-indexenv">set_null, <A HREF="#@default1070">11.2.3</A>, <A HREF="#@default1294">12.2.4</A>
</LI><LI CLASS="li-indexenv">shared libraries, <A HREF="#@default37">2.4</A>, <A HREF="#@default1901">19.4</A>
</LI><LI CLASS="li-indexenv">shared library, <A HREF="#@default2130">D</A>
</LI><LI CLASS="li-indexenv">short name, <A HREF="#@default374">6.7</A>, <A HREF="#@default2131">D</A>
</LI><LI CLASS="li-indexenv">sidl.BaseClass, <A HREF="#@default321">6.6</A>
</LI><LI CLASS="li-indexenv">sidl.BaseException, <A HREF="#@default118">6.2</A>, <A HREF="#@default325">6.6</A>
</LI><LI CLASS="li-indexenv">sidl.BaseInterface, <A HREF="#@default319">6.6</A>, <A HREF="#@default323">6.6</A>
</LI><LI CLASS="li-indexenv">sidl.InvViolation, <A HREF="#@default299">6.5</A>, <A HREF="#@default1998">21.2.3</A>
</LI><LI CLASS="li-indexenv">sidl.PostViolation, <A HREF="#@default298">6.5</A>, <A HREF="#@default1997">21.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default499">8.3.8</A>, <A HREF="#@default513">8.3.8</A>, <A HREF="#@default687">9.3.8</A>, <A HREF="#@default701">9.3.8</A>, <A HREF="#@default911">10.3.7</A>, <A HREF="#@default925">10.3.7</A>, <A HREF="#@default1162">11.3.7</A>, <A HREF="#@default1176">11.3.7</A>, <A HREF="#@default1386">12.3.7</A>, <A HREF="#@default1400">12.3.7</A>, <A HREF="#@default1598">13.3.9</A>, <A HREF="#@default1612">13.3.9</A>, <A HREF="#@default1772">14.3.9</A>, <A HREF="#@default1786">14.3.9</A>, <A HREF="#@default1943">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">sidl.PreViolation, <A HREF="#@default297">6.5</A>, <A HREF="#@default1996">21.2.3</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default498">8.3.8</A>, <A HREF="#@default512">8.3.8</A>, <A HREF="#@default686">9.3.8</A>, <A HREF="#@default700">9.3.8</A>, <A HREF="#@default910">10.3.7</A>, <A HREF="#@default924">10.3.7</A>, <A HREF="#@default1161">11.3.7</A>, <A HREF="#@default1175">11.3.7</A>, <A HREF="#@default1385">12.3.7</A>, <A HREF="#@default1399">12.3.7</A>, <A HREF="#@default1597">13.3.9</A>, <A HREF="#@default1611">13.3.9</A>, <A HREF="#@default1771">14.3.9</A>, <A HREF="#@default1785">14.3.9</A>, <A HREF="#@default1942">21.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">sidl.RuntimeException, <A HREF="#@default114">6.2</A>
</LI><LI CLASS="li-indexenv">sidl.SIDLException, <A HREF="#@default120">6.2</A>, <A HREF="#@default327">6.6</A>, <A HREF="#@default990">11.2.1</A>, <A HREF="#@default1234">12.2.2</A>
</LI><LI CLASS="li-indexenv">sidl_header.h, <A HREF="#@default433">8.3.2</A>
</LI><LI CLASS="li-indexenv">sidl_ucxx.hh, <A HREF="#@default596">9.2.3</A>, <A HREF="#@default604">9.2.3</A>, <A HREF="#@default617">9.3.2</A>
</LI><LI CLASS="li-indexenv">sidlArrayAddr, <A HREF="#@default264">6.4</A>
</LI><LI CLASS="li-indexenv">sidlArrayDim, <A HREF="#@default252">6.4</A>
</LI><LI CLASS="li-indexenv">sidlArrayElem, <A HREF="#@default262">6.4</A>
</LI><LI CLASS="li-indexenv">sidlLength, <A HREF="#@default258">6.4</A>
</LI><LI CLASS="li-indexenv">sidlLower, <A HREF="#@default254">6.4</A>
</LI><LI CLASS="li-indexenv">sidlStride, <A HREF="#@default260">6.4</A>
</LI><LI CLASS="li-indexenv">sidlUpper, <A HREF="#@default256">6.4</A>
</LI><LI CLASS="li-indexenv">sidlx, <A HREF="#@default1845">18.2.1</A>
</LI><LI CLASS="li-indexenv">signature, <A HREF="#@default371">6.7</A>
</LI><LI CLASS="li-indexenv">single process, <A HREF="#@default2133">D</A>
</LI><LI CLASS="li-indexenv">skeleton, <A HREF="#@default2134">D</A>
</LI><LI CLASS="li-indexenv">slice, <A HREF="#@default180">6.4</A>, <A HREF="#@default217">6.4</A>
</LI><LI CLASS="li-indexenv">smartCopy, <A HREF="#@default182">6.4</A>, <A HREF="#@default219">6.4</A>, <A HREF="#@default1075">11.2.3</A>, <A HREF="#@default1299">12.2.4</A>
</LI><LI CLASS="li-indexenv">smartcopy, <A HREF="#@default166">6.4</A>
</LI><LI CLASS="li-indexenv">splicer blocks, <A HREF="#@default91">5.2.1</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default536">8.4.2</A>, <A HREF="#@default724">9.4.2</A>, <A HREF="#@default948">10.4.2</A>, <A HREF="#@default1199">11.4.2</A>, <A HREF="#@default1423">12.4.2</A>, <A HREF="#@default1637">13.4.2</A>, <A HREF="#@default1810">14.4.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">state, <A HREF="#@default2137">D</A>
</LI><LI CLASS="li-indexenv">static, <A HREF="#@default352">6.7</A>, <A HREF="#@default2138">D</A>
</LI><LI CLASS="li-indexenv">static linking, <A HREF="#@default2139">D</A>
</LI><LI CLASS="li-indexenv">static methods, <A HREF="#@default1555">13.3.5</A>
</LI><LI CLASS="li-indexenv">stride, <A HREF="#@default204">6.4</A>, <A HREF="#@default237">6.4</A>, <A HREF="#@default823">10.2.3</A>, <A HREF="#@default1061">11.2.3</A>, <A HREF="#@default1074">11.2.3</A>, <A HREF="#@default1285">12.2.4</A>, <A HREF="#@default1298">12.2.4</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example, <A HREF="#@default822">10.2.3</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">string, <A HREF="#@default395">8.2.3</A>, <A HREF="#@default576">9.2.3</A>, <A HREF="#@default768">10.2.3</A>, <A HREF="#@default781">10.2.3</A>, <A HREF="#@default1006">11.2.3</A>, <A HREF="#@default1250">12.2.4</A>, <A HREF="#@default1466">13.2.3</A>, <A HREF="#@default2140">D</A>
</LI><LI CLASS="li-indexenv">strings, <A HREF="#@default144">6.3</A>, <A HREF="#@default1017">11.2.3</A>, <A HREF="#@default1261">12.2.4</A>
</LI><LI CLASS="li-indexenv">stub, <A HREF="#@default2141">D</A>
</LI><LI CLASS="li-indexenv">stub files, <A HREF="#@default90">5.2.1</A>
</LI><LI CLASS="li-indexenv">swallows<UL CLASS="indexenv"><LI CLASS="li-indexenv">
unladen, <A HREF="#@default961">10.4.3</A>
</LI></UL>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Ticket, <A HREF="#@default1887">18.5</A>
</LI><LI CLASS="li-indexenv">TicketBook, <A HREF="#@default1889">18.5.3</A>
</LI><LI CLASS="li-indexenv">tarball, <A HREF="#@default2143">D</A>
</LI><LI CLASS="li-indexenv">throw, <A HREF="#@default116">6.2</A>
</LI><LI CLASS="li-indexenv">throws, <A HREF="#@default2144">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
example<UL CLASS="indexenv"><LI CLASS="li-indexenv">
vuDot, <A HREF="#@default310">6.5</A>
</LI><LI CLASS="li-indexenv">vuSum, <A HREF="#@default495">8.3.8</A>, <A HREF="#@default683">9.3.8</A>, <A HREF="#@default907">10.3.7</A>, <A HREF="#@default1158">11.3.7</A>, <A HREF="#@default1382">12.3.7</A>, <A HREF="#@default1594">13.3.9</A>, <A HREF="#@default1768">14.3.9</A>, <A HREF="#@default1939">21.2</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-indexenv">type, <A HREF="#@default2145">D</A>
</LI><LI CLASS="li-indexenv">type casting, <A HREF="#@default420">8.2.4</A>, <A HREF="#@default609">9.2.4</A>, <A HREF="#@default632">9.3.3</A>, <A HREF="#@default828">10.2.4</A>, <A HREF="#@default1082">11.2.4</A>, <A HREF="#@default1306">12.2.5</A>, <A HREF="#@default1517">13.2.4</A>, <A HREF="#@default1694">14.2.4</A>
</LI><LI CLASS="li-indexenv">type repositories, <A HREF="#@default379">6.8</A>
</LI><LI CLASS="li-indexenv">types, <A HREF="#@default123">6.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Unix shell &amp; bintools, <A HREF="#@default63">3.2.2</A>
</LI><LI CLASS="li-indexenv">URL, <A HREF="#@default2146">D</A>
</LI><LI CLASS="li-indexenv">unpackObj, <A HREF="#@default1863">18.2.4</A>
</LI><LI CLASS="li-indexenv">upper, <A HREF="#@default203">6.4</A>, <A HREF="#@default236">6.4</A>, <A HREF="#@default1072">11.2.3</A>, <A HREF="#@default1296">12.2.4</A>
</LI><LI CLASS="li-indexenv">user, <A HREF="#@default17">2.3</A>, <A HREF="#@default2147">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">VM, <A HREF="#@default2150">D</A>
</LI><LI CLASS="li-indexenv">VPATH, <A HREF="#@default2152">D</A>
</LI><LI CLASS="li-indexenv">VPATH builds, <A HREF="#@default42">3.1.1</A>, <A HREF="#@default2153">D</A>
</LI><LI CLASS="li-indexenv">version, <A HREF="#@default2148">D</A>
</LI><LI CLASS="li-indexenv">versions, <A HREF="#@default130">6.2</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
restrict, <A HREF="#@default136">6.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">virtual, <A HREF="#@default2149">D</A>
</LI><LI CLASS="li-indexenv">virtual methods, <A HREF="#@default349">6.7</A>
</LI><LI CLASS="li-indexenv">void, <A HREF="#@default2151">D</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Web Services, <A HREF="#@default1842">18.2</A>
</LI><LI CLASS="li-indexenv">wrap, <A HREF="#@default1906">20</A>
</LI><LI CLASS="li-indexenv">wrapObj, <A HREF="#@default1905">20</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Xerces-J, <A HREF="#@default60">3.2.1</A>
</LI><LI CLASS="li-indexenv">XML, <A HREF="#@default378">6.8</A>, <A HREF="#@default2154">D</A>
<UL CLASS="indexenv"><LI CLASS="li-indexenv">
basic structure, <A HREF="#@default1831">16.3</A>
</LI><LI CLASS="li-indexenv">classes, <A HREF="#@default1834">16.3</A>
</LI><LI CLASS="li-indexenv">DTD, <A HREF="#@default2050">C.2</A>
</LI><LI CLASS="li-indexenv">generation, <A HREF="#@default1835">16.4</A>
</LI><LI CLASS="li-indexenv">interfaces, <A HREF="#@default1833">16.3</A>
</LI><LI CLASS="li-indexenv">packages, <A HREF="#@default1832">16.3</A>
</LI><LI CLASS="li-indexenv">purpose, <A HREF="#@default1830">16.2</A>
</LI></UL>
</LI><LI CLASS="li-indexenv">XML parser<UL CLASS="indexenv"><LI CLASS="li-indexenv">
Java, <A HREF="#@default61">3.2.1</A>
</LI></UL>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://hevea.inria.fr/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.</EM></BLOCKQUOTE></BODY>
</HTML>
