<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="index.css">
<TITLE>SIDL Basics</TITLE>
</HEAD>
<BODY >
<A HREF="index007.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index009.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc21">Chapter 6</A>  SIDL Basics</H1><UL>
<LI><A HREF="index008.html#toc22">Introduction</A>
</LI><LI><A HREF="index008.html#toc23">SIDL Files</A>
</LI><LI><A HREF="index008.html#toc24">Fundamental Types</A>
</LI><LI><A HREF="index008.html#toc25">Arrays</A>
</LI><LI><A HREF="index008.html#toc26">Interface Contracts</A>
</LI><LI><A HREF="index008.html#toc27">SIDL Runtime</A>
</LI><LI><A HREF="index008.html#toc28">Objects</A>
</LI><LI><A HREF="index008.html#toc29">XML Repositories</A>
</LI></UL>
<P><A NAME="c:basics"></A></P><P><BR>
</P><H2 CLASS="section"><A NAME="toc22"></A><A NAME="htoc22">6.1</A>  Introduction</H2><P>
This chapter describes the basics of the Scientific Interface Definition 
Language (SIDL). The goal is to provide sufficient information to enable 
most library and component developers to begin using SIDL to wrap 
their software. It begins with an overview of SIDL files followed by an 
introduction to the fundamental data types. More complex topics such as
the object arrays, exceptions, objects, and the XML repository are then 
addressed.</P><H2 CLASS="section"><A NAME="toc23"></A><A NAME="htoc23">6.2</A>  SIDL Files</H2><P><A NAME="s:basics_sidl"></A><A NAME="@default96"></A></P><P>SIDL files are human-readable, language- and platform- independent
interface specifications for objects and their methods. SIDL allows
you to specify classes, interfaces, and the methods therein. All
methods defined in SIDL are public, since the developer is writing
them as part of an interface description. Any data you wish a SIDL
object to hold is not declared in the SIDL file, and is
private.<A NAME="@default97"></A> Data should be placed in the implementation
skeleton files, and cannot be publicly exported.</P><P>Babel reads the SIDL files to generate the appropriate programming language 
bindings. These bindings, in the form of stub, intermediate object 
representation (IOR), and implementation skeleton sources, provide the basis 
for language interoperable software using Babel. In addition, SIDL files
are used to populate the XML symbol repository that can serve as an 
alternate source of interface specifications during the generation of 
programming language bindings.</P><H3 CLASS="subsection">Basic Structure</H3><P><A NAME="@default98"></A></P><P>The basic structure of a SIDL file is illustrated below.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> &lt;identifier&gt; [<B>version</B> &lt;<B>version</B>&gt;]
{
  <B>interface</B> &lt;identifier&gt; [ &lt;inheritance&gt; ]
  {
    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]

      .
      .
      .


    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]
  }


  <B>class</B> &lt;identifier&gt; [ &lt;inheritance&gt; ]
  {
    [&lt;type&gt;] &lt;identifier&gt; (&lt;parameters&gt;) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]
      .
      .
      .


    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [<B>throws</B> &lt;exception&gt;];
      [<B>require</B> &lt;contract-clause&gt;]
      [<B>ensure</B> &lt;contract-clause&gt;]
  }


  <B>package</B> &lt;identifier&gt; [<B>version</B> &lt;<B>version</B>&gt;]
  {
      .
      .
      .
  }
}</I></FONT></TD></TR>
</TABLE><P>The main elements are <EM>packages</EM>, <EM>interfaces</EM>, <EM>classes</EM>, 
<EM>methods</EM>, <EM>types</EM>, and <EM>contract clauses</EM>. For a more 
detailed description, refer to Appendix <A HREF="index027.html#c:grammar">B</A>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Packages</B></DT><DD CLASS="dd-description"><A NAME="@default99"></A><A NAME="@default100"></A>provide a mechanism for specifying name space hierarchies. 
That is, it enables grouping sets of interface and/or class descriptions as 
well as nested packages. Identified by the <EM>package</EM> keyword, packages 
have a <EM>scoped</EM> name that consists of one or more identifiers, or name 
strings, separated by a period (“.”). A package can contain multiple 
interfaces, classes and nested packages. By default, packages are now 
re-entrant<A NAME="@default101"></A>. In order to make them non-re-entrant, they must be declared as
<FONT COLOR=maroon><I><TT>final</TT></I></FONT>.<A NAME="@default102"></A><A NAME="@default103"></A></DD><DT CLASS="dt-description"><B>Interfaces</B></DT><DD CLASS="dd-description"> <A NAME="@default104"></A><A NAME="@default105"></A>define a set of methods that a caller can invoke on an 
object of a class that implements the methods. Multiple inheritance of 
interfaces is supported, which means an interface or a class can be derived from one 
or more interfaces. </DD><DT CLASS="dt-description"><B>Classes</B></DT><DD CLASS="dd-description"> <A NAME="@default106"></A><A NAME="@default107"></A> also define a set of methods that a caller can invoke on an 
object. A class can extend only one other class but it can implement multiple
interfaces. So we have single inheritance of classes and multiple inheritance 
of interfaces.</DD><DT CLASS="dt-description"><B>Methods</B></DT><DD CLASS="dd-description"> <A NAME="@default108"></A><A NAME="@default109"></A> define services
that are available for invocation by a caller. The signature of the
method consists of the return <EM>type</EM>, identifier, arguments, and
exceptions. Each parameter has a <EM>type</EM> and a
<EM>mode</EM><A NAME="@default110"></A>. The <EM>mode</EM> indicates whether the value
of the specified <EM>type</EM> is passed from caller to callee
(<EM>in</EM><A NAME="@default111"></A>), from callee to caller (<EM>out</EM><A NAME="@default112"></A>),
or both (<EM>inout</EM><A NAME="@default113"></A>). All methods are implicitly
capable of throwing a <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT> exception.
<A NAME="@default114"></A><A NAME="@default115"></A>
A <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT> is used to indicate an error
in the Babel generated code or potentially a network exception. Each
additional exception that a method can <EM>throw</EM><A NAME="@default116"></A> when
it detects an error must be listed. These exceptions can be either
interfaces or classes so long as they inherit
from<A NAME="@default117"></A>
<FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT><A NAME="@default118"></A><A NAME="@default119"></A>.
For a default implementation of the exception interfaces, the
exception classes should extend
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT><A NAME="@default120"></A><A NAME="@default121"></A>.
Methods and parameter passing modes are discussed in greater detail in
Section <A HREF="#sec:basics:objects:methods">6.7</A>.</DD><DT CLASS="dt-description"><B>Types</B></DT><DD CLASS="dd-description"> <A NAME="@default122"></A><A NAME="@default123"></A> are used to constrain the the values of parameters, exceptions, 
and return values associated with methods. SIDL supports basic types such as
<FONT COLOR=maroon><I><TT>int</TT></I></FONT>, <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, and <FONT COLOR=maroon><I><TT>long</TT></I></FONT> as well as strings, complex
numbers, classes, and arrays.</DD><DT CLASS="dt-description"><B>Contract clauses</B></DT><DD CLASS="dd-description"> 
<A NAME="@default124"></A><A NAME="@default125"></A> are used 
to define properties that must hold before and/or after method invocation.</DD></DL><H3 CLASS="subsection">Comments and Doc-Comments</H3><P><A NAME="@default126"></A><A NAME="@default127"></A></P><P>SIDL has the same commenting style as C++/Java
and even has a special documentation comment
(so called <EM>doc-comment</EM>) similar to those
used in Javadoc. 
One can embed comments anywhere in their SIDL file. 
Documentation comments should immediately precede
the class, interface, or method with which they are associated.
Babel replicates documentation comments in the files it generates.
It does not replicate plain comments.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/*
 *  1. This is a multi-line comment.
 *
 */

//  2. This comment fits entirely on a single line.

/*  3. This comment can fill less than a line. */

/** 4. This is a documentation comment. */

/**
 *  5. Documentation comments can span
 *     multiple lines without the beginning
 *     space-asterisk-space combinations
 *     getting in the way.
 */</I></FONT></TD></TR>
</TABLE><P>Consider the above SIDL file fragment. 
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
This comment is a regular multi-line comment that is
delimited by a slash-star , star-slash 
	(“<TT>/*</TT>”, “<TT>*/</TT>”) pair.
</LI><LI CLASS="li-enumerate">This is a single-line comment that starts 
	with a double slash “<TT>//</TT>” and continues 
	to the end of the line.
</LI><LI CLASS="li-enumerate">This comment is the same as # 1 except that it
	is completely contained on a single line. It can
	be embedded in the middle of a line anywhere 
	a space naturally occurs.
</LI><LI CLASS="li-enumerate">This is a documentation comment. In keeping with
	Javadoc, Doc++, and other tools, it is delimited by
	slash-star-star and star-slash 
	(“<TT>/**</TT>”, “<TT>*/</TT>”) combinations.
	Documentation comments are important because their
	contents are preserved by Babel in the corresponding
	generated files. Doc-comments must directly
	precede the interface, class, or method that they
	document.
</LI><LI CLASS="li-enumerate">This is a multi-line variant of a doc-comment. Note
	that initial asterisks on a line are assumed to
	be for human readers only and are discarded by
	Babel when it reads in the text. The multi-line
	doc-comment is the preferred way of documenting
	SIDL.
</LI></OL><H3 CLASS="subsection">Packages and Versions</H3><P><A NAME="@default128"></A><A NAME="@default129"></A><A NAME="@default130"></A></P><P>SIDL has both a packaging and versioning mechanism built in. 
Packages are essentially named scopes, serving a similar function
as Java packages or C++ namespaces. Versions
are decimal separated integer values where it is assumed
larger numbers imply more recent versions. All classes 
and interfaces in that package get that same 
version number. If subpackages are specified, they can have their own version 
number assigned. If a package is declared without a version, it can only 
contain other packages. If a package declares interfaces or classes,
a version number for that package is required.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg {

}</I></FONT></TD></TR>
</TABLE><P>
This SIDL file represents the minimum needed for each and every SIDL
file. The package statement defines a scope where all
classes within the package must reside. Since no version clause is included, 
the version number defaults to 0.</P><P>Packages can be nested.<A NAME="@default131"></A> This is shown in the example below. The version 
numbers assigned to all the types is determined by the package, or subpackage, 
in which it resides. In the design of the SIDL file, remember that
some languages get very long function names from excessively nested packages
or excessively long package names.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg <B>version</B> 1.0 {

  <B>package</B> thisIsAReallyLongPackageName {
  }

  <B>package</B> this <B>version</B> 0.6 {
    <B>package</B> is {
      <B>package</B> a {
        <B>package</B> really {
          <B>package</B> deeply <B>version</B> 0.4 {
            <B>package</B> nested {
              <B>package</B> packageName <B>version</B> 0.1 {
              }
            }
          }
        }
      }
    }
  }
}</I></FONT></TD></TR>
</TABLE><P>In SIDL you can use as much or as little of a type name as necessary 
to uniquely identify it. If absolute specificity is required, a leading
dot can be used to identify the global (top) package.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"> <FONT COLOR=maroon><I>   1 <B>package</B> foo {
    2   <B>class</B> A {}
    3   <B>package</B> foo {
    4     <B>class</B> A {
    5       foo.A bar();  //which foo.A?
    6       .foo.A wuux(); //first foo.A.
    7       .foo.foo.A wuxx(); //second foo.A.
    8     }
    9   }
   10 }</I></FONT></TD></TR>
</TABLE><P>External types can be expressed in one of two ways. The fully
scoped<A NAME="@default132"></A>
external type can be used anywhere in the class description. Alternatively, 
an <FONT COLOR=maroon><I><TT>import</TT></I></FONT><A NAME="@default133"></A><A NAME="@default134"></A> statement can be used to put the type in the local
package-space. <FONT COLOR=maroon><I><TT>import</TT></I></FONT> statements can request a specific
version of the package, if that version is not found, Babel will print
an error. If no version is specified, Babel will take whatever
version it is being run on. Babel can not be run on two versions of
a given package at the same time, even if you only import or require
one of them. </P><P>Another way to restrict the package version you use is the
<FONT COLOR=maroon><I><TT>restrict</TT></I></FONT><A NAME="@default135"></A><A NAME="@default136"></A> statement.
<FONT COLOR=maroon><I><TT>restrict</TT></I></FONT> does not import the package, but if you do later
import the package or refer to something in that package by it’s fully
scoped name, Babel will guarantee that the correct version of the
package will be used. Also note that all restrict statements must
come before the first import statement.</P><P>Below is a sample SIDL file, that should help bring all of these concepts
together.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>require</B> pkgC <B>version</B> 2.0; // restrict pkgC to version 2.0, not imported

<B>import</B> pkgA <B>version</B> 1.0; // restrict pkgA version 1.0. Includes class pkgA.A

<B>import</B> pkgB;      // import pkgB regaurdless of version.  Includes class pkgB.B

<B>package</B> mypkg <B>version</B> 2.0 {
  <B>class</B> foo {
    setA( A ); // imported from pkgA, must be pkgA.A-v1.0
    setB( B ); // imported from pkgB, must be pkgB.B, no version restriction
    setC( pkgC.C ); // must be pkgC.C-v2.0
    setD( pkgD.D ); // no version restriction
  }
}</I></FONT></TD></TR>
</TABLE><H3 CLASS="subsection">Re-entrant Packages</H3><P><A NAME="@default137"></A><A NAME="@default138"></A></P><P>By default, SIDL packages are re-entrant. This means that Babel allows sub-packages to be 
broken into separate files, but you’d still have to run Babel on 
all the files at the same time. Here’s how it works.</P><P>First define the outermost package in a file.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg <B>version</B> 2.0 {

}</I></FONT></TD></TR>
</TABLE><P>Then define a sub-package in a second file.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> mypkg.subpkg <B>version</B> 2.0 {

}</I></FONT></TD></TR>
</TABLE><P>Note that both files begin with the identical version statement.
Now as long as you run Babel on both SIDL files at the same time
(with the outermost one first on the commandline), all is fine.</P><P>This works because the package statement takes a scoped identifier
as an argument. As long as Babel knows that a package <FONT COLOR=maroon><I><TT>mypkg</TT></I></FONT>
exists, it can handle a new package called <FONT COLOR=maroon><I><TT>subpkg</TT></I></FONT>. (This would
also work if <FONT COLOR=maroon><I><TT>subpkg</TT></I></FONT> were a class. Version 
statements require an identifier for the outermost package. Since
packages cannot have dots “.” in their names, the only dots in 
version statements should appear at the numbers, not the package names.</P><P>Running the second file without the first will (and should) generate
an error since the enclosing package was not declared. Re-entrance 
should be used judiciously. This feature may be disabled by labeling
a given package as <FONT COLOR=maroon><I><TT>final</TT></I></FONT>.</P><H3 CLASS="subsection">The From Clause</H3><P><A NAME="@default139"></A></P><P>The from clause is a special SIDL statement that allows an implementor
of multiple interfaces to add or rename the extensions of conflicting
methods from interfaces. However, only method extensions
can be changed, and the methods must have different signatures. For
example, one can change the name of conflicting methods from two interfaces:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>interface</B> A {
  <B>void</B> set(<B>in int</B> i);
}
<B>interface</B> B{
  <B>void</B> set(<B>in float</B> i);
}
<B>class</B> C <B>implements</B> A, B {
  <B>void</B> set[Int](<B>in int</B> i) from A.set;
  <B>void</B> set[Float](<B>in float</B> i) from B.set;
}</I></FONT></TD></TR>
</TABLE><P>Or change the name of an interface method that conflicts with your
inherited class methods:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>interface</B> A {
  <B>void</B> set(<B>in int</B> i);
}
<B>class</B> B {
  <B>void</B> set(<B>in float</B> i);
}
<B>class</B> C <B>extends</B> B <B>implements</B> A  {
  <B>void</B> set[Int](<B>in int</B> i) from A.set;
  <B>void</B> set(<B>in float</B> i); //Cannot use the from clause on class methods
}</I></FONT></TD></TR>
</TABLE><P>But it doesn’t work for methods that have the same signature:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/* X THIS WILL NOT COMPILE X */

<B>interface</B> A {
  <B>void</B> set(<B>in int</B> i);
}
<B>interface</B> B{
  <B>void</B> set(<B>in int</B> i);
}
<B>class</B> C <B>implements</B> A, B {
  <B>void</B> set[A](<B>in int</B> i) from A.set; //ERROR
  <B>void</B> set[B](<B>in int</B> i) from B.set; //signature conflict
}

/* X THIS WILL NOT COMPILE X */</I></FONT></TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc24"></A><A NAME="htoc24">6.3</A>  Fundamental Types</H2><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 6.1: SIDL Types</TD></TR>
</TABLE></DIV><A NAME="tbl:basics:fundamental_types"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><B>SIDL TYPE</B></TD><TD ALIGN=right NOWRAP><B>SIZE (BITS)</B></TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>bool</TT></I></FONT></TD><TD ALIGN=right NOWRAP>1</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>char</TT></I></FONT></TD><TD ALIGN=right NOWRAP>8</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>int</TT></I></FONT></TD><TD ALIGN=right NOWRAP>32</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>long</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>float</TT></I></FONT></TD><TD ALIGN=right NOWRAP>32</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=right NOWRAP>128</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>opaque</TT></I></FONT></TD><TD ALIGN=right NOWRAP>64</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>enum</TT></I></FONT></TD><TD ALIGN=right NOWRAP>32</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>interface</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>class</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>array&lt;Type,Dim&gt;</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>array&lt; &gt;</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
<TR><TD ALIGN=left NOWRAP><FONT COLOR=maroon><I><TT>rarray&lt;Type,Dim&gt;(index variables)</TT></I></FONT></TD><TD ALIGN=right NOWRAP>varies</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Table <A HREF="#tbl:basics:fundamental_types">6.1</A><A NAME="@default140"></A><A NAME="@default141"></A> briefly 
shows the different data types that are supported 
in Babel. Refer to each chapter for the language specific bindings
for each SIDL type. The “S” in SIDL stands for 
“Scientific.” This emphasis is reflected in the
fundamental support for complex numbers (<FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>
and <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>) and dynamic multidimensional arrays
(<FONT COLOR=maroon><I><TT>array&lt;Type,Dim&gt;</TT></I></FONT>).</P><P>C++ developers looking at the SIDL syntax for arrays, 
might think that SIDL is a templated IDL, but this
is not so. Although the syntax for SIDL arrays looks
like a template, it is specific only to the array type.
Developers cannot create templated classes or methods
in SIDL.
</P><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
Although C++ templates are a very powerful programming 
mechanism, they apply only to C++. For Babel to implement
similar hashing routines, method names in languages other
than C++ would become prohibitively (thousands of characters) 
long. Moreover, this C++ template hashing mechanism is
compiler specific so while C++ is very good at hiding
the expanded template names (unless there is an error to report)
we would have to add babel C++ bindings on a compiler by compiler basis.
</EM></BLOCKQUOTE><P>Discussion of the various types is broken up into sections.
Numeric types such as <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, <FONT COLOR=maroon><I><TT>char</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>long</TT></I></FONT>, <FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT>, <FONT COLOR=maroon><I><TT>string</TT></I></FONT>s, as well as information about
enumerated types and the opaque type are all covered in this Subsection <A HREF="#ssec:basics:fundamental:numbers">6.3</A>.</P><P>Information about extended types such as
Interfaces and Classes along with the methods they contain are described in Section <A HREF="#sec:basics:objects">6.7</A>, and Section <A HREF="#s:arrays">6.4</A> covers Array.</P><H3 CLASS="subsection">Numeric Types</H3><P><A NAME="ssec:basics:fundamental:numbers"></A>
<A NAME="@default142"></A><A NAME="@default143"></A></P><P>The SIDL types <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, <FONT COLOR=maroon><I><TT>char</TT></I></FONT>, <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>long</TT></I></FONT>, <FONT COLOR=maroon><I><TT>float</TT></I></FONT>, <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT>, 
and <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT> are the smallest and easiest data
types to transfer between languages transparently.
They all have a fixed size and can just as 
reasonably be copied as passed by reference.</P><P>Most languages natively support all of these data types
(though perhaps less so with complex types). There are 
a few notable exceptions that may be of interest. </P><P>ANSI C does not define the size of 
<TT>int</TT> and <TT>long</TT>, only that the latter be at least
as big as the former. As of the C99 standard, there
are types <TT>int32_t</TT> and <TT>int64_t</TT> that
are signed integers that explicitly support a fixed number of bits. 
Most compilers already have these symbols defined appropriately
in <TT>sys/types.h</TT> (pre C99 standard) or <TT>inttypes.h</TT>.</P><P>Python defines its <TT>int</TT> and <TT>long</TT> to be equivalent
to C, and therefore suffers the same platform dependent 
integer size problem with less flexibility for a workaround.
It is not uncommon for regression tests involving longs and 
Python to fail on certain platforms. Python 2.2 has a patch to make
SIDL long support better.</P><H3 CLASS="subsection">Strings</H3><P><A NAME="ssec:basics:fundamental:strings"></A>
<A NAME="@default144"></A><A NAME="@default145"></A></P><P>Strings are an interesting datatype because they are fundamental
to many pieces of software, but represented differently by
practically every single programming language. Strings
can have a high overhead to support language interoperability 
because there is invariably so much copying involved.</P><P><SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> and Fortran 90/95 support for strings is limited to a predetermined 
buffer size. Since the results of a string assignment into
that buffer in Fortran does not propagate the length of the
string, trailing whitespace is always trimmed for any string
begin passed out from a Fortran implementation.</P><H3 CLASS="subsection">Opaque</H3><P><A NAME="ssec:basics:fundamental:opaque"></A>
<A NAME="@default146"></A><A NAME="@default147"></A></P><P>The <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> type is dangerous and rarely useful. However, there
are particular times when an opaque type is the only way to solve a
problem; for example, it is one of the few portable ways to implement
an object with state in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. When a SIDL file uses an
<FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> type, Babel guarantees only bits will be relayed exactly
between caller and callee. If there is a need to pass more
information than an opaque provides, than the developer can simply
pass a pointer to that information.</P><P>Use of a <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> carries a heavy penalty. Method calls with
<FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> types in the argument list (or return type) are
restricted to in-process calls only.
</P><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
Since <FONT COLOR=maroon><TT><I>opaque</I></TT></FONT> is typically used for a pointer to memory, 
this sequence of bits has no meaning outside of its own
process space.
</EM></BLOCKQUOTE><H3 CLASS="subsection">Enumerations</H3><P><A NAME="ssec:basics:fundamental:enums"></A>
<A NAME="@default148"></A><A NAME="@default149"></A></P><P>An enumeration is typically used in programming
languages to specify a limited range of states
to enable dealing with them by names instead of hard-coded values.
For language interoperability purposes — especially to 
support this concept on languages with no native support — 
we’ve had to create specific rules for the integer values
associated with enumerated types.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> enumSample <B>version</B> 1.0 {

  // undefined integer values
  <B>enum</B> color {
    red, orange, yellow, green, blue, violet
  };

  // completely defined integer values
  <B>enum</B> car {
    /**
     * A sports car.
     */
    porsche = 911,
    /**
     * A family car.
     */
    ford = 150,
    /**
     * A luxury car.
     */
    mercedes = 550
  };

  // partially defined integer value
  <B>enum</B> number {
    notZero,    // This non-doc comment will not be retained.
    notOne,
    zero=0,
    one=1,
    negOne=-1,
    notNeg
  };
}</I></FONT></TD></TR>
</TABLE><P>Above is a sample of enumerations taken directly from 
our regression tests. It defines a package <FONT COLOR=maroon><I><TT>enumSample</TT></I></FONT>
that contains three enumerations. C/C++ developers
will find the syntax very familiar.
When defining an enumeration, the actual integer values
assigned can be undefined, completely defined, or
partially defined.</P><P>SIDL defines the following rules for adding integer
values to enumerated states that don’t have a value
explicitly defined.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Error if two states are explicitly assigned the same value
</LI><LI CLASS="li-enumerate">Assign all explicit values to their named state.
</LI><LI CLASS="li-enumerate">Assign smallest unused non-negative value to first 
	unassigned state in enumeration.
</LI><LI CLASS="li-enumerate">Repeat 3 until all states have assigned (unique) values.
</LI></OL><P>To verify the application of these rules, 
the <FONT COLOR=maroon><I><TT>enumSample.number</TT></I></FONT> enumeration
will have the following values assigned to
its states: <FONT COLOR=maroon><I><TT>NotZero</TT></I></FONT>=2, <FONT COLOR=maroon><I><TT>NotOne</TT></I></FONT>=3,
<FONT COLOR=maroon><I><TT>zero</TT></I></FONT>=0; <FONT COLOR=maroon><I><TT>one</TT></I></FONT>=1, <FONT COLOR=maroon><I><TT>negOne</TT></I></FONT>=-1,
<FONT COLOR=maroon><I><TT>notNeg</TT></I></FONT>=4.
</P><H2 CLASS="section"><A NAME="toc25"></A><A NAME="htoc25">6.4</A>  Arrays</H2><P><A NAME="s:arrays"></A></P><P>Support for multi-dimensional arrays is one of the features that 
separates SIDL/Babel language interoperability from Microsoft’s
COM/DCOM<A NAME="@default150"></A> and the OMG’s CORBA<A NAME="@default151"></A>. 
SIDL supports two kinds of arrays: normal and raw.
Normal SIDL arrays provide all the features of a normal SIDL type, while
raw SIDL arrays, called r-arrays, exist to provide more 
efficient, lower level access to numeric arrays.
For example, a one-dimensional r-array in C appears as a
double pointer and a length parameter. To highlight the contrast,
normal SIDL arrays appear as a struct in C, a template class in C++,
an 64-bit integer in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, and a derived type in Fortran 90/95.</P><P>The SIDL array API and data structure can be used in client code to
prepare arguments for passing to a SIDL method. It is used inside
the implementation code to get data and meta-data from incoming
array arguments.
The remainder of this section will focus on the C API for arrays
because it is the basis for the other language APIs.</P><H3 CLASS="subsection">SIDL Arrays</H3><P><A NAME="ss:arrays"></A>
<A NAME="@default152"></A><A NAME="@default153"></A></P><P>Normal SIDL arrays provide all the features of a normal SIDL type.
They are meant to generalize the array types built into many languages.
They are not parallel array classes or particularly sophisticated, but 
are very, very general. It is expected that developers requiring 
parallel array libraries build them on top of the SIDL array type. </P><P>Characteristics of normal SIDL arrays are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
reference counted;
</LI><LI CLASS="li-itemize">can be passed as <TT>in</TT>, <TT>inout</TT>, or <TT>out</TT> parameters;
</LI><LI CLASS="li-itemize">can be returned from a method;
</LI><LI CLASS="li-itemize">can be allocated or borrowed;
</LI><LI CLASS="li-itemize">can be set to <TT>NULL</TT>; and
</LI><LI CLASS="li-itemize">can be “row-major”<A NAME="@default154"></A> or<A NAME="@default155"></A> 
“column-major”<A NAME="@default156"></A>.
</LI></UL><H4 CLASS="subsubsection">Generic Arrays</H4><P><A NAME="sss:basics:genericarrays"></A>
<A NAME="@default157"></A><A NAME="@default158"></A></P><P>The design of the (normal) array data structure enables the concept of a
generic array, an array whose data type and dimension are
unspecified. In SIDL, a generic array is indicated with the type
<FONT COLOR=maroon><I><TT>array&lt; &gt;</TT></I></FONT>. There is no type or dimension information
between the &lt; and &gt;. </P><P>Generic arrays are useful for making interfaces that are very flexible
without requiring numerous methods to be defined. For example, if you
were writing an interface to serialize an array, you could write one
method <FONT COLOR=maroon><I><TT>void serialize(in array&lt; &gt; array);</TT></I></FONT> to handle an
array of any type or dimension. Without generic arrays, you would have
to define 77 different <FONT COLOR=maroon><I><TT>serialize</TT></I></FONT> methods to handle each
possible array type and dimension.</P><P>In C, you can use the macro API to determine the dimension, bounds on
each dimension and stride for a generic array. All other languages
except Python provide a function API to determine the same information
for a generic array. </P><P>Starting with Babel 1.1.0, Babel’s Python binding now uses either the
Python NumPy or Numeric Python array API. This switch in Babel follows
a switch in the Python community where the Python community has
deprecated Numeric Python and appointed NumPy as its successor. If you
need examples about how to write code that can work with either Python
array API look at Babel’s array regression tests, arrays and ordering.</P><P>The function API for generic arrays includes the following methods:
<TT>addRef</TT>, <TT>smartCopy</TT>, <TT>deleteRef</TT>, <TT>dimen</TT>,
<TT>lower</TT>, <TT>upper</TT>, <TT>length</TT>, <TT>stride</TT>,
<TT>isColumnOrder</TT>, <TT>isRowOrder</TT>, and <TT>type</TT>. With the
exception of <TT>type</TT>, these methods have all been presented
above. The name of the method has the type left
empty. Where the name for <TT>addRef</TT> in C on a double array is
<TT>sidl_double_array_addRef</TT>, its name is
<TT>sidl__array_addRef</TT> for a generic array. Note, there are two
underscores between <TT>sidl</TT> and <TT>array</TT> in the generic array
case.</P><P>The <TT>type</TT> method is defined as follows in the case of C.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/**
 * Return an integer indicating the type of elements held by the
 * array. Zero is returned if array is NULL.
 */</I></FONT>
int32_t
sidl__array_type(<B>const struct</B> sidl__array* array);</TD></TR>
</TABLE><P>
It returns a value that indicates what the underlying type of the
array actually is. The return value is either zero or one of the
values in <TT>sidl_array_type</TT>.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>enum</B> sidl_array_type {
  <FONT COLOR="blue"><I>/* these values must match values used in F77 &amp; F90 too */</I></FONT>
  sidl_bool_array      = 1,
  sidl_char_array      = 2,
  sidl_dcomplex_array  = 3,
  sidl_double_array    = 4,
  sidl_fcomplex_array  = 5,
  sidl_float_array     = 6,
  sidl_int_array       = 7,
  sidl_long_array      = 8,
  sidl_opaque_array    = 9,
  sidl_string_array    = 10,
  sidl_interface_array = 11 <FONT COLOR="blue"><I>/* an array of sidl.BaseInterface's */</I></FONT>
};</TD></TR>
</TABLE><P>
Once you’ve discovered the underlying type of the generic array, you
can safely cast its pointer to the actual pointer type (in languages
like C). Each language binding provides a way to cast generic array
pointers to specific types and vice versa.</P><P>In the case of a <TT>sidl_interface_array</TT>, you can case the array
to an array of <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> interface references. Your
code should treat it as such. You can downcast individual elements of
the array as you need. Your code should consider the possibility that
downcasting may fail. Babel can only guarantee that the elements of
the array are <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>’s.</P><H3 CLASS="subsection">R-arrays</H3><P><A NAME="ss:r-arrays"></A>
<A NAME="@default159"></A><A NAME="@default160"></A><A NAME="@default161"></A></P><P>Since SIDL was designed to serve the high performance computing
community, both SIDL object developers and clients may require direct
access to the underlying array data structure for optimization
purposes, such as instruction pipelining or cache performance. Hence,
support for raw SIDL arrays was introduced for low level access to
numeric arrays. At present, they are available in C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
Fortran 90/95 and Fortran 2003/2008. In all other languages R-arrays are
implemented as regular SIDL arrays with no particular performance
advantage.</P><P>Unlike normal SIDL arrays, the use of r-arrays are more restricted.
More specifically, they have the following constraints:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Only the <TT>in</TT> and <TT>inout</TT> parameter modes are
available for r-arrays. R-arrays cannot be used as return values or as 
<TT>out</TT> parameters.
</LI><LI CLASS="li-enumerate">R-arrays must be contiguous in memory, and multi-dimensional
arrays must be in column-major order (i. e., Fortran order).
</LI><LI CLASS="li-enumerate"><TT>NULL</TT> is not an allowable value for an r-array parameter.
</LI><LI CLASS="li-enumerate">The semantics for <TT>inout</TT> r-array parameters are
different. The implementation is not allowed to deallocate the array
and return a new r-array. <TT>inout</TT> means that the array data is
transferred from caller to callee at the start of a method
invocation and from callee to caller at the end of the a method
invocation.
</LI><LI CLASS="li-enumerate">The implementation of a method taking an r-array parameter
cannot change the shape of the array.
</LI><LI CLASS="li-enumerate">The lower index is always 0, and the upper index is <I>n</I>−1 where
<I>n</I> is the length in a particular dimension. This is contrary to the
normal convention for Fortran arrays.
</LI><LI CLASS="li-enumerate">It can only be used for arrays of SIDL <TT>int</TT>, <TT>long</TT>,
<TT>float</TT>, <TT>double</TT>, <TT>fcomplex</TT>, and <TT>dcomplex</TT> types.
</LI></OL><BLOCKQUOTE CLASS="quotation"><B>Rationale:</B> <EM>
The way r-arrays are passed to the server-side code, particularly
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, makes it impossible for them to be allocated or deallocated. This
makes <TT>out</TT> and return values impossible. Because the data has to
be accessible directly from <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> without any additional
meta-data, the array data must be in column-major order.</EM><P><EM>Arrays of char are not currently supported for r-arrays because in
some languages characters are treated as 16-bit Unicode characters.
</EM></P></BLOCKQUOTE><P>The advantages of r-arrays include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Arrays appear more “natural” in C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, Fortran 90/95 and
future low level languages.
</LI><LI CLASS="li-itemize">Developers need less or no code to translate between their array
data structure and SIDL’s array data structure.
</LI><LI CLASS="li-itemize">SIDL generated APIs can have signatures very similar if not
identical to well known legacy APIs.
</LI><LI CLASS="li-itemize">Less performance overhead because r-arrays can avoid a call to
<TT>malloc</TT> and <TT>free</TT>.
</LI></UL><P>When you declare an r-array, you also declare the index variables that
will hold the size of the array in each dimension. For example, here
is a method to solve one of the fundamental problems of linear
algebra, <I>A x</I> = <I>b</I>: </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    <FONT COLOR=maroon><I><B>void</B> solve(<B>in    rarray</B>&lt;<B>double</B>,2&gt; A(m,n),
               <B>inout rarray</B>&lt;<B>double</B>&gt;   x(n),
               <B>in    rarray</B>&lt;<B>double</B>&gt;   b(m),
               <B>in    int</B>              m,
               <B>in    int</B>              n);</I></FONT></TD></TR>
</TABLE><P>In this example, <TT>A</TT> is a 2-D array of doubles with <TT>m</TT> rows
and <TT>n</TT> columns. <TT>x</TT> is a 1-D array of doubles of length
<TT>n</TT>, and <TT>b</TT> is a 1-D array of doubles of length
<TT>m</TT>. Note that by explicitly declaring the index variables, SIDL
takes avoid using extra array size parameters by taking advantage of
the fact that the sizes of <TT>A</TT>, <TT>x</TT> and <TT>b</TT> are all
inter-related. The explicit declaration also allows the developer to
control where the index parameters appear in the argument list. In
many cases, the argument types and order can match existing APIs.</P><P>The mapping for the solve method will be shown for C, C++, <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>
and Fortran 90/95 in the following chapters. In languages that do not
support low level access such as Python and Java, r-arrays are treated
just like normal SIDL arrays, and the redundant index arguments are
dropped from the argument list. The indexing information is available
from the SIDL array data structure.</P><H3 CLASS="subsection">SIDL Language Features</H3><P><A NAME="ss:sidl_arrays"></A>
<A NAME="@default162"></A></P><P>As of release 0.6.5, interface definitions can specify that an
array argument or return value must have a particular ordering for a
method. The type <TT>array&lt;int, 2, row-major&gt;</TT> indicates a dense,
<SUP><A NAME="text9" HREF="#note9">1</A></SUP>
two-dimensional array of 32 bit integers in row-major order; and
likewise, the type <TT>array&lt;int, 2, column-major&gt;</TT> indicates an
dense array in column-major order. Some numerical routines can only
provide high performance with a particular type of array. The ordering
is part of the interface definition to give clients the information
they need to use the underlying code efficiently. The ordering
specification is optional.</P><P>For one-dimensional arrays, specifying <TT>row-major</TT> or
<TT>column-major</TT> allows you to specify that the array must be
dense, that is stride 1. Otherwise, for one-dimensional arrays
row-major and column-major are identical.</P><P>If you pass an array into a method and the array does not have the
specified ordering, the skeleton code will make a copy of the array
with the required ordering and pass the copy to the method. This
copying is necessary for correctness, but it will cause a decrease in
performance. The implementor of the method can count on an incoming
array to have the required ordering.</P><P>For <TT>out</TT> parameters and return values, an ordering
specification means that the method promises to return an array with
the specified ordering. The implementation should create the
<TT>out</TT> arrays with the proper ordering; because if it does not,
the skeleton code will have to copy the outgoing array into a new
array with the required ordering.</P><P>For <TT>inout</TT> parameters, an ordering specification means the
ordering specification will be enforced by the skeleton code for the
incoming and outgoing array value.</P><P>At the time of writing this, the ordering constraints are enforced for
Python implementation because Python uses NumPy or Numeric Python arrays, so
Babel cannot control the array ordering as fully. The Python
skeletons do force outgoing arrays (i. e., arrays passed back from
Python) to have the required ordering.</P><H3 CLASS="subsection">Independent and borrowed arrays</H3><P>
<A NAME="@default163"></A><A NAME="@default164"></A></P><P>From a memory perspective, there are two main kinds of arrays:
independent and borrowed. The independent arrays owns and manages its
data. It allocates space for the array elements when the array is
created, and it deallocates that space when the array is finally
destroyed.</P><P>The borrowed array does not own or manage its data. It borrows its
array element data from another source that it cannot manage, and it
only allocates space for the index bounds and stride information. The
rationale for borrowed arrays is to allow data from another source to
temporarily appear as a SIDL array without requiring data be copied.</P><P>If you <TT>slice</TT> an independent array, the resulting array is also
considered independent even though it borrows data from the original
independent array. The resulting array can still manage its data by
retaining a reference to the original array; hence, its element data
cannot disappear until the resulting array is destroyed.
If you <TT>slice</TT> a borrowed array, the resulting array is also
borrowed because like its original array, it doesn’t manage the
underlying data.</P><P>In the Babel generated code, r-arrays are converted to borrowed
arrays. These borrowed arrays are allocated on the stack rather than
on the heap to improve performance of r-arrays.</P><H3 CLASS="subsection">The Life of an Array</H3><P>
<A NAME="@default165"></A></P><P>The existence of borrowed arrays causes the arrays to deviate from the
normal reference counting pattern. You may recall that all arrays are reference counted,
and an array’s resources are reclaimed when the reference count goes to
zero. However, a borrowed array’s array element data will disappear
whenever the source of the borrowed data determines that it should
regardless of the reference count in corresponding the SIDL array.
This behavior means that developers should consider any SIDL array
that they did not create themselves, for example incoming arguments to
methods, as potential borrowed arrays. When a method wants to keep a
copy of an array that might be a borrowed array, it should use the
<TT>smartCopy</TT><A NAME="@default166"></A><A NAME="@default167"></A> method documented below.</P><P>Here are some rules of thumb about the use of borrowed arrays:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The creator of a borrowed array should guarantee that the data for the
borrowed array will exist through the duration of any method calls
using the borrowed array.
</LI><LI CLASS="li-itemize">Methods should not return a borrowed array as a return value or
<TT>out</TT> parameter unless the method can guarantee that the array
element data will be available until the process shuts down.
</LI><LI CLASS="li-itemize">There is a negligible performance cost when using <TT>smartCopy</TT>
when the array is not borrowed, and there is a huge correctness
benefit when the array is borrowed.
</LI></UL><H3 CLASS="subsection">The <TT>NULL</TT> Array</H3><P>
<A NAME="@default168"></A></P><P><TT>NULL</TT> is a special array reference value that refers to no
array. It’s used to indicate that an array reference currently points
to nothing. The way you refer to <TT>NULL</TT> varies from language to
language, but the concept is the same. In C++ and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>,
<TT>0</TT> (numeral zero) is the value of the <TT>NULL</TT> array. In C,
the preprocessor symbol <TT>NULL</TT> is the value for the <TT>NULL</TT>
array. In Python, it’s the special constant <TT>None</TT>, and in Java
it’s <TT>null</TT>. In Fortran 90/95, there is a function <TT>set_null</TT>,
to initialize a pointer to the <TT>NULL</TT> value, and there is a
logical function <TT>is_null</TT> to test whether an array is equal to
<TT>NULL</TT>.</P><H3 CLASS="subsection">The Language Bindings</H3><P>The C++ binding for array provides access to the C API in case you<A NAME="@default169"></A>
need to take the gloves off and revel in the data directly. But the
C++ binding also provides a templated wrapper class to provide a more
natural look and feel for C++ programmers.</P><P>In some cases, the Python binding for arrays must copy SIDL arrays
to/from NumPy or Numeric Python arrays; it should not happen for normally
strided arrays except when an ordering constraint requires it. Arrays
in Python<A NAME="@default170"></A><A NAME="@default171"></A> don’t have the
SIDL methods available. They just have the NumPy or Numeric Python API
available.</P><P>The <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> API mimics the C API; all the C functions have been
Fortran’ified and have _f appended to their names. The 
Fortran 90/95 API uses function overloading to allow programmers to use
the short array method names.</P><H3 CLASS="subsection">The Array API</H3><P><A NAME="ss:basics:array:api"></A></P><P>In the following presentation, we use the SIDL <FONT COLOR=maroon><I><TT>double</TT></I></FONT> type; however,
everything in this section applies to all types except where noted.
The basic types are in the SIDL
namespace. Table <A HREF="#tbl:basics:arraytypes">6.2</A><A NAME="@default172"></A> shows the prefix for SIDL
base types and the actual value type held by the array...</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 6.2: SIDL types to array function prefixes</TD></TR>
</TABLE></DIV>
<A NAME="tbl:basics:arraytypes"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SIDL TYPE</B></TD><TD ALIGN=left NOWRAP><B>ARRAY FUNCTION PREFIX</B></TD><TD ALIGN=left NOWRAP><B>VALUE TYPE</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>bool</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_bool</TT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_bool</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>char</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_char</TT>	</TD><TD ALIGN=left NOWRAP><TT>char</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>dcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_dcomplex</TT></TD><TD ALIGN=left NOWRAP><TT>struct sidl_dcomplex</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>double</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_double</TT> 	</TD><TD ALIGN=left NOWRAP><TT>double</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>fcomplex</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_fcomplex</TT>	</TD><TD ALIGN=left NOWRAP><TT>struct sidl_fcomplex</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>float</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_float</TT> 	</TD><TD ALIGN=left NOWRAP><TT>float</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>int</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_int</TT> 	</TD><TD ALIGN=left NOWRAP><TT>int32_t</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>long</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_long</TT> 	</TD><TD ALIGN=left NOWRAP><TT>int64_t</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>opaque</TT></I></FONT> 	</TD><TD ALIGN=left NOWRAP><TT>sidl_opaque</TT> 	</TD><TD ALIGN=left NOWRAP><TT>void *</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP> <FONT COLOR=maroon><I><TT>string</TT></I></FONT></TD><TD ALIGN=left NOWRAP><TT>sidl_string</TT> 	</TD><TD ALIGN=left NOWRAP><TT>char *</TT></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>For arrays of interfaces or classes, the name of the 
array function prefix is derived from the fully qualified type name. 
For example, for the type <FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT>, the
array functions all begin with <TT>sidl_BaseClass</TT>. 
For <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT>, they all begin with
<TT>sidl_BaseInterface</TT>.</P><P>When you add an object or interface to an array,
the reference count of the element being overwritten is
decremented, and the reference count of the element being added is
incremented. When you get an object or interface from an array,
the caller owns the returned reference.</P><P>For arrays of strings<A NAME="@default173"></A> when you add a string to any array, the array
will store a copy of the string. When you retrieve a string from an
array, you will receive a copy of the string. You should
<TT>sidl_String_free</TT> the returned string when you are done with it.</P><P>When you create an array of interfaces, classes, or strings, all
elements of the array are initialized<A NAME="@default174"></A> to NULL. Other arrays are not
initialized. When an array of interfaces, classes, or strings is
destroyed, it releases any held references in the case of objects or
interfaces. In the case of strings, it frees any non-NULL pointers.</P><P>The name of the data structure that holds the array if double is 
<TT>struct sidl_double__array</TT>. For some types, the data structure 
is an opaque type, and for others, it is defined in a public C header
file.</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 6.3: SIDL Array Functions</TD></TR>
</TABLE></DIV>
<A NAME="tbl:basics:arrayfuncs"></A>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <B>SHORT NAME</B></TD><TD ALIGN=left NOWRAP><B>DESCRIPTION</B></TD></TR>
<TR><TD ALIGN=left NOWRAP> <TT>createCol</TT>	</TD><TD ALIGN=left NOWRAP>Creates a column-major order SIDL array <A NAME="@default175"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>createRow</TT>	</TD><TD ALIGN=left NOWRAP>Creates a row-major order SIDL array <A NAME="@default176"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>create1d</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a dense one-dimensional SIDL array <A NAME="@default177"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>create2dCol</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a dense, column-major, two-dimensional SIDL array <A NAME="@default178"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>create2dRow</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a dense, column-major, two-dimensional SIDL array <A NAME="@default179"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>slice</TT> 	</TD><TD ALIGN=left NOWRAP>Creates a sub-array of another array. Takes
parameters to define array properties. <A NAME="@default180"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>borrow</TT> 	</TD><TD ALIGN=left NOWRAP>Makes a SIDL array from third party data
without copying it <A NAME="@default181"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>	
<TT>smartCopy</TT> 	</TD><TD ALIGN=left NOWRAP>Copies a borrowed array or addRefs a
non-borrowed array <A NAME="@default182"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>addRef</TT>		</TD><TD ALIGN=left NOWRAP>Increments the reference count. <A NAME="@default183"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>deleteRef</TT>	</TD><TD ALIGN=left NOWRAP>Decrements the reference count. <A NAME="@default184"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get1</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
one-dimensional array <A NAME="@default185"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get2</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
two-dimensional array <A NAME="@default186"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get3</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
three-dimensional array <A NAME="@default187"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get4</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
four-dimensional array <A NAME="@default188"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get5</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
five-dimensional array <A NAME="@default189"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get6</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
six-dimensional array <A NAME="@default190"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get7</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from a
seven-dimensional array <A NAME="@default191"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>get</TT>		</TD><TD ALIGN=left NOWRAP>Returns the indexed element from 
an array of any dimension <A NAME="@default192"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set1</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
one-dimensional array <A NAME="@default193"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set2</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
two-dimensional array <A NAME="@default194"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set3</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
three-dimensional array <A NAME="@default195"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set4</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
four-dimensional array <A NAME="@default196"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set5</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
five-dimensional array <A NAME="@default197"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set6</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
six-dimensional array <A NAME="@default198"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set7</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in a
seven-dimensional array <A NAME="@default199"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>set</TT>		</TD><TD ALIGN=left NOWRAP>Sets the indexed element in 
an array of any dimension <A NAME="@default200"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>dimen</TT>		</TD><TD ALIGN=left NOWRAP>Returns the dimension of the array <A NAME="@default201"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>lower</TT>		</TD><TD ALIGN=left NOWRAP>Returns the lower bound of the specified dimension <A NAME="@default202"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>upper</TT>		</TD><TD ALIGN=left NOWRAP>Returns the upper bound of the specified dimension <A NAME="@default203"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>stride</TT>		</TD><TD ALIGN=left NOWRAP>Returns the stride of the specified
dimension <A NAME="@default204"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>length</TT>		</TD><TD ALIGN=left NOWRAP>Returns the length of the Array in the
specified dimension <A NAME="@default205"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>isColumnOrder</TT>	</TD><TD ALIGN=left NOWRAP>Returns true if the array is a dense
column-major order array, false otherwise <A NAME="@default206"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>isRowOrder</TT>	</TD><TD ALIGN=left NOWRAP>Returns true if the array is a dense
row-major order array, false otherwise <A NAME="@default207"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>copy</TT>		</TD><TD ALIGN=left NOWRAP>Copies the contents of source array to dest
array <A NAME="@default208"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>ensure</TT>		</TD><TD ALIGN=left NOWRAP>Returns an array with guaranteed ordering
and dimension from any array. <A NAME="@default209"></A></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>first</TT>		</TD><TD ALIGN=left NOWRAP>Provides direct access to the element data of
the array. <A NAME="@default210"></A></TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The functions are listed succinctly in
Table <A HREF="#tbl:basics:arrayfuncs">6.3</A><A NAME="@default211"></A> as well as in detail over the next
few pages.</P><H4 CLASS="subsubsection">Function: createCol</H4><P><A NAME="@default212"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/* C */
<B>struct</B> sidl_double__array*
sidl_double__array_createCol(int32_t       dimen,
                             const int32_t lower[],
                             const int32_t upper[]);
//
// C++
<B>static</B> sidl::<B>array</B>&lt;<B>double</B>&gt;
sidl::<B>array</B>&lt;<B>double</B>&gt;::createCol(int32_t       dimen,
                               const int32_t lower[],
                               const int32_t upper[]);
C
C FORTRAN 77
       subroutine sidl_double__array_createCol_f(dimen, lower, upper, result)
       integer*4 dimen
       integer*4 lower(dimen), upper(dimen)
       integer*8 result
!
! FORTRAN 90
subroutine createCol(lower, upper, result)
  integer (selected_int_kind(9)), dimension(:), intent(<B>in</B>) :: lower, upper
  type (sidl_double_3d), intent(<B>out</B>) :: result ! type depends on dimension
! dimension of result is inferred from the size of lower

// Java
// (isRow should be false to get a column order array) 
  public Array(<B>int</B> dim, <B>int</B>[] lower, <B>int</B>[] upper, boolean isRow);</I></FONT></TD></TR>
</TABLE><P>This method creates a column-major, multi-dimensional array in a
contiguous block of memory. <TT>dimen</TT> should be strictly greater
than zero, and <TT>lower</TT> and <TT>upper</TT> should have <TT>dimen</TT>
elements. <TT>lower[i]</TT> must be less than or equal to
<TT>upper[i]-1</TT> for <TT>i ≥ 0</TT> and <TT>i &lt; dimen</TT>. If
this function fails for some reason, it returns
<TT>NULL</TT>. <TT>lower[i]</TT> specifies the smallest valid index for
dimension <TT>i</TT>, and <TT>upper[i]</TT> specifies the largest. Note
this definition is somewhat un-C like where the upper bound is often
one past the end. In SIDL, the size of dimension <TT>i</TT> is <TT>1
+ upper[i] - lower[i]</TT>.</P><P>The function makes copies of the information provided by <TT>dimen</TT>,
<TT>lower</TT>, and <TT>upper</TT>, so the caller is not obliged to
maintain those values after the function call.</P><P>For Fortran, the new array is returned in the last parameter,
<TT>result</TT>. A zero value in <TT>result</TT> indicates that the
operation failed. For Fortran 90/95, you can use the function
<TT>not_null</TT> to verify that <TT>result</TT> is a valid array.</P><H4 CLASS="subsubsection">Function: createRow</H4><P><A NAME="@default213"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_createRow(int32_t       dimen,
                             <B>const</B> int32_t lower[],
                             <B>const</B> int32_t upper[]);
//
// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::createRow(int32_t       dimen,
                               <B>const</B> int32_t lower[],
                               <B>const</B> int32_t upper[]);
C
C FORTRAN 77
       subroutine sidl_double__array_createRow_f(dimen, lower, upper, result)
       integer*4 dimen
       integer*4 lower(dimen), upper(dimen)
       integer*8 result
!
! FORTRAN 90
subroutine createRow(lower, upper, result)
  integer (selected_int_kind(9)), dimension(:), intent(in) :: lower, upper
  type(sidl_double_3d), intent(out) :: result ! type depends on dimension
! dimension of result is inferred from the size of lower

// Java
// (isRow should be true to get a row order array)
  public Array(<B>int</B> dim, <B>int</B>[] lower, <B>int</B>[] upper, boolean isRow);</TD></TR>
</TABLE><P>This method creates a row-major, multi-dimensional array in a
contiguous block of memory. Other than the difference in the
ordering of the array elements, this method is identical to
<TT>createCol</TT>.</P><H4 CLASS="subsubsection">Function: create1d</H4><P><A NAME="@default214"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_create1d(int32_t len);

// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::create1d(int32_t len);

C FORTRAN 77
       subroutine sidl_double__array_create1d_f(len, result)
       integer*4 len
       integer*8 result

! FORTRAN 90
subroutine create1d(len, result)
  integer (selected_int_kind(9)), intent(in) :: len
  type(sidl_double_1d), intent(out) :: result

// Java
  public Array1(<B>int</B> s0, boolean isRow);</TD></TR>
</TABLE><P>This method creates a dense, one-dimensional vector of ints with a lower
index of 0 and an upper index of <I>len</I> − 1. This is defined primarily
as a convenience for C and C++ programmers; Fortran programmers should note
that this subroutine creates arrays whose lower index is <EM>0</EM> not like
standard Fortran arrays whose lower index is 1. If <I>len</I> ≤ 0, this
routine returns NULL.</P><H4 CLASS="subsubsection">Function: create2dCol</H4><P><A NAME="@default215"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_create2dCol(int32_t m, int32_t n);

// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::create2dCol(int32_t m, int32_t n);

C FORTRAN 77
       subroutine sidl_double__array_create2dCol_f(m, n, result)
       integer*4 m, n
       integer*8 result

! FORTRAN 90
subroutine create2dCol(m, n, result)
  integer (selected_int_kind(9)), intent(in) :: m, n
  type(sidl_double_2d), intent(out) :: result

// Java
// isRow should be false to get a column order array
  public Array2(<B>int</B> s0, <B>int</B> s1, boolean isRow);</TD></TR>
</TABLE><P>This method creates a dense, column-major, two-dimensional array of
ints with a lower index of (0, 0) and an upper index of (<I>m</I> − 1, <I>n</I> −
1). If <I>m</I> ≤ 0 or <I>n</I> ≤ 0, this method returns NULL. This is
defined primarily as a convenience for C and C++ programmers; Fortran
programmers should note that this subroutine creates arrays whose
lower index is <EM>0</EM> not like standard Fortran arrays whose lower
index is 1.</P><H4 CLASS="subsubsection">Function: create2dRow</H4><P><A NAME="@default216"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_create2dRow(int32_t m, int32_t n);

// C++
<B>static</B> sidl::array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::create2dRow(int32_t m, int32_t n);

C FORTRAN 77
       subroutine sidl_double__array_create2dRow_f(m, n, result)
       integer*4 m, n
       integer*8 result

! FORTRAN 90
subroutine create2dRow(m, n, result)
  integer (selected_int_kind(9)), intent(in) :: m, n
  type(sidl_double_2d), intent(out) :: result

// Java
// isRow should be false to get a column order array
  public Array2(<B>int</B> s0, <B>int</B> s1, boolean isRow);</TD></TR>
</TABLE><P>This method creates a dense, row-major, two-dimensional array of ints
with a lower index of (0, 0) and an upper index of (<I>m</I> − 1, <I>n</I> − 1).
If <I>m</I> ≤ 0 or <I>n</I> ≤ 0, this method returns NULL. This is defined
primarily as a convenience for C and C++ programmers; Fortran
programmers should note that this subroutine creates arrays whose
lower index is <EM>0</EM> not like standard Fortran arrays whose lower
index is 1.</P><H4 CLASS="subsubsection">Function: slice</H4><P><A NAME="@default217"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array *
sidl_double__array_slice(<B>struct</B> sidl_double__array *src,
                         int32_t                    dimen,
                         <B>const</B> int32_t              numElem[],
                         <B>const</B> int32_t             *srcStart,
                         <B>const</B> int32_t             *srcStride,
                         <B>const</B> int32_t             *newStart);
//
// C++
array&lt;<B>double</B>&gt;
sidl::array&lt;<B>double</B>&gt;::slice(<B>int</B> dimen,
                           <B>const</B> int32_t numElem[],
                           <B>const</B> int32_t *srcStart = 0,
                           <B>const</B> int32_t *srcStride = 0,
                           <B>const</B> int32_t *newStart = 0);
C
C FORTRAN 77
       subroutine sidl_double__array_slice_f(src, dimen, numElem, srcStart,
      $                       srcStride, newStart, result)
       integer*8 src, result
       integer*4 dimen
       integer*4 numElem(srcDimen), srcStart(srcDimen)
       integer*4 srcStride(srcDimen),  newStart(dimen)
!
! FORTRAN 90
subroutine slice(src, dimen, numElem, srcStart, srcStride, newStart, result)
  type(sidl_double_3d), intent(in) :: src     ! type depends on dimension
  type(sidl_double_2d), intent(out) :: result ! type depends on dimension
  integer (selected_int_kind(9)), intent(in) :: dimen
  integer (selected_int_kind(9)), intent(in), dimension(:) :: &amp;
     numElem, srcStart, srcStride, newStart

// Java
  public native Array _slice(<B>int</B> dimen, <B>int</B>[] numElem, <B>int</B>[] srcStart,
                             <B>int</B>[] srcStride, <B>int</B>[] newStart);</TD></TR>
</TABLE><P>This method will create a sub-array of another array. The resulting
array shares data with the original array. The new array can be of
the same dimension or potentially less than the original array. If
you are removing a dimension, indicate the dimensions to remove by
setting <TT>numElem[i]</TT> to zero for any dimension <TT>i</TT> that
should go away in the new array. The meaning of each argument is
covered below.
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>src</B></DT><DD CLASS="dd-description"> the array to be created will be a subset of this array. If
this argument is NULL, NULL will be returned. The returned array
borrows data from <TT>src</TT>, so modifying one array modifies both.
In C++, the <TT>this</TT> pointer takes the place of <TT>src</TT>.
</DD><DT CLASS="dt-description"><B>dimen</B></DT><DD CLASS="dd-description"> this argument must be greater than zero and less than or
equal to the dimension of <TT>src</TT>. An illegal value will cause a
NULL return value.
</DD><DT CLASS="dt-description"><B>numElem</B></DT><DD CLASS="dd-description"> this specifies how many elements from src should be
in the new array in each dimension. A zero entry indicates that the 
dimension should not appear in the new array. This argument should
be an array with an entry for each dimension of <TT>src</TT>. 
<TT>NULL</TT> will be returned for <TT>src</TT> if either<BR>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TT>srcStart[i] + numElem[i] * srcStride[i]</TT></TD><TD ALIGN=center NOWRAP>&gt;</TD><TD ALIGN=left NOWRAP><TT>upper[i]</TT>, or</TD></TR>
<TR><TD ALIGN=right NOWRAP><TT>srcStart[i] + numElem[i] * srcStride[i]</TT></TD><TD ALIGN=center NOWRAP>&lt;</TD><TD ALIGN=left NOWRAP><TT>lower[i]</TT></TD></TR>
</TABLE>
</DIV></DD><DT CLASS="dt-description"><B>srcStart</B></DT><DD CLASS="dd-description">this parameter specifies which element of <TT>src</TT>
will be the first element of the new array. If this argument is NULL,
the first element of <TT>src</TT> will be the first element of the new
array. If non-NULL, this argument provides the coordinates of an
element of <TT>src</TT>, so it must have an entry for each dimension of
<TT>src</TT>. <TT>NULL</TT> will be returned for <TT>src</TT> if either
<DIV CLASS="center">
<TT>srcStart[i] &lt; lower[i]</TT>, or <TT>srcStart[i] &gt; upper[i]</TT>.
</DIV></DD><DT CLASS="dt-description"><B>srcStride</B></DT><DD CLASS="dd-description">this argument lets you specify the stride between
elements of <TT>src</TT> for each dimension. For example with a stride
of 2, you could create a sub-array with only the odd or even elements
of <TT>src</TT>. If this argument is NULL, the stride is taken to be
one in each dimension. If non-NULL, this argument should be an array
with an entry for each dimension of <TT>src</TT>. The stride values are
relative to the original source array, <TT>src</TT>, so the default
stride of one in each dimension is appropriate for cases where you
want a dense subsection of the original array.
</DD><DT CLASS="dt-description"><B>newLower</B></DT><DD CLASS="dd-description"> this argument is like the <TT>lower</TT> argument in a
create method. It sets the coordinates for the first element in the
new array. If this argument is NULL, the values indicated by
<TT>srcStart</TT> will be used. If non-NULL, this should be an array
with <TT>dimen</TT> elements.
</DD></DL><P>
Assuming the method is successful and the return value is named
newArray, <TT>src[srcStart]</TT> refers to the same underlying element
as <TT>newArray[newStart]</TT>.</P><P>If <TT>src</TT> is not a borrowed array (i. e., it manages its own data),
the returned array can manage its by keeping a reference to
<TT>src</TT>. It is not considered a borrowed array for purposes of
<TT>smartCopy</TT>.</P><H4 CLASS="subsubsection">Function: borrow</H4><P><A NAME="@default218"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_borrow(<B>double</B>*       firstElement,
                          int32_t       dimen,
                          <B>const</B> int32_t lower[],
                          <B>const</B> int32_t upper[],
                          <B>const</B> int32_t stride[]);
//
// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::borrow(<B>double</B>*       firstElement,
                            int32_t       dimen,
                            <B>const</B> int32_t lower[],
                            <B>const</B> int32_t upper[],
                            <B>const</B> int32_t stride[]);
C
C FORTRAN 77
       subroutine sidl_double__array_borrow_f(firstElement, dimen, lower,
     $      upper, stride, result)
       real*8 firstElement()
       integer*4 dimen, lower(dimen), upper(dimen), stride(dimen)
       integer*8 result
!
! FORTRAN 90
subroutine borrow(firstElement, dimen, lower, upper, stride, &amp;
                                    result)
  real (selected_real_kind(17,308)), intent(in) :: firstElement
  integer (selected_int_kind(9)), intent(in) :: dimen
  integer (selected_int_kind(9)), dimension(:), intent(in) :: lower, upper,&amp;
                                              stride
  type(sidl_double_1d), intent(out) :: result ! type depends on array dimension</TD></TR>
</TABLE><P>This method creates a proxy SIDL multi-dimensional array using data
provided by a third party. In some cases, this routine can be used to
avoid making a copy of the array data. <TT>dimen</TT>, <TT>lower</TT>, and
<TT>upper</TT> have the same meaning and constraints as in
<TT>SIDL_double__array_createCol</TT>. The <TT>firstElement</TT> argument
should be a pointer to the first element of the array; in this
context, the first element is the one whose index is <TT>lower</TT>.</P><P><TT>stride[i]</TT> specifies the signed offset from one element in
dimension <TT>i</TT> to the next element in dimension <TT>i</TT>. For a
one dimensional array, the first element has the address
<TT>firstElement</TT>, the second element has the address
<TT>firstElement + stride[0]</TT>, the third element has the address
<TT>firstElement + 2 * stride[0]</TT>, etc. The algorithm for
determining the address of the element in a multi-dimensional
array whose index is in array <TT>ind[]</TT> is as follows:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">int32_t* addr = firstElement;
<B>for</B>(<B>int</B> i = 0; i &lt; dimen; ++i) {
  addr += (ind[i] - lower[i])*stride[i];
}
<FONT COLOR="blue"><I>/* now addr is the address of element ind */</I></FONT></TD></TR>
</TABLE><P>Note elements of stride need not be positive.</P><P>The function makes copies of the information provided by <TT>dimen</TT>, 
<TT>lower</TT>, <TT>upper</TT>, and <TT>stride</TT>. 
The type of <TT>firstElement</TT> is changed depending on the array value type
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>).</P><H4 CLASS="subsubsection">Function: smartCopy</H4><P><A NAME="@default219"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array*
sidl_double__array_smartCopy(<B>struct</B> sidl_double__array *array);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::smartCopy();

C FORTRAN 77
       subroutine sidl_double__array_smartCopy_f(array, result)
       integer*8 array, result

! FORTRAN 90
subroutine smartCopy(array, result)
  type(sidl_double_1d), intent(in) :: array   ! type depends on dimension
  type(sidl_double_1d), intent(out) :: result ! type depends on dimension

// Java
  public native Array _smartCopy();</TD></TR>
</TABLE><P>This method will copy a borrowed array or increment the reference
count of an array that is able to manage its own data. This method is
useful when you want to keep a copy of an incoming array. The C++
method operates on <TT>this</TT>.</P><H4 CLASS="subsubsection">Function: addRef</H4><P><A NAME="@default220"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_addRef(<B>struct</B> sidl_double__array* array);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::addRef() throw ( NullIORException );

C FORTRAN 77
       subroutine sidl_double__array_addRef_f(array)
       integer*8 array

! FORTRAN 90
subroutine addRef(array)
  type(sidl_double_1d), intent(in) :: array ! type depends on array dimension</TD></TR>
</TABLE><P>This increments the reference count by one. In C++, this method
should be avoided because the C++ wrapper class manages the reference
count for you.</P><H4 CLASS="subsubsection">Function: deleteRef</H4><P><A NAME="@default221"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_deleteRef(<B>struct</B> sidl_double__array* array);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::deleteRef() throw ( NullIORException );

C FORTRAN 77
       subroutine sidl_double__array_deleteRef_f(array)
       integer*8 array

! FORTRAN 90
subroutine deleteRef(array)
  type(sidl_double_1d), intent(out) :: array ! type depends on dimension</TD></TR>
</TABLE><P>This decreases the reference count by one. If this reduces the
reference count to zero, the resources associated with the array are
reclaimed. In C++, this method should be avoided because the C++
wrapper class manages the reference count for you.</P><H4 CLASS="subsubsection">Function: get1</H4><P><A NAME="@default222"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get1(<B>const struct</B> sidl_double__array* array,
                        int32_t                          i1);

// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1);

C FORTRAN 77
       subroutine sidl_double__array_get1_f(array, i1, result)
       integer*8 array
       integer*4 i1
       real*8 result

! FORTRAN 90
subroutine get(array, i1, result)
  type(sidl_int_1d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i);</TD></TR>
</TABLE><P>This method returns the element with index <TT>i1</TT> for a one 
dimensional array. 
The return type of this method is the value type for the 
SIDL type being held (see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for one dimensional 
arrays. 
For objects and interfaces, the client owns the 
returned reference (i. e., the client is obliged to call
<TT>deleteRef()</TT> when they are done with the reference 
unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string 
(i. e., the client is obliged to call
free on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value 
cases when i1 is out of bounds.</P><H4 CLASS="subsubsection">Function: get2</H4><P><A NAME="@default223"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get2(<B>const struct</B> sidl_double__array* array,
                        int32_t                       i1,
                        int32_t                       i2);

// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1, int32_t i2);

C FORTRAN 77
       subroutine sidl_int__array_get2_f(array, i1, i2, result)
       integer*8 array
       integer*4 i1, i2
       real*8 result

! FORTRAN 90
subroutine get(array, i1, i2, result)
  type(sidl_int_2d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i, <B>int</B> j);</TD></TR>
</TABLE><P>This method returns the element with indices (<TT>i1</TT>, <TT>i2</TT>) for 
a two dimensional array. 
The return type of this method is the value type for the SIDL type being held 
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>.
This method must only be called for two dimensional arrays. 
For objects and interfaces, the client owns the returned reference 
(i. e., the client is obliged to
call <TT>deleteRef</TT> when they are done with the reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string 
(i. e., the client is obliged to call
free on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when 
<TT>i1</TT>, <TT>i2</TT> are out of bounds.</P><H4 CLASS="subsubsection">Function: get3</H4><P><A NAME="@default224"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get3(<B>const struct</B> sidl_double__array* array,
                        int32_t                          i1,
                        int32_t                          i2,
                        int32_t                          i3);
// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1, int32_t i2, int32_t i3);

C FORTRAN 77
       subroutine sidl_double__array_get3_f(array, i1, i2, i3, result)
       integer*8 array
       integer*4 i1, i2, i3
       real*8 result

! FORTRAN 90
subroutine get(array, i1, i2, i3, result)
  type(sidl_double_3d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i, <B>int</B> j, <B>int</B> k);</TD></TR>
</TABLE><P>This method returns the element with indices (<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>) for
a three dimensional array. 
The return type of this method is the value type for the SIDL type being held
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for three dimensional arrays. 
For objects and interfaces, the client owns the returned reference (i. e., the client is
obliged to call <TT>deleteRef()</TT> when they are done with the 
reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string (i. e., the client is
obliged to call <TT>free()</TT> on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when i1, i2, i3 
are out of bounds.</P><H4 CLASS="subsubsection">Function: get4</H4><P><A NAME="@default225"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get4(<B>const struct</B> sidl_double__array* array,
                     int32_t                       i1,
                     int32_t                       i2,
                     int32_t                       i3,
                     int32_t                       i4);
// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(int32_t i1, int32_t i2, int32_t i3, int32_t i4);

C FORTRAN 77
       subroutine sidl_double__array_get4_f(array, i1, i2, i3, i4, result)
       integer*8 array
       integer*4 i1, i2, i3, i4
       real*8 result

! FORTRAN 90
subroutine get(array, i1, i2, i3, i4, result)
  type(sidl_double_4d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3, i4
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public <B>double</B> get(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l);</TD></TR>
</TABLE><P>This method returns the element with indices(<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>, <TT>i4</TT>) 
for a four dimensional array. 
The return type of this method is the value type for the SIDL type being
held (see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for four dimensional arrays. 
For objects and interfaces, the client owns the returned reference 
(i. e., the client is
obliged to call <TT>deleteRef()</TT> when they are done with the 
reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string (i. e., the client is
obliged to call <TT>free()</TT> on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when 
<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>, or <TT>i4</TT> are out of bounds.</P><H4 CLASS="subsubsection">Function: get5-7</H4><P><A NAME="@default226"></A></P><P>Methods <TT>get5</TT>–<TT>get7</TT> are defined in an analogous way.</P><H4 CLASS="subsubsection">Function: get</H4><P><A NAME="@default227"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B>
sidl_double__array_get(<B>const struct</B> sidl_double__array* array,
                    <B>const</B> int32_t                 indices[]);

// C++
<B>double</B>
sidl::array&lt;<B>double</B>&gt;::get(<B>const</B> int32_t indices[]);

C FORTRAN 77
       subroutine sidl_double__array_get_f(array, indices, result)
       integer*8 array
       integer*4 indices()
       real*8 result

! FORTRAN 90
subroutine get(array, indices, result)
  type(sidl_real_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)), dimension(:), intent(in) ::indices
  real (selected_real_kind(17,308)), intent(out) :: result

// Java
  public native <B>double</B> _get(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l, <B>int</B> m, <B>int</B> n, <B>int</B> o);</TD></TR>
</TABLE><P>This method returns the element whose index is indices for an array of any dimension. 
The return type of this method is the value type for the SIDL type being held
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method can be called for any positively dimensioned array. 
For objects and interfaces, the client owns the returned reference 
(i. e., the client is obliged to call <TT>deleteRef()</TT> when they are 
done with the reference unless it is <TT>NULL</TT>). 
For arrays of strings, the client owns the returned string (i. e., the client is
obliged to call <TT>free()</TT> on the returned pointer unless it is <TT>NULL</TT>). 
There is no reliable way to determine from the return value cases when indices
has an element out of bounds.</P><H4 CLASS="subsubsection">Function: set1</H4><P><A NAME="@default228"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set1(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        <B>double</B>                     value));

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set1_f(array, i1, value)
       integer*8 array
       integer*4 i1
       real*8 value

! FORTRAN 90
subroutine set(array, i1, value)
  type(sidl_double_1d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1,
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index <TT>i1</TT> of a one dimensional array to value. 
The type of the argument value is the value type for the SIDL type being held 
(see Table <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for one dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by calling
<TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string, 
so the client retains ownership of the value pointer.</P><H4 CLASS="subsubsection">Function: set2</H4><P><A NAME="@default229"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set2(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        int32_t                    i2,
                        <B>double</B>                     value));

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, int32_t i2, <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set2_f(array, i1, i2, value)
       integer*8 array
       integer*4 i1, i2
       real*8 value

! FORTRAN 90
subroutine set(array, i1, i2, value)
  type(sidl_int_2d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>int</B> j, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index (<TT>i1</TT>, <TT>i2</TT>) of 
a two dimensional array to value. 
The type of the argument value is the value type for the SIDL type being held (see
table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for two dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by calling
<TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string, 
so the client retains ownership of the value pointer.</P><H4 CLASS="subsubsection">Function: set3</H4><P><A NAME="@default230"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set3(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        int32_t                    i2,
                        int32_t                    i3,
                        <B>double</B>                     value));

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, int32_t i2, int32_t i3, <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set3_f(array, i1, i2, i3, value)
       integer*8 array
       integer*4 i1, i2, i3
       real*8 value

! FORTRAN 90
subroutine set(array, i1, i2, i3, value)
  type(sidl_double_3d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index (<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>) 
of a three dimensional array to value. 
The type of the argument value is the value type for the SIDL type being held
(see table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for three dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by calling
<TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string,
so the client retains ownership of the value pointer.</P><H4 CLASS="subsubsection">Function: set4</H4><P><A NAME="@default231"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set4(<B>struct</B> sidl_double__array* array,
                        int32_t                    i1,
                        int32_t                    i2,
                        int32_t                    i3,
                        int32_t                    i4,
                        <B>double</B>                     value));
//
// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(int32_t i1, int32_t i2,
                         int32_t i3, int32_t i4, <B>double</B> value);
C
C FORTRAN 77
       subroutine sidl_double__array_set4_f(array, i1, i2, i3, i4, value)
       integer*8 array
       integer*4 i1, i2, i3, i4
       real*8 value
!
! FORTRAN 90
subroutine set(array, i1, i2, i3, i4, value)
  type(sidl_double_4d), intent(in) :: array
  integer (selected_int_kind(9)), intent(in) :: i1, i2, i3, i4
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public <B>void</B> set(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l, <B>double</B> value) {</TD></TR>
</TABLE><P>This method sets the value in index (<TT>i1</TT>, <TT>i2</TT>, <TT>i3</TT>, <TT>i4</TT>) 
of a four dimensional array to value. 
The type of the argument value is the value type for the SIDL type being
held (see table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
This method must only be called for four dimensional arrays. 
For arrays of objects and interfaces, the array will make its own reference by
calling <TT>addRef()</TT> on value, so the client retains its reference to value. 
For arrays of strings, the array will make a copy of the string, 
so the client retains ownership of the value pointer.</P><H4 CLASS="subsubsection">Function: set5-7</H4><P><A NAME="@default232"></A></P><P>Methods <TT>set5</TT>–<TT>set7</TT> are defined in an analogous way.</P><H4 CLASS="subsubsection">Function: set</H4><P><A NAME="@default233"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_set(<B>struct</B> sidl_double__array* array,
                       <B>const</B> int32_t              indices[],
                       <B>double</B>                     value);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::set(<B>const</B> int32_t indices[], <B>double</B> value);

C FORTRAN 77
       subroutine sidl_double__array_set_f(array, indices, value)
       integer*8 array
       integer*4 indices()
       real*8 value

! FORTRAN 90
subroutine set(array, indices, value)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)), intent(in), dimension(:) :: indices
  real (selected_real_kind(17,308)), intent(in) :: value

// Java
  public native <B>void</B> _set(<B>int</B> i, <B>int</B> j, <B>int</B> k, <B>int</B> l, <B>int</B> m, <B>int</B> n,
                          <B>int</B> o, <B>double</B> value);</TD></TR>
</TABLE><P>This method sets the value in index indices for an array of any dimension to value. 
The type of the argument value is the value type for the SIDL type being held (see
table  <A HREF="#tbl:basics:arraytypes">6.2</A>). 
For arrays of objects and interfaces, the array will make its own reference 
by calling <TT>addRef()</TT> on value, so the client retains its reference to value.
For arrays of strings, the array will make a copy of the string, so the client 
retains ownership of the value pointer.</P><H4 CLASS="subsubsection">Function: dimen</H4><P><A NAME="@default234"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_dimen(<B>const struct</B> sidl_double__array *array);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::dimen() <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_dimen_f(array, result)
       integer*8 array
       integer*4 result

! FORTRAN 90
integer (selected_int_kind(9)) dimen(array)
  type(sidl_double_1d) :: array ! type depends on dimension

// Java
public native <B>int</B> _dim();</TD></TR>
</TABLE><P>This method returns the dimension of the array.</P><H4 CLASS="subsubsection">Function: lower</H4><P><A NAME="@default235"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_lower(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::lower(int32_t ind) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_lower_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function lower(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)) :: ind

// Java
  public native <B>int</B> _lower(<B>int</B> dim);</TD></TR>
</TABLE><P>This method returns the lower bound on the index for dimension <TT>ind</TT> of array.</P><H4 CLASS="subsubsection">Function: upper</H4><P><A NAME="@default236"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_upper(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::upper(int32_t ind) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_upper_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function upper(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)), intent(in) :: ind

// Java
  public native <B>int</B> _upper(<B>int</B> dim);</TD></TR>
</TABLE><P>This method returns the upper bound on the index for dimension ind of array. 
If the upper bound is greater than or equal to the lower bound, the upper bound is a valid
index (i. e., it is not one past the end).</P><H4 CLASS="subsubsection">Function: stride</H4><P><A NAME="@default237"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_stride(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++
int32_t
sidl::array&lt;<B>double</B>&gt;::stride(int32_t ind) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_stride_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function stride(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)) :: ind

// Java
  public native <B>int</B> _stride(<B>int</B> dim);</TD></TR>
</TABLE><P>This method returns the stride for a particular dimension. This
stride indicates how much to add to a pointer to get for the current
element this the particular dimension to the next.</P><H4 CLASS="subsubsection">Function: length</H4><P><A NAME="@default238"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
int32_t
sidl_double__array_length(<B>const struct</B> sidl_double__array *array, int32_t ind);

// C++ Default dimension is 1.
int32_t
sidl::array&lt;int32_t&gt;::length(int32_t ind = 0) <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_length_f(array, ind, result)
       integer*8 array
       integer*4 ind, result

! FORTRAN 90
integer (selected_int_kind(9)) function length(array, ind)
  type(sidl_double_1d), intent(in) :: array ! type depends on dimension
  integer (selected_int_kind(9)) :: ind

// Java
  public native <B>int</B> _length(<B>int</B> dim);

// For one dimensional Java arrays. Array1:
  public <B>int</B> lenth();</TD></TR>
</TABLE><P>This method returns the length for a particular dimension. It is
equivalent to the statement <TT>upper(dim) - lower(dim) + 1</TT>.</P><P>There is also a shortcut for one-dimensional arrays available in C++ 
and Java. In C++, if <TT>length</TT> is called with no arguments, it
defaults to the first dimension. In Java <TT>Array1</TT>
one-dimensional Java arrays have a length function that takes no arguments.</P><H4 CLASS="subsubsection">Function: isColumnOrder</H4><P><A NAME="@default239"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
sidl_bool
sidl_double__array_isColumnOrder(<B>const struct</B> sidl_double__array *array);

// C++
bool
sidl::array&lt;<B>double</B>&gt;::isColumnOrder() <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_isColumnOrder_f(array, result)
       integer*8 array
       logical   result

! FORTRAN 90
logical function isColumnOrder(array)
  type(sidl_double_2d), intent(in) :: array ! type depends on dimension

// Java
  public native boolean _isColumnOrder();</TD></TR>
</TABLE><P>This method returns a true value if and only if <TT>array</TT> is dense,
column-major ordered array. It does not modify the array at all.</P><H4 CLASS="subsubsection">Function: isRowOrder</H4><P><A NAME="@default240"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
sidl_bool
sidl_double__array_isRowOrder(<B>const struct</B> sidl_double__array *array);

// C++
bool
sidl::array&lt;<B>double</B>&gt;::isRowOrder() <B>const</B>;

C FORTRAN 77
       subroutine sidl_double__array_isRowOrder_f(array, result)
       integer*8 array
       logical   result

! FORTRAN 90
logical function isRowOrder(array)
  type(sidl_double_1d), intent(<B>int</B>) :: array ! type depends on dimension

// Java
  public native boolean _isRowOrder();</TD></TR>
</TABLE><P>This method returns a true value if and only if <TT>array</TT> is dense,
row-major ordered array. It does not modify the array at all.</P><H4 CLASS="subsubsection">Function: copy</H4><P><A NAME="@default241"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>void</B>
sidl_double__array_copy(<B>const struct</B> sidl_double__array *src
                              <B>struct</B> sidl_double__array *dest);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::copy(<B>const</B> sidl::array&lt;<B>double</B>&gt; &amp;src);

C FORTRAN 77
       subroutine sidl_double__array_copy_f(array, dest)
       integer*8 array, dest

! FORTRAN 90
subroutine copy(array, dest)
  type(sidl_double_1d), intent(in) :: array ! type depends on array dimension
  type(sidl_double_1d), intent(in) :: dest  ! type depends on array dimension

// Java
  public <B>void</B> _copy(sidl.Double.Array dest);</TD></TR>
</TABLE><P>This method copies the contents of <TT>src</TT> to <TT>dest</TT>. For the
copy to take place, both arrays must exist and be of the same
dimension. This method will not modify <TT>dest</TT>’s size, index
bounds, or stride; only the array element values of <TT>dest</TT> may be
changed by this function. No part of <TT>src</TT> is changed by this
method.</P><P>If <TT>dest</TT> has different index bounds than <TT>src</TT>, this method
only copies the elements where the two arrays overlap. If <TT>dest</TT>
and <TT>src</TT> have no indices in common, nothing is copied. For
example, if <TT>src</TT> is a 1-d array with elements 0-5 and dest is a
1-d array with element 2-3, this function will copy element 2 and 3
from <TT>src</TT> to <TT>dest</TT>. If <TT>dest</TT> had elements 4-10,
this method could copy elements 4 and 5.</P><H4 CLASS="subsubsection">Function: ensure</H4><P><A NAME="@default242"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>struct</B> sidl_double__array *
sidl_double__array_ensure(<B>const struct</B> sidl_double__array *src,
                          int32_t                          dimen,
                          <B>int</B>                              ordering);

// C++
<B>void</B>
sidl::array&lt;<B>double</B>&gt;::ensure(int32_t dimen, <B>int</B> ordering);

C FORTRAN 77
       subroutine sidl_double__array_ensure_f(src, dimen, ordering, result)
       integer*8 src, result
       integer*4 dimen, ordering

! FORTRAN 90
subroutine ensure(src, dimen, ordering, result)
   type(sidl_double_1d), intent(in) :: src    ! type depends on array dimension
   type(sidl_double_1d), intent(out) :: result! type depends on array dimension
   integer (selected_int_kind(9)) :: dimen, ordering</TD></TR>
</TABLE><P>This method is used to obtain a matrix with a guaranteed ordering and
dimension from an array with uncertain properties. If the incoming
array has the required ordering and dimension, its reference count is
incremented, and it is returned. If it doesn’t, a copy with the
correct ordering is created and returned. In either case, the caller
knows that the returned matrix (if not NULL) has the desired
properties.</P><P>This method is used internally to enforce the array ordering
constraints in SIDL. Clients can use it in similar ways. However,
because the method was intended as an internal Babel feature, 
is not available in Java or Python.</P><P>The ordering parameter should be one of the constants defined in
<TT>enum sidl_array_ordering</TT> (e. g.<BR>
<TT>sidl_general_order</TT>,
<TT>sidl_column_major_order</TT>, or <TT>sidl_row_major_order</TT>). If
you pass in<BR>
<TT>sidl_general_order</TT>, this routine will only check
the dimension of the matrix.</P><H4 CLASS="subsubsection">Function: first</H4><P><A NAME="@default243"></A></P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR="blue"><I>/* C */</I></FONT>
<B>double</B> *
sidl_double__array_first(<B>const struct</B> sidl_double__array *src);

// C++
<B>double</B>* first() throw();

C FORTRAN 77
      subroutine sidl_double__array_access_f(array, ref, lower, upper,
     $   stride, index)
      integer*8 array, index
      integer*4 lower(), upper(), stride()
      integer*4 ref()</TD></TR>
</TABLE><P>This method provides direct access to the element data. Using this
pointer and the stride information, you can perform your own array
accesses without function calls. This method isn’t available for
arrays of strings, interface and objects because of memory/reference
management issues. There is no equivalent of this
function in Java or Python. To see how to get direct array access in
Fortran 90/95, see Chapter <A HREF="index013.html#c:f90">11</A>.<A NAME="@default244"></A><A NAME="@default245"></A></P><P>The Fortran versions of the method return the lower, upper and
stride information in three arrays, each with enough elements to hold
an entry for each dimension of <TT>array</TT>. Because <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> does
not have pointers, you must pass in a reference array, <TT>array</TT>.
Upon exit, <TT>ref(index)</TT> is the first element of the array. The
type of <TT>ref</TT> depends on the type of the array.</P><HR SIZE=2><BLOCKQUOTE CLASS="quotation"><DIV CLASS="marginpar marginparright">WARNING:</DIV>
<A NAME="@default246"></A><A NAME="@default247"></A>
While calling the Fortran direct access routines, there is a
possibility of an alignment error between your reference pointer,
<TT>ref</TT>, and the pointer to the first element of the array data.
The problem is more likely with arrays of <TT>double</TT> or
<TT>dcomplex</TT>; although, it could occur with any type on some future
platform. If <TT>index</TT> is zero on return, an alignment error
occurred. If an alignment error occurs, you may be able to solve it
by recompiling your Fortran files with flags to force doubles to be
aligned on 8 byte boundaries. For example, the <TT>-malign-double</TT>
flag for g77 forces doubles to be aligned on 64-bit boundaries. An
alignment error occurs when <TT>(char *)ref</TT> minus <TT>(char
*)sidl_double__array_first(array)</TT> is not integer divisible by
<TT>sizeof(datatype)</TT> where <TT>ref</TT> refers to the address of the
reference array.
</BLOCKQUOTE><HR SIZE=2><P><BR>

Here is an example <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> subroutine to output each element of
a <A NAME="@default248"></A> 
1-dimensional array of doubles using the direct access
routine. Fortran 90/95 has a pointer in the array derived type when
direct access is possible.</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">C This subroutine will print each element of an array of doubles
      subroutine print_array(dblarray)
      implicit none
      integer*8 dblarray, index
      real*8 refarray(1)
      integer*4 lower(1), upper(1), stride(1), dimen, i
      if (dblarray .ne. 0) then
         call sidl_double__array_dimen_f(dblarray, dimen)
         if (dimen .eq. 1) then
            call sidl_double__array_access_f(dblarray, refarray,
     $           lower, upper, stride, index)
            if (index .ne. 0) then
               do i = lower(1), upper(1)
                  write(*,*) refarray(index + (i-lower(1))*stride(1))
               enddo
            else
               write(*,*) 'Alignment error occured'
            endif
         endif
      endif
      end</TD></TR>
</TABLE><P>For a 2-dimensional array, the loop and array access is</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      do i = lower(1), upper(1)
         do j = lower(2), upper(2)
            write(*,*) refarray(index+(i-lower(1))*stride(1)+
     $           (j - lower(2))*stride(2))
         enddo
      enddo</TD></TR>
</TABLE><P>Suppose you are wrapping a legacy Fortran application and you need to
pass a SIDL array to a Fortran subroutine. Further suppose there is
a <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> and Fortran 90/95 version of the subroutine. For example,
the <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> subroutine has a signature such as:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">      subroutine TriedAndTrue(x, n)
      integer n
      real*8 x(n)
C insert wonderful, efficient, debugged code here
      end</TD></TR>
</TABLE><P>The Fortran 90/95 subroutine has basically the same signature as follows:
<A NAME="@default249"></A> 
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">subroutine TriedAndTrue(x, n)
  integer (selected_int_kind(9))     :: n
  real (selected_real_kind(17, 308)) :: x(n)

  <FONT COLOR="blue"><I>! insert wonderful, efficient, debugged code here</I></FONT>
end subroutine TriedAndTrue</TD></TR>
</TABLE><P>Here is one way to wrap this method using SIDL. First of all, the
SIDL method definition specifies that the array must be a
1-dimensional, column-major ordered array. This forces the incoming
array to be a dense column.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    <FONT COLOR=maroon><I><B>static void</B> TriedAndTrue(<B>inout array</B>&lt;<B>double</B>,1,column-major&gt; arg);</I></FONT></TD></TR>
</TABLE><P>Given that method definition in a class named Class and a package
named Pkg, the implementation of the wrapper should look something
like the following for <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>:</P><DIV CLASS="flushright"><FONT COLOR=purple><B><SPAN CLASS="textboxed"><SPAN STYLE="font-variant:small-caps">fortran</SPAN> 77</SPAN></B></FONT></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">        subroutine Pkg_Class_TriedAndTrue_fi(arg)
        implicit none
        integer*8 arg
C       DO-NOT-DELETE splicer.begin(Pkg.Class.TriedAndTrue)
        real*8 refarray(1)
        integer*4 lower(1), upper(1), stride(1)
        integer*8 index
        integer n
        call sidl_double__array_access_f(arg, refarray,
     $       lower, upper, stride, index)
        if (index .ne. 0) then
c we can assume stride(1) = 1 because of column-major specification
           n = 1 + upper(1) - lower(1)
           call TriedAndTrue(refarray(index), n)
        else
           write(*,*) 'ERROR: array alignment'
        endif
C       DO-NOT-DELETE splicer.end(Pkg.Class.TriedAndTrue)
        end</TD></TR>
</TABLE><P>Similarly, it should look something like the following for Fortran 90/95, where
the include statements are required at the top of the “Impl” file to ensure
proper handling of subroutine names that have automatically been mangled
by the Babel compiler:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>Fortran 90/95</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">#<B>include</B> "Pkg_Class_fAbbrev.h"
#<B>include</B> "sidl_BaseClass_fAbbrev.h"
#<B>include</B> "sidl_BaseInterface_fAbbrev.h"
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(_miscellaneous_code_start)</I></FONT>
#<B>include</B> "sidl_double_fAbbrev.h"
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(_miscellaneous_code_start)</I></FONT>
.
.
.
subroutine Pkg_Class_TriedAndTrue_mi(arg)
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Pkg.Class.TriedAndTrue.use)</I></FONT>
  <B>use</B> SIDL_double_array
  <FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Pkg.Class.TriedAndTrue.use)</I></FONT>
  implicit <B>none</B>
  type(sidl_double_a) :: arg

<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.begin(Pkg.Class.TriedAndTrue)</I></FONT>
  real (selected_real_kind(17,308)), dimension(1) :: refarray
  integer (selected_int_kind(8)), dimension(1)    :: low, up, str
  integer (selected_int_kind(8))    :: index, n
  call access(arg, refarray, low, up, str, index)
  if (index .ne. 0) then
    <FONT COLOR="blue"><I>! We can assume stride(1) = 1 because of column-major specification</I></FONT>
    n = 1 + upper(1) - lower(1)
    call TriedAndTrue(refarray(index), n)
  else
    write(*,*) 'ERROR: array alignment'
  <B>endif</B>
<FONT COLOR="blue"><I>! DO-NOT-DELETE splicer.end(Pkg.Class.TriedAndTrue)</I></FONT>
end subroutine Pkg_Class_TriedAndTrue_mi</TD></TR>
</TABLE><H3 CLASS="subsection">The C Macro API</H3><P><A NAME="@default250"></A><A NAME="@default251"></A></P><P>Many of the SIDL array access functions have a corresponding C macro 
API for those who fear the function overhead of the C function API. 
When efficiency is not a concern, we recommend using the function API, 
but the C macro API is preferable to the direct access to the data structure. 
Parts of the macro API are not available for arrays of strings,
interfaces or objects because the issues associated with memory and
object reference management.</P><P>The macro API is very similar to the function API; however, 
a single set of macros applies to all the supported array types. 
The macro names are independent of the type of array you’re accessing.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlArrayDim(array)</TD></TR>
</TABLE><P>
<A NAME="@default252"></A><A NAME="@default253"></A>
Return the dimension of array.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlLower(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default254"></A><A NAME="@default255"></A>
Return the lower bound on dimension ind.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlUpper(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default256"></A><A NAME="@default257"></A>
Return the upper bound on dimension ind.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlLength(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default258"></A><A NAME="@default259"></A>
Return the extent on dimension ind. The extent is equal to
<TT>sidlUpper(array,ind) - sidlLower(array,ind) + 1</TT>.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlStride(array,ind)</TD></TR>
</TABLE><P>
<A NAME="@default260"></A><A NAME="@default261"></A>
Return the stride for dimension ind. 
The stride is the offset between elements in a particular dimension. 
It can be positive or negative. It is in terms of number of value
types (i. e., it’s 1 means contiguous regardless of what data type).</P><P>The macros to access array elements of array elements
are unavailable for arrays of strings, classes and interfaces.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlArrayElem1(array, ind1)
sidlArrayElem2(array, ind1, ind2)
sidlArrayElem3(array, ind1, ind2, ind3)
sidlArrayElem4(array, ind1, ind2, ind3, ind4)
sidlArrayElem5(array, ind1, ind2, ind3, ind4, ind5)
sidlArrayElem6(array, ind1, ind2, ind3, ind4, ind5, ind6)
sidlArrayElem7(array, ind1, ind2, ind3, ind4, ind5, ind6, ind7)</TD></TR>
</TABLE><P>
<A NAME="@default262"></A><A NAME="@default263"></A>
Provide access to array elements to arrays of dimension 1–7. This
macro can appear on the left hand side of an assignment or on the
right hand side in an expression. These macros blindly assume that
the dimension and indices are correct.</P><P>The macros to access the address of array elements are unavailable for
arrays of strings, classes, and interfaces.
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">sidlArrayAddr1(array, ind1)
sidlArrayAddr2(array, ind1, ind2)
sidlArrayAddr3(array, ind1, ind2, ind3)
sidlArrayAddr4(array, ind1, ind2, ind3, ind4)
sidlArrayAddr5(array, ind1, ind2, ind3, ind4, ind5)
sidlArrayAddr6(array, ind1, ind2, ind3, ind4, ind5, ind6)
sidlArrayAddr7(array, ind1, ind2, ind3, ind4, ind5, ind6, ind7)</TD></TR>
</TABLE><P>
<A NAME="@default264"></A><A NAME="@default265"></A>
Return the address of elements in arrays of dimension 1–7. This
macro can appear on the left hand side of an assignment or on the
right hand side in an expression. These macros blindly assume that
the dimension and indices are correct.</P><H3 CLASS="subsection">The C Data Structure</H3><P>
<A NAME="@default266"></A><A NAME="@default267"></A></P><P>If even the macro interface is not fast enough for you, 
you can access the internal data structure for all the basic types except string. 
You cannot access the internal data structure for arrays of strings, 
interfaces and objects.</P><P>The basic form of the C data structure for type XXXX is:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>ANSI C</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><B>struct</B> sidl__array_vtable {

  <FONT COLOR="blue"><I>/* Release resources associted with the array (refcount at zero) */</I></FONT>
  <B>void</B> (*d_destroy)(<B>struct</B> sidl__array *);

  <FONT COLOR="blue"><I>/* Clone or addRef depending on whether data is borrowed */</I></FONT>
  <B>struct</B> sidl__array *(*d_smartcopy)(<B>struct</B> sidl__array *);

  <FONT COLOR="blue"><I>/* Return the type of the array. */</I></FONT>
  int32_t (*d_arraytype)(<B>void</B>);
};

<B>struct</B> sidl__array {
  int32_t                         *d_lower;
  int32_t                         *d_upper;
  int32_t                         *d_stride;
  <B>const struct</B> sidl__array_vtable *d_vtable;
  int32_t                          d_dimen;
  int32_t                          d_refcount;
};


<B>struct</B> sidl_XXXX__array {
  <B>struct</B> sidl__array       d_metadata;
  &lt;value type <B>for</B> XXXX&gt;   *d_firstElement;
};</TD></TR>
</TABLE><P>The string “&lt;value type for XXXX&gt;” should be replaced by something like 
<TT>sidl_bool</TT>for an array of <FONT COLOR=maroon><I><TT>bool</TT></I></FONT>, 
<TT>int32_t</TT> for any array of <FONT COLOR=maroon><I><TT>int</TT></I></FONT>, 
<TT>double</TT> for an array of <FONT COLOR=maroon><I><TT>double</TT></I></FONT>, 
<TT>int64_t</TT> for an array of <FONT COLOR=maroon><I><TT>long</TT></I></FONT>, etc. (See Table <A HREF="#tbl:basics:arraytypes">6.2</A>)</P><DL CLASS="description"><DT CLASS="dt-description">
<TT><B>d_dimen</B></TT></DT><DD CLASS="dd-description"> tells the dimension of the multi-dimensional array. 
<TT>d_lower</TT>, <TT>d_upper</TT>, and <TT>d_stride</TT> each point to arrays 
of <TT>d_dimen int32_t</TT>’s. <TT>d_lower[i]</TT> provides the lower bound 
for the index in dimension <TT>i</TT>, and <TT>d_upper[i]</TT> provides the upper 
bound for the index in dimension <TT>i</TT>. Both the lower and upper bounds 
are valid index values; the upper bound is not one past the end.</DD><DT CLASS="dt-description"><TT><B>d_borrowed</B></TT></DT><DD CLASS="dd-description"> is true if the array does not managed the data 
that <TT>d_firstElement</TT> points too, and it is false otherwise. This 
mainly influences the behavior of the destructor.<P>Clients should not modify <TT>d_lower</TT>, <TT>d_upper</TT>, <TT>d_stride</TT>, 
<TT>d_dimen</TT>, <TT>d_borrowed</TT> or (in the case of pointers) the values 
to which they point.</P></DD><DT CLASS="dt-description"><TT><B>d_stride[i]</B></TT></DT><DD CLASS="dd-description"> determines how elements are packed in dimension 
<TT>i</TT>. A value of 1 means that to get from element <TT>j</TT> to <TT>j+1</TT> 
in dimension <TT>i</TT>, you add one to the data pointer. Negative values for 
<TT>d_stride</TT> can be used to express a transposed matrix. The definition 
also allows either column or row major ordering for the data, and it also 
allows treating a subsection of an array as an array.</DD></DL><P>The data structure was inspired by the data structure used by Numeric Python; 
although, in Numeric Python, the stride is in terms of bytes. In SIDL, the 
stride is in terms of number of objects. One can convert to the Numeric 
Python view of things by multiplying the stride by the sizeof the value type.</P><H2 CLASS="section"><A NAME="toc26"></A><A NAME="htoc26">6.5</A>  Interface Contracts</H2><P><A NAME="s:ifc_contracts"></A>
<A NAME="@default268"></A>
<A NAME="@default269"></A></P><P>Interface contracts define behaviors expected of callers (or clients) 
and callees (or servers) of methods.
These behaviors are specified within clauses of SIDL interfaces
and classes and may be checked at runtime through options used to establish
an enforcement policy. 
Executable interface contracts thereby provide a mechanism for helping 
ensure software is implemented and used correctly.
This section focuses on specification basics and traditional interface 
contract enforcement options.</P><H3 CLASS="subsection">Contract Clauses</H3><P><A NAME="ss:intro_contract_clauses"></A>
<EM>Contract clauses</EM> define constraints on properties of methods (including 
argument and return 
values)<SUP><A NAME="text10" HREF="#note10">2</A></SUP> and objects.
Babel supports three types of clauses using SIDL syntax borrowed from 
Eiffel [<A ></A>]. 
Those clauses are:
preconditions,
<A NAME="@default270"></A>
<A NAME="@default271"></A><A NAME="@default272"></A>
postconditions,
<A NAME="@default273"></A>
<A NAME="@default274"></A><A NAME="@default275"></A> and
class invariants.
<A NAME="@default276"></A>
<A NAME="@default277"></A><A NAME="@default278"></A></P><P>Each clause corresponds to a different set of enforcement points.
<EM>Precondition</EM>
<A NAME="@default279"></A>
<A NAME="@default280"></A><A NAME="@default281"></A> 
and <EM>postcondition</EM>
<A NAME="@default282"></A>
<A NAME="@default283"></A><A NAME="@default284"></A> 
clauses are specified on a method basis.
A <EM>precondition</EM> declares constraints on invocation of a method while
a <EM>postcondition</EM> constrains its effects. In some cases, there may
be properties needing to hold throughout the life of an instance of a
class. 
Rather than require the assertions be specified in the precondition and 
postcondition clauses of every method, the 
<EM>class invariant</EM>
<A NAME="@default285"></A>
<A NAME="@default286"></A><A NAME="@default287"></A> 
clause, which can also be specified on interfaces, should be used.</P><P>The general structure of a SIDL method specification is provided below.
The specification defines the method signature; that is, it provides 
the name, parameter list, return type, and any exceptions thrown (or raised) 
by the method.
The SIDL specification can also include the definition of preconditions in 
the <TT>require</TT> clause and postconditions in the <TT>ensure</TT> clause.</P><P><A NAME="@default288"></A><A NAME="@default289"></A>
<A NAME="@default290"></A>
<A NAME="@default291"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">    [&lt;type&gt;] &lt;identifier&gt; ( [&lt;parameters&gt;] ) [throws &lt;exception&gt;];
      [require &lt;contract-clause-expressions&gt;]
      [ensure &lt;contract-clause-expressions&gt;]</TD></TR>
</TABLE><P>When contract clauses are added to the specification, each method’s 
<TT>throws</TT> clause <EM>must</EM> explicitly list the appropriate 
contract clause violation exception.
The exceptions, as defined in <TT>sidl.sidl</TT>, are shown below.
The need for explicitly declaring the exceptions is based on Babel’s current 
SIDL-to-C++ exceptions mapping in the generated middleware.</P><P><A NAME="@default292"></A>
<A NAME="@default293"></A>
<A NAME="@default294"></A>
<A NAME="@default295"></A>
<A NAME="@default296"></A>
<A NAME="@default297"></A>
<A NAME="@default298"></A>
<A NAME="@default299"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;PreViolation&lt;/code&gt; indicates an assertion within a precondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PreViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {}

  /**
   * &lt;code&gt;PostViolation&lt;/code&gt; indicates an assertion within a postcondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PostViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {}

  /**
   * &lt;code&gt;InvViolation&lt;/code&gt; indicates an assertion within a invariant
   * clause of the interface contract has been violated.
   */
  <B>class</B> InvViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }</I></FONT></TD></TR>
</TABLE><P>The basic structure of a contract clause, including the clause type
(i. e., <TT>require</TT>, <TT>ensure</TT>, or <TT>invariants</TT>),
<A NAME="@default300"></A><A NAME="@default301"></A><A NAME="@default302"></A>
is provided below.
Each clause, when present, contains a list of assertions. 
Each assertion may be preceded by a label. 
The label serves two purposes. First, if thoughtfully written, it provides 
a succinct “description” of the purpose of the assertion in the specification.
Second, through its automatic inclusion in the exception message of a violated
contract, the label helps identify the offended assertion.</P><P><A NAME="@default303"></A>
<A NAME="@default304"></A>

</P><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">   &lt;clause-type&gt;
      [label-1:]  &lt;assertion-expression-1&gt;;
     [[label-2:]  &lt;assertion-expression-2&gt;;
                           ...
      [label-n:]  &lt;assertion-expression-n&gt;;]</TD></TR>
</TABLE><P>For example, the SIDL specification of a vector dot product method with a 
contract is:</P><P><A NAME="@default305"></A>
<A NAME="@default306"></A>
<A NAME="@default307"></A>
<A NAME="@default308"></A><A NAME="@default309"></A>
<A NAME="@default310"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>/**
 * Return the dot (, inner, or scalar) product of the specified vectors.
 */
<B>double</B> vuDot(<B>in array</B>&lt;<B>double</B>&gt; u, <B>in array</B>&lt;<B>double</B>&gt; v, <B>in double</B> tol)
  <B>throws</B>
     sidl.PreViolation, sidl.PostViolation;
  <B>require</B>
     not_null_u : u != null;
     u_is_1d : dimen(u) == 1;
     not_null_v : v != null;
     v_is_1d : dimen(v) == 1;
     same_size : size(u) == size(v);
     non_neg_tolerance : tol &gt;= 0.0;
  <B>ensure</B>
     no_side_effects : is pure;
     vuAreEqual(u, v, tol) implies (result &gt;= 0.0);
     (vuIsZero(u, tol) and vuIsZero(v, tol))
       implies nearEqual(result, 0.0, tol);</I></FONT></TD></TR>
</TABLE><P>This specification includes both precondition and postcondition 
clauses.
The precondition clause, identified by <TT>require</TT>, contains six 
executable assertions. 
The first five assertions require the two normal SIDL arrays,
<TT>u</TT> and <TT>v</TT>, be non-null, one-dimensional arrays of the same 
size. The fifth assertion requires the tolerance argument, <TT>tol</TT>, 
be non-negative. 
The postconditions clause, identified by <TT>ensure</TT>, contains three 
assertions.
The <TT>is pure</TT> assertion indicates implementations <EM>should</EM> be 
side-effect free<SUP><A NAME="text11" HREF="#note11">3</A></SUP>.
This allows the method to be included in the contract of another method.
The remaining assertions indicate all implementations of the method must 
ensure the following, assuming the preconditions are satisfied: </P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
if <TT>u</TT> and <TT>v</TT> are equal then the result of calling 
<TT>vuDot</TT> should be non-negative; and
</LI><LI CLASS="li-enumerate">if <TT>u</TT> and <TT>v</TT> are both zero vectors then the result 
should be within the provided tolerance. 
</LI></OL><P>The tolerance argument, <TT>tol</TT>, was only added here to support 
assertions in the postconditions clause. That is, the argument is not 
expected to be needed or used by any implementation of the method.</P><P>It is important to keep in mind that the assertions within interface contracts
only need to hold at the method call boundary.
The implementations of some methods may have to temporarily violate the 
contract during processing.
However, as long as the corresponding assertions hold at the call boundary, 
the contract is not actually violated.</P><P>Optional interface contracts consist of clauses defining obligations on 
callers and callees.
Clauses, when specified, must contain assertions required to hold at the 
appropriate point(s) during execution.
Assertions within precondition (and invariant) clauses must hold immediately
before the method is executed; whereas, postcondition (and invariant) clause
assertions must hold immediately after control returns from the method.
More information on SIDL specifications, including supported operators and
built-in functions, can be found in Chapter <A HREF="index023.html#c:contracts">21</A>.</P><H3 CLASS="subsection">Contract Enforcement</H3><P><A NAME="ss:intro_contract_enforcement"></A>
<A NAME="@default311"></A>
<A NAME="@default312"></A>
The options used to establish an interface contract enforcement policy 
should be based on the goals of a particular application run.
During testing and debugging, contract enforcement tends to focus on 
determining whether the caller and callee conform to the specification.
Historically, contract enforcement is disabled during deployment.
Consequently, traditional interface contract enforcement tends to be 
all-or-nothing for one or more type of contract clause.</P><P>The simplest approach is to always enforce all contract clauses.
SIDL provides the <TT>setEnforceAll</TT> helper method, whose specification 
is provided below, for setting the associated enforcement options.
While this strategy makes testing straightforward, it is important
to keep in mind that it carries the risk of not fully testing the compliance
of the codes.
For example, if the test suite is not sufficiently thorough, there is a risk 
of not exposing non-compliance of contract clauses in downstream methods 
when there can be dependencies involving sequences of method calls.</P><P><A NAME="@default313"></A>
<A NAME="@default314"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /**
     * Sets the enforcement policy to always check the specified
     * type(s) of contracts.  This is equivalent to calling
     * setPolicy() with ALWAYS as the enforcement frequency
     * and the specified (or default) contract class.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceAll(<B>in</B> ContractClass contractClass,
                              <B>in bool</B>          clearStats);

    /* ... */
  }</I></FONT></TD></TR>
</TABLE><P>A traditional alternative for test suites singling out callers from 
callees involves separately enforcing precondition and postcondition 
clauses.
For example, when testing whether one or more implementations of an interface
comply with their specification, enforcement is generally limited to
postconditions (with test codes satisfying the preconditions).
Once confidence is gained in the implementation, the callers may be 
tested with only precondition enforcement enabled (with test codes
violating the preconditions).
The full range of clause type-based <TT>ContractClass</TT> options 
are provided below.
Separating clause enforcement in this manner therefore allows test 
suites to distinguish between caller and callee contract compliance.</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * Contract classification.  The classification is used to filter
   * contract clauses by the corresponding characteristic(s).
   */
  <B>enum</B> ContractClass {
    /**
     * All classifications of interface contract clauses.
     */
    ALLCLASSES,

    /* ... */

    /**
     * Only invariant clauses.
     */
    INVARIANTS,
    /**
     * Invariant plus postcondition clauses.
     */
    INVPOST,
    /**
     * Invariant plus precondition clauses.
     */
    INVPRE,

    /* ... */

    /**
     * Only postcondition clauses.
     */
    POSTCONDS,
    /**
     * Only precondition clauses.
     */
    PRECONDS,
    /**
     * Precondition plus postcondition clauses.
     */
    PREPOST,

    /* ... */
  };</I></FONT></TD></TR>
</TABLE><P>Assertion enforcement has historically been considered to be too time 
consuming to allow during deployment.
So the traditional approach has been to disable their enforcement.
SIDL provides the <TT>setEnforceNone</TT> helper method, whose specification 
is shown below, for disabling contract enforcement at runtime.</P><P><A NAME="@default315"></A>
<A NAME="@default316"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting">  <FONT COLOR=maroon><I>/**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /* ... */

    /**
     * Sets the policy options to disable all contract enforcement.
     * This is equivalent to calling setPolicy() with NEVER as the
     * enforcement frequency.
     *
     * @param clearStats  TRUE if enforcement statistics are to be
     *                      cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceNone(<B>in bool</B> clearStats);

    /* ... */
  }</I></FONT></TD></TR>
</TABLE><P>Enforcement policies in affect should be based on the goals of a given
execution. 
Testing and debugging with contracts tend to focus on caller and callee
compliance; therefore, enforcement can involve checking all or type-specific
subsets of contract clauses.
Contract enforcement is traditionally disabled during deployment, however.
All of these strategies are supported through two SIDL helper methods.
Language-specific examples of the use of these methods are provided in 
Part <A HREF="index-multipage.html#p:supported_langs">II</A>.
Additional information, including advanced and experimental enforcement 
capabilities, can be found in Chapter <A HREF="index023.html#c:contracts">21</A>.
</P><H2 CLASS="section"><A NAME="toc27"></A><A NAME="htoc27">6.6</A>  SIDL Runtime</H2><P><A NAME="s:sidl_runtime"></A>
<A NAME="@default317"></A>
The runtime library supports a collection of interfaces and classes,
some of which form the basis of the SIDL object model while, as discussed
in other sections of this chapter, others provide enhanced capabilities.</P><H3 CLASS="subsection">Inheritance</H3><P><A NAME="s:base_inheritance"></A>
<A NAME="@default318"></A>
The object model core consists of base interfaces, classes, and
exceptions.
All interfaces implicitly inherit from
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT><A NAME="@default319"></A><A NAME="@default320"></A>.
Classes implicitly inherit from
<FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT><A NAME="@default321"></A><A NAME="@default322"></A>, 
which implements 
<FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT><A NAME="@default323"></A><A NAME="@default324"></A>.
Hence, all objects can be cast to <FONT COLOR=maroon><I><TT>sidl.BaseInterface</TT></I></FONT> and 
<FONT COLOR=maroon><I><TT>sidl.BaseClass</TT></I></FONT>.
Exceptions must <EM>explicitly</EM> implement the interfaces in 
<FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT><A NAME="@default325"></A><A NAME="@default326"></A>.
The easiest way to do this is to extend 
<FONT COLOR=maroon><I><TT>sidl.SIDLException</TT></I></FONT><A NAME="@default327"></A><A NAME="@default328"></A>,
which the basic Exception functionality, including <TT>getNote</TT> and
<TT>setNote</TT>. One or more of these functions can also be overriden.
If a method in SIDL claims to throw an object that does not
inherit from <FONT COLOR=maroon><I><TT>sidl.BaseException</TT></I></FONT>, Babel will report it as an error.</P><H3 CLASS="subsection">Interfaces</H3><P>
The SIDL runtime library supports the six interface categories described
below.</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Base</B></DT><DD CLASS="dd-description"> The base class, interface, and exception upon which all 
Babel-enabled software builds.
</DD><DT CLASS="dt-description"><B>Contract Enforcement</B></DT><DD CLASS="dd-description"> Contract enforcement policy class and contract
clause exceptions used to establish enforcement options and identify, at
runtime, contract clause violations, respectively.
</DD><DT CLASS="dt-description"><B>Library Handler</B></DT><DD CLASS="dd-description"> The DLL and Loader classes facilitate dynamic loading
of objects at runtime.
</DD><DT CLASS="dt-description"><B>Introspection</B></DT><DD CLASS="dd-description"> The ClassInfo interface and ClassInfoI class enable
checking meta-data associated with a class.
</DD><DT CLASS="dt-description"><B>I/O</B></DT><DD CLASS="dd-description"> The input-output package used for serializing and deserializing 
SIDL types.
</DD><DT CLASS="dt-description"><B>RMI</B></DT><DD CLASS="dd-description"> The rmi package used for managing remote method invocations.
</DD></DL><P>The associated capabilities, as defined in <TT>sidl.sidl</TT>, are:</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I>//
// File:        sidl.sidl
// Revision:    @(#) $Revision$
// Date:        $Date$
// Description: sidl interface description for the basic sidl run-time library
// 
// Copyright (c) 2001-2007, The Regents of the University of Calfornia.
// Produced at the Lawrence Livermore National Laboratory.
// Written by the Components Team &lt;components@llnl.gov&gt;
// UCRL-CODE-2002-054
// All rights reserved.
// 
// This file is part of Babel. For more information, see
// http://www.llnl.gov/CASC/components/. Please read the COPYRIGHT file
// for Our Notice and the LICENSE file for the GNU Lesser General Public
// License.
// 
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License (as published by
// the Free Software Foundation) version 2.1 dated February 1999.
// 
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
// conditions of the GNU Lesser General Public License for more details.
// 
// You should have recieved a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

/**
 * The &lt;code&gt;sidl&lt;/code&gt; package contains the fundamental type and interface
 * definitions for the &lt;code&gt;sidl&lt;/code&gt; interface definition language.  It
 * defines common run-time libraries and common base classes and interfaces.
 * Every interface implicitly inherits from &lt;code&gt;sidl.BaseInterface&lt;/code&gt;
 * and every class implicitly inherits from &lt;code&gt;sidl.BaseClass&lt;/code&gt;.
 *
 */
<B>final package</B> sidl <B>version</B> 0.9.17 {

  /**
   * Every interface in &lt;code&gt;sidl&lt;/code&gt; implicitly inherits
   * from &lt;code&gt;BaseInterface&lt;/code&gt;, and it is implemented
   * by &lt;code&gt;BaseClass&lt;/code&gt; below.
   */
  <B>interface</B> BaseInterface {

    /**
     * &lt;p&gt;
     * Add one to the intrinsic reference count in the underlying object.
     * Object in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Objects continue to exist as long as the reference count is
     * positive. Clients should call this method whenever they
     * create another ongoing reference to an object or interface.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This does not have a return value because there is no language
     * independent type that can refer to an interface or a
     * class.
     * &lt;/p&gt;
     */
    <B>void</B> addRef();

    /**
     * Decrease by one the intrinsic reference count in the underlying
     * object, and delete the object if the reference is non-positive.
     * Objects in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Clients should call this method whenever they remove a
     * reference to an object or interface.
     */
    <B>void</B> deleteRef();

    /**
     * Return true if and only if &lt;code&gt;obj&lt;/code&gt; refers to the same
     * object as this object.
     */
    <B>bool</B> isSame(<B>in</B> BaseInterface iobj);

    /**
     * Return whether this object is an instance of the specified type.
     * The string name must be the &lt;code&gt;sidl&lt;/code&gt; type name.  This
     * routine will return &lt;code&gt;true&lt;/code&gt; if and only if a cast to
     * the string type name would succeed.
     */
    <B>bool</B> isType(<B>in string</B> name);

    /**
     * Return the meta-data about the class implementing this interface.
     */
    ClassInfo getClassInfo();
  }

  /**
   * Every class implicitly inherits from &lt;code&gt;BaseClass&lt;/code&gt;.  This
   * class implements the methods in &lt;code&gt;BaseInterface&lt;/code&gt;.
   */
  <B>class</B> BaseClass <B>implements</B> BaseInterface {
    /**
     * &lt;p&gt;
     * Add one to the intrinsic reference count in the underlying object.
     * Object in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Objects continue to exist as long as the reference count is
     * positive. Clients should call this method whenever they
     * create another ongoing reference to an object or interface.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This does not have a return value because there is no language
     * independent type that can refer to an interface or a
     * class.
     * &lt;/p&gt;
     */
    <B>final void</B> addRef();

    /**
     * Decrease by one the intrinsic reference count in the underlying
     * object, and delete the object if the reference is non-positive.
     * Objects in &lt;code&gt;sidl&lt;/code&gt; have an intrinsic reference count.
     * Clients should call this method whenever they remove a
     * reference to an object or interface.
     */
    <B>final void</B> deleteRef();

    /**
     * Return true if and only if &lt;code&gt;obj&lt;/code&gt; refers to the same
     * object as this object.
     */
    <B>final bool</B> isSame(<B>in</B> BaseInterface iobj);

    /**
     * Return whether this object is an instance of the specified type.
     * The string name must be the &lt;code&gt;sidl&lt;/code&gt; type name.  This
     * routine will return &lt;code&gt;true&lt;/code&gt; if and only if a cast to
     * the string type name would succeed.
     */
    <B>bool</B> isType(<B>in string</B> name);

    /**
     * Return the meta-data about the class implementing this interface.
     */
    <B>final</B> ClassInfo getClassInfo();
  }

  /**
   * This package has some I/O capability that's not core to the
   * SIDL object model, but still needed by parts of the generated code
   */
  <B>package</B> io {
    /**
     *   Objects that implement Serializable will be serializable (copyable)
     * over RMI, or storable to streams.  Classes that can pack or unpack
     *  themselves should implement this interface
     */
    <B>interface</B> Serializable {
      <B>void</B> packObj( <B>in</B> Serializer ser );
      <B>void</B> unpackObj( <B>in</B> Deserializer des );
    }
  }

  /**
   * Every exception implements &lt;code&gt;BaseException&lt;/code&gt;. This interface
   * declares the basic functionality to get and set error messages and stack
   * traces.
   */
  <B>interface</B> BaseException <B>extends</B> sidl.io.Serializable{

    /**
     * Return the message associated with the exception.
     */
    <B>string</B> getNote();

    /**
     * Set the message associated with the exception.
     */
    <B>void</B> setNote(<B>in string</B> message);

    /**
     * Returns formatted string containing the concatenation of all
     * tracelines.
     */
    <B>string</B> getTrace();

    /**
     * Adds a stringified entry/line to the stack trace.
     */
    <B>void</B> add[Line](<B>in string</B> traceline);

    /**
     * Formats and adds an entry to the stack trace based on the
     * file name, line number, and method name.
     */
    <B>void</B> add(<B>in string</B> filename, <B>in int</B> lineno, <B>in string</B> methodname);
  }

  /**
   * This exception type is the default exception for every method.
   *
   */
  <B>interface</B> RuntimeException <B>extends</B> BaseException {}

  /**
   * &lt;code&gt;SIDLException&lt;/code&gt; provides the basic functionality of the
   * &lt;code&gt;BaseException&lt;/code&gt; interface for getting and setting error
   * messages and stack traces.
   */
  <B>class</B> SIDLException <B>implements</B>-all BaseException {
  }

  /**
   * &lt;code&gt;PreViolation&lt;/code&gt; indicates an assertion within a precondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PreViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }

  /**
   * &lt;code&gt;PostViolation&lt;/code&gt; indicates an assertion within a postcondition
   * clause of the interface contract has been violated.
   */
  <B>class</B> PostViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }

  /**
   * &lt;code&gt;InvViolation&lt;/code&gt; indicates an assertion within a invariant
   * clause of the interface contract has been violated.
   */
  <B>class</B> InvViolation <B>extends</B> SIDLException <B>implements</B> RuntimeException {
  }

  /**
   * Contract clause types.
   */
  <B>enum</B> ClauseType {
    INVARIANT,
    PRECONDITION,
    POSTCONDITION,
  };

  /**
   * Contract classification.  The classification is used to filter
   * contract clauses by the corresponding characteristic(s).
   */
  <B>enum</B> ContractClass {
    /**
     * All classifications of interface contract clauses.
     */
    ALLCLASSES,
    /**
     * Only constant-time complexity, or O(1), clauses.
     */
    CONSTANT,
    /**
     * Only cubic-time complexity, or O(n^3), clauses.
     */
    CUBIC,
    /**
     * Only invariant clauses.
     */
    INVARIANTS,
    /**
     * Invariant plus postcondition clauses.
     */
    INVPOST,
    /**
     * Invariant plus precondition clauses.
     */
    INVPRE,
    /**
     * Only linear-time complexity, or O(n), clauses.
     */
    LINEAR,
    /**
     * Method calls.  Only clauses containing at least one method call.
     */
    METHODCALLS,
    /**
     * Only postcondition clauses.
     */
    POSTCONDS,
    /**
     * Only precondition clauses.
     */
    PRECONDS,
    /**
     * Precondition plus postcondition clauses.
     */
    PREPOST,
    /**
     * Only quadratic-time complexity, or O(n^2), clauses.
     */
    QUADRATIC,
    /**
     * Only quartic-time complexity, or O(n^4), clauses.
     */
    QUARTIC,
    /**
     * Only quintic-time complexity, or O(n^5), clauses.
     */
    QUINTIC,
    /**
     * Results.  Only clauses containing at least one assertion on an
     * out, inout, or result argument.
     */
    RESULTS,
    /**
     * Only septic-time complexity, or O(n^7), clauses.
     */
    SEPTIC,
    /**
     * Only sextic-time complexity, or O(n^6), clauses.
     */
    SEXTIC,
    /**
     * Simple expressions.  Only clauses consisting solely of
     * simple expressions (i.e., no method calls).
     */
    SIMPLEEXPRS,
  };

  /**
   * Contract clause enforcement frequency.
   */
  <B>enum</B> EnforceFreq {
    /**
     * Never.  Disable enforcement by completely by-passing checks
     * regardless of the selected contract classification.
     */
    NEVER,
    /**
     * Always.  Every clause of the selected contract classification
     * is enforced.
     */
    ALWAYS,
    /**
     * Adaptive fit.  Check clauses of the selected contract classification
     * only if they will not result in exceeding the overhead limit based
     * on accumulations of estimated execution times.
     */
    ADAPTFIT,
    /**
     * Adaptive timing.  Check clauses of the selected contract classification
     * only if their estimated execution time is within the overhead limit
     * applied to the estimated time of the corresponding method.
     */
    ADAPTTIMING,
    /**
     * Periodic.  Check clauses of the selected contract classification
     * at the specified interval.
     */
    PERIODIC,
    /**
     * Random.  Check clauses of the selected contract classifcation on a
     * random basis using the specified maximum.
     */
    RANDOM,
    /**
     * Simulated Annealing.  Essentially Adaptive fit but checks are
     * allowed to randomly exceed the overhead limit with decreasing
     * probability over time.
     */
    SIMANNEAL,
  };

  /**
   * Contract enforcement tracing levels.  Enforcement traces rely on
   * runtime timing automatically inserted within the middleware.
   */
  <B>enum</B> EnfTraceLevel {
    /**
     * None.  No tracing is to be performed.
     */
    NONE,
    /**
     * Core.  Time trace start and end only.  This can be useful for
     * simple program timing.
     */
    CORE,
    /**
     * Basic enforcement tracing.  CORE plus interface contract clause timing.
     */
    BASIC,
    /**
     * Overhead of enforcement decisions.  BASIC plus timing of
     * enforcement decisions.  (Experimental feature.)
     */
    OVERHEAD,
  };

  /**
   * &lt;code&gt;EnfPolicy&lt;/code&gt; maintains the current interface
   * contract enforcement policy.
   */
  <B>class</B> EnfPolicy {
    /**
     * Sets the enforcement policy to always check the specified
     * type(s) of contracts.  This is equivalent to calling
     * setPolicy() with ALWAYS as the enforcement frequency
     * and the specified (or default) contract class.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceAll(<B>in</B> ContractClass contractClass,
                              <B>in bool</B>          clearStats);

    /**
     * Sets the policy options to disable all contract enforcement.
     * This is equivalent to calling setPolicy() with NEVER as the
     * enforcement frequency.
     *
     * @param clearStats  TRUE if enforcement statistics are to be
     *                      cleared; FALSE otherwise.
     */
    <B>static void</B> setEnforceNone(<B>in bool</B> clearStats);

    /**
     * Sets enforcement policy and options.  This method should be
     * invoked directly to avoid the default enforcement behavior.
     *
     * @param contractClass  Contract classification
     *                         [Default = ALLCLASSES]
     * @param enforceFreq    Enforcement frequency
     *                         [Default = ALWAYS]
     * @param interval       Sampling interval representing the
     *                         period (for PERIODIC) or maximum
     *                         random number/window (for RANDOM)
     *                         [Default = 0 if negative specified]
     * @param overheadLimit  Limit on performance overhead [0.0 .. 1.0)
     *                         [Default = 0.0 (or 0%) if negative]
     * @param appAvgPerCall  Average extra, application-specific
     *                         execution time, normalized by calls
     *                         to annotated methods
     *                         [Default = 0.0 if negative]
     * @param annealLimit    Limit on simulated annealing function
     *                         to ensure its termination
     *                         (0.0 .. 2.72]
     *                         [Default = 2.72 if negative specified]
     * @param clearStats      TRUE if enforcement statistics are to be
     *                          cleared; FALSE otherwise.
     */
    <B>static void</B> setPolicy(<B>in</B> ContractClass contractClass,
                          <B>in</B> EnforceFreq   enforceFreq,
                          <B>in int</B>           interval,
                          <B>in double</B>        overheadLimit,
                          <B>in double</B>        appAvgPerCall,
                          <B>in double</B>        annealLimit,
                          <B>in bool</B>          clearStats);

    /**
     * Returns TRUE if contract enforcement is enabled; FALSE otherwise.
     */
    <B>static bool</B> areEnforcing();

    /**
     * Returns the contract classification policy option.
     */
    <B>static</B> ContractClass getContractClass();

    /**
     * Returns the enforcement frequency policy option.
     */
    <B>static</B> EnforceFreq getEnforceFreq();

    /**
     * Returns the interval for PERIODIC (i.e., the interval) or
     * RANDOM (i.e., the maximum random number).  Returns 0 by default.
     */
    <B>static int</B> getSamplingInterval();

    /**
     * Returns the desired enforcement overhead limit for
     * performance-driven frequency options (i.e., ADAPTFIT,
     * ADAPTTIMING, and SIMANNEAL).  Returns 0.0 by default.
     */
    <B>static double</B> getOverheadLimit();

    /**
     * Returns the average assumed execution time associated
     * with the program or application.  Returns 0.0 by default.
     */
    <B>static double</B> getAppAvgPerCall();

    /**
     * Returns the annealing limit for SIMANNEAL enforcement
     * frequency option.  Returns 0.0 by default.
     */
    <B>static double</B> getAnnealLimit();

    /**
     * Returns the name, or description, of the enforcement policy.
     * The caller is responsible for calling sidl_String_free()
     * on the name when done with it.
     *
     * @param useAbbrev   TRUE if the abbreviated name is to be
     *                    returned.
     */
    <B>static string</B> getPolicyName(<B>in bool</B> useAbbrev);

    /**
     * Prints statistics data to the file with the specified name.
     * The file is opened (for append) and closed on each call.
     *
     * @param filename   Name of the file to which the statistics
     *                     data should be written.
     * @param header     TRUE if the header line is to be printed
     *                     prior to the statistics line (for compressed
     *                     output only).
     * @param prefix     String description for identifying information,
     *                     if any, intended to preceed the statistics
     *                     data.  Useful for distinguishing between
     *                     different objects, for example.
     * @param compressed TRUE if the enforcer state is to be dumped
     *                     on a single line with semi-colon separators
     *                     between fields.
     */
    <B>static void</B> dumpStats(<B>in string</B> filename,
                          <B>in bool</B>   header,
                          <B>in string</B> prefix,
                          <B>in bool</B>   compressed);

    /**
     * Starts enforcement trace file generation.
     *
     * @param filename    Name of the destination trace file.
     * @param traceLevel  Level of trace timing and reporting required.
     *                      [Default = NONE]
     */
    <B>static void</B> startTrace(<B>in string</B>        filename,
                           <B>in</B> EnfTraceLevel traceLevel);

    /**
     * Returns TRUE if contract enforcement tracing is enabled;
     * FALSE otherwise.
     */
    <B>static bool</B> areTracing();

    /**
     * Returns the name of the trace file.  If one was not provided,
     * the default name is returned.
     */
    <B>static string</B> getTraceFilename();

    /**
     * Returns the level of enforcement tracing.
     */
    <B>static</B> EnfTraceLevel getTraceLevel();

    /**
     * Terminates enforcement trace file generation.  Takes a final
     * timestamp and logs the remaining trace information.
     */
    <B>static void</B> endTrace();
  }


  /**
   * When loading a dynamically linked library, there are three
   * settings: LOCAL, GLOBAL and SCLSCOPE.
   */
  <B>enum</B> Scope {
      /** Attempt to load the symbols into a local namespace. */
      LOCAL,
      /** Attempt to load the symbols into the global namespace. */
      GLOBAL,
      /** Use the scope setting from the SCL file. */
      SCLSCOPE
      }

  /**
   * When loading a dynmaically linked library, there are three
   * settings: LAZY, NOW, SCLRESOLVE
   */
  <B>enum</B> Resolve {
    /** Resolve symbols on an as needed basis. */
    LAZY,
      /** Resolve all symbols at load time. */
      NOW,
      /** Use the resolve setting from the SCL file. */
      SCLRESOLVE
      }

  /**
   * The &lt;code&gt;DLL&lt;/code&gt; class encapsulates access to a single
   * dynamically linked library.  DLLs are loaded at run-time using
   * the &lt;code&gt;loadLibrary&lt;/code&gt; method and later unloaded using
   * &lt;code&gt;unloadLibrary&lt;/code&gt;.  Symbols in a loaded library are
   * resolved to an opaque pointer by method &lt;code&gt;lookupSymbol&lt;/code&gt;.
   * Class instances are created by &lt;code&gt;createClass&lt;/code&gt;.
   */
  <B>class</B> DLL {

    /**
     * Load a dynamic link library using the specified URI.  The
     * URI may be of the form "main:", "lib:", "file:", "ftp:", or
     * "http:".  A URI that starts with any other protocol string
     * is assumed to be a file name.  The "main:" URI creates a
     * library that allows access to global symbols in the running
     * program's main address space.  The "lib:X" URI converts the
     * library "X" into a platform-specific name (e.g., libX.so) and
     * loads that library.  The "file:" URI opens the DLL from the
     * specified file path.  The "ftp:" and "http:" URIs copy the
     * specified library from the remote site into a local temporary
     * file and open that file.  This method returns true if the
     * DLL was loaded successfully and false otherwise.  Note that
     * the "ftp:" and "http:" protocols are valid only if the W3C
     * WWW library is available.
     *
     * @param uri          the URI to load. This can be a .la file
     *                     (a metadata file produced by libtool) or
     *                     a shared library binary (i.e., .so,
     *                     .dll or whatever is appropriate for your
     *                     OS)
     * @param loadGlobally &lt;code&gt;true&lt;/code&gt; means that the shared
     *                     library symbols will be loaded into the
     *                     global namespace; &lt;code&gt;false&lt;/code&gt;
     *                     means they will be loaded into a
     *                     private namespace. Some operating systems
     *                     may not be able to honor the value presented
     *                     here.
     * @param loadLazy     &lt;code&gt;true&lt;/code&gt; instructs the loader to
     *                     that symbols can be resolved as needed (lazy)
     *                     instead of requiring everything to be resolved
     *                     now (at load time).
     */
    <B>bool</B> loadLibrary(<B>in string</B> uri,
                     <B>in bool</B> loadGlobally,
                     <B>in bool</B> loadLazy);

    /**
     * Get the library name.  This is the name used to load the
     * library in &lt;code&gt;loadLibrary&lt;/code&gt; except that all file names
     * contain the "file:" protocol.
     */
    <B>string</B> getName();

    /**
     * Return true if the library was loaded into the global namespace.
     */
    <B>bool</B> isGlobal();

    /**
     * Return true if the library was loaded using lazy symbol resolution.
     */
    <B>bool</B> isLazy();

    /**
     * Unload the dynamic link library.  The library may no longer
     * be used to access symbol names.  When the library is actually
     * unloaded from the memory image depends on details of the operating
     * system.
     */
    <B>void</B> unloadLibrary();

    /**
     * Lookup a symbol from the DLL and return the associated pointer.
     * A null value is returned if the name does not exist.
     */
    <B>opaque</B> lookupSymbol(<B>in string</B> linker_name);

    /**
     * Create an instance of the sidl class.  If the class constructor
     * is not defined in this DLL, then return null.
     */
    BaseClass createClass(<B>in string</B> sidl_name);
  }

  /**
   * Interface &lt;code&gt;Finder&lt;/code&gt; is an interface for classes that resolve
   * dynamic libraries.
   * Class &lt;code&gt;Loader&lt;/code&gt; takes one of these interfaces through the
   * method &lt;code&gt;setFinder&lt;/code&gt;.  If NULL is passed to setFinder, the
   * class &lt;code&gt;DefaultFinder&lt;/code&gt; is used.
   */
  <B>interface</B> Finder {
    /**
     * Find a DLL containing the specified information for a sidl
     * class. This method searches through the files in set set path
     * looking for a shared library that contains the client-side or IOR
     * for a particular sidl class.
     *
     * @param sidl_name  the fully qualified (long) name of the
     *                   class/interface to be found. Package names
     *                   are separated by period characters from each
     *                   other and the class/interface name.
     * @param target     to find a client-side binding, this is
     *                   normally the name of the language.
     *                   To find the implementation of a class
     *                   in order to make one, you should pass
     *                   the string "ior/impl" here.
     * @param lScope     this specifies whether the symbols should
     *                   be loaded into the global scope, a local
     *                   scope, or use the setting in the file.
     * @param lResolve   this specifies whether symbols should be
     *                   resolved as needed (LAZY), completely
     *                   resolved at load time (NOW), or use the
     *                   setting from the file.
     * @return a non-NULL object means the search was successful.
     *         The DLL has already been added.
     */
    DLL findLibrary(<B>in string</B>  sidl_name,
                    <B>in string</B>  target,
                    <B>in</B> Scope   lScope,
                    <B>in</B> Resolve lResolve);

    /**
     * Set the search path, which is a semi-colon separated sequence of
     * URIs as described in class &lt;code&gt;DLL&lt;/code&gt;.  This method will
     * invalidate any existing search path.
     */
    <B>void</B> setSearchPath(<B>in string</B> path_name);

    /**
     * Return the current search path.  If the search path has not been
     * set, then the search path will be taken from environment variable
     * SIDL_DLL_PATH.
     */
    <B>string</B> getSearchPath();

    /**
     * Append the specified path fragment to the beginning of the
     * current search path.  If the search path has not yet been set
     * by a call to &lt;code&gt;setSearchPath&lt;/code&gt;, then this fragment will
     * be appended to the path in environment variable SIDL_DLL_PATH.
     */
    <B>void</B> addSearchPath(<B>in string</B> path_fragment);

  }

  /**
   *  This class is the Default Finder.  If no Finder is set in class Loader,
   *  this finder is used.  It uses SCL files from the filesystem to
   *  resolve dynamic libraries.
   *
   * The initial search path is taken from the SIDL_DLL_PATH
   * environment variable.
   */

  <B>class</B> DFinder <B>implements</B>-all Finder {
  }


  /**
   * Class &lt;code&gt;Loader&lt;/code&gt; manages dyanamic loading and symbol name
   * resolution for the sidl runtime system.  The &lt;code&gt;Loader&lt;/code&gt; class
   * manages a library search path and keeps a record of all libraries
   * loaded through this interface, including the initial "global" symbols
   * in the main program.
   *
   * Unless explicitly set, the &lt;code&gt;Loader&lt;/code&gt; uses the default
   * &lt;code&gt;sidl.Finder&lt;/code&gt; implemented in &lt;code&gt;sidl.DFinder&lt;/code&gt;.
   * This class searches the filesystem for &lt;code&gt;.scl&lt;/code&gt; files when
   * trying to find a class. The initial path is taken from the
   * environment variable SIDL_DLL_PATH, which is a semi-colon
   * separated sequence of URIs as described in class &lt;code&gt;DLL&lt;/code&gt;.
   */
  <B>class</B> Loader {

    /**
     * Load the specified library if it has not already been loaded.
     * The URI format is defined in class &lt;code&gt;DLL&lt;/code&gt;.  The search
     * path is not searched to resolve the library name.
     *
     * @param uri          the URI to load. This can be a .la file
     *                     (a metadata file produced by libtool) or
     *                     a shared library binary (i.e., .so,
     *                     .dll or whatever is appropriate for your
     *                     OS)
     * @param loadGlobally &lt;code&gt;true&lt;/code&gt; means that the shared
     *                     library symbols will be loaded into the
     *                     global namespace; &lt;code&gt;false&lt;/code&gt;
     *                     means they will be loaded into a
     *                     private namespace. Some operating systems
     *                     may not be able to honor the value presented
     *                     here.
     * @param loadLazy     &lt;code&gt;true&lt;/code&gt; instructs the loader to
     *                     that symbols can be resolved as needed (lazy)
     *                     instead of requiring everything to be resolved
     *                     now.
     * @return if the load was successful, a non-NULL DLL object is returned.
     */
    <B>static</B> DLL loadLibrary(<B>in string</B> uri,
                           <B>in bool</B> loadGlobally,
                           <B>in bool</B> loadLazy);

    /**
     * Append the specified DLL to the beginning of the list of already
     * loaded DLLs.
     */
    <B>static void</B> addDLL(<B>in</B> DLL dll);

    /**
     * Unload all dynamic link libraries.  The library may no longer
     * be used to access symbol names.  When the library is actually
     * unloaded from the memory image depends on details of the operating
     * system.
     */
    <B>static void</B> unloadLibraries();

    /**
     * Find a DLL containing the specified information for a sidl
     * class. This method searches SCL files in the search path looking
     * for a shared library that contains the client-side or IOR
     * for a particular sidl class.
     *
     * This call is implemented by calling the current
     * &lt;code&gt;Finder&lt;/code&gt;. The default finder searches the local
     * file system for &lt;code&gt;.scl&lt;/code&gt; files to locate the
     * target class/interface.
     *
     * @param sidl_name  the fully qualified (long) name of the
     *                   class/interface to be found. Package names
     *                   are separated by period characters from each
     *                   other and the class/interface name.
     * @param target     to find a client-side binding, this is
     *                   normally the name of the language.
     *                   To find the implementation of a class
     *                   in order to make one, you should pass
     *                   the string "ior/impl" here.
     * @param lScope     this specifies whether the symbols should
     *                   be loaded into the global scope, a local
     *                   scope, or use the setting in the SCL file.
     * @param lResolve   this specifies whether symbols should be
     *                   resolved as needed (LAZY), completely
     *                   resolved at load time (NOW), or use the
     *                   setting from the SCL file.
     * @return a non-NULL object means the search was successful.
     *         The DLL has already been added.
     */
    <B>static</B> DLL findLibrary(<B>in string</B>  sidl_name,
                           <B>in string</B>  target,
                           <B>in</B> Scope   lScope,
                           <B>in</B> Resolve lResolve);

    /**
     * Set the search path, which is a semi-colon separated sequence of
     * URIs as described in class &lt;code&gt;DLL&lt;/code&gt;.  This method will
     * invalidate any existing search path.
     *
     * This updates the search path in the current &lt;code&gt;Finder&lt;/code&gt;.
     */
    <B>static void</B> setSearchPath(<B>in string</B> path_name);

    /**
     * Return the current search path.  The default
     * &lt;code&gt;Finder&lt;/code&gt; initializes the search path
     * from environment variable SIDL_DLL_PATH.
     *
     */
    <B>static string</B> getSearchPath();

    /**
     * Append the specified path fragment to the beginning of the
     * current search path.  This method operates on the Loader's
     * current &lt;code&gt;Finder&lt;/code&gt;. This will add a path to the
     * current search path. Normally, the search path is initialized
     * from the SIDL_DLL_PATH environment variable.
     */
    <B>static void</B> addSearchPath(<B>in string</B> path_fragment);

    /**
     * This method sets the &lt;code&gt;Finder&lt;/code&gt; that
     * &lt;code&gt;Loader&lt;/code&gt; will use to find DLLs.  If no
     * &lt;code&gt;Finder&lt;/code&gt; is set or if NULL is passed in, the Default
     * Finder &lt;code&gt;DFinder&lt;/code&gt; will be used.
     *
     * Future calls to &lt;code&gt;findLibrary&lt;/code&gt;,
     * &lt;code&gt;addSearchPath&lt;/code&gt;, &lt;code&gt;getSearchPath&lt;/code&gt;, and
     * &lt;code&gt;setSearchPath&lt;/code&gt; are deligated to the
     * &lt;code&gt;Finder&lt;/code&gt; set here.
     */
    <B>static void</B> setFinder(<B>in</B> Finder f);

    /**
     * This method gets the &lt;code&gt;Finder&lt;/code&gt; that &lt;code&gt;Loader&lt;/code&gt;
     * uses to find DLLs.
     */
    <B>static</B> Finder getFinder();
  }

  /**
   * This provides an interface to the meta-data available on the
   * class.
   */
  <B>interface</B> ClassInfo {
    /**
     * Return the name of the class.
     */
    <B>string</B> getName();

    /**
     * Return the version number of the class. This should be a string
     * with a sequence of numbers separated by periods.
     */
    <B>string</B> getVersion();

    /**
     * Get the version of the intermediate object representation.
     * This will be in the form of major_version.minor_version.
     */
    <B>string</B> getIORVersion();
  }

  /**
   * An implementation of the &lt;code&gt;ClassInfo&lt;/code&gt; interface. This
   * provides methods to set all the attributes that are read-only in
   * the &lt;code&gt;ClassInfo&lt;/code&gt; interface.
   */
  <B>class</B> ClassInfoI <B>implements</B>-all ClassInfo {
    /**
     * Set the name of the class.
     */
    <B>final void</B> setName(<B>in string</B> name);

    /**
     * Set the version number of the class.
     */
    <B>final void</B> setVersion(<B>in string</B> ver);

    /**
     * Set the IOR major and minor version numbers.
     */
    <B>final void</B> setIORVersion(<B>in int</B> major, <B>in int</B> minor);
  }

  /**
   * Exception thrown from Babel internals when memory allocation
   * fails.  This exception is special in that it avoids any memory
   * allocation.  For this reason, the trace or note may be truncated
   * to fit in the preallocated buffers.
   */
  <B>class</B> MemAllocException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {

    /**
     * Returns the preallocated copy of this exception.  Any
     * failure of memory allocation should throw the exception returned
     * by this method to avoid further allocation failures.
     */
    <B>static</B> MemAllocException getSingletonException();

    /**
     * Return the message associated with the exception.
     */
    <B>string</B> getNote();

    /**
     * Set the message associated with the exception.
     */
    <B>void</B> setNote(<B>in string</B> message);

    /**
     * Returns formatted string containing the concatenation of all
     * tracelines.
     */
    <B>string</B> getTrace();

    /**
     * Adds a stringified entry/line to the stack trace.
     */
    <B>void</B> add[Line](<B>in string</B> traceline);

    /**
     * Formats and adds an entry to the stack trace based on the
     * file name, line number, and method name.
     */
    <B>void</B> add(<B>in string</B> filename, <B>in int</B> lineno, <B>in string</B> methodname);

  }

  /**
   * Exception is thrown when a cast fails and the failure needs to
   * be communicated up the call stack.  (Note: babel _cast does NOT
   * throw this exception)
   */
  <B>class</B> CastException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {
  }

  /**
   * This Exception is thrown by the Babel runtime when a non SIDL
   * exception is thrown from an exception throwing language such as
   * C++ or Java.
   */
  <B>class</B> LangSpecificException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {
  }

  /**
   * This Exception is thrown when a method is called that an
   * implmentation has not been written for yet.  The throw code is
   * placed into the _Impl files automatically when they are generated.
   */
  <B>class</B> NotImplementedException <B>extends</B> sidl.SIDLException
    <B>implements</B> RuntimeException {
  }


  /**
   * This package has some I/O capability that's not core to the SIDL
   * object model, but still needed by parts of the generated code
   */
  <B>package</B> io {

    /** generic exception for I/O issues */
    <B>class</B> IOException <B>extends</B> sidl.SIDLException
      <B>implements</B> RuntimeException {
    }


    /**
     * Standard interface for packing Babel types
     */
    <B>interface</B> Serializer {
      <B>void</B> packBool( <B>in string</B> key, <B>in bool</B> value )
         ;
      <B>void</B> packChar( <B>in string</B> key, <B>in char</B> value )
         ;
      <B>void</B> packInt( <B>in string</B> key, <B>in int</B> value )
         ;
      <B>void</B> packLong( <B>in string</B> key, <B>in long</B> value )
         ;
      <B>void</B> packOpaque(  <B>in string</B> key, <B>in opaque</B> value )
         ;
      <B>void</B> packFloat( <B>in string</B> key, <B>in float</B> value )
         ;
      <B>void</B> packDouble( <B>in string</B> key, <B>in double</B> value )
         ;
      <B>void</B> packFcomplex( <B>in string</B> key, <B>in fcomplex</B> value )
         ;
      <B>void</B> packDcomplex( <B>in string</B> key, <B>in dcomplex</B> value )
         ;
      <B>void</B> packString( <B>in string</B> key, <B>in string</B> value )
         ;
      <B>void</B> packSerializable( <B>in string</B> key, <B>in</B> Serializable value )
        ;

      /**
       * pack arrays of values.  It is possible to ensure an array is
       * in a certain order by passing in ordering and dimension
       * requirements.  ordering should represent a value in the
       * sidl_array_ordering enumeration in sidlArray.h If either
       * argument is 0, it means there is no restriction on that
       * aspect.  The boolean reuse_array flag is set to true if the
       * remote unserializer should try to reuse the array that is
       * passed into it or not.
       */
      <B>void</B> packBoolArray( <B>in string</B> key, <B>in array</B>&lt;<B>bool</B>&gt; value,
                          <B>in int</B> ordering, <B>in int</B> dimen,
                          <B>in bool</B> reuse_array );
      <B>void</B> packCharArray( <B>in string</B> key, <B>in array</B>&lt;<B>char</B>&gt; value,
                          <B>in int</B> ordering, <B>in int</B> dimen,
                          <B>in bool</B> reuse_array );
      <B>void</B> packIntArray( <B>in string</B> key, <B>in array</B>&lt;<B>int</B>&gt; value,
                         <B>in int</B> ordering, <B>in int</B> dimen,
                         <B>in bool</B> reuse_array );
      <B>void</B> packLongArray( <B>in string</B> key, <B>in array</B>&lt;<B>long</B>&gt; value,
                          <B>in int</B> ordering, <B>in int</B> dimen,
                          <B>in bool</B> reuse_array );
      <B>void</B> packOpaqueArray( <B>in string</B> key, <B>in array</B>&lt;<B>opaque</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> reuse_array );
      <B>void</B> packFloatArray( <B>in string</B> key, <B>in array</B>&lt;<B>float</B>&gt; value,
                           <B>in int</B> ordering, <B>in int</B> dimen,
                           <B>in bool</B> reuse_array );
      <B>void</B> packDoubleArray( <B>in string</B> key, <B>in array</B>&lt;<B>double</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> reuse_array );
      <B>void</B> packFcomplexArray( <B>in string</B> key, <B>in array</B>&lt;<B>fcomplex</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> reuse_array );
      <B>void</B> packDcomplexArray( <B>in string</B> key, <B>in array</B>&lt;<B>dcomplex</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> reuse_array );
      <B>void</B> packStringArray( <B>in string</B> key, <B>in array</B>&lt;<B>string</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> reuse_array );
      <B>void</B> packGenericArray( <B>in string</B> key, <B>in array</B>&lt;&gt; value,
                             <B>in bool</B> reuse_array );
      <B>void</B> packSerializableArray( <B>in string</B> key,
                                  <B>in array</B>&lt;Serializable&gt; value,
                                  <B>in int</B> ordering, <B>in int</B> dimen,
                                  <B>in bool</B> reuse_array );
    }

    /**
     * Standard interface for unpacking Babel types
     */
    <B>interface</B> Deserializer {
      /* unpack values */
      <B>void</B> unpackBool( <B>in string</B> key, <B>inout bool</B> value );
      <B>void</B> unpackChar( <B>in string</B> key, <B>inout char</B> value );
      <B>void</B> unpackInt( <B>in string</B> key, <B>inout int</B> value );
      <B>void</B> unpackLong( <B>in string</B> key, <B>inout long</B> value );
      <B>void</B> unpackOpaque( <B>in string</B> key, <B>inout opaque</B> value );
      <B>void</B> unpackFloat( <B>in string</B> key, <B>inout float</B> value );
      <B>void</B> unpackDouble( <B>in string</B> key, <B>inout double</B> value );
      <B>void</B> unpackFcomplex( <B>in string</B> key, <B>inout fcomplex</B> value );
      <B>void</B> unpackDcomplex( <B>in string</B> key, <B>inout dcomplex</B> value );
      <B>void</B> unpackString( <B>in string</B> key, <B>inout string</B> value );
      <B>void</B> unpackSerializable( <B>in string</B> key, <B>inout</B> Serializable value );

      /** unpack arrays of values
       * It is possible to ensure an array is
       * in a certain order by passing in ordering and dimension
       * requirements.  ordering should represent a value in the
       * sidl_array_ordering enumeration in sidlArray.h If either
       * argument is 0, it means there is no restriction on that
       * aspect.  The rarray flag should be set if the array being
       * passed in is actually an rarray.  The semantics are slightly
       * different for rarrays.  The passed in array MUST be reused,
       * even if the array has changed bounds.
       */
      <B>void</B> unpackBoolArray( <B>in string</B> key, <B>inout array</B>&lt;<B>bool</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> isRarray );
      <B>void</B> unpackCharArray( <B>in string</B> key, <B>inout array</B>&lt;<B>char</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> isRarray  );
      <B>void</B> unpackIntArray( <B>in string</B> key, <B>inout array</B>&lt;<B>int</B>&gt; value,
                           <B>in int</B> ordering, <B>in int</B> dimen,
                           <B>in bool</B> isRarray  );
      <B>void</B> unpackLongArray( <B>in string</B> key, <B>inout array</B>&lt;<B>long</B>&gt; value,
                            <B>in int</B> ordering, <B>in int</B> dimen,
                            <B>in bool</B> isRarray  );
      <B>void</B> unpackOpaqueArray( <B>in string</B> key, <B>inout array</B>&lt;<B>opaque</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> isRarray  );
      <B>void</B> unpackFloatArray( <B>in string</B> key, <B>inout array</B>&lt;<B>float</B>&gt; value,
                             <B>in int</B> ordering, <B>in int</B> dimen,
                             <B>in bool</B> isRarray  );
      <B>void</B> unpackDoubleArray( <B>in string</B> key, <B>inout array</B>&lt;<B>double</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> isRarray  );
      <B>void</B> unpackFcomplexArray( <B>in string</B> key, <B>inout array</B>&lt;<B>fcomplex</B>&gt; value,
                                <B>in int</B> ordering, <B>in int</B> dimen,
                                <B>in bool</B> isRarray  );
      <B>void</B> unpackDcomplexArray( <B>in string</B> key,
                                <B>inout array</B>&lt;<B>dcomplex</B>&gt; value,
                                <B>in int</B> ordering, <B>in int</B> dimen,
                                <B>in bool</B> isRarray  );
      <B>void</B> unpackStringArray( <B>in string</B> key, <B>inout array</B>&lt;<B>string</B>&gt; value,
                              <B>in int</B> ordering, <B>in int</B> dimen,
                              <B>in bool</B> isRarray  );
      <B>void</B> unpackGenericArray( <B>in string</B> key, <B>inout array</B>&lt;&gt; value);
      <B>void</B> unpackSerializableArray( <B>in string</B> key,
                                    <B>inout array</B>&lt;Serializable&gt; value,
                                    <B>in int</B> ordering, <B>in int</B> dimen,
                                    <B>in bool</B> isRarray  );
    }

  } //end package io

  /**
   * This package contains necessary interfaces for RMI protocols to
   * hook into Babel, plus a Protocol Factory class.  The intention is
   * that authors of new protocols will create classes that implement
   * InstanceHandle, Invocation and Response (they could even have one
   * object that implements all three interfaces).
   */
  <B>package</B> rmi {

    /**
     * Generic Network Exception
     */
    <B>class</B> NetworkException <B>extends</B> sidl.io.IOException {
      <B>int</B> getHopCount();
      <B>void</B> packObj( <B>in</B> sidl.io.Serializer ser );
      <B>void</B> unpackObj( <B>in</B> sidl.io.Deserializer des );
      <B>void</B> setErrno(<B>in int</B> err);
      <B>int</B> getErrno();
    }

    /**
     * This exception is thrown by the RMI library when a
     * host can not be found by a DNS lookup.
     */
    <B>class</B> UnknownHostException <B>extends</B> NetworkException {}

    /**
     * This exception is normally thrown by the RMI library when the
     * server is started up and the port it is assigned to use is
     * already in use.
     */
    <B>class</B> BindException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when an
     * attempt to connect to a remote host fails.
     */
    <B>class</B> ConnectException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when a host
     * can be found by DNS, but is not reachable.  It usually means
     * a router is down.
     */
    <B>class</B> NoRouteToHostException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when a request
     * times out.
     */
    <B>class</B> TimeOutException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when the network
     * unexpected loses it's connection.  Can be caused by reset,
     * software connection abort, connection reset by peer, etc.
     */
    <B>class</B> UnexpectedCloseException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by a server when a passed in object
     * id does not match any known object.
     */
    <B>class</B> ObjectDoesNotExistException <B>extends</B> NetworkException {}

    /**
     * This exception is thrown by the RMI library when a passed in URL
     * is malformed.
     */
    <B>class</B> MalformedURLException <B>extends</B> NetworkException {}

    /**
     * This is a base class for all protocol specific exceptions.
     */
    <B>class</B> ProtocolException <B>extends</B> NetworkException {}

    /**
     * This exception thrown when one attempts to pass a local object remotely but
     * there is no local server running to serve the object
     */
    <B>class</B> NoServerException <B>extends</B> NetworkException {}

    /**
     * This singleton class keeps a table of string prefixes
     * (e.g. "babel" or "proteus") to protocol implementations.  The
     * intent is to parse a URL (e.g. "babel://server:port/class") and
     * create classes that implement
     * &lt;code&gt;sidl.rmi.InstanceHandle&lt;/code&gt;.
     */
    <B>class</B> ProtocolFactory {
      /**
       * Associate a particular prefix in the URL to a typeName
       * &lt;code&gt;sidl.Loader&lt;/code&gt; can find.  The actual type is
       * expected to implement &lt;code&gt;sidl.rmi.InstanceHandle&lt;/code&gt;
       * Return true iff the addition is successful.  (no collisions
       * allowed)
       */
      <B>static bool</B> addProtocol( <B>in string</B> prefix, <B>in string</B> typeName );

      /**
       * Return the typeName associated with a particular prefix.
       * Return empty string if the prefix
       */
      <B>static string</B> getProtocol( <B>in string</B> prefix );

      /**
       * Remove a protocol from the active list.
       */
      <B>static bool</B> deleteProtocol( <B>in string</B> prefix );

      /**
       * Create a new remote object and return an instance handle for that
       * object.
       * The server and port number are in the url.  Return nil
       * if protocol unknown or InstanceHandle.init() failed.
       */
      <B>static</B> InstanceHandle createInstance( <B>in string</B> url,
                                            <B>in string</B> typeName );

      /**
       * Create an new connection linked to an already existing
       * object on a remote server.  The server and port number are in
       * the url, the objectID is the unique ID of the remote object
       * in the remote instance registry.  Return null if protocol
       * unknown or InstanceHandle.init() failed.  The boolean addRef
       * should be true if connect should remotely addRef
       */
      <B>static</B> InstanceHandle connectInstance( <B>in string</B> url,
                                             <B>in string</B> typeName,
                                             <B>in bool</B> ar);

      /**
       * Request that a remote object be serialized to you.  The server
       * and port number are in the url, the objectID is the unique ID
       * of the remote object in the remote instance registry.  Return
       * null if protocol unknown or InstanceHandle.init() failed.
       */
      <B>static</B> sidl.io.Serializable unserializeInstance( <B>in string</B> url);

    }

    /**
     * This interface holds the state information for handles to
     * remote objects.  Client-side messaging libraries are expected
     * to implement &lt;code&gt;sidl.rmi.InstanceHandle&lt;/code&gt;,
     * &lt;code&gt;sidl.rmi.Invocation&lt;/code&gt; and
     * &lt;code&gt;sidl.rmi.Response&lt;/code&gt;.
     *
     * Every stub with a connection to a remote object holds a pointer
     * to an InstanceHandle that manages the connection. Multiple
     * stubs may point to the same InstanceHandle, however.  Babel
     * takes care of the reference counting, but the developer should
     * keep concurrency issues in mind.
     *
     *  When a new remote object is created:
     *       sidl_rmi_InstanceHandle c =
     *         sidl_rmi_ProtocolFactory_createInstance( url, typeName,
     *               _ex );
     *
     *  When a new stub is created to connect to an existing remote
     * instance:
     *        sidl_rmi_InstanceHandle c =
     *          sidl_rmi_ProtocolFactory_connectInstance( url, _ex );
     *
     *  When a method is invoked:
     *       sidl_rmi_Invocation i =
     *          sidl_rmi_InstanceHandle_createInvocation( methodname );
     *       sidl_rmi_Invocation_packDouble( i, "input_val" , 2.0 );
     *       sidl_rmi_Invocation_packString( i, "input_str", "Hello" );
     *       ...
     *       sidl_rmi_Response r = sidl_rmi_Invocation_invokeMethod( i );
     *       sidl_rmi_Response_unpackBool( i, "_retval", &amp;succeeded );
     *       sidl_rmi_Response_unpackFloat( i, "output_val", &amp;f );
     *
     */
    <B>interface</B> InstanceHandle {

      /** initialize a connection (intended for use by the
       * ProtocolFactory, (see above).  This should parse the url and
       * do everything necessary to create the remote object.
       */
      <B>bool</B> initCreate( <B>in string</B> url, <B>in string</B> typeName );

      /**
       * initialize a connection (intended for use by the ProtocolFactory)
       * This should parse the url and do everything necessary to connect
       * to a remote object.
       */
      <B>bool</B> initConnect( <B>in string</B> url, <B>in string</B> typeName, <B>in bool</B> ar);


      /** Get a connection specifically for the purpose for requesting a
       * serialization of a remote object (intended for use by the
       * ProtocolFactory, (see above).  This should parse the url and
       * request the object.  It should return a deserializer..
       */
      sidl.io.Serializable initUnserialize( <B>in string</B> url);


      /** return the short name of the protocol */
      <B>string</B> getProtocol();

      /** return the object ID for the remote object*/
      <B>string</B> getObjectID();

      /**
       * return the full URL for this object, takes the form:
       * protocol://serviceID/objectID (where serviceID would = server:port
       * on TCP/IP)
       * So usually, like this: protocol://server:port/objectID
       */
      <B>string</B> getObjectURL();

      /** create a serializer handle to invoke the named method */
      Invocation createInvocation( <B>in string</B> methodName );

      /**
       * closes the connection (called by the destructor, if not done
       * explicitly) returns true if successful, false otherwise
       * (including subsequent calls)
       */
      <B>bool</B> close();
    }

    /**
     * This type is used to pack arguments and make the Client-&gt;Server
     * method invocation.
     */
    <B>interface</B> Invocation <B>extends</B> sidl.io.Serializer {

      /**
       * this method is one of a triad.  Only one of which
       * may be called, and it must the the last method called
       * in the object's lifetime.
       */
      Response invokeMethod();

      /**
       * This method is second of the triad.  It returns
       * a Ticket, from which a Response is later extracted.
       */
      Ticket invokeNonblocking();

      /**
       * This method is third of the triad.  It returns
       * and exception iff the invocation cannot be delivered
       * reliably.  It does not wait for the invocation to
       * be acted upon and returns no values from the invocation.
       */
      <B>void</B> invokeOneWay();
    }

    /**
     * This type is created when an invokeMethod is called on an
     * Invocation.  It encapsulates all the results that users will
     * want to pull out of a remote method invocation.
     */
    <B>interface</B> Response <B>extends</B> sidl.io.Deserializer {

      /**
       * May return a communication exception or an execption thrown
       * from the remote server.  If it returns null, then it's safe
       * to unpack arguments
       */
      sidl.BaseException getExceptionThrown();

    }

    /**
     * This interface is implemented by the Server side deserializer.
     * Deserializes method arguments in preperation for the method
     * call.
     */
    <B>interface</B> Call <B>extends</B> sidl.io.Deserializer { }

    /**
     * This interface is implemented by the Server side serializer.
     * Serializes method arguments after the return from the method
     * call.
     */
    <B>interface</B> Return <B>extends</B> sidl.io.Serializer {

      /**
       * This method serialized exceptions thrown on the server side
       * that should be returned to the client.  Assumed to invalidate
       * in previously serialized arguments.  (Also assumed that no
       * more arguments will be serialized.)
       */
      <B>void</B> throwException(<B>in</B> sidl.BaseException ex_to_throw);
    }

    /**
     * Used in lieu of a Response in nonblocking calls
     */
    <B>interface</B> Ticket {

      /** blocks until the Response is recieved */
      <B>void</B> block();

      /**
       * returns immediately: true iff the Response is already
       * received
       */
      <B>bool</B> test();

      /** creates an empty container specialized for Tickets */
      TicketBook createEmptyTicketBook();

      /** returns immediately: returns Response or null
       *  (NOTE: needed for implementors of communication
       *         libraries, not expected for general use).
       */
      Response getResponse();

    }

    /**
     * This is a collection of Tickets that itself can be viewed
     * as a ticket.
     */
    <B>interface</B> TicketBook <B>extends</B> Ticket {

      /** insert a ticket with a user-specified ID */
      <B>void</B> insertWithID( <B>in</B> Ticket t, <B>in int</B> id );

      /** insert a ticket and issue a unique ID */
      <B>int</B> insert( <B>in</B> Ticket t );

      /** remove a ready ticket from the TicketBook
       *  returns 0 (and null) on an empty TicketBook
       */
      <B>int</B> removeReady( <B>out</B> Ticket t );

      /**
       * immediate, returns the number of Tickets in the book.
       */
      <B>bool</B> isEmpty();

    }

    /**
     * This singleton class is implemented by Babel's runtime for RMI
     * libraries to invoke methods on server objects.  It maps
     * objectID strings to sidl_BaseClass objects and vice-versa.
     *
     * The InstanceRegistry creates and returns a unique string when a
     * new object is added to the registry.  When an object's refcount
     * reaches 0 and it is collected, it is removed from the Instance
     * Registry.
     *
     * Objects are added to the registry in 3 ways:
     * 1) Added to the server's registry when an object is
     *    create[Remote]'d.
     * 2) Implicity added to the local registry when an object is
     *    passed as an argument in a remote call.
     * 3) A user may manually add a reference to the local registry
     *    for publishing purposes.  The user hsould keep a reference
     *    to the object.  Currently, the user cannot provide their own
     *    objectID, this capability should probably be added.
     */
    <B>class</B> InstanceRegistry {

      /**
       * Register an instance of a class.
       *
       * the registry will return an objectID string guaranteed to be
       * unique for the lifetime of the process
       */
      <B>static string</B> registerInstance( <B>in</B> sidl.BaseClass instance );

      /**
       * Register an instance of a class with the given instanceID
       *
       * If a different object already exists in registry under
       * the supplied name, a false is returned, if the object was
       * successfully registered, true is returned.
       */
      <B>static string</B> registerInstance[ByString]( <B>in</B> sidl.BaseClass instance,
                                              <B>in string</B> instanceID);

      /**
       * returns a handle to the class based on the unique objectID
       * string, (null if the handle isn't in the table)
       */
      <B>static</B> sidl.BaseClass getInstance[ByString]( <B>in string</B> instanceID );

      /**
       * takes a class and returns the objectID string associated
       * with it.  (null if the handle isn't in the table)
       */
      <B>static string</B> getInstance[ByClass]( <B>in</B> sidl.BaseClass instance );

      /**
       * removes an instance from the table based on its objectID
       * string..  returns a pointer to the object, which must be
       * destroyed.
       */
      <B>static</B> sidl.BaseClass removeInstance[ByString]( <B>in string</B> instanceID );

      /**
       * removes an instance from the table based on its BaseClass
       * pointer.  returns the objectID string, which much be freed.
       */
      <B>static string</B> removeInstance[ByClass]( <B>in</B> sidl.BaseClass instance );
    }

    /**
     * This singleton class is implemented by Babel's runtime for to
     * allow RMI downcasting of objects.  When we downcast an RMI
     * object, we may be required to create a new derived class object
     * with a connect function.  We store all the connect functions in
     * this table for easy access.
     *
     * This Class is for Babel internal use only.
     */
    <B>class</B> ConnectRegistry {

      /**
       * The key is the SIDL classname the registered connect belongs
       * to.  Multiple registrations under the same key are possible,
       * this must be protected against in the user code.  Babel does
       * this internally with a static boolean.
       */
      <B>static void</B> registerConnect( <B>in string</B> key, <B>in opaque</B> func);

      /**
       * Returns the connect method for the class named in the key
       */
      <B>static opaque</B> getConnect( <B>in string</B> key );

      /**
       * Returns the connect method for the class named in the key,
       * and removes it from the table.
       */
      <B>static opaque</B> removeConnect( <B>in string</B> key );
    }

    /**
     * ServerInfo is an interface (possibly implemented by the ORB
     * itself) that provides functions to deal with the problems
     * associated with passing local object remotely.  It should be
     * registered with the ServerRegistry for general use.
     */
    <B>interface</B> ServerInfo {
      <B>string</B> getServerURL(<B>in string</B> objID);

      /**
       * For internal Babel use ONLY. Needed by Babel to determine if
       * a url points to a local or remote object.  Returns the
       * objectID if is local, Null otherwise.
       */
      <B>string</B> isLocalObject(<B>in string</B> url);

      /**
       * This gets an array of logged exceptions.  If an exception
       * can not be thrown back to the caller, we log it with the
       * Server.  This gets the array of all those exceptions.  THIS
       * IS SOMETHING OF A TEST! THIS MAY CHANGE!
       */
      <B>array</B>&lt;sidl.io.Serializable,1&gt; getExceptions();
    }

    /**
     * This singleton class is simply a place to register a
     * ServerInfo interface for general access.  This ServerInfo
     * should give info about the ORB being used to export RMI objects
     * for the current Babel process.
     *
     * This Registry provides two important functions, a way to get
     * the URL for local object we wish to expose over RMI, and a way
     * to tell if an object passed to this process via RMI is actually
     * a local object.  This abilities are protocol specific, the
     * ServerInfo interface must by implemented by the protocol
     * writer.
     *
     * THIS CLASS IS NOT DESIGNED FOR CONCURRENT WRITE ACCESS.  (Only
     * one server is assumed per Babel process)
     */
    <B>class</B> ServerRegistry {
      /**
       * Register the server with the ServerRegistry.
       */
      <B>static void</B> registerServer(<B>in</B> sidl.rmi.ServerInfo si);

      /**
       * Get the registered server from the Server Registery.
       */
      <B>static</B> sidl.rmi.ServerInfo getServer();

      /**
       * Perhaps this should take BaseClass and look the objectID up in
       * the Instance Registry
       */
      <B>static string</B> getServerURL(<B>in string</B> objID);

      /**
       * For internal Babel use ONLY. Needed by Babel to determine if a
       * url points to a local or remote object.  Returns the objectID
       * if is local, Null otherwise.
       */
      <B>static string</B> isLocalObject(<B>in string</B> url);

      /**
       * This gets an array of logged exceptions.  If an exception
       * can not be thrown back to the caller, we log it with the
       * Server.  This gets the array of all those exceptions.  THIS
       * IS SOMETHING OF A TEST! THIS MAY CHANGE!
       */
      <B>static array</B>&lt;sidl.io.Serializable,1&gt; getExceptions();

    }

  } //end package rmi
}</I></FONT></TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc28"></A><A NAME="htoc28">6.7</A>  Objects</H2><P><A NAME="sec:basics:objects"></A>
<A NAME="@default329"></A><A NAME="@default330"></A><A NAME="@default331"></A>
<A NAME="@default332"></A><A NAME="@default333"></A></P><P>One of the strategies that SIDL uses to enforce 
language interoperability is to define an
object model that it supports across all 
language bindings. This enables real 
object-oriented programming in non-OO languages
such as C and <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>. This also means that
the inheritance mechanisms inside real OO languages
may be circumvented.</P><P>Contrary to newer scripting languages such as Python and
Ruby, not everything in SIDL is an object. Only
classes (abstract or not) and interfaces are objects. 
Everything else (e. g. arrays, enums, strings, ints) 
is something other than an object and therefore outside 
the scope of this section.</P><H3 CLASS="subsection">Babel’s Object Model</H3><P><A NAME="sec:basics:objects:babelom"></A></P><P>SIDL defines three types of objects: interfaces, classes, 
and abstract classes. A SIDL
<FONT COLOR=maroon><I><TT>interface</TT></I></FONT><A NAME="@default334"></A><A NAME="@default335"></A> 
is akin to 
a Java interface or a C++ pure abstract base class.
It is an object that defines methods (aka member functions), 
but carries no implementation of those methods. 
A <FONT COLOR=maroon><I><TT>class</TT></I></FONT><A NAME="@default336"></A><A NAME="@default337"></A> 
by comparison is always concrete; meaning 
that there is an implementation for each of its methods
and it can be instantiated. An 
<FONT COLOR=maroon><I><TT>abstract class</TT></I></FONT><A NAME="@default338"></A><A NAME="@default339"></A> 
falls somewhere
between an <FONT COLOR=maroon><I><TT>interface</TT></I></FONT> and a <FONT COLOR=maroon><I><TT>class</TT></I></FONT>. It has at least
one method unimplemented, so it cannot be instantiated, but it
also may have several methods that are implemented and these
implementations can be inherited.</P><P>SIDL supports multiple inheritance<A NAME="@default340"></A> of interfaces and single 
inheritance of implementation.<A NAME="@default341"></A> This is a strategy found in 
other OO languages such as Java and ObjectiveC. The
words to distinguish these two forms of inheritance are
<FONT COLOR=maroon><I><TT>extends</TT></I></FONT> and <FONT COLOR=maroon><I><TT>implements</TT></I></FONT>. Interfaces can
extend multiple interfaces, but they cannot implement anything.
Classes can extend at most one other class (abstract or not), 
but can implement multiple interfaces.</P><P>Furthermore, any inherited abstract methods (inherited from either and
abstract parent class or and implemented interface) will default to
abstract unless they are re-declared in the current class. If a
concrete class
implements many large interfaces, this can result in a fairly large
list of redeclared functions in the class definition. As a shortcut,
we included the <TT>implements-all</TT> directive, a short hand
that states explicitly that we intend to implement every
method in the named interface concretely. That’s why, in the
following example, class B must be declared abstract, but class D is
concrete. Class B does not redeclare the <TT>printMe</TT> function,
but class D <TT>implements-all</TT>. There is no similar directive for
inheritance from abstract classes.</P><P>We display a small SIDL file below and finish this
subsection with a discussion of its details.
<A NAME="@default342"></A>
</P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> object <B>version</B> 1.0 {

  <B>interface</B> A {
    <B>void</B> display();
    <B>void</B> printMe();
  }

  <B>abstract class</B> B <B>implements</B> A {
    <B>void</B> display();
  }

  <B>class</B> C <B>extends</B> B {
    <B>void</B> printMe();
  }

  <B>class</B> D <B>implements</B>-all A {
  }
}</I></FONT></TD></TR>
</TABLE><P><FONT COLOR=maroon><I><TT>object.A</TT></I></FONT> is
an interface that has two methods <FONT COLOR=maroon><I><TT>display()</TT></I></FONT> and <FONT COLOR=maroon><I><TT>print()</TT></I></FONT>.
Both of these methods take no arguments and return no value.
(We will discuss arguments and return values in the next section.)
Since <FONT COLOR=maroon><I><TT>object.A</TT></I></FONT> is an interface, there is no implementation
associated with it, and Babel will not generate any implementation
code associated with it. </P><P><FONT COLOR=maroon><I><TT>object.B</TT></I></FONT> is an abstract class that <A NAME="@default343"></A><A NAME="@default344"></A>
inherits from <FONT COLOR=maroon><I><TT>object.A</TT></I></FONT>. Since it redeclares the
<FONT COLOR=maroon><I><TT>display()</TT></I></FONT> method, Babel will generate the appropriate
code for an implementation of this method only. It will not
generate code for the other inherited method <FONT COLOR=maroon><I><TT>print()</TT></I></FONT>
(since it wasn’t declared in the SIDL file) and it will not
generate constructors/destructors since the class is abstract.</P><P><FONT COLOR=maroon><I><TT>object.C</TT></I></FONT> is a concrete class that extends 
the abstract class <A NAME="@default345"></A><A NAME="@default346"></A>
<FONT COLOR=maroon><I><TT>object.B</TT></I></FONT> it then lists only the unimplemented method
<FONT COLOR=maroon><I><TT>print()</TT></I></FONT>, implying that it will use the implementation
of <FONT COLOR=maroon><I><TT>display()</TT></I></FONT> it inherited from its parent.</P><P><FONT COLOR=maroon><I><TT>object.D</TT></I></FONT> is also a concrete class that uses the
<FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT><A NAME="@default347"></A><A NAME="@default348"></A></P><P>directive. This is identical to using <FONT COLOR=maroon><I><TT>implements</TT></I></FONT> and then
listing all the methods declared in the interface. 
The <FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT> directive was added to SIDL 
as a convenience construct and to save excessive typing
in the SIDL file. By virtue of the <FONT COLOR=maroon><I><TT>implements-all</TT></I></FONT>
directive, <FONT COLOR=maroon><I><TT>object.D</TT></I></FONT> will provide its own implementation of 
all of <FONT COLOR=maroon><I><TT>object.A</TT></I></FONT>’s methods, namely 
<FONT COLOR=maroon><I><TT>display()</TT></I></FONT> and <FONT COLOR=maroon><I><TT>print()</TT></I></FONT>.</P><H3 CLASS="subsection">Methods on Objects</H3><P><A NAME="sec:basics:objects:methods"></A></P><P>Methods in SIDL are virtual<A NAME="@default349"></A> by default. 
This means that the actual binding of a method
invocation to an actual implementation is determined
at runtime, based on the concrete type of the object.</P><P>SIDL currently defines three modifiers to methods
that change their default behavior.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<FONT COLOR=maroon><I><TT>final</TT></I></FONT>   :   
	<A NAME="@default350"></A><A NAME="@default351"></A>
	Final methods are the opposite of virtual.
	While they may still be inherited by child classes, 
	they cannot be overridden.
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>static</TT></I></FONT>   :   
	<A NAME="@default352"></A><A NAME="@default353"></A>	
	Static methods are sometimes called “class methods” because
	they are part of a class, but do not depend on an object instance.
	In non-OO languages, this means that the typical
	first argument of an instance is removed.
	In OO languages, these are mapped directly
	to an Java or C++ static method.
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>local</TT></I></FONT>   :   local is a keyword that relates to RMI. A
	local method cannot be called on a remote
	object. Any call on a local method must be an in-process call, or a
	PreViolation will be thrown.
	<A NAME="@default354"></A><A NAME="@default355"></A><A NAME="@default356"></A>	
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>oneway</TT></I></FONT>   :   oneway is a keyword that relates to RMI. A
	oneway method can only take in arguments, no out arguments. This
	allows the oneway method to be called with a oneway network message,
	so the user doesn’t need to wait for a response. 
	<A NAME="@default357"></A><A NAME="@default358"></A><A NAME="@default359"></A>	
</LI><LI CLASS="li-itemize"><FONT COLOR=maroon><I><TT>nonblocking</TT></I></FONT>   :   nonblocking is a keyword that relates
	to RMI. A nonblocking method is split into two methods, method_send()
	and method_recv(). method_send() takes the in arguments and
	immediately returns a sidl.rmi.Ticket. This Ticket can be used to
	determine when the remote method returns, and get the out arguments.
	<A NAME="@default360"></A><A NAME="@default361"></A><A NAME="@default362"></A>	
</LI></UL><P>Starting with Babel <TT>0.11.0</TT>, all SIDL methods implicitly throw
<FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT>. A <FONT COLOR=maroon><I><TT>sidl.RuntimeException</TT></I></FONT> can be
generated by the Babel generated glue code. For example, if the code
is making a call across the network using remote method invocation and
the network goes down, Babel’s glue code would generate a
<FONT COLOR=maroon><I><TT>RuntimeException</TT></I></FONT>. In cases where the implementation throws an
unexpected exception (i. e., not one that is declared in the method’s
SIDL declaration), the glue code can generate a
<FONT COLOR=maroon><I><TT>RuntimeException</TT></I></FONT>.
<A NAME="@default363"></A></P><H3 CLASS="subsection">Parameter Passing</H3><P>Each parameter in a method call obeys the following syntax
</P><BLOCKQUOTE CLASS="quotation"><TT>
[ (modifier) ] (mode) (type) (name)
</TT></BLOCKQUOTE><P>
<A NAME="@default364"></A><A NAME="@default365"></A><A NAME="@default366"></A><A NAME="@default367"></A><A NAME="@default368"></A>
Where <TT>(mode)</TT> is one of <FONT COLOR=maroon><I><TT>in</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>out</TT></I></FONT>, or <FONT COLOR=maroon><I><TT>inout</TT></I></FONT>; <TT>(type)</TT> is
any SIDL recognized type; and <TT>(name)</TT> is
any non-reserved word<SUP><A NAME="text12" HREF="#note12">4</A></SUP>.
The <TT>(modifier)</TT> is optional, and currently
unimplemented. SIDL currently reserves the word
<FONT COLOR=maroon><I><TT>copy</TT></I></FONT> for future use as an parameter modifier, 
and may add others in the future<SUP><A NAME="text13" HREF="#note13">5</A></SUP>.</P><P>For new users, the parameter’s mode (e. g. <FONT COLOR=maroon><I><TT>in</TT></I></FONT>, 
<FONT COLOR=maroon><I><TT>out</TT></I></FONT>, or <FONT COLOR=maroon><I><TT>inout</TT></I></FONT>) is perhaps the most troublesome.
On the surface, it’s easy to explain that <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameters
are passed into the code, <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters come out, 
and <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> parameters do both. More specifically the rules are:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<FONT COLOR=maroon><I><TT>in</TT></I></FONT> does not mean <TT>const</TT>.
</LI><LI CLASS="li-enumerate"><FONT COLOR=maroon><I><TT>in</TT></I></FONT> arguments are passed by value, therefore what happens
	 inside the function has no effect on the value passed in (from the
	 perspective of the caller).
</LI><LI CLASS="li-enumerate"><FONT COLOR=maroon><I><TT>inout</TT></I></FONT> arguments are passed by reference. The callee is
	 allowed to do whatever it wants with the data passed in,
	 and changes made by the callee are sent back to the caller.
	 For interfaces, classes, and normal arrays, the callee
	 can even destroy the reference, create a new object or
	 array, and return a reference to it.
</LI><LI CLASS="li-enumerate">Objects, interfaces and arrays should be allocated using the
create methods provided. Types created on the stack should never be
passed as an <FONT COLOR=maroon><I><TT>inout</TT></I></FONT> argument, since the implementation
may want to destroy it.
</LI><LI CLASS="li-enumerate"><FONT COLOR=maroon><I><TT>out</TT></I></FONT> arguments are also passed by reference, but the 
incoming value is ignore and typically overwritten.
	 <EM>Do Not</EM> attempt to
	 pass in a value to a function through an out argument. There is no
	 guarantee that the data will make it to the Implementation, and if the
	 data is lost, there is no guarantee the reference will be correctly destroyed.
</LI></OL><P>When an exception is thrown, the value of <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters is
undefined. Thus, the client code should not attempt to free <FONT COLOR=maroon><I><TT>out</TT></I></FONT>
string values or decrement reference counts for objects or arrays when
an exception has been thrown. Some bindings may initialize point types
to a NULL value, but the client should not depend on this behavior.</P><P>For strings and reference counted objects (i. e., objects, interfaces,
and arrays) called a resource here, these rules can be confusing. It
is useful to think about who retains ownership of the resource and the
phases of method call.
</P><DL CLASS="description"><DT CLASS="dt-description">
<FONT COLOR=maroon><I><TT><B>in</B></TT></I></FONT></DT><DD CLASS="dd-description"> The client owns the resource before the call, and the
callee borrows the reference. In the case of a string, the client
owns the string data, and the implementation would have to copy the
string if it wanted to retain a reference. Similarly, the
implementation would have to increment the reference count of an
object or smart copy an array. In the case of an exception being
thrown, the <FONT COLOR=maroon><I><TT>in</TT></I></FONT> parameters are unmodified.
</DD><DT CLASS="dt-description"><FONT COLOR=maroon><I><TT><B>inout</B></TT></I></FONT></DT><DD CLASS="dd-description"> The client initially owns the resource before the
call, and it transfers its ownership to the callee. Thus, the callee
is allowed to decrement the reference count of the object or <TT>free</TT> a
string. When the callee is finished, it transfers ownership back to
the caller (or potentially returns a NULL object/string). In the
event of an exception, the caller should ignore the outgoing
parameter values, and the implementation must insure that the
object’s reference counts are decremented and incoming string values are
<TT>free</TT>’ed.
</DD><DT CLASS="dt-description"><FONT COLOR=maroon><I><TT><B>out</B></TT></I></FONT></DT><DD CLASS="dd-description"> The incoming values of <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters are
ignored, and the callee creates any strings or objects that are to
be returned. When the callee returns, it transfers ownership of the
parameters to the caller. In the event of an exception, the caller
must ignore the value of <FONT COLOR=maroon><I><TT>out</TT></I></FONT> parameters because they may be
uninitialized.
</DD></DL><H3 CLASS="subsection">Method Overloading</H3><P><A NAME="@default369"></A><A NAME="@default370"></A>
<A NAME="sec:overloading"></A>
Method overloading is the object-oriented practice of defining more than one 
method with the same name in a class. Doing so allows the convenient reuse of 
a method name when, for example, the underlying implementations differ based
on the types of the arguments. Actually, support for overloaded methods 
typically relies on the signature<A NAME="@default371"></A>
<A NAME="@default372"></A><A NAME="@default373"></A> of each method to ensure uniqueness. In 
this case, the signature consists of the method name along with the number, 
types, and ordering of its arguments. </P><P>Since Babel supports languages that do not support method overloading, a 
mechanism for generating unique names was needed. These are typically generated 
by compilers based on hashing the argument types into the method name. However, 
developers often manually address this with far fewer characters than would be 
used by a compiler. Consequently, it was determined it would be more efficient 
to leave the task of identifying the unique name to the developer. Therefore, 
Babel allows the specification of the base, or short,
<A NAME="@default374"></A> <A NAME="@default375"></A> method name along with an 
optional method name extension as illustrated in the SIDL file below for the 
<TT>getValue</TT> method. </P><DIV CLASS="flushright"><SPAN CLASS="textboxed"><FONT COLOR=purple><B>SIDL</B></FONT></SPAN></DIV><TABLE CLASS="lstframe" STYLE="padding:1ex;border-style:solid;"><TR><TD CLASS="lstlisting"><FONT COLOR=maroon><I><B>package</B> Overload <B>version</B> 1.0 {

  <B>class</B> Sample {
    <B>int</B>      getValue ( );
    <B>int</B>      getValue[Int]( <B>in int</B> v );
    <B>double</B>   getValue[Double]( <B>in double</B> v );
  }
}</I></FONT></TD></TR>
</TABLE><P>Thus, the full method name<A NAME="@default376"></A> <A NAME="@default377"></A>
is the concatenation of the short name followed 
by the name extension. When generating code for supported languages, Babel 
makes use of either the short or full method name as appropriate for the 
language(s) involved. For those that support method overloading, such 
as C++ and Java, Babel relies only on the short method name, thus ignoring 
the extension. For the rest, like C, Fortran, and Python, Babel must make 
use of the full name to ensure methods are uniquely identified. </P><P>In the example above, the first method specification takes no arguments so has 
no name extension. This is acceptable because there are no potentially 
conflicting methods at this point for any programming language supported by 
Babel. The second method, with the user-defined name extension of <TT>Int</TT>, 
takes a single int argument, resulting in the unique method name 
<TT>getValueInt</TT>. The last method, with a user-defined name extension of 
<TT>Double</TT>, takes a single double argument, resulting in the unique method 
name of <TT>getValueDouble</TT>. Examples of calling overloaded methods from 
Babel-supported languages can be found in the respective language binding 
chapters.

			 
</P><H2 CLASS="section"><A NAME="toc29"></A><A NAME="htoc29">6.8</A>  XML Repositories</H2><P><A NAME="s:xml_repo"></A>
<A NAME="@default378"></A>
Even though SIDL is currently the primary input format for Babel, 
it is not the only format Babel understands. For type
repositories<A NAME="@default379"></A> (similar in function to include directories
for C/C++ headers) the preferred language to articulate
types is XML.</P><P>Babel has the capabilities to convert SIDL files into
XML files adhering to the <TT>sidl.dtd</TT>. This capability is
explained further in Chapter <A HREF="index018.html#c:xml_backend">16</A>. The XML
files in these repositories can be included in subsequent 
runs quickly since all the external references were resolved 
by Babel during their creation. A SIDL file may refer to 
unresolved types.

</P><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note9" HREF="#text9">1</A></DT><DD CLASS="dd-thefootnotes">meaning non-strided
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">2</A></DT><DD CLASS="dd-thefootnotes">Contract clauses should <EM>never</EM> replace defensive 
programming data checks since clause enforcement may be disabled during
deployment. The data checks of defensive programming, on the other hand,
should be executed on <EM>every</EM> run since they are needed to protect
against serious, undesirable side-effects that include abrupt, unexplained
termination.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note11" HREF="#text11">3</A></DT><DD CLASS="dd-thefootnotes">The <TT>is pure</TT> assertion is a non-executable
annotation since Babel is not equiped to statically analyze source code for
any of the supported programming languages.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note12" HREF="#text12">4</A></DT><DD CLASS="dd-thefootnotes">Refer to Section <A HREF="index026.html#s:sidl_reserved">A.2</A> for 
the list of reserved words
</DD><DT CLASS="dt-thefootnotes"><A NAME="note13" HREF="#text13">5</A></DT><DD CLASS="dd-thefootnotes">Babel is 
still pre-1.0 after all!
</DD></DL>
<HR>
<A HREF="index007.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index009.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
