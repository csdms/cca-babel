<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="index.css">
<TITLE>Introduction</TITLE>
</HEAD>
<BODY >
<A HREF="index002.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index005.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc2">Chapter 2</A>  Introduction</H1><UL>
<LI><A HREF="index003.html#toc8">Babel Facilitates Language Interoperability</A>
</LI><LI><A HREF="index003.html#toc9">Scientific Interface Definition Language (SIDL)</A>
</LI><LI><A HREF="index003.html#toc10">Benefits to Customers</A>
</LI><LI><A HREF="index003.html#toc11">Beyond Babel’s Scope</A>
</LI><LI><A HREF="index003.html#toc12">Summary</A>
</LI><LI><A HREF="index003.html#toc13">Organization</A>
</LI></UL>
<P><A NAME="c:intro"></A></P><P><BR>
</P><H2 CLASS="section"><A NAME="toc8"></A><A NAME="htoc3">2.1</A>  Babel Facilitates Language Interoperability</H2><P>
Babel was conceived, designed, and built to solve a problem; namely,
to make scientific software libraries equally 
accessible from all of the standard languages. Hence, its goal is language
interoperability. The vision goes far beyond
calling BLAS<SUP><A NAME="text3" HREF="index004.html#note3">1</A></SUP>
implemented in <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> from a C program. At its heart, Babel
lets programmers use their tool of choice in developing
complete applications using components implemented in one or more
distinct programming languages.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><A NAME="@default5"></A>
<IMG SRC="index001.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.1: Example Babel multi-language application</TD></TR>
</TABLE></DIV>
<A NAME="fig:intro:exampleapp"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>For instance<A NAME="@default6"></A>, let us say that an application scientist
is running a sophisticated C++ code from a Python scripting
environment. This can already be easily accomplished with
technologies like SWIG<A NAME="@default7"></A>. Now let’s say that the simulation
is showing some erratic behavior and the application scientist
wants to extend the <TT>ConvergenceCheck</TT> class to also report some
information to a log file. Let’s also assume that this
application scientist doesn’t want to write a new C++ class
much less rewrite the current application. What this individual
wants to do is derive and utilize a new class in Python from the C++ 
<TT>ConvergenceCheck</TT> class.
Thus, the C++ simulation code will now have to invoke a 
method on a class implemented in Python, which then dispatches
back to the C++ base class after doing its additional logging. In
Babel, this situation is normal and expected. In SWIG, one must use
special settings to enable the director feature to have this level of
flexibility, which increases the code size and
complexity. Figure <A HREF="#fig:intro:exampleapp">2.1</A> shows a high level view 
of what Babel’s solution looks like. The developers write the
application in Python, the library in C++, and the extended
<TT>ConvergenceCheck</TT> in Python. All the glue code is generated by
running Babel on a SIDL file.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><A NAME="@default8"></A>
<IMG SRC="index002.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.2: Language Interoperability Using Current Technology.</TD></TR>
</TABLE></DIV>
<A NAME="fig:intro:currentlanginterop"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><P>Figure <A HREF="#fig:intro:currentlanginterop">2.2</A> lists many of
the primary languages that are of interest to scientific
simulation software developers and users. The good news
is that there is a path from each language to every other;
meaning that calling from one to another is possible.
However, the technologies to get from one language to 
another vary widely, are fraught with pitfalls, and may require
calling through a completely different language.</P><P>Babel works by providing the technology to define and support the
multi-language interoperation of a common subset of functionality 
through programming language-neutral interface specifications.
See Fig. <A HREF="#fig:intro:babellanginterop">2.3</A>
to see a graphical representation of the supported languages. 
It is important to note that this common functionality subset 
is <EM>far</EM> from a lowest common denominator solution in that
Babel actually adds functionality when it is lacking in the host language.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<IMG SRC="index003.png">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2.3: Language Interoperability Using Babel.</TD></TR>
</TABLE></DIV>
<A NAME="fig:intro:babellanginterop"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></DIV></BLOCKQUOTE><H2 CLASS="section"><A NAME="toc9"></A><A NAME="htoc4">2.2</A>  Scientific Interface Definition Language (SIDL)</H2><P><A NAME="@default9"></A> </P><P>In order to support multi-language interoperability, Babel relies 
on the specification of interfaces in the
Scientific Interface Definition Language (SIDL) (pronounced
“SIGH-dull”). SIDL is similar to COM<A NAME="@default10"></A> and CORBA<A NAME="@default11"></A> IDLs, 
but was designed with an emphasis on scientific computing.
Specifically, SIDL supports dynamic multi-dimensional arrays and
has built-in complex numbers. 
SIDL also supports interface contracts<A NAME="@default12"></A>, which 
define properties that must hold true during execution — before and/or 
after method invocation — when contract enforcement is enabled.
It will acquire a set of directives to aid in the description of 
massively parallel distributed objects.</P><P>When it comes to deciding what programming idioms
to support across all languages and which ones to reject,
SIDL strikes a careful balance between minimalism and 
completeness. It is <EM>not</EM> a lowest common denominator solution.
SIDL is minimal to keep the learning curve as low as possible.
It is complete so developers do not feel 
constrained in how to express their solutions.</P><P>SIDL is object-oriented<A NAME="@default13"></A>. Its object
model closely resembles that of Java and Objective C. In this model
there is single inheritance of implementation and multiple inheritance
of interfaces. It supports the typical notions of virtual, static, and
final methods. SIDL also provides a basic set of features by defining
and implementing the basic types for interfaces, classes and
exceptions. All types implicitly inherit from these basic types.</P><P>The most important concept to grasp about SIDL is that SIDL only
defines a public interface that other programs may use to access your code.
As a result, all methods defined as part of a SIDL file are public;
if you do not want a method to be globally usable, simply do not
define it in your SIDL file. Furthermore, all object and class data
is implicitly private. There is no way to declare or define data in a
SIDL file. Instead, any data required for your code should be declared
in the implementation language files. This way, the languages that use
your code through Babel may create your objects and pass them around
just like any normal piece of data, but they may only access the data
through the provided interface.</P><P>SIDL also has a complete set of fundamental data types<A NAME="@default14"></A>, from 
booleans to double precision complex numbers. It also supports
more sophisticated types such as enumerations, strings, 
objects, and dynamic multi-dimensional arrays.</P><P>SIDL is still a work in progress.
Of particular research interest are directives that will be 
added for parallel distributed object interaction and features 
to specify computational quality of service semantics associated 
with the interfaces.</P><H2 CLASS="section"><A NAME="toc10"></A><A NAME="htoc5">2.3</A>  Benefits to Customers</H2><P>Babel has two types of customers<A NAME="@default15"></A>:
<EM>developer</EM><A NAME="@default16"></A> and <EM>user</EM><A NAME="@default17"></A>. The
developer implements a library that will be used by one or more users,
and the user uses libraries via their Babel generated interfaces.
Babel provides value to developers by making their software accessible
to a larger customer base because their software can be used from more
different programming languages. Users, on the other hand, may not
care or even know that they are interacting with a library through
Babel. Babel provides value to users by making more software
accessible to them.</P><P>Babel provides some features that benefits user and developer alike.
The most important aspect to note here is that all Babel objects are
reference counted<A NAME="@default18"></A>. This feature is critical
to encapsulate the memory allocation<A NAME="@default19"></A> library
(e. g. C’s malloc/free<A NAME="@default20"></A> or C++’s new/delete) used in the
implementation of the object. Users never need concern themselves
with when to free up a resource, they only declare when they’re done
with their reference to that resource. Developers are free to use
different memory allocation subsystems in different parts of their
code if need be.</P><P>Babel also provides a consistent type system.
This is particularly important when you want to make
object-oriented libraries written in C++, Python or Java accessible in
procedural languages like <SPAN STYLE="font-variant:small-caps">fortran 77</SPAN>, Fortran 90/95 and C. Babel maps the
object-oriented concepts like inheritance, polymorphism and object
identity into all supported languages.</P><P>Interface contracts
<A NAME="@default21"></A><A NAME="@default22"></A>, which 
identify conditions that must hold at the interface boundary, can be used 
to improve the quality of software for both developers and users.
Interface contracts consist of precondition, postcondition, and/or 
invariant clauses belonging to the interface, not the underlying 
implementation(s). 
<A NAME="@default23"></A>
<EM>Precondition</EM>
<A NAME="@default24"></A>
<A NAME="@default25"></A><A NAME="@default26"></A>
clauses<A NAME="@default27"></A> consist of assertions 
on properties which must hold prior to method execution.
<EM>Postcondition</EM>
<A NAME="@default28"></A>
<A NAME="@default29"></A><A NAME="@default30"></A>
clauses<A NAME="@default31"></A> contain assertions 
which must hold upon method completion. 
<EM>Invariant</EM>
<A NAME="@default32"></A>
<A NAME="@default33"></A><A NAME="@default34"></A>
clauses<A NAME="@default35"></A> apply before and after 
method execution. 
Consequently, in addition to providing useful documentation, SIDL interface 
contracts are enforceable.
So developers can enable contract enforcement as an aid to testing and
debugging.
Users can enable full or partial contract enforcement during deployment
to gain confidence in unfamiliar software.</P><H2 CLASS="section"><A NAME="toc11"></A><A NAME="htoc6">2.4</A>  Beyond Babel’s Scope</H2><P>The language interoperability problem is a large one, 
and though the Babel tools address much of it, there is
still a lot that is beyond the scope of our tool.
Babel is at its heart a code generator and a runtime
library. Consequently, the following features are currently
limitations of the Babel tool kit:</P><DL CLASS="description"><DT CLASS="dt-description"><A NAME="@default36"></A>
<B>Reverse engineering</B></DT><DD CLASS="dd-description"> is not supported. That is, 
there is no support for inspecting or modifying compiled
code. In addition, scanning existing software to 
generate SIDL wrappers is not supported.
There are other groups who are pursuing a C++ 
to SIDL converter. Since SIDL contains different information
than what is in a C++ header file, however, such a 
converter cannot be fully automated without additional help.</DD><DT CLASS="dt-description"><B>Library compatibility</B></DT><DD CLASS="dd-description"><A NAME="@default37"></A> is limited.
Since Python and Java dynamically
load libraries into their virtual machines, using these
languages requires the ability to build shared libraries. 
In general, building shared libraries (particularly from C++)
is difficult and error prone. This is compounded by the
fact that compiler vendors have no standard way of doing
this, and many tools that help building shared libraries don’t
support C++. One can build a legitimate
shared library that still won’t work because there are
unresolved symbols, or the library was loaded in the
wrong mode. </DD><DT CLASS="dt-description"><B>Compiler compatibility</B></DT><DD CLASS="dd-description"><A NAME="@default38"></A> is limited.
Since the C++ standard does not specify a binary interface and uses a lot of
hashing in their symbol tables, there have been no attempts to get libraries 
from dissimilar C++ compilers to work together. Similarly, although we support
<SPAN STYLE="font-variant:small-caps">fortran 77</SPAN> and Fortran 90/95, all libraries of Fortran code must be compiled
with the same compiler…again because of the lack of a
standard binary interface.</DD></DL><P>Despite the aforementioned limitations, Babel does facilitate the development
of language interoperable software. However, issues of robust packaging, 
building, and deployment of language interoperable software still loom 
on the horizon.</P><H2 CLASS="section"><A NAME="toc12"></A><A NAME="htoc7">2.5</A>  Summary</H2><P>
Babel consists of a set of tools intended to facilitate
language interoperability in the scientific computing community. Using 
interfaces for libraries or components specified in Scientific Interface 
Definition Language (SIDL) files, Babel can generate corresponding XML 
representations as well as the source code for the corresponding stubs, 
intermediate object representations, and implementation skeletons. The 
generated source code then becomes the foundation for the glue code 
used for language interoperability between callers of libraries and components.</P><P>In addition to providing generated code automatically handling mapping 
fundamental data type parameters between different languages, Babel has 
built-in support for complex numbers and multi-dimensional arrays. 
Additional benefits include object reference counting to facilitate memory 
management.</P><P>Optional SIDL interface contract features are also provided.
Interface contracts aid in improving the quality of software.
Contracts added to interfaces document constraints and can be
used to enhance testing.
When enabled at runtime, contracts can also be used to help
users gain confidence in unfamiliar software.</P><P>Finally, Babel’s primary goal is to facilitate the development of
language interoperable libraries and components. Hence, support for
reverse engineering is not provided. Given that Babel has been
developed by a research team, there are also limitations associated
with shared library and programming language-specific compiler
interoperability support that have been looked into but probably will
not be addressed in the foreseeable future. Regardless, Babel has
proved to be useful to its stakeholders to the point that it is
becoming an integral part of the Common Component Architecture (CCA).
Refer to papers and presentations on our web site for more
information.</P><H2 CLASS="section"><A NAME="toc13"></A><A NAME="htoc8">2.6</A>  Organization</H2><P>
The remainder of this document is separated into two parts: foundations 
and supported language bindings. Part I is devoted to describing the SIDL and
the Babel tools. It starts with a tutorial to gently introduce the reader to 
the development of glue code from both the implementation (or server) and user 
(or client) sides. The following chapter introduces SIDL and Babel basics. 
Finally, a chapter on advanced topics, such as linking options, is provided.</P><P>Part II describes the language bindings currently supported by Babel.
Most of the bindings are programming languages. In
which case, most have both client- and server-side bindings. However,
Babel also supports textual language backends. At this time,
Extensible Markup Language (XML), Hypertext Markup Language (HTML) and
Scientific Interface Definition Language (SIDL) are the only textual
backends.</P><P>Appendices are included to provide more information on topics such as 
acronyms, the SIDL Grammar, and SIDL XML. In addition, sections are included 
that provide advice and tips on troubleshooting.
	 </P><HR>
<A HREF="index002.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index-multipage.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="index005.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
